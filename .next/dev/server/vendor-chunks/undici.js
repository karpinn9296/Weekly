"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(rsc)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\")\nconst RoundRobinPool = __webpack_require__(/*! ./lib/dispatcher/round-robin-pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/round-robin-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\")\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\")\nconst H2CClient = __webpack_require__(/*! ./lib/dispatcher/h2c-client */ \"(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"(rsc)/./node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst { MockCallHistory, MockCallHistoryLog } = __webpack_require__(/*! ./lib/mock/mock-call-history */ \"(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(rsc)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst SnapshotAgent = __webpack_require__(/*! ./lib/mock/snapshot-agent */ \"(rsc)/./node_modules/undici/lib/mock/snapshot-agent.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.RoundRobinPool = RoundRobinPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent\nmodule.exports.RetryAgent = RetryAgent\nmodule.exports.H2CClient = H2CClient\nmodule.exports.RetryHandler = RetryHandler\n\nmodule.exports.DecoratorHandler = DecoratorHandler\nmodule.exports.RedirectHandler = RedirectHandler\nmodule.exports.interceptors = {\n  redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect.js\"),\n  responseError: __webpack_require__(/*! ./lib/interceptor/response-error */ \"(rsc)/./node_modules/undici/lib/interceptor/response-error.js\"),\n  retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(rsc)/./node_modules/undici/lib/interceptor/retry.js\"),\n  dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(rsc)/./node_modules/undici/lib/interceptor/dump.js\"),\n  dns: __webpack_require__(/*! ./lib/interceptor/dns */ \"(rsc)/./node_modules/undici/lib/interceptor/dns.js\"),\n  cache: __webpack_require__(/*! ./lib/interceptor/cache */ \"(rsc)/./node_modules/undici/lib/interceptor/cache.js\"),\n  decompress: __webpack_require__(/*! ./lib/interceptor/decompress */ \"(rsc)/./node_modules/undici/lib/interceptor/decompress.js\"),\n  deduplicate: __webpack_require__(/*! ./lib/interceptor/deduplicate */ \"(rsc)/./node_modules/undici/lib/interceptor/deduplicate.js\")\n}\n\nmodule.exports.cacheStores = {\n  MemoryCacheStore: __webpack_require__(/*! ./lib/cache/memory-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\")\n}\n\nconst SqliteCacheStore = __webpack_require__(/*! ./lib/cache/sqlite-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js\")\nmodule.exports.cacheStores.SqliteCacheStore = SqliteCacheStore\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\nmodule.exports.util = {\n  parseHeaders: util.parseHeaders,\n  headerNameToString: util.headerNameToString\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      let path = opts.path\n      if (!opts.path.startsWith('/')) {\n        path = `/${path}`\n      }\n\n      url = new URL(util.parseOrigin(url).origin + path)\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\").fetch)\n\nfunction appendFetchStackTrace (err, filename) {\n  if (!err || typeof err !== 'object') {\n    return\n  }\n\n  const stack = typeof err.stack === 'string' ? err.stack : ''\n  const normalizedFilename = filename.replace(/\\\\/g, '/')\n\n  if (stack && (stack.includes(filename) || stack.includes(normalizedFilename))) {\n    return\n  }\n\n  const capture = {}\n  Error.captureStackTrace(capture, appendFetchStackTrace)\n\n  if (!capture.stack) {\n    return\n  }\n\n  const captureLines = capture.stack.split('\\n').slice(1).join('\\n')\n\n  err.stack = stack ? `${stack}\\n${captureLines}` : capture.stack\n}\n\nmodule.exports.fetch = function fetch (init, options = undefined) {\n  return fetchImpl(init, options).catch(err => {\n    appendFetchStackTrace(err, __filename)\n    throw err\n  })\n}\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\").Headers\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\").Response\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\").Request\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData\n\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\n\nmodule.exports.setGlobalOrigin = setGlobalOrigin\nmodule.exports.getGlobalOrigin = getGlobalOrigin\n\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\")\nconst { kConstruct } = __webpack_require__(/*! ./lib/core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nmodule.exports.caches = new CacheStorage(kConstruct)\n\nconst { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(rsc)/./node_modules/undici/lib/web/cookies/index.js\")\n\nmodule.exports.deleteCookie = deleteCookie\nmodule.exports.getCookies = getCookies\nmodule.exports.getSetCookies = getSetCookies\nmodule.exports.setCookie = setCookie\nmodule.exports.parseCookie = parseCookie\n\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\nmodule.exports.parseMIMEType = parseMIMEType\nmodule.exports.serializeAMimeType = serializeAMimeType\n\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { WebSocket, ping } = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\")\nmodule.exports.WebSocket = WebSocket\nmodule.exports.CloseEvent = CloseEvent\nmodule.exports.ErrorEvent = ErrorEvent\nmodule.exports.MessageEvent = MessageEvent\nmodule.exports.ping = ping\n\nmodule.exports.WebSocketStream = __webpack_require__(/*! ./lib/web/websocket/stream/websocketstream */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js\").WebSocketStream\nmodule.exports.WebSocketError = __webpack_require__(/*! ./lib/web/websocket/stream/websocketerror */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\").WebSocketError\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockCallHistory = MockCallHistory\nmodule.exports.MockCallHistoryLog = MockCallHistoryLog\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.SnapshotAgent = SnapshotAgent\nmodule.exports.mockErrors = mockErrors\n\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\")\n\nmodule.exports.EventSource = EventSource\n\nfunction install () {\n  globalThis.fetch = module.exports.fetch\n  globalThis.Headers = module.exports.Headers\n  globalThis.Response = module.exports.Response\n  globalThis.Request = module.exports.Request\n  globalThis.FormData = module.exports.FormData\n  globalThis.WebSocket = module.exports.WebSocket\n  globalThis.CloseEvent = module.exports.CloseEvent\n  globalThis.ErrorEvent = module.exports.ErrorEvent\n  globalThis.MessageEvent = module.exports.MessageEvent\n  globalThis.EventSource = module.exports.EventSource\n}\n\nmodule.exports.install = install\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsNkZBQTZCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxpRkFBdUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsbUdBQWdDO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLHlHQUFtQztBQUNsRSxjQUFjLG1CQUFPLENBQUMsbUZBQXdCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUE4QjtBQUN6RCwwQkFBMEIsbUJBQU8sQ0FBQyxpSEFBdUM7QUFDekUsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQThCO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDZGQUE2QjtBQUN2RCxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDdEMsUUFBUSx1QkFBdUI7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLCtEQUFXO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbkQsUUFBUSxzQ0FBc0MsRUFBRSxtQkFBTyxDQUFDLCtGQUE4QjtBQUN0RixrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBdUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsK0VBQXNCO0FBQy9DLHNCQUFzQixtQkFBTyxDQUFDLHlGQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsNkZBQTZCO0FBQzFELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUMzRSx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBaUM7QUFDbEUsd0JBQXdCLG1CQUFPLENBQUMsbUdBQWdDOztBQUVoRTs7QUFFQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwyQkFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9wb29sJylcbmNvbnN0IEJhbGFuY2VkUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYmFsYW5jZWQtcG9vbCcpXG5jb25zdCBSb3VuZFJvYmluUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcm91bmQtcm9iaW4tcG9vbCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcHJveHktYWdlbnQnKVxuY29uc3QgRW52SHR0cFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50JylcbmNvbnN0IFJldHJ5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50JylcbmNvbnN0IEgyQ0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvaDJjLWNsaWVudCcpXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9saWIvY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IGVycm9yc1xuY29uc3QgYXBpID0gcmVxdWlyZSgnLi9saWIvYXBpJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9saWIvY29yZS9jb25uZWN0JylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stY2xpZW50JylcbmNvbnN0IHsgTW9ja0NhbGxIaXN0b3J5LCBNb2NrQ2FsbEhpc3RvcnlMb2cgfSA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jYWxsLWhpc3RvcnknKVxuY29uc3QgTW9ja0FnZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWFnZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLXBvb2wnKVxuY29uc3QgU25hcHNob3RBZ2VudCA9IHJlcXVpcmUoJy4vbGliL21vY2svc25hcHNob3QtYWdlbnQnKVxuY29uc3QgbW9ja0Vycm9ycyA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1lcnJvcnMnKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciwgc2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9saWIvZ2xvYmFsJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbk9iamVjdC5hc3NpZ24oRGlzcGF0Y2hlci5wcm90b3R5cGUsIGFwaSlcblxubW9kdWxlLmV4cG9ydHMuRGlzcGF0Y2hlciA9IERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLkNsaWVudCA9IENsaWVudFxubW9kdWxlLmV4cG9ydHMuUG9vbCA9IFBvb2xcbm1vZHVsZS5leHBvcnRzLkJhbGFuY2VkUG9vbCA9IEJhbGFuY2VkUG9vbFxubW9kdWxlLmV4cG9ydHMuUm91bmRSb2JpblBvb2wgPSBSb3VuZFJvYmluUG9vbFxubW9kdWxlLmV4cG9ydHMuQWdlbnQgPSBBZ2VudFxubW9kdWxlLmV4cG9ydHMuUHJveHlBZ2VudCA9IFByb3h5QWdlbnRcbm1vZHVsZS5leHBvcnRzLkVudkh0dHBQcm94eUFnZW50ID0gRW52SHR0cFByb3h5QWdlbnRcbm1vZHVsZS5leHBvcnRzLlJldHJ5QWdlbnQgPSBSZXRyeUFnZW50XG5tb2R1bGUuZXhwb3J0cy5IMkNDbGllbnQgPSBIMkNDbGllbnRcbm1vZHVsZS5leHBvcnRzLlJldHJ5SGFuZGxlciA9IFJldHJ5SGFuZGxlclxuXG5tb2R1bGUuZXhwb3J0cy5EZWNvcmF0b3JIYW5kbGVyID0gRGVjb3JhdG9ySGFuZGxlclxubW9kdWxlLmV4cG9ydHMuUmVkaXJlY3RIYW5kbGVyID0gUmVkaXJlY3RIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5pbnRlcmNlcHRvcnMgPSB7XG4gIHJlZGlyZWN0OiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdCcpLFxuICByZXNwb25zZUVycm9yOiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZXNwb25zZS1lcnJvcicpLFxuICByZXRyeTogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmV0cnknKSxcbiAgZHVtcDogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZHVtcCcpLFxuICBkbnM6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL2RucycpLFxuICBjYWNoZTogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvY2FjaGUnKSxcbiAgZGVjb21wcmVzczogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZGVjb21wcmVzcycpLFxuICBkZWR1cGxpY2F0ZTogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZGVkdXBsaWNhdGUnKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jYWNoZVN0b3JlcyA9IHtcbiAgTWVtb3J5Q2FjaGVTdG9yZTogcmVxdWlyZSgnLi9saWIvY2FjaGUvbWVtb3J5LWNhY2hlLXN0b3JlJylcbn1cblxuY29uc3QgU3FsaXRlQ2FjaGVTdG9yZSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlL3NxbGl0ZS1jYWNoZS1zdG9yZScpXG5tb2R1bGUuZXhwb3J0cy5jYWNoZVN0b3Jlcy5TcWxpdGVDYWNoZVN0b3JlID0gU3FsaXRlQ2FjaGVTdG9yZVxuXG5tb2R1bGUuZXhwb3J0cy5idWlsZENvbm5lY3RvciA9IGJ1aWxkQ29ubmVjdG9yXG5tb2R1bGUuZXhwb3J0cy5lcnJvcnMgPSBlcnJvcnNcbm1vZHVsZS5leHBvcnRzLnV0aWwgPSB7XG4gIHBhcnNlSGVhZGVyczogdXRpbC5wYXJzZUhlYWRlcnMsXG4gIGhlYWRlck5hbWVUb1N0cmluZzogdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmdcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIgKGZuKSB7XG4gIHJldHVybiAodXJsLCBvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyID0gb3B0c1xuICAgICAgb3B0cyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzLnBhdGgnKVxuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IG9wdHMucGF0aFxuICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgICB9XG5cbiAgICAgIHVybCA9IG5ldyBVUkwodXRpbC5wYXJzZU9yaWdpbih1cmwpLm9yaWdpbiArIHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyB1cmwgOiB7fVxuICAgICAgfVxuXG4gICAgICB1cmwgPSB1dGlsLnBhcnNlVVJMKHVybClcbiAgICB9XG5cbiAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzXG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgb3B0cy5hZ2VudC4gRGlkIHlvdSBtZWFuIG9wdHMuY2xpZW50PycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IChvcHRzLmJvZHkgPyAnUFVUJyA6ICdHRVQnKVxuICAgIH0sIGhhbmRsZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyXG5cbmNvbnN0IGZldGNoSW1wbCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaCcpLmZldGNoXG5cbmZ1bmN0aW9uIGFwcGVuZEZldGNoU3RhY2tUcmFjZSAoZXJyLCBmaWxlbmFtZSkge1xuICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSB0eXBlb2YgZXJyLnN0YWNrID09PSAnc3RyaW5nJyA/IGVyci5zdGFjayA6ICcnXG4gIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIGlmIChzdGFjayAmJiAoc3RhY2suaW5jbHVkZXMoZmlsZW5hbWUpIHx8IHN0YWNrLmluY2x1ZGVzKG5vcm1hbGl6ZWRGaWxlbmFtZSkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBjYXB0dXJlID0ge31cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgYXBwZW5kRmV0Y2hTdGFja1RyYWNlKVxuXG4gIGlmICghY2FwdHVyZS5zdGFjaykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgY2FwdHVyZUxpbmVzID0gY2FwdHVyZS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJylcblxuICBlcnIuc3RhY2sgPSBzdGFjayA/IGAke3N0YWNrfVxcbiR7Y2FwdHVyZUxpbmVzfWAgOiBjYXB0dXJlLnN0YWNrXG59XG5cbm1vZHVsZS5leHBvcnRzLmZldGNoID0gZnVuY3Rpb24gZmV0Y2ggKGluaXQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIGZldGNoSW1wbChpbml0LCBvcHRpb25zKS5jYXRjaChlcnIgPT4ge1xuICAgIGFwcGVuZEZldGNoU3RhY2tUcmFjZShlcnIsIF9fZmlsZW5hbWUpXG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cy5IZWFkZXJzID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2hlYWRlcnMnKS5IZWFkZXJzXG5tb2R1bGUuZXhwb3J0cy5SZXNwb25zZSA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9yZXNwb25zZScpLlJlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL3JlcXVlc3QnKS5SZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5Gb3JtRGF0YSA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9mb3JtZGF0YScpLkZvcm1EYXRhXG5cbmNvbnN0IHsgc2V0R2xvYmFsT3JpZ2luLCBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9nbG9iYWwnKVxuXG5tb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxPcmlnaW4gPSBzZXRHbG9iYWxPcmlnaW5cbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpblxuXG5jb25zdCB7IENhY2hlU3RvcmFnZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2NhY2hlL2NhY2hlc3RvcmFnZScpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vbGliL2NvcmUvc3ltYm9scycpXG5cbm1vZHVsZS5leHBvcnRzLmNhY2hlcyA9IG5ldyBDYWNoZVN0b3JhZ2Uoa0NvbnN0cnVjdClcblxuY29uc3QgeyBkZWxldGVDb29raWUsIGdldENvb2tpZXMsIGdldFNldENvb2tpZXMsIHNldENvb2tpZSwgcGFyc2VDb29raWUgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jb29raWVzJylcblxubW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29va2llID0gZGVsZXRlQ29va2llXG5tb2R1bGUuZXhwb3J0cy5nZXRDb29raWVzID0gZ2V0Q29va2llc1xubW9kdWxlLmV4cG9ydHMuZ2V0U2V0Q29va2llcyA9IGdldFNldENvb2tpZXNcbm1vZHVsZS5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZVxubW9kdWxlLmV4cG9ydHMucGFyc2VDb29raWUgPSBwYXJzZUNvb2tpZVxuXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2RhdGEtdXJsJylcblxubW9kdWxlLmV4cG9ydHMucGFyc2VNSU1FVHlwZSA9IHBhcnNlTUlNRVR5cGVcbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUFNaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZVxuXG5jb25zdCB7IENsb3NlRXZlbnQsIEVycm9yRXZlbnQsIE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC9ldmVudHMnKVxuY29uc3QgeyBXZWJTb2NrZXQsIHBpbmcgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0Jylcbm1vZHVsZS5leHBvcnRzLldlYlNvY2tldCA9IFdlYlNvY2tldFxubW9kdWxlLmV4cG9ydHMuQ2xvc2VFdmVudCA9IENsb3NlRXZlbnRcbm1vZHVsZS5leHBvcnRzLkVycm9yRXZlbnQgPSBFcnJvckV2ZW50XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlRXZlbnQgPSBNZXNzYWdlRXZlbnRcbm1vZHVsZS5leHBvcnRzLnBpbmcgPSBwaW5nXG5cbm1vZHVsZS5leHBvcnRzLldlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvc3RyZWFtL3dlYnNvY2tldHN0cmVhbScpLldlYlNvY2tldFN0cmVhbVxubW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0RXJyb3IgPSByZXF1aXJlKCcuL2xpYi93ZWIvd2Vic29ja2V0L3N0cmVhbS93ZWJzb2NrZXRlcnJvcicpLldlYlNvY2tldEVycm9yXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdClcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSlcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdClcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSlcblxubW9kdWxlLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnRcbm1vZHVsZS5leHBvcnRzLk1vY2tDYWxsSGlzdG9yeSA9IE1vY2tDYWxsSGlzdG9yeVxubW9kdWxlLmV4cG9ydHMuTW9ja0NhbGxIaXN0b3J5TG9nID0gTW9ja0NhbGxIaXN0b3J5TG9nXG5tb2R1bGUuZXhwb3J0cy5Nb2NrUG9vbCA9IE1vY2tQb29sXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQWdlbnQgPSBNb2NrQWdlbnRcbm1vZHVsZS5leHBvcnRzLlNuYXBzaG90QWdlbnQgPSBTbmFwc2hvdEFnZW50XG5tb2R1bGUuZXhwb3J0cy5tb2NrRXJyb3JzID0gbW9ja0Vycm9yc1xuXG5jb25zdCB7IEV2ZW50U291cmNlIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UnKVxuXG5tb2R1bGUuZXhwb3J0cy5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlXG5cbmZ1bmN0aW9uIGluc3RhbGwgKCkge1xuICBnbG9iYWxUaGlzLmZldGNoID0gbW9kdWxlLmV4cG9ydHMuZmV0Y2hcbiAgZ2xvYmFsVGhpcy5IZWFkZXJzID0gbW9kdWxlLmV4cG9ydHMuSGVhZGVyc1xuICBnbG9iYWxUaGlzLlJlc3BvbnNlID0gbW9kdWxlLmV4cG9ydHMuUmVzcG9uc2VcbiAgZ2xvYmFsVGhpcy5SZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMuUmVxdWVzdFxuICBnbG9iYWxUaGlzLkZvcm1EYXRhID0gbW9kdWxlLmV4cG9ydHMuRm9ybURhdGFcbiAgZ2xvYmFsVGhpcy5XZWJTb2NrZXQgPSBtb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXRcbiAgZ2xvYmFsVGhpcy5DbG9zZUV2ZW50ID0gbW9kdWxlLmV4cG9ydHMuQ2xvc2VFdmVudFxuICBnbG9iYWxUaGlzLkVycm9yRXZlbnQgPSBtb2R1bGUuZXhwb3J0cy5FcnJvckV2ZW50XG4gIGdsb2JhbFRoaXMuTWVzc2FnZUV2ZW50ID0gbW9kdWxlLmV4cG9ydHMuTWVzc2FnZUV2ZW50XG4gIGdsb2JhbFRoaXMuRXZlbnRTb3VyY2UgPSBtb2R1bGUuZXhwb3J0cy5FdmVudFNvdXJjZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5pbnN0YWxsID0gaW5zdGFsbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort(self[kSignal]?.reason)\n  } else {\n    self.reason = self[kSignal]?.reason ?? new RequestAbortedError()\n  }\n  removeSignal(self)\n}\n\nfunction addSignal (self, signal) {\n  self.reason = null\n\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYWJvcnQtc2lnbmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga0xpc3RlbmVyID0gU3ltYm9sKCdrTGlzdGVuZXInKVxuY29uc3Qga1NpZ25hbCA9IFN5bWJvbCgna1NpZ25hbCcpXG5cbmZ1bmN0aW9uIGFib3J0IChzZWxmKSB7XG4gIGlmIChzZWxmLmFib3J0KSB7XG4gICAgc2VsZi5hYm9ydChzZWxmW2tTaWduYWxdPy5yZWFzb24pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZWFzb24gPSBzZWxmW2tTaWduYWxdPy5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICB9XG4gIHJlbW92ZVNpZ25hbChzZWxmKVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmLnJlYXNvbiA9IG51bGxcblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    const connectOptions = { ...opts, method: 'CONNECT' }\n\n    this.dispatch(connectOptions, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEJBQTRCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYXBpLWNvbm5lY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIENvbm5lY3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfQ09OTkVDVCcpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgY29ubmVjdCcsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuXG4gICAgbGV0IGhlYWRlcnMgPSByYXdIZWFkZXJzXG4gICAgLy8gSW5kaWNhdGVzIGlzIGFuIEhUVFAyU2Vzc2lvblxuICAgIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgfVxuXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29ubmVjdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29ubmVjdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IG5ldyBDb25uZWN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IHsgLi4ub3B0cywgbWV0aG9kOiAnQ09OTkVDVCcgfVxuXG4gICAgdGhpcy5kaXNwYXRjaChjb25uZWN0T3B0aW9ucywgY29ubmVjdEhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nfunction noop () {}\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', noop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', noop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDekIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrREFBa0Q7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLDZCQUE2Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMkJBQTJCOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktcGlwZWxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgUGFzc1Rocm91Z2hcbn0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBrUmVzdW1lID0gU3ltYm9sKCdyZXN1bWUnKVxuXG5jbGFzcyBQaXBlbGluZVJlcXVlc3QgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIGNvbnN0IHsgW2tSZXN1bWVdOiByZXN1bWUgfSA9IHRoaXNcblxuICAgIGlmIChyZXN1bWUpIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gICAgICByZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVhZCgpXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVSZXNwb25zZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHJlc3VtZSkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcbiAgICB0aGlzW2tSZXN1bWVdID0gcmVzdW1lXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgdGhpc1trUmVzdW1lXSgpXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhhbmRsZXInKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9QSVBFTElORScpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG5cbiAgICB0aGlzLnJlcSA9IG5ldyBQaXBlbGluZVJlcXVlc3QoKS5vbignZXJyb3InLCBub29wKVxuXG4gICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChib2R5Py5yZXN1bWUpIHtcbiAgICAgICAgICBib2R5LnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgICBpZiAocmVxLnB1c2goY2h1bmssIGVuY29kaW5nKSB8fCByZXEuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcVtrUmVzdW1lXSA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiAoZXJyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHksIHJlcSwgcmVzLCByZXQsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFlcnIgJiYgIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFib3J0ICYmIGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXEsIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuXG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KS5vbigncHJlZmluaXNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgLy8gTm9kZSA8IDE1IGRvZXMgbm90IGNhbGwgX2ZpbmFsIGluIHNhbWUgdGljay5cbiAgICAgIHJlcS5wdXNoKG51bGwpXG4gICAgfSlcblxuICAgIHRoaXMucmVzID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCghcmVzLCAncGlwZWxpbmUgY2Fubm90IGJlIHJldHJpZWQnKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUpIHtcbiAgICBjb25zdCB7IG9wYXF1ZSwgaGFuZGxlciwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMucmVzID0gbmV3IFBpcGVsaW5lUmVzcG9uc2UocmVzdW1lKVxuXG4gICAgbGV0IGJvZHlcbiAgICB0cnkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgIGJvZHkgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShoYW5kbGVyLCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgYm9keTogdGhpcy5yZXMsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnJlcy5vbignZXJyb3InLCBub29wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5Lm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFJlYWRhYmxlJylcbiAgICB9XG5cbiAgICBib2R5XG4gICAgICAub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQsIGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5LnBhdXNlKSB7XG4gICAgICAgICAgYm9keS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICByZXQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKG9wdHMsIGhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKVxuICAgIHJldHVybiBwaXBlbGluZUhhbmRsZXIucmV0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(rsc)/./node_modules/undici/lib/api/readable.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction noop () {}\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.highWaterMark = highWaterMark\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (signal?.aborted) {\n      this.reason = signal.reason ?? new RequestAbortedError()\n    } else if (signal) {\n      this.removeAbortListener = util.addAbortListener(signal, () => {\n        this.reason = signal.reason ?? new RequestAbortedError()\n        if (this.res) {\n          util.destroy(this.res.on('error', noop), this.reason)\n        } else if (this.abort) {\n          this.abort(this.reason)\n        }\n      })\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n      this.removeAbortListener = null\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      try {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          statusText: statusMessage,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      } catch (err) {\n        // If the callback throws synchronously, we need to handle it\n        // Remove reference to res to allow res being garbage collected\n        this.res = null\n\n        // Destroy the response stream\n        util.destroy(res.on('error', noop), err)\n\n        // Use queueMicrotask to re-throw the error so it reaches uncaughtException\n        queueMicrotask(() => {\n          throw err\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res.on('error', noop), err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n\n      if (util.isStream(body)) {\n        body.on('error', noop)\n        util.destroy(body, err)\n      }\n    }\n\n    if (this.removeAbortListener) {\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new RequestHandler(opts, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRUFBWTtBQUN6QyxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzlFLGFBQWEsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHVFQUF1RTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1FQUFtRTs7QUFFL0U7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktcmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuY2xhc3MgUmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIGhpZ2hXYXRlck1hcmsgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChoaWdoV2F0ZXJNYXJrICYmICh0eXBlb2YgaGlnaFdhdGVyTWFyayAhPT0gJ251bWJlcicgfHwgaGlnaFdhdGVyTWFyayA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoaWdoV2F0ZXJNYXJrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1JFUVVFU1QnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgbm9vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnRyYWlsZXJzID0ge31cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcbiAgICB0aGlzLnJlYXNvbiA9IG51bGxcbiAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG5cbiAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLnJlYXNvbiA9IHNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH0gZWxzZSBpZiAoc2lnbmFsKSB7XG4gICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVhc29uID0gc2lnbmFsLnJlYXNvbiA/PyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICAgIGlmICh0aGlzLnJlcykge1xuICAgICAgICAgIHV0aWwuZGVzdHJveSh0aGlzLnJlcy5vbignZXJyb3InLCBub29wKSwgdGhpcy5yZWFzb24pXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgIHRoaXMuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBhYm9ydCwgY29udGV4dCwgcmVzcG9uc2VIZWFkZXJzLCBoaWdoV2F0ZXJNYXJrIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGFyc2VkSGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICAgIGNvbnN0IHJlcyA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICByZXN1bWUsXG4gICAgICBhYm9ydCxcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5tZXRob2QgIT09ICdIRUFEJyAmJiBjb250ZW50TGVuZ3RoXG4gICAgICAgID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpXG4gICAgICAgIDogbnVsbCxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgcmVzLm9uKCdjbG9zZScsIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcilcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIHRoaXMucmVzID0gcmVzXG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHRyYWlsZXJzOiB0aGlzLnRyYWlsZXJzLFxuICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICBib2R5OiByZXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoZSBjYWxsYmFjayB0aHJvd3Mgc3luY2hyb25vdXNseSwgd2UgbmVlZCB0byBoYW5kbGUgaXRcbiAgICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZSB0byByZXMgdG8gYWxsb3cgcmVzIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHRoaXMucmVzID0gbnVsbFxuXG4gICAgICAgIC8vIERlc3Ryb3kgdGhlIHJlc3BvbnNlIHN0cmVhbVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLm9uKCdlcnJvcicsIG5vb3ApLCBlcnIpXG5cbiAgICAgICAgLy8gVXNlIHF1ZXVlTWljcm90YXNrIHRvIHJlLXRocm93IHRoZSBlcnJvciBzbyBpdCByZWFjaGVzIHVuY2F1Z2h0RXhjZXB0aW9uXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKVxuICAgIHRoaXMucmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHF1ZXVlTWljcm90YXNrP1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAvLyBFbnN1cmUgYWxsIHF1ZXVlZCBoYW5kbGVycyBhcmUgaW52b2tlZCBiZWZvcmUgZGVzdHJveWluZyByZXMuXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMub24oJ2Vycm9yJywgbm9vcCksIGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcblxuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgYm9keS5vbignZXJyb3InLCBub29wKVxuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcigpXG4gICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVlc3QuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBSZXF1ZXN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaylcblxuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0SGFuZGxlciA9IFJlcXVlc3RIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { finished } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nfunction noop () {}\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    if (factory === null) {\n      return\n    }\n\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res?.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new StreamHandler(opts, factory, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELFFBQVEsZ0RBQWdELEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDbEYsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx3REFBd0Q7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0Q0FBNEM7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsY0FBYyx5Q0FBeUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELGtCQUFrQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIFN0cmVhbUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZmFjdG9yeScpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9TVFJFQU0nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgbm9vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeVxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudHJhaWxlcnMgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgZmFjdG9yeSwgb3BhcXVlLCBjb250ZXh0LCByZXNwb25zZUhlYWRlcnMgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShmYWN0b3J5LCBudWxsLCB7XG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuXG4gICAgaWYgKFxuICAgICAgIXJlcyB8fFxuICAgICAgdHlwZW9mIHJlcy53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHJlcy5lbmQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiByZXMub24gIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgV3JpdGFibGUnKVxuICAgIH1cblxuICAgIC8vIFRPRE86IEF2b2lkIGZpbmlzaGVkLiBJdCByZWdpc3RlcnMgYW4gdW5uZWNlc3NhcnkgYW1vdW50IG9mIGxpc3RlbmVycy5cbiAgICBmaW5pc2hlZChyZXMsIHsgcmVhZGFibGU6IGZhbHNlIH0sIChlcnIpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlcywgb3BhcXVlLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICBpZiAoZXJyIHx8ICFyZXM/LnJlYWRhYmxlKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWUsIHRyYWlsZXJzIH0pXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgYWJvcnQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXMub24oJ2RyYWluJywgcmVzdW1lKVxuXG4gICAgdGhpcy5yZXMgPSByZXNcblxuICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHJlcy53cml0YWJsZU5lZWREcmFpblxuICAgICAgOiByZXMuX3dyaXRhYmxlU3RhdGU/Lm5lZWREcmFpblxuXG4gICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gcmVzID8gcmVzLndyaXRlKGNodW5rKSA6IHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycylcblxuICAgIHJlcy5lbmQoKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmVhbSAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgU3RyZWFtSGFuZGxlcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaylcblxuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kHTTP2Stream } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    assert(socket[kHTTP2Stream] === true ? statusCode === 200 : statusCode === 101)\n\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    const upgradeOpts = {\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }\n\n    this.dispatch(upgradeOpts, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDbEQsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktdXBncmFkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0hUVFAyU3RyZWFtIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBVcGdyYWRlSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1VQR1JBREUnKVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgYXNzZXJ0KHNvY2tldFtrSFRUUDJTdHJlYW1dID09PSB0cnVlID8gc3RhdHVzQ29kZSA9PT0gMjAwIDogc3RhdHVzQ29kZSA9PT0gMTAxKVxuXG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGUgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVwZ3JhZGUuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBncmFkZUhhbmRsZXIgPSBuZXcgVXBncmFkZUhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgY29uc3QgdXBncmFkZU9wdHMgPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgIHVwZ3JhZGU6IG9wdHMucHJvdG9jb2wgfHwgJ1dlYnNvY2tldCdcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoKHVwZ3JhZGVPcHRzLCB1cGdyYWRlSGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGdyYWRlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(rsc)/./node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(rsc)/./node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(rsc)/./node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(rsc)/./node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(rsc)/./node_modules/undici/lib/api/api-connect.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUhBQWlEO0FBQ2pELG9IQUErQztBQUMvQywwSEFBbUQ7QUFDbkQsdUhBQWlEO0FBQ2pELHVIQUFpRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSByZXF1aXJlKCcuL2FwaS1yZXF1ZXN0Jylcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IHJlcXVpcmUoJy4vYXBpLXN0cmVhbScpXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vYXBpLXBpcGVsaW5lJylcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSByZXF1aXJlKCcuL2FwaS11cGdyYWRlJylcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSByZXF1aXJlKCcuL2FwaS1jb25uZWN0JylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\nconst kUsed = Symbol('kUsed')\nconst kBytesRead = Symbol('kBytesRead')\n\nconst noop = () => {}\n\n/**\n * @class\n * @extends {Readable}\n * @see https://fetch.spec.whatwg.org/#body\n */\nclass BodyReadable extends Readable {\n  /**\n   * @param {object} opts\n   * @param {(this: Readable, size: number) => void} opts.resume\n   * @param {() => (void | null)} opts.abort\n   * @param {string} [opts.contentType = '']\n   * @param {number} [opts.contentLength]\n   * @param {number} [opts.highWaterMark = 64 * 1024]\n   */\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n\n    /** @type {Consume | null} */\n    this[kConsume] = null\n\n    /** @type {number} */\n    this[kBytesRead] = 0\n\n    /** @type {ReadableStream|null} */\n    this[kBody] = null\n\n    /** @type {boolean} */\n    this[kUsed] = false\n\n    /** @type {string} */\n    this[kContentType] = contentType\n\n    /** @type {number|null} */\n    this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null\n\n    /**\n     * Is stream being consumed through Readable API?\n     * This is an optimization so that we avoid checking\n     * for 'data' and 'readable' listeners in the hot path\n     * inside push().\n     *\n     * @type {boolean}\n     */\n    this[kReading] = false\n  }\n\n  /**\n   * @param {Error|null} err\n   * @param {(error:(Error|null)) => void} callback\n   * @returns {void}\n   */\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing an 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kUsed]) {\n      setImmediate(callback, err)\n    } else {\n      callback(err)\n    }\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  on (event, listener) {\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = true\n      this[kUsed] = true\n    }\n    return super.on(event, listener)\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  addListener (event, listener) {\n    return this.on(event, listener)\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  off (event, listener) {\n    const ret = super.off(event, listener)\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  removeListener (event, listener) {\n    return this.off(event, listener)\n  }\n\n  /**\n   * @param {Buffer|null} chunk\n   * @returns {boolean}\n   */\n  push (chunk) {\n    if (chunk) {\n      this[kBytesRead] += chunk.length\n      if (this[kConsume]) {\n        consumePush(this[kConsume], chunk)\n        return this[kReading] ? super.push(chunk) : true\n      }\n    }\n\n    return super.push(chunk)\n  }\n\n  /**\n   * Consumes and returns the body as a string.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-text\n   * @returns {Promise<string>}\n   */\n  text () {\n    return consume(this, 'text')\n  }\n\n  /**\n   * Consumes and returns the body as a JavaScript Object.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-json\n   * @returns {Promise<unknown>}\n   */\n  json () {\n    return consume(this, 'json')\n  }\n\n  /**\n   * Consumes and returns the body as a Blob\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-blob\n   * @returns {Promise<Blob>}\n   */\n  blob () {\n    return consume(this, 'blob')\n  }\n\n  /**\n   * Consumes and returns the body as an Uint8Array.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bytes\n   * @returns {Promise<Uint8Array>}\n   */\n  bytes () {\n    return consume(this, 'bytes')\n  }\n\n  /**\n   * Consumes and returns the body as an ArrayBuffer.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n   * @returns {Promise<ArrayBuffer>}\n   */\n  arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  /**\n   * Not implemented\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-formdata\n   * @throws {NotSupportedError}\n   */\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  /**\n   * Returns true if the body is not null and the body has been consumed.\n   * Otherwise, returns false.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bodyused\n   * @readonly\n   * @returns {boolean}\n   */\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#dom-body-body\n   * @readonly\n   * @returns {ReadableStream}\n   */\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  /**\n   * Dumps the response body by reading `limit` number of bytes.\n   * @param {object} opts\n   * @param {number} [opts.limit = 131072] Number of bytes to read.\n   * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.\n   * @returns {Promise<null>}\n   */\n  dump (opts) {\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      return Promise.reject(new InvalidArgumentError('signal must be an AbortSignal'))\n    }\n\n    const limit = opts?.limit && Number.isFinite(opts.limit)\n      ? opts.limit\n      : 128 * 1024\n\n    if (signal?.aborted) {\n      return Promise.reject(signal.reason ?? new AbortError())\n    }\n\n    if (this._readableState.closeEmitted) {\n      return Promise.resolve(null)\n    }\n\n    return new Promise((resolve, reject) => {\n      if (\n        (this[kContentLength] && (this[kContentLength] > limit)) ||\n        this[kBytesRead] > limit\n      ) {\n        this.destroy(new AbortError())\n      }\n\n      if (signal) {\n        const onAbort = () => {\n          this.destroy(signal.reason ?? new AbortError())\n        }\n        signal.addEventListener('abort', onAbort)\n        this\n          .on('close', function () {\n            signal.removeEventListener('abort', onAbort)\n            if (signal.aborted) {\n              reject(signal.reason ?? new AbortError())\n            } else {\n              resolve(null)\n            }\n          })\n      } else {\n        this.on('close', resolve)\n      }\n\n      this\n        .on('error', noop)\n        .on('data', () => {\n          if (this[kBytesRead] > limit) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n\n  /**\n   * @param {BufferEncoding} encoding\n   * @returns {this}\n   */\n  setEncoding (encoding) {\n    if (Buffer.isEncoding(encoding)) {\n      this._readableState.encoding = encoding\n    }\n    return this\n  }\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestream-locked\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isLocked (bodyReadable) {\n  // Consume is an implicit lock.\n  return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isUnusable (bodyReadable) {\n  return util.isDisturbed(bodyReadable) || isLocked(bodyReadable)\n}\n\n/**\n * @typedef {'text' | 'json' | 'blob' | 'bytes' | 'arrayBuffer'} ConsumeType\n */\n\n/**\n * @template {ConsumeType} T\n * @typedef {T extends 'text' ? string :\n *           T extends 'json' ? unknown :\n *           T extends 'blob' ? Blob :\n *           T extends 'arrayBuffer' ? ArrayBuffer :\n *           T extends 'bytes' ? Uint8Array :\n *           never\n * } ConsumeReturnType\n */\n/**\n * @typedef {object} Consume\n * @property {ConsumeType} type\n * @property {BodyReadable} stream\n * @property {((value?: any) => void)} resolve\n * @property {((err: Error) => void)} reject\n * @property {number} length\n * @property {Buffer[]} body\n */\n\n/**\n * @template {ConsumeType} T\n * @param {BodyReadable} stream\n * @param {T} type\n * @returns {Promise<ConsumeReturnType<T>>}\n */\nfunction consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', reject)\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\n/**\n * @param {Consume} consume\n * @returns {void}\n */\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume], this._readableState.encoding)\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume], this._readableState.encoding)\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @param {BufferEncoding} [encoding='utf8']\n * @returns {string}\n */\nfunction chunksDecode (chunks, length, encoding) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  if (!encoding || encoding === 'utf8' || encoding === 'utf-8') {\n    return buffer.utf8Slice(start, bufferLength)\n  } else {\n    return buffer.subarray(start, bufferLength).toString(encoding)\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction chunksConcat (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return new Uint8Array(0)\n  }\n  if (chunks.length === 1) {\n    // fast-path\n    return new Uint8Array(chunks[0])\n  }\n  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer)\n\n  let offset = 0\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i]\n    buffer.set(chunk, offset)\n    offset += chunk.length\n  }\n\n  return buffer\n}\n\n/**\n * @param {Consume} consume\n * @param {BufferEncoding} encoding\n * @returns {void}\n */\nfunction consumeEnd (consume, encoding) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length, encoding))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length, encoding)))\n    } else if (type === 'arrayBuffer') {\n      resolve(chunksConcat(body, length).buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    } else if (type === 'bytes') {\n      resolve(chunksConcat(body, length))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\n/**\n * @param {Consume} consume\n * @param {Buffer} chunk\n * @returns {void}\n */\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\n/**\n * @param {Consume} consume\n * @param {Error} [err]\n * @returns {void}\n */\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  // Reset the consume object to allow for garbage collection.\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = {\n  Readable: BodyReadable,\n  chunksDecode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM3RyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLGVBQWUsZ0JBQWdCO0FBQy9COztBQUVBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxlQUFlLHFCQUFxQjtBQUNwQzs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLGVBQWUsYUFBYTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsOEJBQThCO0FBQzNDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7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O0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXHJlYWRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yLCBJbnZhbGlkQXJndW1lbnRFcnJvciwgQWJvcnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtRnJvbSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY29uc3Qga0NvbnN1bWUgPSBTeW1ib2woJ2tDb25zdW1lJylcbmNvbnN0IGtSZWFkaW5nID0gU3ltYm9sKCdrUmVhZGluZycpXG5jb25zdCBrQm9keSA9IFN5bWJvbCgna0JvZHknKVxuY29uc3Qga0Fib3J0ID0gU3ltYm9sKCdrQWJvcnQnKVxuY29uc3Qga0NvbnRlbnRUeXBlID0gU3ltYm9sKCdrQ29udGVudFR5cGUnKVxuY29uc3Qga0NvbnRlbnRMZW5ndGggPSBTeW1ib2woJ2tDb250ZW50TGVuZ3RoJylcbmNvbnN0IGtVc2VkID0gU3ltYm9sKCdrVXNlZCcpXG5jb25zdCBrQnl0ZXNSZWFkID0gU3ltYm9sKCdrQnl0ZXNSZWFkJylcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyB7UmVhZGFibGV9XG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKi9cbmNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7KHRoaXM6IFJlYWRhYmxlLCBzaXplOiBudW1iZXIpID0+IHZvaWR9IG9wdHMucmVzdW1lXG4gICAqIEBwYXJhbSB7KCkgPT4gKHZvaWQgfCBudWxsKX0gb3B0cy5hYm9ydFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udGVudFR5cGUgPSAnJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNvbnRlbnRMZW5ndGhdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0XVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHtcbiAgICByZXN1bWUsXG4gICAgYWJvcnQsXG4gICAgY29udGVudFR5cGUgPSAnJyxcbiAgICBjb250ZW50TGVuZ3RoLFxuICAgIGhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogcmVzdW1lLFxuICAgICAgaGlnaFdhdGVyTWFya1xuICAgIH0pXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gZmFsc2VcblxuICAgIHRoaXNba0Fib3J0XSA9IGFib3J0XG5cbiAgICAvKiogQHR5cGUge0NvbnN1bWUgfCBudWxsfSAqL1xuICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpc1trQnl0ZXNSZWFkXSA9IDBcblxuICAgIC8qKiBAdHlwZSB7UmVhZGFibGVTdHJlYW18bnVsbH0gKi9cbiAgICB0aGlzW2tCb2R5XSA9IG51bGxcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzW2tVc2VkXSA9IGZhbHNlXG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzW2tDb250ZW50VHlwZV0gPSBjb250ZW50VHlwZVxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8bnVsbH0gKi9cbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IE51bWJlci5pc0Zpbml0ZShjb250ZW50TGVuZ3RoKSA/IGNvbnRlbnRMZW5ndGggOiBudWxsXG5cbiAgICAvKipcbiAgICAgKiBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgICogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgICAqIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgICAqIGluc2lkZSBwdXNoKCkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzW2tSZWFkaW5nXSA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJcbiAgICogQHBhcmFtIHsoZXJyb3I6KEVycm9yfG51bGwpKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXNba0Fib3J0XSgpXG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgTm9kZSBcImJ1Z1wiLiBJZiB0aGUgc3RyZWFtIGlzIGRlc3Ryb3llZCBpbiBzYW1lXG4gICAgLy8gdGljayBhcyBpdCBpcyBjcmVhdGVkLCB0aGVuIGEgdXNlciB3aG8gaXMgd2FpdGluZyBmb3IgYVxuICAgIC8vIHByb21pc2UgKGkuZSBtaWNybyB0aWNrKSBmb3IgaW5zdGFsbGluZyBhbiAnZXJyb3InIGxpc3RlbmVyIHdpbGxcbiAgICAvLyBuZXZlciBnZXQgYSBjaGFuY2UgYW5kIHdpbGwgYWx3YXlzIGVuY291bnRlciBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgIGlmICghdGhpc1trVXNlZF0pIHtcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaywgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0gZXZlbnRcbiAgICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGxpc3RlbmVyXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChldmVudCA9PT0gJ2RhdGEnIHx8IGV2ZW50ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzW2tSZWFkaW5nXSA9IHRydWVcbiAgICAgIHRoaXNba1VzZWRdID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0gZXZlbnRcbiAgICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGxpc3RlbmVyXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgYWRkTGlzdGVuZXIgKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzeW1ib2x9IGV2ZW50XG4gICAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsaXN0ZW5lclxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIG9mZiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcmV0ID0gc3VwZXIub2ZmKGV2ZW50LCBsaXN0ZW5lcilcbiAgICBpZiAoZXZlbnQgPT09ICdkYXRhJyB8fCBldmVudCA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSAoXG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCB8fFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzeW1ib2x9IGV2ZW50XG4gICAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsaXN0ZW5lclxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHJlbW92ZUxpc3RlbmVyIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfG51bGx9IGNodW5rXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcHVzaCAoY2h1bmspIHtcbiAgICBpZiAoY2h1bmspIHtcbiAgICAgIHRoaXNba0J5dGVzUmVhZF0gKz0gY2h1bmsubGVuZ3RoXG4gICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sIGNodW5rKVxuICAgICAgICByZXR1cm4gdGhpc1trUmVhZGluZ10gPyBzdXBlci5wdXNoKGNodW5rKSA6IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBhbmQgcmV0dXJucyB0aGUgYm9keSBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktdGV4dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgdGV4dCAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ3RleHQnKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGFuZCByZXR1cm5zIHRoZSBib2R5IGFzIGEgSmF2YVNjcmlwdCBPYmplY3QuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWpzb25cbiAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAqL1xuICBqc29uICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnanNvbicpXG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYW5kIHJldHVybnMgdGhlIGJvZHkgYXMgYSBCbG9iXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJsb2JcbiAgICogQHJldHVybnMge1Byb21pc2U8QmxvYj59XG4gICAqL1xuICBibG9iICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYmxvYicpXG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYW5kIHJldHVybnMgdGhlIGJvZHkgYXMgYW4gVWludDhBcnJheS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYnl0ZXNcbiAgICogQHJldHVybnMge1Byb21pc2U8VWludDhBcnJheT59XG4gICAqL1xuICBieXRlcyAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2J5dGVzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBhbmQgcmV0dXJucyB0aGUgYm9keSBhcyBhbiBBcnJheUJ1ZmZlci5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYXJyYXlidWZmZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgYXJyYXlCdWZmZXIgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdhcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvKipcbiAgICogTm90IGltcGxlbWVudGVkXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWZvcm1kYXRhXG4gICAqIEB0aHJvd3Mge05vdFN1cHBvcnRlZEVycm9yfVxuICAgKi9cbiAgYXN5bmMgZm9ybURhdGEgKCkge1xuICAgIC8vIFRPRE86IEltcGxlbWVudC5cbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm9keSBpcyBub3QgbnVsbCBhbmQgdGhlIGJvZHkgaGFzIGJlZW4gY29uc3VtZWQuXG4gICAqIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keXVzZWRcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHlcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX1cbiAgICovXG4gIGdldCBib2R5ICgpIHtcbiAgICBpZiAoIXRoaXNba0JvZHldKSB7XG4gICAgICB0aGlzW2tCb2R5XSA9IFJlYWRhYmxlU3RyZWFtRnJvbSh0aGlzKVxuICAgICAgaWYgKHRoaXNba0NvbnN1bWVdKSB7XG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgdGhlIGJlc3Qgd2F5IHRvIGZvcmNlIGEgbG9jaz9cbiAgICAgICAgdGhpc1trQm9keV0uZ2V0UmVhZGVyKCkgLy8gRW5zdXJlIHN0cmVhbSBpcyBsb2NrZWQuXG4gICAgICAgIGFzc2VydCh0aGlzW2tCb2R5XS5sb2NrZWQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzW2tCb2R5XVxuICB9XG5cbiAgLyoqXG4gICAqIER1bXBzIHRoZSByZXNwb25zZSBib2R5IGJ5IHJlYWRpbmcgYGxpbWl0YCBudW1iZXIgb2YgYnl0ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5saW1pdCA9IDEzMTA3Ml0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRzLnNpZ25hbF0gQW4gQWJvcnRTaWduYWwgdG8gY2FuY2VsIHRoZSBkdW1wLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudWxsPn1cbiAgICovXG4gIGR1bXAgKG9wdHMpIHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRzPy5zaWduYWxcblxuICAgIGlmIChzaWduYWwgIT0gbnVsbCAmJiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEFib3J0U2lnbmFsJykpXG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBvcHRzPy5saW1pdCAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5saW1pdClcbiAgICAgID8gb3B0cy5saW1pdFxuICAgICAgOiAxMjggKiAxMDI0XG5cbiAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2lnbmFsLnJlYXNvbiA/PyBuZXcgQWJvcnRFcnJvcigpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmNsb3NlRW1pdHRlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzW2tDb250ZW50TGVuZ3RoXSAmJiAodGhpc1trQ29udGVudExlbmd0aF0gPiBsaW1pdCkpIHx8XG4gICAgICAgIHRoaXNba0J5dGVzUmVhZF0gPiBsaW1pdFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShuZXcgQWJvcnRFcnJvcigpKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KVxuICAgICAgICB0aGlzXG4gICAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpXG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbignY2xvc2UnLCByZXNvbHZlKVxuICAgICAgfVxuXG4gICAgICB0aGlzXG4gICAgICAgIC5vbignZXJyb3InLCBub29wKVxuICAgICAgICAub24oJ2RhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXNba0J5dGVzUmVhZF0gPiBsaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJFbmNvZGluZ30gZW5jb2RpbmdcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBzZXRFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgICBpZiAoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jb2RpbmdcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tbG9ja2VkXG4gKiBAcGFyYW0ge0JvZHlSZWFkYWJsZX0gYm9keVJlYWRhYmxlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNMb2NrZWQgKGJvZHlSZWFkYWJsZSkge1xuICAvLyBDb25zdW1lIGlzIGFuIGltcGxpY2l0IGxvY2suXG4gIHJldHVybiBib2R5UmVhZGFibGVba0JvZHldPy5sb2NrZWQgPT09IHRydWUgfHwgYm9keVJlYWRhYmxlW2tDb25zdW1lXSAhPT0gbnVsbFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbiAqIEBwYXJhbSB7Qm9keVJlYWRhYmxlfSBib2R5UmVhZGFibGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VudXNhYmxlIChib2R5UmVhZGFibGUpIHtcbiAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQoYm9keVJlYWRhYmxlKSB8fCBpc0xvY2tlZChib2R5UmVhZGFibGUpXG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0ZXh0JyB8ICdqc29uJyB8ICdibG9iJyB8ICdieXRlcycgfCAnYXJyYXlCdWZmZXInfSBDb25zdW1lVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtDb25zdW1lVHlwZX0gVFxuICogQHR5cGVkZWYge1QgZXh0ZW5kcyAndGV4dCcgPyBzdHJpbmcgOlxuICogICAgICAgICAgIFQgZXh0ZW5kcyAnanNvbicgPyB1bmtub3duIDpcbiAqICAgICAgICAgICBUIGV4dGVuZHMgJ2Jsb2InID8gQmxvYiA6XG4gKiAgICAgICAgICAgVCBleHRlbmRzICdhcnJheUJ1ZmZlcicgPyBBcnJheUJ1ZmZlciA6XG4gKiAgICAgICAgICAgVCBleHRlbmRzICdieXRlcycgPyBVaW50OEFycmF5IDpcbiAqICAgICAgICAgICBuZXZlclxuICogfSBDb25zdW1lUmV0dXJuVHlwZVxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENvbnN1bWVcbiAqIEBwcm9wZXJ0eSB7Q29uc3VtZVR5cGV9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7Qm9keVJlYWRhYmxlfSBzdHJlYW1cbiAqIEBwcm9wZXJ0eSB7KCh2YWx1ZT86IGFueSkgPT4gdm9pZCl9IHJlc29sdmVcbiAqIEBwcm9wZXJ0eSB7KChlcnI6IEVycm9yKSA9PiB2b2lkKX0gcmVqZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXG4gKiBAcHJvcGVydHkge0J1ZmZlcltdfSBib2R5XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NvbnN1bWVUeXBlfSBUXG4gKiBAcGFyYW0ge0JvZHlSZWFkYWJsZX0gc3RyZWFtXG4gKiBAcGFyYW0ge1R9IHR5cGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPENvbnN1bWVSZXR1cm5UeXBlPFQ+Pn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZSAoc3RyZWFtLCB0eXBlKSB7XG4gIGFzc2VydCghc3RyZWFtW2tDb25zdW1lXSlcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChpc1VudXNhYmxlKHN0cmVhbSkpIHtcbiAgICAgIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICAgICAgaWYgKHJTdGF0ZS5kZXN0cm95ZWQgJiYgclN0YXRlLmNsb3NlRW1pdHRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyZWFtXG4gICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJykpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChyU3RhdGUuZXJyb3JlZCA/PyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHN0cmVhbVtrQ29uc3VtZV0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1cbiAgICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgZXJyKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tDb25zdW1lXS5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICBjb25zdW1lU3RhcnQoc3RyZWFtW2tDb25zdW1lXSlcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29uc3VtZX0gY29uc3VtZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVTdGFydCAoY29uc3VtZSkge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7IF9yZWFkYWJsZVN0YXRlOiBzdGF0ZSB9ID0gY29uc3VtZS5zdHJlYW1cblxuICBpZiAoc3RhdGUuYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBzdGFydCA9IHN0YXRlLmJ1ZmZlckluZGV4XG4gICAgY29uc3QgZW5kID0gc3RhdGUuYnVmZmVyLmxlbmd0aFxuICAgIGZvciAobGV0IG4gPSBzdGFydDsgbiA8IGVuZDsgbisrKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBzdGF0ZS5idWZmZXJbbl0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2Ygc3RhdGUuYnVmZmVyKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBjaHVuaylcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0sIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcpXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5zdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0sIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN1bWUuc3RyZWFtLnJlc3VtZSgpXG5cbiAgd2hpbGUgKGNvbnN1bWUuc3RyZWFtLnJlYWQoKSAhPSBudWxsKSB7XG4gICAgLy8gTG9vcFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gY2h1bmtzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlckVuY29kaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2h1bmtzRGVjb2RlIChjaHVua3MsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgfHwgbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgY29uc3QgYnVmZmVyID0gY2h1bmtzLmxlbmd0aCA9PT0gMSA/IGNodW5rc1swXSA6IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpXG4gIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcblxuICAvLyBTa2lwIEJPTS5cbiAgY29uc3Qgc3RhcnQgPVxuICAgIGJ1ZmZlckxlbmd0aCA+IDIgJiZcbiAgICBidWZmZXJbMF0gPT09IDB4ZWYgJiZcbiAgICBidWZmZXJbMV0gPT09IDB4YmIgJiZcbiAgICBidWZmZXJbMl0gPT09IDB4YmZcbiAgICAgID8gM1xuICAgICAgOiAwXG4gIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgIHJldHVybiBidWZmZXIudXRmOFNsaWNlKHN0YXJ0LCBidWZmZXJMZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheShzdGFydCwgYnVmZmVyTGVuZ3RoKS50b1N0cmluZyhlbmNvZGluZylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW119IGNodW5rc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNodW5rc0NvbmNhdCAoY2h1bmtzLCBsZW5ndGgpIHtcbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgfHwgbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApXG4gIH1cbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBmYXN0LXBhdGhcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmtzWzBdKVxuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cobGVuZ3RoKS5idWZmZXIpXG5cbiAgbGV0IG9mZnNldCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXVxuICAgIGJ1ZmZlci5zZXQoY2h1bmssIG9mZnNldClcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25zdW1lfSBjb25zdW1lXG4gKiBAcGFyYW0ge0J1ZmZlckVuY29kaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVFbmQgKGNvbnN1bWUsIGVuY29kaW5nKSB7XG4gIGNvbnN0IHsgdHlwZSwgYm9keSwgcmVzb2x2ZSwgc3RyZWFtLCBsZW5ndGggfSA9IGNvbnN1bWVcblxuICB0cnkge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc29sdmUoY2h1bmtzRGVjb2RlKGJvZHksIGxlbmd0aCwgZW5jb2RpbmcpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICByZXNvbHZlKEpTT04ucGFyc2UoY2h1bmtzRGVjb2RlKGJvZHksIGxlbmd0aCwgZW5jb2RpbmcpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgIHJlc29sdmUoY2h1bmtzQ29uY2F0KGJvZHksIGxlbmd0aCkuYnVmZmVyKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICByZXNvbHZlKG5ldyBCbG9iKGJvZHksIHsgdHlwZTogc3RyZWFtW2tDb250ZW50VHlwZV0gfSkpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICByZXNvbHZlKGNodW5rc0NvbmNhdChib2R5LCBsZW5ndGgpKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25zdW1lfSBjb25zdW1lXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25zdW1lUHVzaCAoY29uc3VtZSwgY2h1bmspIHtcbiAgY29uc3VtZS5sZW5ndGggKz0gY2h1bmsubGVuZ3RoXG4gIGNvbnN1bWUuYm9keS5wdXNoKGNodW5rKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29uc3VtZX0gY29uc3VtZVxuICogQHBhcmFtIHtFcnJvcn0gW2Vycl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25zdW1lRmluaXNoIChjb25zdW1lLCBlcnIpIHtcbiAgaWYgKGNvbnN1bWUuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGVycikge1xuICAgIGNvbnN1bWUucmVqZWN0KGVycilcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnJlc29sdmUoKVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGNvbnN1bWUgb2JqZWN0IHRvIGFsbG93IGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gIGNvbnN1bWUudHlwZSA9IG51bGxcbiAgY29uc3VtZS5zdHJlYW0gPSBudWxsXG4gIGNvbnN1bWUucmVzb2x2ZSA9IG51bGxcbiAgY29uc3VtZS5yZWplY3QgPSBudWxsXG4gIGNvbnN1bWUubGVuZ3RoID0gMFxuICBjb25zdW1lLmJvZHkgPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBSZWFkYWJsZTogQm9keVJlYWRhYmxlLFxuICBjaHVua3NEZWNvZGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/cache/memory-cache-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\")\nconst { assertCacheKey, assertCacheValue } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheKey} CacheKey\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheValue} CacheValue\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @typedef {import('../../types/cache-interceptor.d.ts').default.GetResult} GetResult\n */\n\n/**\n * @implements {CacheStore}\n * @extends {EventEmitter}\n */\nclass MemoryCacheStore extends EventEmitter {\n  #maxCount = 1024\n  #maxSize = 104857600 // 100MB\n  #maxEntrySize = 5242880 // 5MB\n\n  #size = 0\n  #count = 0\n  #entries = new Map()\n  #hasEmittedMaxSizeEvent = false\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]\n   */\n  constructor (opts) {\n    super()\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('MemoryCacheStore options must be an object')\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n\n      if (opts.maxSize !== undefined) {\n        if (\n          typeof opts.maxSize !== 'number' ||\n          !Number.isInteger(opts.maxSize) ||\n          opts.maxSize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxSize must be a non-negative integer')\n        }\n        this.#maxSize = opts.maxSize\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n    }\n  }\n\n  /**\n   * Get the current size of the cache in bytes\n   * @returns {number} The current size of the cache in bytes\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * Check if the cache is full (either max size or max count reached)\n   * @returns {boolean} True if the cache is full, false otherwise\n   */\n  isFull () {\n    return this.#size >= this.#maxSize || this.#count >= this.#maxCount\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req\n   * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const now = Date.now()\n    const entries = this.#entries.get(topLevelKey)\n\n    const entry = entries ? findEntry(key, entries, now) : null\n\n    return entry == null\n      ? undefined\n      : {\n          statusMessage: entry.statusMessage,\n          statusCode: entry.statusCode,\n          headers: entry.headers,\n          body: entry.body,\n          vary: entry.vary ? entry.vary : undefined,\n          etag: entry.etag,\n          cacheControlDirectives: entry.cacheControlDirectives,\n          cachedAt: entry.cachedAt,\n          staleAt: entry.staleAt,\n          deleteAt: entry.deleteAt\n        }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, val) {\n    assertCacheKey(key)\n    assertCacheValue(val)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const store = this\n    const entry = { ...key, ...val, body: [], size: 0 }\n\n    return new Writable({\n      write (chunk, encoding, callback) {\n        if (typeof chunk === 'string') {\n          chunk = Buffer.from(chunk, encoding)\n        }\n\n        entry.size += chunk.byteLength\n\n        if (entry.size >= store.#maxEntrySize) {\n          this.destroy()\n        } else {\n          entry.body.push(chunk)\n        }\n\n        callback(null)\n      },\n      final (callback) {\n        let entries = store.#entries.get(topLevelKey)\n        if (!entries) {\n          entries = []\n          store.#entries.set(topLevelKey, entries)\n        }\n        const previousEntry = findEntry(key, entries, Date.now())\n        if (previousEntry) {\n          const index = entries.indexOf(previousEntry)\n          entries.splice(index, 1, entry)\n          store.#size -= previousEntry.size\n        } else {\n          entries.push(entry)\n          store.#count += 1\n        }\n\n        store.#size += entry.size\n\n        // Check if cache is full and emit event if needed\n        if (store.#size > store.#maxSize || store.#count > store.#maxCount) {\n          // Emit maxSizeExceeded event if we haven't already\n          if (!store.#hasEmittedMaxSizeEvent) {\n            store.emit('maxSizeExceeded', {\n              size: store.#size,\n              maxSize: store.#maxSize,\n              count: store.#count,\n              maxCount: store.#maxCount\n            })\n            store.#hasEmittedMaxSizeEvent = true\n          }\n\n          // Perform eviction\n          for (const [key, entries] of store.#entries) {\n            for (const entry of entries.splice(0, entries.length / 2)) {\n              store.#size -= entry.size\n              store.#count -= 1\n            }\n            if (entries.length === 0) {\n              store.#entries.delete(key)\n            }\n          }\n\n          // Reset the event flag after eviction\n          if (store.#size < store.#maxSize && store.#count < store.#maxCount) {\n            store.#hasEmittedMaxSizeEvent = false\n          }\n        }\n\n        callback(null)\n      }\n    })\n  }\n\n  /**\n   * @param {CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    for (const entry of this.#entries.get(topLevelKey) ?? []) {\n      this.#size -= entry.size\n      this.#count -= 1\n    }\n    this.#entries.delete(topLevelKey)\n  }\n}\n\nfunction findEntry (key, entries, now) {\n  return entries.find((entry) => (\n    entry.deleteAt > now &&\n    entry.method === key.method &&\n    (entry.vary == null || Object.keys(entry.vary).every(headerName => {\n      if (entry.vary[headerName] === null) {\n        return key.headers[headerName] === undefined\n      }\n\n      return entry.vary[headerName] === key.headers[headerName]\n    }))\n  ))\n}\n\nmodule.exports = MemoryCacheStore\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9tZW1vcnktY2FjaGUtc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzlDLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyx1RUFBa0I7O0FBRXZFO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsYUFBYSxpRUFBaUU7QUFDOUUsYUFBYSxpRUFBaUU7QUFDOUUsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVGQUF1RjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVyxHQUFHLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsYUFBYSxpRUFBaUU7QUFDOUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXLEdBQUcsU0FBUzs7QUFFbEQ7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTs7QUFFQSwyQkFBMkIsV0FBVyxHQUFHLFNBQVM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNhY2hlXFxtZW1vcnktY2FjaGUtc3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5jb25zdCB7IGFzc2VydENhY2hlS2V5LCBhc3NlcnRDYWNoZVZhbHVlIH0gPSByZXF1aXJlKCcuLi91dGlsL2NhY2hlLmpzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0gQ2FjaGVLZXlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWV9IENhY2hlVmFsdWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlU3RvcmV9IENhY2hlU3RvcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdH0gR2V0UmVzdWx0XG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7Q2FjaGVTdG9yZX1cbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmNsYXNzIE1lbW9yeUNhY2hlU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAjbWF4Q291bnQgPSAxMDI0XG4gICNtYXhTaXplID0gMTA0ODU3NjAwIC8vIDEwME1CXG4gICNtYXhFbnRyeVNpemUgPSA1MjQyODgwIC8vIDVNQlxuXG4gICNzaXplID0gMFxuICAjY291bnQgPSAwXG4gICNlbnRyaWVzID0gbmV3IE1hcCgpXG4gICNoYXNFbWl0dGVkTWF4U2l6ZUV2ZW50ID0gZmFsc2VcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0Lk1lbW9yeUNhY2hlU3RvcmVPcHRzIHwgdW5kZWZpbmVkfSBbb3B0c11cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIoKVxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lbW9yeUNhY2hlU3RvcmUgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm1heENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heENvdW50ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdHMubWF4Q291bnQpIHx8XG4gICAgICAgICAgb3B0cy5tYXhDb3VudCA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVtb3J5Q2FjaGVTdG9yZSBvcHRpb25zLm1heENvdW50IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWF4Q291bnQgPSBvcHRzLm1heENvdW50XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm1heFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIG9wdHMubWF4U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heFNpemUpIHx8XG4gICAgICAgICAgb3B0cy5tYXhTaXplIDwgMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZW1vcnlDYWNoZVN0b3JlIG9wdGlvbnMubWF4U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBvcHRzLm1heFNpemVcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heEVudHJ5U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heEVudHJ5U2l6ZSkgfHxcbiAgICAgICAgICBvcHRzLm1heEVudHJ5U2l6ZSA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVtb3J5Q2FjaGVTdG9yZSBvcHRpb25zLm1heEVudHJ5U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heEVudHJ5U2l6ZSA9IG9wdHMubWF4RW50cnlTaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBjYWNoZSBpbiBieXRlc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY3VycmVudCBzaXplIG9mIHRoZSBjYWNoZSBpbiBieXRlc1xuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNhY2hlIGlzIGZ1bGwgKGVpdGhlciBtYXggc2l6ZSBvciBtYXggY291bnQgcmVhY2hlZClcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNhY2hlIGlzIGZ1bGwsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaXNGdWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZSA+PSB0aGlzLiNtYXhTaXplIHx8IHRoaXMuI2NvdW50ID49IHRoaXMuI21heENvdW50XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSByZXFcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0IHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG5cbiAgICBjb25zdCB0b3BMZXZlbEtleSA9IGAke2tleS5vcmlnaW59OiR7a2V5LnBhdGh9YFxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLiNlbnRyaWVzLmdldCh0b3BMZXZlbEtleSlcblxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllcyA/IGZpbmRFbnRyeShrZXksIGVudHJpZXMsIG5vdykgOiBudWxsXG5cbiAgICByZXR1cm4gZW50cnkgPT0gbnVsbFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDoge1xuICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IGVudHJ5LnN0YXR1c01lc3NhZ2UsXG4gICAgICAgICAgc3RhdHVzQ29kZTogZW50cnkuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzOiBlbnRyeS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGVudHJ5LmJvZHksXG4gICAgICAgICAgdmFyeTogZW50cnkudmFyeSA/IGVudHJ5LnZhcnkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZXRhZzogZW50cnkuZXRhZyxcbiAgICAgICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzOiBlbnRyeS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzLFxuICAgICAgICAgIGNhY2hlZEF0OiBlbnRyeS5jYWNoZWRBdCxcbiAgICAgICAgICBzdGFsZUF0OiBlbnRyeS5zdGFsZUF0LFxuICAgICAgICAgIGRlbGV0ZUF0OiBlbnRyeS5kZWxldGVBdFxuICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWV9IHZhbFxuICAgKiBAcmV0dXJucyB7V3JpdGFibGUgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjcmVhdGVXcml0ZVN0cmVhbSAoa2V5LCB2YWwpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG4gICAgYXNzZXJ0Q2FjaGVWYWx1ZSh2YWwpXG5cbiAgICBjb25zdCB0b3BMZXZlbEtleSA9IGAke2tleS5vcmlnaW59OiR7a2V5LnBhdGh9YFxuXG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzXG4gICAgY29uc3QgZW50cnkgPSB7IC4uLmtleSwgLi4udmFsLCBib2R5OiBbXSwgc2l6ZTogMCB9XG5cbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKHtcbiAgICAgIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5zaXplICs9IGNodW5rLmJ5dGVMZW5ndGhcblxuICAgICAgICBpZiAoZW50cnkuc2l6ZSA+PSBzdG9yZS4jbWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS5ib2R5LnB1c2goY2h1bmspXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgfSxcbiAgICAgIGZpbmFsIChjYWxsYmFjaykge1xuICAgICAgICBsZXQgZW50cmllcyA9IHN0b3JlLiNlbnRyaWVzLmdldCh0b3BMZXZlbEtleSlcbiAgICAgICAgaWYgKCFlbnRyaWVzKSB7XG4gICAgICAgICAgZW50cmllcyA9IFtdXG4gICAgICAgICAgc3RvcmUuI2VudHJpZXMuc2V0KHRvcExldmVsS2V5LCBlbnRyaWVzKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSBmaW5kRW50cnkoa2V5LCBlbnRyaWVzLCBEYXRlLm5vdygpKVxuICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5pbmRleE9mKHByZXZpb3VzRW50cnkpXG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEsIGVudHJ5KVxuICAgICAgICAgIHN0b3JlLiNzaXplIC09IHByZXZpb3VzRW50cnkuc2l6ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSlcbiAgICAgICAgICBzdG9yZS4jY291bnQgKz0gMVxuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmUuI3NpemUgKz0gZW50cnkuc2l6ZVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGlzIGZ1bGwgYW5kIGVtaXQgZXZlbnQgaWYgbmVlZGVkXG4gICAgICAgIGlmIChzdG9yZS4jc2l6ZSA+IHN0b3JlLiNtYXhTaXplIHx8IHN0b3JlLiNjb3VudCA+IHN0b3JlLiNtYXhDb3VudCkge1xuICAgICAgICAgIC8vIEVtaXQgbWF4U2l6ZUV4Y2VlZGVkIGV2ZW50IGlmIHdlIGhhdmVuJ3QgYWxyZWFkeVxuICAgICAgICAgIGlmICghc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQpIHtcbiAgICAgICAgICAgIHN0b3JlLmVtaXQoJ21heFNpemVFeGNlZWRlZCcsIHtcbiAgICAgICAgICAgICAgc2l6ZTogc3RvcmUuI3NpemUsXG4gICAgICAgICAgICAgIG1heFNpemU6IHN0b3JlLiNtYXhTaXplLFxuICAgICAgICAgICAgICBjb3VudDogc3RvcmUuI2NvdW50LFxuICAgICAgICAgICAgICBtYXhDb3VudDogc3RvcmUuI21heENvdW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUGVyZm9ybSBldmljdGlvblxuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cmllc10gb2Ygc3RvcmUuI2VudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcy5zcGxpY2UoMCwgZW50cmllcy5sZW5ndGggLyAyKSkge1xuICAgICAgICAgICAgICBzdG9yZS4jc2l6ZSAtPSBlbnRyeS5zaXplXG4gICAgICAgICAgICAgIHN0b3JlLiNjb3VudCAtPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgc3RvcmUuI2VudHJpZXMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNldCB0aGUgZXZlbnQgZmxhZyBhZnRlciBldmljdGlvblxuICAgICAgICAgIGlmIChzdG9yZS4jc2l6ZSA8IHN0b3JlLiNtYXhTaXplICYmIHN0b3JlLiNjb3VudCA8IHN0b3JlLiNtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlS2V5fSBrZXlcbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2Yga2V5fWApXG4gICAgfVxuXG4gICAgY29uc3QgdG9wTGV2ZWxLZXkgPSBgJHtrZXkub3JpZ2lufToke2tleS5wYXRofWBcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy4jZW50cmllcy5nZXQodG9wTGV2ZWxLZXkpID8/IFtdKSB7XG4gICAgICB0aGlzLiNzaXplIC09IGVudHJ5LnNpemVcbiAgICAgIHRoaXMuI2NvdW50IC09IDFcbiAgICB9XG4gICAgdGhpcy4jZW50cmllcy5kZWxldGUodG9wTGV2ZWxLZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEVudHJ5IChrZXksIGVudHJpZXMsIG5vdykge1xuICByZXR1cm4gZW50cmllcy5maW5kKChlbnRyeSkgPT4gKFxuICAgIGVudHJ5LmRlbGV0ZUF0ID4gbm93ICYmXG4gICAgZW50cnkubWV0aG9kID09PSBrZXkubWV0aG9kICYmXG4gICAgKGVudHJ5LnZhcnkgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlbnRyeS52YXJ5KS5ldmVyeShoZWFkZXJOYW1lID0+IHtcbiAgICAgIGlmIChlbnRyeS52YXJ5W2hlYWRlck5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrZXkuaGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YXJ5W2hlYWRlck5hbWVdID09PSBrZXkuaGVhZGVyc1toZWFkZXJOYW1lXVxuICAgIH0pKVxuICApKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbW9yeUNhY2hlU3RvcmVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/cache/sqlite-cache-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { assertCacheKey, assertCacheValue } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\n\nlet DatabaseSync\n\nconst VERSION = 3\n\n// 2gb\nconst MAX_ENTRY_SIZE = 2 * 1000 * 1000 * 1000\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @implements {CacheStore}\n *\n * @typedef {{\n *  id: Readonly<number>,\n *  body?: Uint8Array\n *  statusCode: number\n *  statusMessage: string\n *  headers?: string\n *  vary?: string\n *  etag?: string\n *  cacheControlDirectives?: string\n *  cachedAt: number\n *  staleAt: number\n *  deleteAt: number\n * }} SqliteStoreValue\n */\nmodule.exports = class SqliteCacheStore {\n  #maxEntrySize = MAX_ENTRY_SIZE\n  #maxCount = Infinity\n\n  /**\n   * @type {import('node:sqlite').DatabaseSync}\n   */\n  #db\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #getValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #updateValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #insertValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteExpiredValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteByUrlQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #countEntriesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync | null}\n   */\n  #deleteOldValuesQuery\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts\n   */\n  constructor (opts) {\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('SqliteCacheStore options must be an object')\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n\n        if (opts.maxEntrySize > MAX_ENTRY_SIZE) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be less than 2gb')\n        }\n\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n    }\n\n    if (!DatabaseSync) {\n      DatabaseSync = (__webpack_require__(/*! node:sqlite */ \"node:sqlite\").DatabaseSync)\n    }\n    this.#db = new DatabaseSync(opts?.location ?? ':memory:')\n\n    this.#db.exec(`\n      PRAGMA journal_mode = WAL;\n      PRAGMA synchronous = NORMAL;\n      PRAGMA temp_store = memory;\n      PRAGMA optimize;\n\n      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (\n        -- Data specific to us\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        url TEXT NOT NULL,\n        method TEXT NOT NULL,\n\n        -- Data returned to the interceptor\n        body BUF NULL,\n        deleteAt INTEGER NOT NULL,\n        statusCode INTEGER NOT NULL,\n        statusMessage TEXT NOT NULL,\n        headers TEXT NULL,\n        cacheControlDirectives TEXT NULL,\n        etag TEXT NULL,\n        vary TEXT NULL,\n        cachedAt INTEGER NOT NULL,\n        staleAt INTEGER NOT NULL\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_getValuesQuery ON cacheInterceptorV${VERSION}(url, method, deleteAt);\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteByUrlQuery ON cacheInterceptorV${VERSION}(deleteAt);\n    `)\n\n    this.#getValuesQuery = this.#db.prepare(`\n      SELECT\n        id,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      FROM cacheInterceptorV${VERSION}\n      WHERE\n        url = ?\n        AND method = ?\n      ORDER BY\n        deleteAt ASC\n    `)\n\n    this.#updateValueQuery = this.#db.prepare(`\n      UPDATE cacheInterceptorV${VERSION} SET\n        body = ?,\n        deleteAt = ?,\n        statusCode = ?,\n        statusMessage = ?,\n        headers = ?,\n        etag = ?,\n        cacheControlDirectives = ?,\n        cachedAt = ?,\n        staleAt = ?\n      WHERE\n        id = ?\n    `)\n\n    this.#insertValueQuery = this.#db.prepare(`\n      INSERT INTO cacheInterceptorV${VERSION} (\n        url,\n        method,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `)\n\n    this.#deleteByUrlQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`\n    )\n\n    this.#countEntriesQuery = this.#db.prepare(\n      `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`\n    )\n\n    this.#deleteExpiredValuesQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`\n    )\n\n    this.#deleteOldValuesQuery = this.#maxCount === Infinity\n      ? null\n      : this.#db.prepare(`\n        DELETE FROM cacheInterceptorV${VERSION}\n        WHERE id IN (\n          SELECT\n            id\n          FROM cacheInterceptorV${VERSION}\n          ORDER BY cachedAt DESC\n          LIMIT ?\n        )\n      `)\n  }\n\n  close () {\n    this.#db.close()\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const value = this.#findValue(key)\n    return value\n      ? {\n          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : undefined,\n          statusCode: value.statusCode,\n          statusMessage: value.statusMessage,\n          headers: value.headers ? JSON.parse(value.headers) : undefined,\n          etag: value.etag ? value.etag : undefined,\n          vary: value.vary ? JSON.parse(value.vary) : undefined,\n          cacheControlDirectives: value.cacheControlDirectives\n            ? JSON.parse(value.cacheControlDirectives)\n            : undefined,\n          cachedAt: value.cachedAt,\n          staleAt: value.staleAt,\n          deleteAt: value.deleteAt\n        }\n      : undefined\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value\n   */\n  set (key, value) {\n    assertCacheKey(key)\n\n    const url = this.#makeValueUrl(key)\n    const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body\n    const size = body?.byteLength\n\n    if (size && size > this.#maxEntrySize) {\n      return\n    }\n\n    const existingValue = this.#findValue(key, true)\n    if (existingValue) {\n      // Updating an existing response, let's overwrite it\n      this.#updateValueQuery.run(\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.cachedAt,\n        value.staleAt,\n        existingValue.id\n      )\n    } else {\n      this.#prune()\n      // New response, let's insert it\n      this.#insertValueQuery.run(\n        url,\n        key.method,\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.vary ? JSON.stringify(value.vary) : null,\n        value.cachedAt,\n        value.staleAt\n      )\n    }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, value) {\n    assertCacheKey(key)\n    assertCacheValue(value)\n\n    let size = 0\n    /**\n     * @type {Buffer[] | null}\n     */\n    const body = []\n    const store = this\n\n    return new Writable({\n      decodeStrings: true,\n      write (chunk, encoding, callback) {\n        size += chunk.byteLength\n\n        if (size < store.#maxEntrySize) {\n          body.push(chunk)\n        } else {\n          this.destroy()\n        }\n\n        callback()\n      },\n      final (callback) {\n        store.set(key, { ...value, body })\n        callback()\n      }\n    })\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    this.#deleteByUrlQuery.run(this.#makeValueUrl(key))\n  }\n\n  #prune () {\n    if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {\n      return 0\n    }\n\n    {\n      const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    {\n      const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Counts the number of rows in the cache\n   * @returns {Number}\n   */\n  get size () {\n    const { total } = this.#countEntriesQuery.get()\n    return total\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {string}\n   */\n  #makeValueUrl (key) {\n    return `${key.origin}/${key.path}`\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {boolean} [canBeExpired=false]\n   * @returns {SqliteStoreValue | undefined}\n   */\n  #findValue (key, canBeExpired = false) {\n    const url = this.#makeValueUrl(key)\n    const { headers, method } = key\n\n    /**\n     * @type {SqliteStoreValue[]}\n     */\n    const values = this.#getValuesQuery.all(url, method)\n\n    if (values.length === 0) {\n      return undefined\n    }\n\n    const now = Date.now()\n    for (const value of values) {\n      if (now >= value.deleteAt && !canBeExpired) {\n        return undefined\n      }\n\n      let matches = true\n\n      if (value.vary) {\n        const vary = JSON.parse(value.vary)\n\n        for (const header in vary) {\n          if (!headerValueEquals(headers[header], vary[header])) {\n            matches = false\n            break\n          }\n        }\n      }\n\n      if (matches) {\n        return value\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * @param {string|string[]|null|undefined} lhs\n * @param {string|string[]|null|undefined} rhs\n * @returns {boolean}\n */\nfunction headerValueEquals (lhs, rhs) {\n  if (lhs == null && rhs == null) {\n    return true\n  }\n\n  if ((lhs == null && rhs != null) ||\n      (lhs != null && rhs == null)) {\n    return false\n  }\n\n  if (Array.isArray(lhs) && Array.isArray(rhs)) {\n    if (lhs.length !== rhs.length) {\n      return false\n    }\n\n    return lhs.every((x, i) => x === rhs[i])\n  }\n\n  return lhs === rhs\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9zcWxpdGUtY2FjaGUtc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsdUVBQWtCOztBQUV2RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpRUFBaUU7QUFDOUUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUZBQXVGO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0VBQW1DO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFFBQVEs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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY2FjaGVcXHNxbGl0ZS1jYWNoZS1zdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBhc3NlcnRDYWNoZUtleSwgYXNzZXJ0Q2FjaGVWYWx1ZSB9ID0gcmVxdWlyZSgnLi4vdXRpbC9jYWNoZS5qcycpXG5cbmxldCBEYXRhYmFzZVN5bmNcblxuY29uc3QgVkVSU0lPTiA9IDNcblxuLy8gMmdiXG5jb25zdCBNQVhfRU5UUllfU0laRSA9IDIgKiAxMDAwICogMTAwMCAqIDEwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZVN0b3JlfSBDYWNoZVN0b3JlXG4gKiBAaW1wbGVtZW50cyB7Q2FjaGVTdG9yZX1cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogIGlkOiBSZWFkb25seTxudW1iZXI+LFxuICogIGJvZHk/OiBVaW50OEFycmF5XG4gKiAgc3RhdHVzQ29kZTogbnVtYmVyXG4gKiAgc3RhdHVzTWVzc2FnZTogc3RyaW5nXG4gKiAgaGVhZGVycz86IHN0cmluZ1xuICogIHZhcnk/OiBzdHJpbmdcbiAqICBldGFnPzogc3RyaW5nXG4gKiAgY2FjaGVDb250cm9sRGlyZWN0aXZlcz86IHN0cmluZ1xuICogIGNhY2hlZEF0OiBudW1iZXJcbiAqICBzdGFsZUF0OiBudW1iZXJcbiAqICBkZWxldGVBdDogbnVtYmVyXG4gKiB9fSBTcWxpdGVTdG9yZVZhbHVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3FsaXRlQ2FjaGVTdG9yZSB7XG4gICNtYXhFbnRyeVNpemUgPSBNQVhfRU5UUllfU0laRVxuICAjbWF4Q291bnQgPSBJbmZpbml0eVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLkRhdGFiYXNlU3luY31cbiAgICovXG4gICNkYlxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjZ2V0VmFsdWVzUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI3VwZGF0ZVZhbHVlUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI2luc2VydFZhbHVlUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI2RlbGV0ZUV4cGlyZWRWYWx1ZXNRdWVyeVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjZGVsZXRlQnlVcmxRdWVyeVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjY291bnRFbnRyaWVzUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jIHwgbnVsbH1cbiAgICovXG4gICNkZWxldGVPbGRWYWx1ZXNRdWVyeVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuU3FsaXRlQ2FjaGVTdG9yZU9wdHMgfCB1bmRlZmluZWR9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3FsaXRlQ2FjaGVTdG9yZSBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heEVudHJ5U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heEVudHJ5U2l6ZSkgfHxcbiAgICAgICAgICBvcHRzLm1heEVudHJ5U2l6ZSA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3FsaXRlQ2FjaGVTdG9yZSBvcHRpb25zLm1heEVudHJ5U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplID4gTUFYX0VOVFJZX1NJWkUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTcWxpdGVDYWNoZVN0b3JlIG9wdGlvbnMubWF4RW50cnlTaXplIG11c3QgYmUgbGVzcyB0aGFuIDJnYicpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNtYXhFbnRyeVNpemUgPSBvcHRzLm1heEVudHJ5U2l6ZVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5tYXhDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2Ygb3B0cy5tYXhDb3VudCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heENvdW50KSB8fFxuICAgICAgICAgIG9wdHMubWF4Q291bnQgPCAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NxbGl0ZUNhY2hlU3RvcmUgb3B0aW9ucy5tYXhDb3VudCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heENvdW50ID0gb3B0cy5tYXhDb3VudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghRGF0YWJhc2VTeW5jKSB7XG4gICAgICBEYXRhYmFzZVN5bmMgPSByZXF1aXJlKCdub2RlOnNxbGl0ZScpLkRhdGFiYXNlU3luY1xuICAgIH1cbiAgICB0aGlzLiNkYiA9IG5ldyBEYXRhYmFzZVN5bmMob3B0cz8ubG9jYXRpb24gPz8gJzptZW1vcnk6JylcblxuICAgIHRoaXMuI2RiLmV4ZWMoYFxuICAgICAgUFJBR01BIGpvdXJuYWxfbW9kZSA9IFdBTDtcbiAgICAgIFBSQUdNQSBzeW5jaHJvbm91cyA9IE5PUk1BTDtcbiAgICAgIFBSQUdNQSB0ZW1wX3N0b3JlID0gbWVtb3J5O1xuICAgICAgUFJBR01BIG9wdGltaXplO1xuXG4gICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn0gKFxuICAgICAgICAtLSBEYXRhIHNwZWNpZmljIHRvIHVzXG4gICAgICAgIGlkIElOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVCxcbiAgICAgICAgdXJsIFRFWFQgTk9UIE5VTEwsXG4gICAgICAgIG1ldGhvZCBURVhUIE5PVCBOVUxMLFxuXG4gICAgICAgIC0tIERhdGEgcmV0dXJuZWQgdG8gdGhlIGludGVyY2VwdG9yXG4gICAgICAgIGJvZHkgQlVGIE5VTEwsXG4gICAgICAgIGRlbGV0ZUF0IElOVEVHRVIgTk9UIE5VTEwsXG4gICAgICAgIHN0YXR1c0NvZGUgSU5URUdFUiBOT1QgTlVMTCxcbiAgICAgICAgc3RhdHVzTWVzc2FnZSBURVhUIE5PVCBOVUxMLFxuICAgICAgICBoZWFkZXJzIFRFWFQgTlVMTCxcbiAgICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlcyBURVhUIE5VTEwsXG4gICAgICAgIGV0YWcgVEVYVCBOVUxMLFxuICAgICAgICB2YXJ5IFRFWFQgTlVMTCxcbiAgICAgICAgY2FjaGVkQXQgSU5URUdFUiBOT1QgTlVMTCxcbiAgICAgICAgc3RhbGVBdCBJTlRFR0VSIE5PVCBOVUxMXG4gICAgICApO1xuXG4gICAgICBDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059X2dldFZhbHVlc1F1ZXJ5IE9OIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfSh1cmwsIG1ldGhvZCwgZGVsZXRlQXQpO1xuICAgICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2NhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfV9kZWxldGVCeVVybFF1ZXJ5IE9OIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfShkZWxldGVBdCk7XG4gICAgYClcblxuICAgIHRoaXMuI2dldFZhbHVlc1F1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBTRUxFQ1RcbiAgICAgICAgaWQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGRlbGV0ZUF0LFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNNZXNzYWdlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBldGFnLFxuICAgICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLFxuICAgICAgICB2YXJ5LFxuICAgICAgICBjYWNoZWRBdCxcbiAgICAgICAgc3RhbGVBdFxuICAgICAgRlJPTSBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn1cbiAgICAgIFdIRVJFXG4gICAgICAgIHVybCA9ID9cbiAgICAgICAgQU5EIG1ldGhvZCA9ID9cbiAgICAgIE9SREVSIEJZXG4gICAgICAgIGRlbGV0ZUF0IEFTQ1xuICAgIGApXG5cbiAgICB0aGlzLiN1cGRhdGVWYWx1ZVF1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBVUERBVEUgY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059IFNFVFxuICAgICAgICBib2R5ID0gPyxcbiAgICAgICAgZGVsZXRlQXQgPSA/LFxuICAgICAgICBzdGF0dXNDb2RlID0gPyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZSA9ID8sXG4gICAgICAgIGhlYWRlcnMgPSA/LFxuICAgICAgICBldGFnID0gPyxcbiAgICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlcyA9ID8sXG4gICAgICAgIGNhY2hlZEF0ID0gPyxcbiAgICAgICAgc3RhbGVBdCA9ID9cbiAgICAgIFdIRVJFXG4gICAgICAgIGlkID0gP1xuICAgIGApXG5cbiAgICB0aGlzLiNpbnNlcnRWYWx1ZVF1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBJTlNFUlQgSU5UTyBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn0gKFxuICAgICAgICB1cmwsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZGVsZXRlQXQsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIHN0YXR1c01lc3NhZ2UsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGV0YWcsXG4gICAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMsXG4gICAgICAgIHZhcnksXG4gICAgICAgIGNhY2hlZEF0LFxuICAgICAgICBzdGFsZUF0XG4gICAgICApIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPywgPywgPywgPywgPywgPylcbiAgICBgKVxuXG4gICAgdGhpcy4jZGVsZXRlQnlVcmxRdWVyeSA9IHRoaXMuI2RiLnByZXBhcmUoXG4gICAgICBgREVMRVRFIEZST00gY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059IFdIRVJFIHVybCA9ID9gXG4gICAgKVxuXG4gICAgdGhpcy4jY291bnRFbnRyaWVzUXVlcnkgPSB0aGlzLiNkYi5wcmVwYXJlKFxuICAgICAgYFNFTEVDVCBDT1VOVCgqKSBBUyB0b3RhbCBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfWBcbiAgICApXG5cbiAgICB0aGlzLiNkZWxldGVFeHBpcmVkVmFsdWVzUXVlcnkgPSB0aGlzLiNkYi5wcmVwYXJlKFxuICAgICAgYERFTEVURSBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfSBXSEVSRSBkZWxldGVBdCA8PSA/YFxuICAgIClcblxuICAgIHRoaXMuI2RlbGV0ZU9sZFZhbHVlc1F1ZXJ5ID0gdGhpcy4jbWF4Q291bnQgPT09IEluZmluaXR5XG4gICAgICA/IG51bGxcbiAgICAgIDogdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICAgIERFTEVURSBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfVxuICAgICAgICBXSEVSRSBpZCBJTiAoXG4gICAgICAgICAgU0VMRUNUXG4gICAgICAgICAgICBpZFxuICAgICAgICAgIEZST00gY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059XG4gICAgICAgICAgT1JERVIgQlkgY2FjaGVkQXQgREVTQ1xuICAgICAgICAgIExJTUlUID9cbiAgICAgICAgKVxuICAgICAgYClcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLiNkYi5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHJldHVybnMgeyhpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdCAmIHsgYm9keT86IEJ1ZmZlciB9KSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgYXNzZXJ0Q2FjaGVLZXkoa2V5KVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNmaW5kVmFsdWUoa2V5KVxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgPyB7XG4gICAgICAgICAgYm9keTogdmFsdWUuYm9keSA/IEJ1ZmZlci5mcm9tKHZhbHVlLmJvZHkuYnVmZmVyLCB2YWx1ZS5ib2R5LmJ5dGVPZmZzZXQsIHZhbHVlLmJvZHkuYnl0ZUxlbmd0aCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc3RhdHVzQ29kZTogdmFsdWUuc3RhdHVzQ29kZSxcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiB2YWx1ZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgIGhlYWRlcnM6IHZhbHVlLmhlYWRlcnMgPyBKU09OLnBhcnNlKHZhbHVlLmhlYWRlcnMpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGV0YWc6IHZhbHVlLmV0YWcgPyB2YWx1ZS5ldGFnIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHZhcnk6IHZhbHVlLnZhcnkgPyBKU09OLnBhcnNlKHZhbHVlLnZhcnkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXM6IHZhbHVlLmNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAgICAgICAgICAgID8gSlNPTi5wYXJzZSh2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2FjaGVkQXQ6IHZhbHVlLmNhY2hlZEF0LFxuICAgICAgICAgIHN0YWxlQXQ6IHZhbHVlLnN0YWxlQXQsXG4gICAgICAgICAgZGVsZXRlQXQ6IHZhbHVlLmRlbGV0ZUF0XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWUgJiB7IGJvZHk6IG51bGwgfCBCdWZmZXIgfCBBcnJheTxCdWZmZXI+fX0gdmFsdWVcbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydENhY2hlS2V5KGtleSlcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuI21ha2VWYWx1ZVVybChrZXkpXG4gICAgY29uc3QgYm9keSA9IEFycmF5LmlzQXJyYXkodmFsdWUuYm9keSkgPyBCdWZmZXIuY29uY2F0KHZhbHVlLmJvZHkpIDogdmFsdWUuYm9keVxuICAgIGNvbnN0IHNpemUgPSBib2R5Py5ieXRlTGVuZ3RoXG5cbiAgICBpZiAoc2l6ZSAmJiBzaXplID4gdGhpcy4jbWF4RW50cnlTaXplKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy4jZmluZFZhbHVlKGtleSwgdHJ1ZSlcbiAgICBpZiAoZXhpc3RpbmdWYWx1ZSkge1xuICAgICAgLy8gVXBkYXRpbmcgYW4gZXhpc3RpbmcgcmVzcG9uc2UsIGxldCdzIG92ZXJ3cml0ZSBpdFxuICAgICAgdGhpcy4jdXBkYXRlVmFsdWVRdWVyeS5ydW4oXG4gICAgICAgIGJvZHksXG4gICAgICAgIHZhbHVlLmRlbGV0ZUF0LFxuICAgICAgICB2YWx1ZS5zdGF0dXNDb2RlLFxuICAgICAgICB2YWx1ZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICB2YWx1ZS5oZWFkZXJzID8gSlNPTi5zdHJpbmdpZnkodmFsdWUuaGVhZGVycykgOiBudWxsLFxuICAgICAgICB2YWx1ZS5ldGFnID8gdmFsdWUuZXRhZyA6IG51bGwsXG4gICAgICAgIHZhbHVlLmNhY2hlQ29udHJvbERpcmVjdGl2ZXMgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSA6IG51bGwsXG4gICAgICAgIHZhbHVlLmNhY2hlZEF0LFxuICAgICAgICB2YWx1ZS5zdGFsZUF0LFxuICAgICAgICBleGlzdGluZ1ZhbHVlLmlkXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3BydW5lKClcbiAgICAgIC8vIE5ldyByZXNwb25zZSwgbGV0J3MgaW5zZXJ0IGl0XG4gICAgICB0aGlzLiNpbnNlcnRWYWx1ZVF1ZXJ5LnJ1bihcbiAgICAgICAgdXJsLFxuICAgICAgICBrZXkubWV0aG9kLFxuICAgICAgICBib2R5LFxuICAgICAgICB2YWx1ZS5kZWxldGVBdCxcbiAgICAgICAgdmFsdWUuc3RhdHVzQ29kZSxcbiAgICAgICAgdmFsdWUuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgdmFsdWUuaGVhZGVycyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlLmhlYWRlcnMpIDogbnVsbCxcbiAgICAgICAgdmFsdWUuZXRhZyA/IHZhbHVlLmV0YWcgOiBudWxsLFxuICAgICAgICB2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzID8gSlNPTi5zdHJpbmdpZnkodmFsdWUuY2FjaGVDb250cm9sRGlyZWN0aXZlcykgOiBudWxsLFxuICAgICAgICB2YWx1ZS52YXJ5ID8gSlNPTi5zdHJpbmdpZnkodmFsdWUudmFyeSkgOiBudWxsLFxuICAgICAgICB2YWx1ZS5jYWNoZWRBdCxcbiAgICAgICAgdmFsdWUuc3RhbGVBdFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGtleVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVWYWx1ZX0gdmFsdWVcbiAgICogQHJldHVybnMge1dyaXRhYmxlIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgY3JlYXRlV3JpdGVTdHJlYW0gKGtleSwgdmFsdWUpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG4gICAgYXNzZXJ0Q2FjaGVWYWx1ZSh2YWx1ZSlcblxuICAgIGxldCBzaXplID0gMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCdWZmZXJbXSB8IG51bGx9XG4gICAgICovXG4gICAgY29uc3QgYm9keSA9IFtdXG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzXG5cbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKHtcbiAgICAgIGRlY29kZVN0cmluZ3M6IHRydWUsXG4gICAgICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBzaXplICs9IGNodW5rLmJ5dGVMZW5ndGhcblxuICAgICAgICBpZiAoc2l6ZSA8IHN0b3JlLiNtYXhFbnRyeVNpemUpIHtcbiAgICAgICAgICBib2R5LnB1c2goY2h1bmspXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0sXG4gICAgICBmaW5hbCAoY2FsbGJhY2spIHtcbiAgICAgICAgc3RvcmUuc2V0KGtleSwgeyAuLi52YWx1ZSwgYm9keSB9KVxuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGtleVxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGtleSB0byBiZSBvYmplY3QsIGdvdCAke3R5cGVvZiBrZXl9YClcbiAgICB9XG5cbiAgICB0aGlzLiNkZWxldGVCeVVybFF1ZXJ5LnJ1bih0aGlzLiNtYWtlVmFsdWVVcmwoa2V5KSlcbiAgfVxuXG4gICNwcnVuZSAoKSB7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aGlzLiNtYXhDb3VudCkgJiYgdGhpcy5zaXplIDw9IHRoaXMuI21heENvdW50KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLiNkZWxldGVFeHBpcmVkVmFsdWVzUXVlcnkucnVuKERhdGUubm93KCkpLmNoYW5nZXNcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMuI2RlbGV0ZU9sZFZhbHVlc1F1ZXJ5Py5ydW4oTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLiNtYXhDb3VudCAqIDAuMSksIDEpKS5jaGFuZ2VzXG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvKipcbiAgICogQ291bnRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgY2FjaGVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICBjb25zdCB7IHRvdGFsIH0gPSB0aGlzLiNjb3VudEVudHJpZXNRdWVyeS5nZXQoKVxuICAgIHJldHVybiB0b3RhbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0ga2V5XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICAjbWFrZVZhbHVlVXJsIChrZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5Lm9yaWdpbn0vJHtrZXkucGF0aH1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2FuQmVFeHBpcmVkPWZhbHNlXVxuICAgKiBAcmV0dXJucyB7U3FsaXRlU3RvcmVWYWx1ZSB8IHVuZGVmaW5lZH1cbiAgICovXG4gICNmaW5kVmFsdWUgKGtleSwgY2FuQmVFeHBpcmVkID0gZmFsc2UpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNtYWtlVmFsdWVVcmwoa2V5KVxuICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kIH0gPSBrZXlcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTcWxpdGVTdG9yZVZhbHVlW119XG4gICAgICovXG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy4jZ2V0VmFsdWVzUXVlcnkuYWxsKHVybCwgbWV0aG9kKVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChub3cgPj0gdmFsdWUuZGVsZXRlQXQgJiYgIWNhbkJlRXhwaXJlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gdHJ1ZVxuXG4gICAgICBpZiAodmFsdWUudmFyeSkge1xuICAgICAgICBjb25zdCB2YXJ5ID0gSlNPTi5wYXJzZSh2YWx1ZS52YXJ5KVxuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIHZhcnkpIHtcbiAgICAgICAgICBpZiAoIWhlYWRlclZhbHVlRXF1YWxzKGhlYWRlcnNbaGVhZGVyXSwgdmFyeVtoZWFkZXJdKSkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxudWxsfHVuZGVmaW5lZH0gbGhzXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxudWxsfHVuZGVmaW5lZH0gcmhzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGVhZGVyVmFsdWVFcXVhbHMgKGxocywgcmhzKSB7XG4gIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoKGxocyA9PSBudWxsICYmIHJocyAhPSBudWxsKSB8fFxuICAgICAgKGxocyAhPSBudWxsICYmIHJocyA9PSBudWxsKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICBpZiAobGhzLmxlbmd0aCAhPT0gcmhzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGxocy5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmhzW2ldKVxuICB9XG5cbiAgcmV0dXJuIGxocyA9PT0gcmhzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nconst SessionCache = class WeakSessionCache {\n  constructor (maxCachedSessions) {\n    this._maxCachedSessions = maxCachedSessions\n    this._sessionCache = new Map()\n    this._sessionRegistry = new FinalizationRegistry((key) => {\n      if (this._sessionCache.size < this._maxCachedSessions) {\n        return\n      }\n\n      const ref = this._sessionCache.get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this._sessionCache.delete(key)\n      }\n    })\n  }\n\n  get (sessionKey) {\n    const ref = this._sessionCache.get(sessionKey)\n    return ref ? ref.deref() : null\n  }\n\n  set (sessionKey, session) {\n    if (this._maxCachedSessions === 0) {\n      return\n    }\n\n    this._sessionCache.set(sessionKey, new WeakRef(session))\n    this._sessionRegistry.register(session, sessionKey)\n  }\n}\n\nfunction buildConnector ({ allowH2, useH2c, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = __webpack_require__(/*! node:tls */ \"node:tls\")\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      assert(sessionKey)\n\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      port = port || 443\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n\n      port = port || 80\n\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port,\n        host: hostname\n      })\n      if (useH2c === true) {\n        socket.alpnProtocol = 'h2'\n      }\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port })\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nmodule.exports = buildConnector\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGdFQUFVOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwRkFBMEY7QUFDckg7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywwQkFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRkFBZ0YseUJBQXlCOztBQUV6RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmxldCB0bHMgLy8gaW5jbHVkZSB0bHMgY29uZGl0aW9uYWxseSBzaW5jZSBpdCBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZVxuXG4vLyBUT0RPOiBzZXNzaW9uIHJlLXVzZSBkb2VzIG5vdCB3YWl0IGZvciB0aGUgZmlyc3Rcbi8vIGNvbm5lY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2Vzc2lvbiBhbmQgbWlnaHQgdGhlcmVmb3JlXG4vLyByZXNvbHZlIHRoZSBzYW1lIHNlcnZlcm5hbWUgbXVsdGlwbGUgdGltZXMgZXZlbiB3aGVuXG4vLyByZS11c2UgaXMgZW5hYmxlZC5cblxuY29uc3QgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgIHRoaXMuX21heENhY2hlZFNlc3Npb25zID0gbWF4Q2FjaGVkU2Vzc2lvbnNcbiAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Nlc3Npb25DYWNoZS5zaXplIDwgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoa2V5KVxuICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkICYmIHJlZi5kZXJlZigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCAoc2Vzc2lvbktleSkge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSlcbiAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gIH1cblxuICBzZXQgKHNlc3Npb25LZXksIHNlc3Npb24pIHtcbiAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5LnJlZ2lzdGVyKHNlc3Npb24sIHNlc3Npb25LZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgdXNlSDJjLCBtYXhDYWNoZWRTZXNzaW9ucywgc29ja2V0UGF0aCwgdGltZW91dCwgc2Vzc2lvbjogY3VzdG9tU2Vzc2lvbiwgLi4ub3B0cyB9KSB7XG4gIGlmIChtYXhDYWNoZWRTZXNzaW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhDYWNoZWRTZXNzaW9ucykgfHwgbWF4Q2FjaGVkU2Vzc2lvbnMgPCAwKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4Q2FjaGVkU2Vzc2lvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gIH1cblxuICBjb25zdCBvcHRpb25zID0geyBwYXRoOiBzb2NrZXRQYXRoLCAuLi5vcHRzIH1cbiAgY29uc3Qgc2Vzc2lvbkNhY2hlID0gbmV3IFNlc3Npb25DYWNoZShtYXhDYWNoZWRTZXNzaW9ucyA9PSBudWxsID8gMTAwIDogbWF4Q2FjaGVkU2Vzc2lvbnMpXG4gIHRpbWVvdXQgPSB0aW1lb3V0ID09IG51bGwgPyAxMGUzIDogdGltZW91dFxuICBhbGxvd0gyID0gYWxsb3dIMiAhPSBudWxsID8gYWxsb3dIMiA6IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0ICh7IGhvc3RuYW1lLCBob3N0LCBwcm90b2NvbCwgcG9ydCwgc2VydmVybmFtZSwgbG9jYWxBZGRyZXNzLCBodHRwU29ja2V0IH0sIGNhbGxiYWNrKSB7XG4gICAgbGV0IHNvY2tldFxuICAgIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIGlmICghdGxzKSB7XG4gICAgICAgIHRscyA9IHJlcXVpcmUoJ25vZGU6dGxzJylcbiAgICAgIH1cbiAgICAgIHNlcnZlcm5hbWUgPSBzZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuc2VydmVybmFtZSB8fCB1dGlsLmdldFNlcnZlck5hbWUoaG9zdCkgfHwgbnVsbFxuXG4gICAgICBjb25zdCBzZXNzaW9uS2V5ID0gc2VydmVybmFtZSB8fCBob3N0bmFtZVxuICAgICAgYXNzZXJ0KHNlc3Npb25LZXkpXG5cbiAgICAgIGNvbnN0IHNlc3Npb24gPSBjdXN0b21TZXNzaW9uIHx8IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBwb3J0ID0gcG9ydCB8fCA0NDNcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIEFMUE5Qcm90b2NvbHM6IGFsbG93SDIgPyBbJ2h0dHAvMS4xJywgJ2gyJ10gOiBbJ2h0dHAvMS4xJ10sXG4gICAgICAgIHNvY2tldDogaHR0cFNvY2tldCwgLy8gdXBncmFkZSBzb2NrZXQgY29ubmVjdGlvblxuICAgICAgICBwb3J0LFxuICAgICAgICBob3N0OiBob3N0bmFtZVxuICAgICAgfSlcblxuICAgICAgc29ja2V0XG4gICAgICAgIC5vbignc2Vzc2lvbicsIGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogQ2FuIGEgc2Vzc2lvbiBiZWNvbWUgaW52YWxpZCBvbmNlIGVzdGFibGlzaGVkPyBEb24ndCB0aGluayBzbz9cbiAgICAgICAgICBzZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIHNlc3Npb24pXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCghaHR0cFNvY2tldCwgJ2h0dHBTb2NrZXQgY2FuIG9ubHkgYmUgc2VudCBvbiBUTFMgdXBkYXRlJylcblxuICAgICAgcG9ydCA9IHBvcnQgfHwgODBcblxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgICBpZiAodXNlSDJjID09PSB0cnVlKSB7XG4gICAgICAgIHNvY2tldC5hbHBuUHJvdG9jb2wgPSAnaDInXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhckNvbm5lY3RUaW1lb3V0ID0gdXRpbC5zZXR1cENvbm5lY3RUaW1lb3V0KG5ldyBXZWFrUmVmKHNvY2tldCksIHsgdGltZW91dCwgaG9zdG5hbWUsIHBvcnQgfSlcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbGVhckNvbm5lY3RUaW1lb3V0KVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihudWxsLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJDb25uZWN0VGltZW91dClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcmV0dXJuIHNvY2tldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRDb25uZWN0b3JcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @see https://developer.mozilla.org/docs/Web/HTTP/Headers\n */\nconst wellknownHeaderNames = /** @type {const} */ ([\n  'Accept',\n  'Accept-Encoding',\n  'Accept-Language',\n  'Accept-Ranges',\n  'Access-Control-Allow-Credentials',\n  'Access-Control-Allow-Headers',\n  'Access-Control-Allow-Methods',\n  'Access-Control-Allow-Origin',\n  'Access-Control-Expose-Headers',\n  'Access-Control-Max-Age',\n  'Access-Control-Request-Headers',\n  'Access-Control-Request-Method',\n  'Age',\n  'Allow',\n  'Alt-Svc',\n  'Alt-Used',\n  'Authorization',\n  'Cache-Control',\n  'Clear-Site-Data',\n  'Connection',\n  'Content-Disposition',\n  'Content-Encoding',\n  'Content-Language',\n  'Content-Length',\n  'Content-Location',\n  'Content-Range',\n  'Content-Security-Policy',\n  'Content-Security-Policy-Report-Only',\n  'Content-Type',\n  'Cookie',\n  'Cross-Origin-Embedder-Policy',\n  'Cross-Origin-Opener-Policy',\n  'Cross-Origin-Resource-Policy',\n  'Date',\n  'Device-Memory',\n  'Downlink',\n  'ECT',\n  'ETag',\n  'Expect',\n  'Expect-CT',\n  'Expires',\n  'Forwarded',\n  'From',\n  'Host',\n  'If-Match',\n  'If-Modified-Since',\n  'If-None-Match',\n  'If-Range',\n  'If-Unmodified-Since',\n  'Keep-Alive',\n  'Last-Modified',\n  'Link',\n  'Location',\n  'Max-Forwards',\n  'Origin',\n  'Permissions-Policy',\n  'Pragma',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'RTT',\n  'Range',\n  'Referer',\n  'Referrer-Policy',\n  'Refresh',\n  'Retry-After',\n  'Sec-WebSocket-Accept',\n  'Sec-WebSocket-Extensions',\n  'Sec-WebSocket-Key',\n  'Sec-WebSocket-Protocol',\n  'Sec-WebSocket-Version',\n  'Server',\n  'Server-Timing',\n  'Service-Worker-Allowed',\n  'Service-Worker-Navigation-Preload',\n  'Set-Cookie',\n  'SourceMap',\n  'Strict-Transport-Security',\n  'Supports-Loading-Mode',\n  'TE',\n  'Timing-Allow-Origin',\n  'Trailer',\n  'Transfer-Encoding',\n  'Upgrade',\n  'Upgrade-Insecure-Requests',\n  'User-Agent',\n  'Vary',\n  'Via',\n  'WWW-Authenticate',\n  'X-Content-Type-Options',\n  'X-DNS-Prefetch-Control',\n  'X-Frame-Options',\n  'X-Permitted-Cross-Domain-Policies',\n  'X-Powered-By',\n  'X-Requested-With',\n  'X-XSS-Protection'\n])\n\n/** @type {Record<typeof wellknownHeaderNames[number]|Lowercase<typeof wellknownHeaderNames[number]>, string>} */\nconst headerNameLowerCasedRecord = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null)\n\n/**\n * @type {Record<Lowercase<typeof wellknownHeaderNames[number]>, Buffer>}\n */\nconst wellknownHeaderNameBuffers = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(wellknownHeaderNameBuffers, null)\n\n/**\n * @param {string} header Lowercased header\n * @returns {Buffer}\n */\nfunction getHeaderNameAsBuffer (header) {\n  let buffer = wellknownHeaderNameBuffers[header]\n\n  if (buffer === undefined) {\n    buffer = Buffer.from(header)\n  }\n\n  return buffer\n}\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = wellknownHeaderNames[i]\n  const lowerCasedKey = key.toLowerCase()\n  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =\n    lowerCasedKey\n}\n\nmodule.exports = {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord,\n  getHeaderNameAsBuffer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvR0FBb0c7QUFDL0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvSGVhZGVyc1xuICovXG5jb25zdCB3ZWxsa25vd25IZWFkZXJOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdBY2NlcHQnLFxuICAnQWNjZXB0LUVuY29kaW5nJyxcbiAgJ0FjY2VwdC1MYW5ndWFnZScsXG4gICdBY2NlcHQtUmFuZ2VzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAnQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtTWF4LUFnZScsXG4gICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QnLFxuICAnQWdlJyxcbiAgJ0FsbG93JyxcbiAgJ0FsdC1TdmMnLFxuICAnQWx0LVVzZWQnLFxuICAnQXV0aG9yaXphdGlvbicsXG4gICdDYWNoZS1Db250cm9sJyxcbiAgJ0NsZWFyLVNpdGUtRGF0YScsXG4gICdDb25uZWN0aW9uJyxcbiAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nLFxuICAnQ29udGVudC1FbmNvZGluZycsXG4gICdDb250ZW50LUxhbmd1YWdlJyxcbiAgJ0NvbnRlbnQtTGVuZ3RoJyxcbiAgJ0NvbnRlbnQtTG9jYXRpb24nLFxuICAnQ29udGVudC1SYW5nZScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeS1SZXBvcnQtT25seScsXG4gICdDb250ZW50LVR5cGUnLFxuICAnQ29va2llJyxcbiAgJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLVJlc291cmNlLVBvbGljeScsXG4gICdEYXRlJyxcbiAgJ0RldmljZS1NZW1vcnknLFxuICAnRG93bmxpbmsnLFxuICAnRUNUJyxcbiAgJ0VUYWcnLFxuICAnRXhwZWN0JyxcbiAgJ0V4cGVjdC1DVCcsXG4gICdFeHBpcmVzJyxcbiAgJ0ZvcndhcmRlZCcsXG4gICdGcm9tJyxcbiAgJ0hvc3QnLFxuICAnSWYtTWF0Y2gnLFxuICAnSWYtTW9kaWZpZWQtU2luY2UnLFxuICAnSWYtTm9uZS1NYXRjaCcsXG4gICdJZi1SYW5nZScsXG4gICdJZi1Vbm1vZGlmaWVkLVNpbmNlJyxcbiAgJ0tlZXAtQWxpdmUnLFxuICAnTGFzdC1Nb2RpZmllZCcsXG4gICdMaW5rJyxcbiAgJ0xvY2F0aW9uJyxcbiAgJ01heC1Gb3J3YXJkcycsXG4gICdPcmlnaW4nLFxuICAnUGVybWlzc2lvbnMtUG9saWN5JyxcbiAgJ1ByYWdtYScsXG4gICdQcm94eS1BdXRoZW50aWNhdGUnLFxuICAnUHJveHktQXV0aG9yaXphdGlvbicsXG4gICdSVFQnLFxuICAnUmFuZ2UnLFxuICAnUmVmZXJlcicsXG4gICdSZWZlcnJlci1Qb2xpY3knLFxuICAnUmVmcmVzaCcsXG4gICdSZXRyeS1BZnRlcicsXG4gICdTZWMtV2ViU29ja2V0LUFjY2VwdCcsXG4gICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnLFxuICAnU2VjLVdlYlNvY2tldC1LZXknLFxuICAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcsXG4gICdTZWMtV2ViU29ja2V0LVZlcnNpb24nLFxuICAnU2VydmVyJyxcbiAgJ1NlcnZlci1UaW1pbmcnLFxuICAnU2VydmljZS1Xb3JrZXItQWxsb3dlZCcsXG4gICdTZXJ2aWNlLVdvcmtlci1OYXZpZ2F0aW9uLVByZWxvYWQnLFxuICAnU2V0LUNvb2tpZScsXG4gICdTb3VyY2VNYXAnLFxuICAnU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eScsXG4gICdTdXBwb3J0cy1Mb2FkaW5nLU1vZGUnLFxuICAnVEUnLFxuICAnVGltaW5nLUFsbG93LU9yaWdpbicsXG4gICdUcmFpbGVyJyxcbiAgJ1RyYW5zZmVyLUVuY29kaW5nJyxcbiAgJ1VwZ3JhZGUnLFxuICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cycsXG4gICdVc2VyLUFnZW50JyxcbiAgJ1ZhcnknLFxuICAnVmlhJyxcbiAgJ1dXVy1BdXRoZW50aWNhdGUnLFxuICAnWC1Db250ZW50LVR5cGUtT3B0aW9ucycsXG4gICdYLUROUy1QcmVmZXRjaC1Db250cm9sJyxcbiAgJ1gtRnJhbWUtT3B0aW9ucycsXG4gICdYLVBlcm1pdHRlZC1Dcm9zcy1Eb21haW4tUG9saWNpZXMnLFxuICAnWC1Qb3dlcmVkLUJ5JyxcbiAgJ1gtUmVxdWVzdGVkLVdpdGgnLFxuICAnWC1YU1MtUHJvdGVjdGlvbidcbl0pXG5cbi8qKiBAdHlwZSB7UmVjb3JkPHR5cGVvZiB3ZWxsa25vd25IZWFkZXJOYW1lc1tudW1iZXJdfExvd2VyY2FzZTx0eXBlb2Ygd2VsbGtub3duSGVhZGVyTmFtZXNbbnVtYmVyXT4sIHN0cmluZz59ICovXG5jb25zdCBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCA9IHt9XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkLCBudWxsKVxuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8TG93ZXJjYXNlPHR5cGVvZiB3ZWxsa25vd25IZWFkZXJOYW1lc1tudW1iZXJdPiwgQnVmZmVyPn1cbiAqL1xuY29uc3Qgd2VsbGtub3duSGVhZGVyTmFtZUJ1ZmZlcnMgPSB7fVxuXG4vLyBOb3RlOiBvYmplY3QgcHJvdG90eXBlcyBzaG91bGQgbm90IGJlIGFibGUgdG8gYmUgcmVmZXJlbmNlZC4gZS5nLiBgT2JqZWN0I2hhc093blByb3BlcnR5YC5cbk9iamVjdC5zZXRQcm90b3R5cGVPZih3ZWxsa25vd25IZWFkZXJOYW1lQnVmZmVycywgbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyIExvd2VyY2FzZWQgaGVhZGVyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJOYW1lQXNCdWZmZXIgKGhlYWRlcikge1xuICBsZXQgYnVmZmVyID0gd2VsbGtub3duSGVhZGVyTmFtZUJ1ZmZlcnNbaGVhZGVyXVxuXG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGhlYWRlcilcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWxsa25vd25IZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICBjb25zdCBrZXkgPSB3ZWxsa25vd25IZWFkZXJOYW1lc1tpXVxuICBjb25zdCBsb3dlckNhc2VkS2V5ID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRba2V5XSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2xvd2VyQ2FzZWRLZXldID1cbiAgICBsb3dlckNhc2VkS2V5XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQsXG4gIGdldEhlYWRlck5hbWVBc0J1ZmZlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst undiciDebugLog = util.debuglog('undici')\nconst fetchDebuglog = util.debuglog('fetch')\nconst websocketDebuglog = util.debuglog('websocket')\n\nconst channels = {\n  // Client\n  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n  connected: diagnosticsChannel.channel('undici:client:connected'),\n  connectError: diagnosticsChannel.channel('undici:client:connectError'),\n  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n  // Request\n  create: diagnosticsChannel.channel('undici:request:create'),\n  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n  bodyChunkSent: diagnosticsChannel.channel('undici:request:bodyChunkSent'),\n  bodyChunkReceived: diagnosticsChannel.channel('undici:request:bodyChunkReceived'),\n  headers: diagnosticsChannel.channel('undici:request:headers'),\n  trailers: diagnosticsChannel.channel('undici:request:trailers'),\n  error: diagnosticsChannel.channel('undici:request:error'),\n  // WebSocket\n  open: diagnosticsChannel.channel('undici:websocket:open'),\n  close: diagnosticsChannel.channel('undici:websocket:close'),\n  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n  ping: diagnosticsChannel.channel('undici:websocket:ping'),\n  pong: diagnosticsChannel.channel('undici:websocket:pong'),\n  // ProxyAgent\n  proxyConnected: diagnosticsChannel.channel('undici:proxy:connected')\n}\n\nlet isTrackingClientEvents = false\n\nfunction trackClientEvents (debugLog = undiciDebugLog) {\n  if (isTrackingClientEvents) {\n    return\n  }\n\n  // Check if any of the channels already have subscribers to prevent duplicate subscriptions\n  // This can happen when both Node.js built-in undici and undici as a dependency are present\n  if (channels.beforeConnect.hasSubscribers || channels.connected.hasSubscribers ||\n      channels.connectError.hasSubscribers || channels.sendHeaders.hasSubscribers) {\n    isTrackingClientEvents = true\n    return\n  }\n\n  isTrackingClientEvents = true\n\n  diagnosticsChannel.subscribe('undici:client:beforeConnect',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connecting to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connected',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connected to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connectError',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host },\n        error\n      } = evt\n      debugLog(\n        'connection to %s%s using %s%s errored - %s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version,\n        error.message\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:sendHeaders',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('sending request to %s %s%s', method, origin, path)\n    })\n}\n\nlet isTrackingRequestEvents = false\n\nfunction trackRequestEvents (debugLog = undiciDebugLog) {\n  if (isTrackingRequestEvents) {\n    return\n  }\n\n  // Check if any of the channels already have subscribers to prevent duplicate subscriptions\n  // This can happen when both Node.js built-in undici and undici as a dependency are present\n  if (channels.headers.hasSubscribers || channels.trailers.hasSubscribers ||\n      channels.error.hasSubscribers) {\n    isTrackingRequestEvents = true\n    return\n  }\n\n  isTrackingRequestEvents = true\n\n  diagnosticsChannel.subscribe('undici:request:headers',\n    evt => {\n      const {\n        request: { method, path, origin },\n        response: { statusCode }\n      } = evt\n      debugLog(\n        'received response to %s %s%s - HTTP %d',\n        method,\n        origin,\n        path,\n        statusCode\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:request:trailers',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('trailers received from %s %s%s', method, origin, path)\n    })\n\n  diagnosticsChannel.subscribe('undici:request:error',\n    evt => {\n      const {\n        request: { method, path, origin },\n        error\n      } = evt\n      debugLog(\n        'request to %s %s%s errored - %s',\n        method,\n        origin,\n        path,\n        error.message\n      )\n    })\n}\n\nlet isTrackingWebSocketEvents = false\n\nfunction trackWebSocketEvents (debugLog = websocketDebuglog) {\n  if (isTrackingWebSocketEvents) {\n    return\n  }\n\n  // Check if any of the channels already have subscribers to prevent duplicate subscriptions\n  // This can happen when both Node.js built-in undici and undici as a dependency are present\n  if (channels.open.hasSubscribers || channels.close.hasSubscribers ||\n      channels.socketError.hasSubscribers || channels.ping.hasSubscribers ||\n      channels.pong.hasSubscribers) {\n    isTrackingWebSocketEvents = true\n    return\n  }\n\n  isTrackingWebSocketEvents = true\n\n  diagnosticsChannel.subscribe('undici:websocket:open',\n    evt => {\n      const {\n        address: { address, port }\n      } = evt\n      debugLog('connection opened %s%s', address, port ? `:${port}` : '')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:close',\n    evt => {\n      const { websocket, code, reason } = evt\n      debugLog(\n        'closed connection to %s - %s %s',\n        websocket.url,\n        code,\n        reason\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:socket_error',\n    err => {\n      debugLog('connection errored - %s', err.message)\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:ping',\n    evt => {\n      debugLog('ping received')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:pong',\n    evt => {\n      debugLog('pong received')\n    })\n}\n\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n  trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n  trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n}\n\nif (websocketDebuglog.enabled) {\n  trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog)\n  trackWebSocketEvents(websocketDebuglog)\n}\n\nmodule.exports = {\n  channels\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLDJCQUEyQixtQkFBTyxDQUFDLDBEQUEwQjtBQUM3RCxhQUFhLG1CQUFPLENBQUMsNEJBQVc7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG9CQUFvQjtBQUNwQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRO0FBQ1I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLDZEQUE2RCxLQUFLO0FBQ2xFLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxkaWFnbm9zdGljcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnbm9kZTpkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG5jb25zdCB1bmRpY2lEZWJ1Z0xvZyA9IHV0aWwuZGVidWdsb2coJ3VuZGljaScpXG5jb25zdCBmZXRjaERlYnVnbG9nID0gdXRpbC5kZWJ1Z2xvZygnZmV0Y2gnKVxuY29uc3Qgd2Vic29ja2V0RGVidWdsb2cgPSB1dGlsLmRlYnVnbG9nKCd3ZWJzb2NrZXQnKVxuXG5jb25zdCBjaGFubmVscyA9IHtcbiAgLy8gQ2xpZW50XG4gIGJlZm9yZUNvbm5lY3Q6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKSxcbiAgY29ubmVjdGVkOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKSxcbiAgY29ubmVjdEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKSxcbiAgc2VuZEhlYWRlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJyksXG4gIC8vIFJlcXVlc3RcbiAgY3JlYXRlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJyksXG4gIGJvZHlTZW50OiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKSxcbiAgYm9keUNodW5rU2VudDogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmJvZHlDaHVua1NlbnQnKSxcbiAgYm9keUNodW5rUmVjZWl2ZWQ6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpib2R5Q2h1bmtSZWNlaXZlZCcpLFxuICBoZWFkZXJzOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycpLFxuICB0cmFpbGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJyksXG4gIGVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InKSxcbiAgLy8gV2ViU29ja2V0XG4gIG9wZW46IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKSxcbiAgY2xvc2U6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJyksXG4gIHNvY2tldEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InKSxcbiAgcGluZzogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycpLFxuICBwb25nOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwb25nJyksXG4gIC8vIFByb3h5QWdlbnRcbiAgcHJveHlDb25uZWN0ZWQ6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cHJveHk6Y29ubmVjdGVkJylcbn1cblxubGV0IGlzVHJhY2tpbmdDbGllbnRFdmVudHMgPSBmYWxzZVxuXG5mdW5jdGlvbiB0cmFja0NsaWVudEV2ZW50cyAoZGVidWdMb2cgPSB1bmRpY2lEZWJ1Z0xvZykge1xuICBpZiAoaXNUcmFja2luZ0NsaWVudEV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBjaGFubmVscyBhbHJlYWR5IGhhdmUgc3Vic2NyaWJlcnMgdG8gcHJldmVudCBkdXBsaWNhdGUgc3Vic2NyaXB0aW9uc1xuICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBib3RoIE5vZGUuanMgYnVpbHQtaW4gdW5kaWNpIGFuZCB1bmRpY2kgYXMgYSBkZXBlbmRlbmN5IGFyZSBwcmVzZW50XG4gIGlmIChjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzIHx8IGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycyB8fFxuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yLmhhc1N1YnNjcmliZXJzIHx8IGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgaXNUcmFja2luZ0NsaWVudEV2ZW50cyA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlzVHJhY2tpbmdDbGllbnRFdmVudHMgPSB0cnVlXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0JyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKFxuICAgICAgICAnY29ubmVjdGluZyB0byAlcyVzIHVzaW5nICVzJXMnLFxuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0ID8gYDoke3BvcnR9YCA6ICcnLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgKVxuICAgIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdMb2coXG4gICAgICAgICdjb25uZWN0ZWQgdG8gJXMlcyB1c2luZyAlcyVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIClcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH0sXG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJ2Nvbm5lY3Rpb24gdG8gJXMlcyB1c2luZyAlcyVzIGVycm9yZWQgLSAlcycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQgPyBgOiR7cG9ydH1gIDogJycsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICApXG4gICAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKCdzZW5kaW5nIHJlcXVlc3QgdG8gJXMgJXMlcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICAgIH0pXG59XG5cbmxldCBpc1RyYWNraW5nUmVxdWVzdEV2ZW50cyA9IGZhbHNlXG5cbmZ1bmN0aW9uIHRyYWNrUmVxdWVzdEV2ZW50cyAoZGVidWdMb2cgPSB1bmRpY2lEZWJ1Z0xvZykge1xuICBpZiAoaXNUcmFja2luZ1JlcXVlc3RFdmVudHMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgY2hhbm5lbHMgYWxyZWFkeSBoYXZlIHN1YnNjcmliZXJzIHRvIHByZXZlbnQgZHVwbGljYXRlIHN1YnNjcmlwdGlvbnNcbiAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYm90aCBOb2RlLmpzIGJ1aWx0LWluIHVuZGljaSBhbmQgdW5kaWNpIGFzIGEgZGVwZW5kZW5jeSBhcmUgcHJlc2VudFxuICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycyB8fCBjaGFubmVscy50cmFpbGVycy5oYXNTdWJzY3JpYmVycyB8fFxuICAgICAgY2hhbm5lbHMuZXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBpc1RyYWNraW5nUmVxdWVzdEV2ZW50cyA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlzVHJhY2tpbmdSZXF1ZXN0RXZlbnRzID0gdHJ1ZVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfSxcbiAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJ3JlY2VpdmVkIHJlc3BvbnNlIHRvICVzICVzJXMgLSBIVFRQICVkJyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN0YXR1c0NvZGVcbiAgICAgIClcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKCd0cmFpbGVycyByZWNlaXZlZCBmcm9tICVzICVzJXMnLCBtZXRob2QsIG9yaWdpbiwgcGF0aClcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH0sXG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJ3JlcXVlc3QgdG8gJXMgJXMlcyBlcnJvcmVkIC0gJXMnLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZXJyb3IubWVzc2FnZVxuICAgICAgKVxuICAgIH0pXG59XG5cbmxldCBpc1RyYWNraW5nV2ViU29ja2V0RXZlbnRzID0gZmFsc2VcblxuZnVuY3Rpb24gdHJhY2tXZWJTb2NrZXRFdmVudHMgKGRlYnVnTG9nID0gd2Vic29ja2V0RGVidWdsb2cpIHtcbiAgaWYgKGlzVHJhY2tpbmdXZWJTb2NrZXRFdmVudHMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgY2hhbm5lbHMgYWxyZWFkeSBoYXZlIHN1YnNjcmliZXJzIHRvIHByZXZlbnQgZHVwbGljYXRlIHN1YnNjcmlwdGlvbnNcbiAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYm90aCBOb2RlLmpzIGJ1aWx0LWluIHVuZGljaSBhbmQgdW5kaWNpIGFzIGEgZGVwZW5kZW5jeSBhcmUgcHJlc2VudFxuICBpZiAoY2hhbm5lbHMub3Blbi5oYXNTdWJzY3JpYmVycyB8fCBjaGFubmVscy5jbG9zZS5oYXNTdWJzY3JpYmVycyB8fFxuICAgICAgY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMgfHwgY2hhbm5lbHMucGluZy5oYXNTdWJzY3JpYmVycyB8fFxuICAgICAgY2hhbm5lbHMucG9uZy5oYXNTdWJzY3JpYmVycykge1xuICAgIGlzVHJhY2tpbmdXZWJTb2NrZXRFdmVudHMgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICBpc1RyYWNraW5nV2ViU29ja2V0RXZlbnRzID0gdHJ1ZVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTp3ZWJzb2NrZXQ6b3BlbicsXG4gICAgZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWRkcmVzczogeyBhZGRyZXNzLCBwb3J0IH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKCdjb25uZWN0aW9uIG9wZW5lZCAlcyVzJywgYWRkcmVzcywgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJylcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTp3ZWJzb2NrZXQ6Y2xvc2UnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7IHdlYnNvY2tldCwgY29kZSwgcmVhc29uIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKFxuICAgICAgICAnY2xvc2VkIGNvbm5lY3Rpb24gdG8gJXMgLSAlcyAlcycsXG4gICAgICAgIHdlYnNvY2tldC51cmwsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlYXNvblxuICAgICAgKVxuICAgIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InLFxuICAgIGVyciA9PiB7XG4gICAgICBkZWJ1Z0xvZygnY29ubmVjdGlvbiBlcnJvcmVkIC0gJXMnLCBlcnIubWVzc2FnZSlcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycsXG4gICAgZXZ0ID0+IHtcbiAgICAgIGRlYnVnTG9nKCdwaW5nIHJlY2VpdmVkJylcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycsXG4gICAgZXZ0ID0+IHtcbiAgICAgIGRlYnVnTG9nKCdwb25nIHJlY2VpdmVkJylcbiAgICB9KVxufVxuXG5pZiAodW5kaWNpRGVidWdMb2cuZW5hYmxlZCB8fCBmZXRjaERlYnVnbG9nLmVuYWJsZWQpIHtcbiAgdHJhY2tDbGllbnRFdmVudHMoZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkID8gZmV0Y2hEZWJ1Z2xvZyA6IHVuZGljaURlYnVnTG9nKVxuICB0cmFja1JlcXVlc3RFdmVudHMoZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkID8gZmV0Y2hEZWJ1Z2xvZyA6IHVuZGljaURlYnVnTG9nKVxufVxuXG5pZiAod2Vic29ja2V0RGVidWdsb2cuZW5hYmxlZCkge1xuICB0cmFja0NsaWVudEV2ZW50cyh1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkID8gdW5kaWNpRGVidWdMb2cgOiB3ZWJzb2NrZXREZWJ1Z2xvZylcbiAgdHJhY2tXZWJTb2NrZXRFdmVudHMod2Vic29ja2V0RGVidWdsb2cpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGFubmVsc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nconst kUndiciError = Symbol.for('undici.error.UND_ERR')\nclass UndiciError extends Error {\n  constructor (message, options) {\n    super(message, options)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kUndiciError] === true\n  }\n\n  get [kUndiciError] () {\n    return true\n  }\n}\n\nconst kConnectTimeoutError = Symbol.for('undici.error.UND_ERR_CONNECT_TIMEOUT')\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kConnectTimeoutError] === true\n  }\n\n  get [kConnectTimeoutError] () {\n    return true\n  }\n}\n\nconst kHeadersTimeoutError = Symbol.for('undici.error.UND_ERR_HEADERS_TIMEOUT')\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHeadersTimeoutError] === true\n  }\n\n  get [kHeadersTimeoutError] () {\n    return true\n  }\n}\n\nconst kHeadersOverflowError = Symbol.for('undici.error.UND_ERR_HEADERS_OVERFLOW')\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHeadersOverflowError] === true\n  }\n\n  get [kHeadersOverflowError] () {\n    return true\n  }\n}\n\nconst kBodyTimeoutError = Symbol.for('undici.error.UND_ERR_BODY_TIMEOUT')\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kBodyTimeoutError] === true\n  }\n\n  get [kBodyTimeoutError] () {\n    return true\n  }\n}\n\nconst kInvalidArgumentError = Symbol.for('undici.error.UND_ERR_INVALID_ARG')\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInvalidArgumentError] === true\n  }\n\n  get [kInvalidArgumentError] () {\n    return true\n  }\n}\n\nconst kInvalidReturnValueError = Symbol.for('undici.error.UND_ERR_INVALID_RETURN_VALUE')\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInvalidReturnValueError] === true\n  }\n\n  get [kInvalidReturnValueError] () {\n    return true\n  }\n}\n\nconst kAbortError = Symbol.for('undici.error.UND_ERR_ABORT')\nclass AbortError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'The operation was aborted'\n    this.code = 'UND_ERR_ABORT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kAbortError] === true\n  }\n\n  get [kAbortError] () {\n    return true\n  }\n}\n\nconst kRequestAbortedError = Symbol.for('undici.error.UND_ERR_ABORTED')\nclass RequestAbortedError extends AbortError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestAbortedError] === true\n  }\n\n  get [kRequestAbortedError] () {\n    return true\n  }\n}\n\nconst kInformationalError = Symbol.for('undici.error.UND_ERR_INFO')\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInformationalError] === true\n  }\n\n  get [kInformationalError] () {\n    return true\n  }\n}\n\nconst kRequestContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH')\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestContentLengthMismatchError] === true\n  }\n\n  get [kRequestContentLengthMismatchError] () {\n    return true\n  }\n}\n\nconst kResponseContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH')\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseContentLengthMismatchError] === true\n  }\n\n  get [kResponseContentLengthMismatchError] () {\n    return true\n  }\n}\n\nconst kClientDestroyedError = Symbol.for('undici.error.UND_ERR_DESTROYED')\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kClientDestroyedError] === true\n  }\n\n  get [kClientDestroyedError] () {\n    return true\n  }\n}\n\nconst kClientClosedError = Symbol.for('undici.error.UND_ERR_CLOSED')\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kClientClosedError] === true\n  }\n\n  get [kClientClosedError] () {\n    return true\n  }\n}\n\nconst kSocketError = Symbol.for('undici.error.UND_ERR_SOCKET')\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kSocketError] === true\n  }\n\n  get [kSocketError] () {\n    return true\n  }\n}\n\nconst kNotSupportedError = Symbol.for('undici.error.UND_ERR_NOT_SUPPORTED')\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kNotSupportedError] === true\n  }\n\n  get [kNotSupportedError] () {\n    return true\n  }\n}\n\nconst kBalancedPoolMissingUpstreamError = Symbol.for('undici.error.UND_ERR_BPL_MISSING_UPSTREAM')\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kBalancedPoolMissingUpstreamError] === true\n  }\n\n  get [kBalancedPoolMissingUpstreamError] () {\n    return true\n  }\n}\n\nconst kHTTPParserError = Symbol.for('undici.error.UND_ERR_HTTP_PARSER')\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHTTPParserError] === true\n  }\n\n  get [kHTTPParserError] () {\n    return true\n  }\n}\n\nconst kResponseExceededMaxSizeError = Symbol.for('undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE')\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseExceededMaxSizeError] === true\n  }\n\n  get [kResponseExceededMaxSizeError] () {\n    return true\n  }\n}\n\nconst kRequestRetryError = Symbol.for('undici.error.UND_ERR_REQ_RETRY')\nclass RequestRetryError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'RequestRetryError'\n    this.message = message || 'Request retry error'\n    this.code = 'UND_ERR_REQ_RETRY'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestRetryError] === true\n  }\n\n  get [kRequestRetryError] () {\n    return true\n  }\n}\n\nconst kResponseError = Symbol.for('undici.error.UND_ERR_RESPONSE')\nclass ResponseError extends UndiciError {\n  constructor (message, code, { headers, body }) {\n    super(message)\n    this.name = 'ResponseError'\n    this.message = message || 'Response error'\n    this.code = 'UND_ERR_RESPONSE'\n    this.statusCode = code\n    this.body = body\n    this.headers = headers\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseError] === true\n  }\n\n  get [kResponseError] () {\n    return true\n  }\n}\n\nconst kSecureProxyConnectionError = Symbol.for('undici.error.UND_ERR_PRX_TLS')\nclass SecureProxyConnectionError extends UndiciError {\n  constructor (cause, message, options = {}) {\n    super(message, { cause, ...options })\n    this.name = 'SecureProxyConnectionError'\n    this.message = message || 'Secure Proxy Connection failed'\n    this.code = 'UND_ERR_PRX_TLS'\n    this.cause = cause\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kSecureProxyConnectionError] === true\n  }\n\n  get [kSecureProxyConnectionError] () {\n    return true\n  }\n}\n\nconst kMaxOriginsReachedError = Symbol.for('undici.error.UND_ERR_MAX_ORIGINS_REACHED')\nclass MaxOriginsReachedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MaxOriginsReachedError'\n    this.message = message || 'Maximum allowed origins reached'\n    this.code = 'UND_ERR_MAX_ORIGINS_REACHED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kMaxOriginsReachedError] === true\n  }\n\n  get [kMaxOriginsReachedError] () {\n    return true\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError,\n  RequestRetryError,\n  ResponseError,\n  SecureProxyConnectionError,\n  MaxOriginsReachedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGtVbmRpY2lFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSJylcbmNsYXNzIFVuZGljaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpXG4gICAgdGhpcy5uYW1lID0gJ1VuZGljaUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVtrVW5kaWNpRXJyb3JdID09PSB0cnVlXG4gIH1cblxuICBnZXQgW2tVbmRpY2lFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga0Nvbm5lY3RUaW1lb3V0RXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnKVxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tDb25uZWN0VGltZW91dEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdFRpbWVvdXRFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga0hlYWRlcnNUaW1lb3V0RXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnKVxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tIZWFkZXJzVGltZW91dEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrSGVhZGVyc1RpbWVvdXRFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga0hlYWRlcnNPdmVyZmxvd0Vycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfSEVBREVSU19PVkVSRkxPVycpXG5jbGFzcyBIZWFkZXJzT3ZlcmZsb3dFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzT3ZlcmZsb3dFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdIZWFkZXJzIE92ZXJmbG93IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1cnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tIZWFkZXJzT3ZlcmZsb3dFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0hlYWRlcnNPdmVyZmxvd0Vycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrQm9keVRpbWVvdXRFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX0JPRFlfVElNRU9VVCcpXG5jbGFzcyBCb2R5VGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0JvZHlUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnQm9keSBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JPRFlfVElNRU9VVCdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba0JvZHlUaW1lb3V0RXJyb3JdID09PSB0cnVlXG4gIH1cblxuICBnZXQgW2tCb2R5VGltZW91dEVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9JTlZBTElEX0FSRycpXG5jbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQXJndW1lbnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdJbnZhbGlkIEFyZ3VtZW50IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lOVkFMSURfQVJHJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVtrSW52YWxpZEFyZ3VtZW50RXJyb3JdID09PSB0cnVlXG4gIH1cblxuICBnZXQgW2tJbnZhbGlkQXJndW1lbnRFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga0ludmFsaWRSZXR1cm5WYWx1ZUVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnKVxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0ludmFsaWRSZXR1cm5WYWx1ZUVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrQWJvcnRFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX0FCT1JUJylcbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JUJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVtrQWJvcnRFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0Fib3J0RXJyb3JdICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IGtSZXF1ZXN0QWJvcnRlZEVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfQUJPUlRFRCcpXG5jbGFzcyBSZXF1ZXN0QWJvcnRlZEVycm9yIGV4dGVuZHMgQWJvcnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGFib3J0ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQUJPUlRFRCdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba1JlcXVlc3RBYm9ydGVkRXJyb3JdID09PSB0cnVlXG4gIH1cblxuICBnZXQgW2tSZXF1ZXN0QWJvcnRlZEVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrSW5mb3JtYXRpb25hbEVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfSU5GTycpXG5jbGFzcyBJbmZvcm1hdGlvbmFsRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW5mb3JtYXRpb25hbEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgaW5mb3JtYXRpb24nXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5GTydcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba0luZm9ybWF0aW9uYWxFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0luZm9ybWF0aW9uYWxFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX1JFUV9DT05URU5UX0xFTkdUSF9NSVNNQVRDSCcpXG5jbGFzcyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFUV9DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga1Jlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnKVxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga0NsaWVudERlc3Ryb3llZEVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfREVTVFJPWUVEJylcbmNsYXNzIENsaWVudERlc3Ryb3llZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudERlc3Ryb3llZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgZGVzdHJveWVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0RFU1RST1lFRCdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba0NsaWVudERlc3Ryb3llZEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrQ2xpZW50RGVzdHJveWVkRXJyb3JdICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IGtDbGllbnRDbG9zZWRFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX0NMT1NFRCcpXG5jbGFzcyBDbGllbnRDbG9zZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDbGllbnRDbG9zZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgY2xpZW50IGlzIGNsb3NlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DTE9TRUQnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tDbGllbnRDbG9zZWRFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0NsaWVudENsb3NlZEVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrU29ja2V0RXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9TT0NLRVQnKVxuY2xhc3MgU29ja2V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzb2NrZXQpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTb2NrZXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdTb2NrZXQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfU09DS0VUJ1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tTb2NrZXRFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba1NvY2tldEVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrTm90U3VwcG9ydGVkRXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9OT1RfU1VQUE9SVEVEJylcbmNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vdCBzdXBwb3J0ZWQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfTk9UX1NVUFBPUlRFRCdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba05vdFN1cHBvcnRlZEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrTm90U3VwcG9ydGVkRXJyb3JdICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IGtCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX0JQTF9NSVNTSU5HX1VQU1RSRUFNJylcbmNsYXNzIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ01pc3NpbmdVcHN0cmVhbUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vIHVwc3RyZWFtIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBCYWxhbmNlZFBvb2wnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQlBMX01JU1NJTkdfVVBTVFJFQU0nXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0JhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrSFRUUFBhcnNlckVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfSFRUUF9QQVJTRVInKVxuY2xhc3MgSFRUUFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29kZSwgZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0hUVFBQYXJzZXJFcnJvcidcbiAgICB0aGlzLmNvZGUgPSBjb2RlID8gYEhQRV8ke2NvZGV9YCA6IHVuZGVmaW5lZFxuICAgIHRoaXMuZGF0YSA9IGRhdGEgPyBkYXRhLnRvU3RyaW5nKCkgOiB1bmRlZmluZWRcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2Vba0hUVFBQYXJzZXJFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba0hUVFBQYXJzZXJFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga1Jlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9SRVNfRVhDRUVERURfTUFYX1NJWkUnKVxuY2xhc3MgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGNvbnRlbnQgZXhjZWVkZWQgbWF4IHNpemUnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTX0VYQ0VFREVEX01BWF9TSVpFJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVtrUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba1Jlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3JdICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IGtSZXF1ZXN0UmV0cnlFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX1JFUV9SRVRSWScpXG5jbGFzcyBSZXF1ZXN0UmV0cnlFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdFJldHJ5RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCByZXRyeSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfUkVUUlknXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tSZXF1ZXN0UmV0cnlFcnJvcl0gPT09IHRydWVcbiAgfVxuXG4gIGdldCBba1JlcXVlc3RSZXRyeUVycm9yXSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jb25zdCBrUmVzcG9uc2VFcnJvciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5lcnJvci5VTkRfRVJSX1JFU1BPTlNFJylcbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCB7IGhlYWRlcnMsIGJvZHkgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTUE9OU0UnXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tSZXNwb25zZUVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrUmVzcG9uc2VFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga1NlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yID0gU3ltYm9sLmZvcigndW5kaWNpLmVycm9yLlVORF9FUlJfUFJYX1RMUycpXG5jbGFzcyBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKGNhdXNlLCBtZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlLCAuLi5vcHRpb25zIH0pXG4gICAgdGhpcy5uYW1lID0gJ1NlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NlY3VyZSBQcm94eSBDb25uZWN0aW9uIGZhaWxlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9QUlhfVExTJ1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZVxuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVtrU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3JdID09PSB0cnVlXG4gIH1cblxuICBnZXQgW2tTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuY29uc3Qga01heE9yaWdpbnNSZWFjaGVkRXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX0VSUl9NQVhfT1JJR0lOU19SRUFDSEVEJylcbmNsYXNzIE1heE9yaWdpbnNSZWFjaGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnTWF4T3JpZ2luc1JlYWNoZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdNYXhpbXVtIGFsbG93ZWQgb3JpZ2lucyByZWFjaGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX01BWF9PUklHSU5TX1JFQUNIRUQnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tNYXhPcmlnaW5zUmVhY2hlZEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrTWF4T3JpZ2luc1JlYWNoZWRFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFib3J0RXJyb3IsXG4gIEhUVFBQYXJzZXJFcnJvcixcbiAgVW5kaWNpRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIENvbm5lY3RUaW1lb3V0RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIFJlcXVlc3RSZXRyeUVycm9yLFxuICBSZXNwb25zZUVycm9yLFxuICBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcixcbiAgTWF4T3JpZ2luc1JlYWNoZWRFcnJvclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  serializePathWithQuery,\n  assertRequestHandler,\n  getServerName,\n  normalizedMethodRecords,\n  getProtocolFromUrlString\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    expectContinue,\n    servername,\n    throwOnError,\n    maxRedirections\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    if (throwOnError != null) {\n      throw new InvalidArgumentError('invalid throwOnError')\n    }\n\n    if (maxRedirections != null && maxRedirections !== 0) {\n      throw new InvalidArgumentError('maxRedirections is not supported, use the redirect interceptor')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? serializePathWithQuery(path, query) : path\n\n    // TODO: shall we maybe standardize it to an URL object?\n    this.origin = origin\n\n    this.protocol = getProtocolFromUrlString(origin)\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking ?? this.method !== 'HEAD'\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    assertRequestHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host) || null\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (channels.bodyChunkSent.hasSubscribers) {\n      channels.bodyChunkSent.publish({ request: this, chunk })\n    }\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.bodyChunkReceived.hasSubscribers) {\n      channels.bodyChunkReceived.publish({ request: this, chunk })\n    }\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0REFBUTtBQUNwQixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDZFQUFrQjtBQUMvQyxRQUFRLDZCQUE2QixFQUFFLG1CQUFPLENBQUMsc0VBQWE7O0FBRTVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDJCQUEyQixtQ0FBbUM7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCxLQUFLO0FBQ3ZELFFBQVE7QUFDUixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixhQUFhLElBQUk7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOENBQThDLFlBQVk7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1N0cmVhbSxcbiAgZGVzdHJveSxcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGFMaWtlLFxuICBpc0l0ZXJhYmxlLFxuICBpc0Jsb2JMaWtlLFxuICBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5LFxuICBhc3NlcnRSZXF1ZXN0SGFuZGxlcixcbiAgZ2V0U2VydmVyTmFtZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMsXG4gIGdldFByb3RvY29sRnJvbVVybFN0cmluZ1xufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHsgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGNoYXJzIFxceDAwIHRvIFxceDIwXG5jb25zdCBpbnZhbGlkUGF0aFJlZ2V4ID0gL1teXFx1MDAyMS1cXHUwMGZmXS9cblxuY29uc3Qga0hhbmRsZXIgPSBTeW1ib2woJ2hhbmRsZXInKVxuXG5jbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeSxcbiAgICBpZGVtcG90ZW50LFxuICAgIGJsb2NraW5nLFxuICAgIHVwZ3JhZGUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgcmVzZXQsXG4gICAgZXhwZWN0Q29udGludWUsXG4gICAgc2VydmVybmFtZSxcbiAgICB0aHJvd09uRXJyb3IsXG4gICAgbWF4UmVkaXJlY3Rpb25zXG4gIH0sIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHBhdGhbMF0gIT09ICcvJyAmJlxuICAgICAgIShwYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpICYmXG4gICAgICBtZXRob2QgIT09ICdDT05ORUNUJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdwYXRoIG11c3QgYmUgYW4gYWJzb2x1dGUgVVJMIG9yIHN0YXJ0IHdpdGggYSBzbGFzaCcpXG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUGF0aFJlZ2V4LnRlc3QocGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCByZXF1ZXN0IHBhdGgnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1ttZXRob2RdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICBpZiAodGhyb3dPbkVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB0aHJvd09uRXJyb3InKVxuICAgIH1cblxuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiBtYXhSZWRpcmVjdGlvbnMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgcmVkaXJlY3QgaW50ZXJjZXB0b3InKVxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyc1RpbWVvdXQgPSBoZWFkZXJzVGltZW91dFxuXG4gICAgdGhpcy5ib2R5VGltZW91dCA9IGJvZHlUaW1lb3V0XG5cbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZFxuXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5XG5cbiAgICAgIGNvbnN0IHJTdGF0ZSA9IHRoaXMuYm9keS5fcmVhZGFibGVTdGF0ZVxuICAgICAgaWYgKCFyU3RhdGUgfHwgIXJTdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVuZEhhbmRsZXIgPSBmdW5jdGlvbiBhdXRvRGVzdHJveSAoKSB7XG4gICAgICAgICAgZGVzdHJveSh0aGlzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5vbignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVyciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkub24oJ2Vycm9yJywgdGhpcy5lcnJvckhhbmRsZXIpXG4gICAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gYm9keSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5idWZmZXIuYnl0ZUxlbmd0aCA/IEJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnl0ZUxlbmd0aCA/IEJ1ZmZlci5mcm9tKGJvZHkpIDogbnVsbFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5Lmxlbmd0aCA/IEJ1ZmZlci5mcm9tKGJvZHkpIDogbnVsbFxuICAgIH0gZWxzZSBpZiAoaXNGb3JtRGF0YUxpa2UoYm9keSkgfHwgaXNJdGVyYWJsZShib2R5KSB8fCBpc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keSBtdXN0IGJlIGEgc3RyaW5nLCBhIEJ1ZmZlciwgYSBSZWFkYWJsZSBzdHJlYW0sIGFuIGl0ZXJhYmxlLCBvciBhbiBhc3luYyBpdGVyYWJsZScpXG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZVxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnVwZ3JhZGUgPSB1cGdyYWRlIHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IHF1ZXJ5ID8gc2VyaWFsaXplUGF0aFdpdGhRdWVyeShwYXRoLCBxdWVyeSkgOiBwYXRoXG5cbiAgICAvLyBUT0RPOiBzaGFsbCB3ZSBtYXliZSBzdGFuZGFyZGl6ZSBpdCB0byBhbiBVUkwgb2JqZWN0P1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG5cbiAgICB0aGlzLnByb3RvY29sID0gZ2V0UHJvdG9jb2xGcm9tVXJsU3RyaW5nKG9yaWdpbilcblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA/PyB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnXG5cbiAgICB0aGlzLnJlc2V0ID0gcmVzZXQgPT0gbnVsbCA/IG51bGwgOiByZXNldFxuXG4gICAgdGhpcy5ob3N0ID0gbnVsbFxuXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gbnVsbFxuXG4gICAgdGhpcy5jb250ZW50VHlwZSA9IG51bGxcblxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG5cbiAgICAvLyBPbmx5IGZvciBIMlxuICAgIHRoaXMuZXhwZWN0Q29udGludWUgPSBleHBlY3RDb250aW51ZSAhPSBudWxsID8gZXhwZWN0Q29udGludWUgOiBmYWxzZVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIGFycmF5IG11c3QgYmUgZXZlbicpXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVyKSB8fCBoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBpbiBrZXktdmFsdWUgcGFpciBmb3JtYXQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBrZXlzW2ldLCBoZWFkZXJzW2tleXNbaV1dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheScpXG4gICAgfVxuXG4gICAgYXNzZXJ0UmVxdWVzdEhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKVxuXG4gICAgdGhpcy5zZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBnZXRTZXJ2ZXJOYW1lKHRoaXMuaG9zdCkgfHwgbnVsbFxuXG4gICAgdGhpc1trSGFuZGxlcl0gPSBoYW5kbGVyXG5cbiAgICBpZiAoY2hhbm5lbHMuY3JlYXRlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jcmVhdGUucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmIChjaGFubmVscy5ib2R5Q2h1bmtTZW50Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5ib2R5Q2h1bmtTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBjaHVuayB9KVxuICAgIH1cbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25SZXF1ZXN0U2VudCAoKSB7XG4gICAgaWYgKGNoYW5uZWxzLmJvZHlTZW50Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5ib2R5U2VudC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgYWJvcnQodGhpcy5lcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db25uZWN0KGFib3J0KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXNwb25zZVN0YXJ0ZWQ/LigpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuaGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzVGV4dCB9IH0pXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAoY2hhbm5lbHMuYm9keUNodW5rUmVjZWl2ZWQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmJvZHlDaHVua1JlY2VpdmVkLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBjaHVuayB9KVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRGF0YShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWVcbiAgICBpZiAoY2hhbm5lbHMudHJhaWxlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLnRyYWlsZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCB0cmFpbGVycyB9KVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFRoaXMgbWlnaHQgYmUgYSBiYWQgaWRlYT9cbiAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRmluYWxseSgpXG5cbiAgICBpZiAoY2hhbm5lbHMuZXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBlcnJvciB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uRmluYWxseSAoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0aGlzLmJvZHkub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kSGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgdGhpcy5lbmRIYW5kbGVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgaGVhZGVyTmFtZSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2tleV1cblxuICBpZiAoaGVhZGVyTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGVhZGVyTmFtZSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2hlYWRlck5hbWVdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4oaGVhZGVyTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoZWFkZXIga2V5JylcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbFtpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICAgIH1cbiAgICAgICAgYXJyLnB1c2godmFsW2ldKVxuICAgICAgfSBlbHNlIGlmICh2YWxbaV0gPT09IG51bGwpIHtcbiAgICAgICAgYXJyLnB1c2goJycpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKGAke3ZhbFtpXX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB2YWwgPSBhcnJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdmFsID0gJydcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBgJHt2YWx9YFxuICB9XG5cbiAgaWYgKHJlcXVlc3QuaG9zdCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnaG9zdCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBob3N0IGhlYWRlcicpXG4gICAgfVxuICAgIC8vIENvbnN1bWVkIGJ5IENsaWVudFxuICAgIHJlcXVlc3QuaG9zdCA9IHZhbFxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudExlbmd0aCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgcmVxdWVzdC5jb250ZW50TGVuZ3RoID0gcGFyc2VJbnQodmFsLCAxMClcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXF1ZXN0LmNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29udGVudC1sZW5ndGggaGVhZGVyJylcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC10eXBlJykge1xuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPSB2YWxcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAndHJhbnNmZXItZW5jb2RpbmcnIHx8IGhlYWRlck5hbWUgPT09ICdrZWVwLWFsaXZlJyB8fCBoZWFkZXJOYW1lID09PSAndXBncmFkZScpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtoZWFkZXJOYW1lfSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdjb25uZWN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwudG9Mb3dlckNhc2UoKSA6IG51bGxcbiAgICBpZiAodmFsdWUgIT09ICdjbG9zZScgJiYgdmFsdWUgIT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb24gaGVhZGVyJylcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJlcXVlc3QucmVzZXQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdleHBlY3QnKSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdleHBlY3QgaGVhZGVyIG5vdCBzdXBwb3J0ZWQnKVxuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuaGVhZGVycy5wdXNoKGtleSwgdmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kBody: Symbol('abstracted request body'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kResume: Symbol('resume'),\n  kOnError: Symbol('on error'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n  kConstruct: Symbol('constructable'),\n  kListeners: Symbol('listeners'),\n  kHTTPContext: Symbol('http context'),\n  kMaxConcurrentStreams: Symbol('max concurrent streams'),\n  kHTTP2InitialWindowSize: Symbol('http2 initial window size'),\n  kHTTP2ConnectionWindowSize: Symbol('http2 connection window size'),\n  kEnableConnectProtocol: Symbol('http2session connect protocol'),\n  kRemoteSettings: Symbol('http2session remote settings'),\n  kHTTP2Stream: Symbol('http2session client stream'),\n  kNoProxyAgent: Symbol('no proxy agent'),\n  kHttpProxyAgent: Symbol('http proxy agent'),\n  kHttpsProxyAgent: Symbol('https proxy agent')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga0Rlc3Ryb3k6IFN5bWJvbCgnZGVzdHJveScpLFxuICBrRGlzcGF0Y2g6IFN5bWJvbCgnZGlzcGF0Y2gnKSxcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga1dyaXRpbmc6IFN5bWJvbCgnd3JpdGluZycpLFxuICBrUmVzdW1pbmc6IFN5bWJvbCgncmVzdW1pbmcnKSxcbiAga1F1ZXVlOiBTeW1ib2woJ3F1ZXVlJyksXG4gIGtDb25uZWN0OiBTeW1ib2woJ2Nvbm5lY3QnKSxcbiAga0Nvbm5lY3Rpbmc6IFN5bWJvbCgnY29ubmVjdGluZycpLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQ6IFN5bWJvbCgnZGVmYXVsdCBrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQ6IFN5bWJvbCgnbWF4IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQgdGhyZXNob2xkJyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWU6IFN5bWJvbCgna2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmU6IFN5bWJvbCgna2VlcCBhbGl2ZScpLFxuICBrSGVhZGVyc1RpbWVvdXQ6IFN5bWJvbCgnaGVhZGVycyB0aW1lb3V0JyksXG4gIGtCb2R5VGltZW91dDogU3ltYm9sKCdib2R5IHRpbWVvdXQnKSxcbiAga1NlcnZlck5hbWU6IFN5bWJvbCgnc2VydmVyIG5hbWUnKSxcbiAga0xvY2FsQWRkcmVzczogU3ltYm9sKCdsb2NhbCBhZGRyZXNzJyksXG4gIGtIb3N0OiBTeW1ib2woJ2hvc3QnKSxcbiAga05vUmVmOiBTeW1ib2woJ25vIHJlZicpLFxuICBrQm9keVVzZWQ6IFN5bWJvbCgndXNlZCcpLFxuICBrQm9keTogU3ltYm9sKCdhYnN0cmFjdGVkIHJlcXVlc3QgYm9keScpLFxuICBrUnVubmluZzogU3ltYm9sKCdydW5uaW5nJyksXG4gIGtCbG9ja2luZzogU3ltYm9sKCdibG9ja2luZycpLFxuICBrUGVuZGluZzogU3ltYm9sKCdwZW5kaW5nJyksXG4gIGtTaXplOiBTeW1ib2woJ3NpemUnKSxcbiAga0J1c3k6IFN5bWJvbCgnYnVzeScpLFxuICBrUXVldWVkOiBTeW1ib2woJ3F1ZXVlZCcpLFxuICBrRnJlZTogU3ltYm9sKCdmcmVlJyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtDbG9zZWQ6IFN5bWJvbCgnY2xvc2VkJyksXG4gIGtOZWVkRHJhaW46IFN5bWJvbCgnbmVlZCBkcmFpbicpLFxuICBrUmVzZXQ6IFN5bWJvbCgncmVzZXQnKSxcbiAga0Rlc3Ryb3llZDogU3ltYm9sLmZvcignbm9kZWpzLnN0cmVhbS5kZXN0cm95ZWQnKSxcbiAga1Jlc3VtZTogU3ltYm9sKCdyZXN1bWUnKSxcbiAga09uRXJyb3I6IFN5bWJvbCgnb24gZXJyb3InKSxcbiAga01heEhlYWRlcnNTaXplOiBTeW1ib2woJ21heCBoZWFkZXJzIHNpemUnKSxcbiAga1J1bm5pbmdJZHg6IFN5bWJvbCgncnVubmluZyBpbmRleCcpLFxuICBrUGVuZGluZ0lkeDogU3ltYm9sKCdwZW5kaW5nIGluZGV4JyksXG4gIGtFcnJvcjogU3ltYm9sKCdlcnJvcicpLFxuICBrQ2xpZW50czogU3ltYm9sKCdjbGllbnRzJyksXG4gIGtDbGllbnQ6IFN5bWJvbCgnY2xpZW50JyksXG4gIGtQYXJzZXI6IFN5bWJvbCgncGFyc2VyJyksXG4gIGtPbkRlc3Ryb3llZDogU3ltYm9sKCdkZXN0cm95IGNhbGxiYWNrcycpLFxuICBrUGlwZWxpbmluZzogU3ltYm9sKCdwaXBlbGluaW5nJyksXG4gIGtTb2NrZXQ6IFN5bWJvbCgnc29ja2V0JyksXG4gIGtIb3N0SGVhZGVyOiBTeW1ib2woJ2hvc3QgaGVhZGVyJyksXG4gIGtDb25uZWN0b3I6IFN5bWJvbCgnY29ubmVjdG9yJyksXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoOiBTeW1ib2woJ3N0cmljdCBjb250ZW50IGxlbmd0aCcpLFxuICBrTWF4UmVkaXJlY3Rpb25zOiBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpLFxuICBrTWF4UmVxdWVzdHM6IFN5bWJvbCgnbWF4UmVxdWVzdHNQZXJDbGllbnQnKSxcbiAga1Byb3h5OiBTeW1ib2woJ3Byb3h5IGFnZW50IG9wdGlvbnMnKSxcbiAga0NvdW50ZXI6IFN5bWJvbCgnc29ja2V0IHJlcXVlc3QgY291bnRlcicpLFxuICBrTWF4UmVzcG9uc2VTaXplOiBTeW1ib2woJ21heCByZXNwb25zZSBzaXplJyksXG4gIGtIVFRQMlNlc3Npb246IFN5bWJvbCgnaHR0cDJTZXNzaW9uJyksXG4gIGtIVFRQMlNlc3Npb25TdGF0ZTogU3ltYm9sKCdodHRwMlNlc3Npb24gc3RhdGUnKSxcbiAga1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeTogU3ltYm9sKCdyZXRyeSBhZ2VudCBkZWZhdWx0IHJldHJ5JyksXG4gIGtDb25zdHJ1Y3Q6IFN5bWJvbCgnY29uc3RydWN0YWJsZScpLFxuICBrTGlzdGVuZXJzOiBTeW1ib2woJ2xpc3RlbmVycycpLFxuICBrSFRUUENvbnRleHQ6IFN5bWJvbCgnaHR0cCBjb250ZXh0JyksXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtczogU3ltYm9sKCdtYXggY29uY3VycmVudCBzdHJlYW1zJyksXG4gIGtIVFRQMkluaXRpYWxXaW5kb3dTaXplOiBTeW1ib2woJ2h0dHAyIGluaXRpYWwgd2luZG93IHNpemUnKSxcbiAga0hUVFAyQ29ubmVjdGlvbldpbmRvd1NpemU6IFN5bWJvbCgnaHR0cDIgY29ubmVjdGlvbiB3aW5kb3cgc2l6ZScpLFxuICBrRW5hYmxlQ29ubmVjdFByb3RvY29sOiBTeW1ib2woJ2h0dHAyc2Vzc2lvbiBjb25uZWN0IHByb3RvY29sJyksXG4gIGtSZW1vdGVTZXR0aW5nczogU3ltYm9sKCdodHRwMnNlc3Npb24gcmVtb3RlIHNldHRpbmdzJyksXG4gIGtIVFRQMlN0cmVhbTogU3ltYm9sKCdodHRwMnNlc3Npb24gY2xpZW50IHN0cmVhbScpLFxuICBrTm9Qcm94eUFnZW50OiBTeW1ib2woJ25vIHByb3h5IGFnZW50JyksXG4gIGtIdHRwUHJveHlBZ2VudDogU3ltYm9sKCdodHRwIHByb3h5IGFnZW50JyksXG4gIGtIdHRwc1Byb3h5QWdlbnQ6IFN5bWJvbCgnaHR0cHMgcHJveHkgYWdlbnQnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    /**\n     * @type {TstNode}\n     */\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @returns {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    /**\n     * @type {TstNode|null}\n     */\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @returns {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWE7O0FBRXpCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFx0cmVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHdlbGxrbm93bkhlYWRlck5hbWVzLFxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY2xhc3MgVHN0Tm9kZSB7XG4gIC8qKiBAdHlwZSB7YW55fSAqL1xuICB2YWx1ZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbGVmdCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbWlkZGxlID0gbnVsbFxuICAvKiogQHR5cGUge251bGwgfCBUc3ROb2RlfSAqL1xuICByaWdodCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGNvZGVcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0ga2V5Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlID0ga2V5LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleSBtdXN0IGJlIGFzY2lpIHN0cmluZycpXG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoICE9PSArK2luZGV4KSB7XG4gICAgICB0aGlzLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RzdE5vZGV9XG4gICAgICovXG4gICAgbGV0IG5vZGUgPSB0aGlzXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuY2hhckNvZGVBdChpbmRleClcbiAgICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5IG11c3QgYmUgYXNjaWkgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5taWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5taWRkbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jb2RlIDwgY29kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubGVmdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5yaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAgKiBAcmV0dXJucyB7VHN0Tm9kZSB8IG51bGx9XG4gICAqL1xuICBzZWFyY2ggKGtleSkge1xuICAgIGNvbnN0IGtleWxlbmd0aCA9IGtleS5sZW5ndGhcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RzdE5vZGV8bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbm9kZSA9IHRoaXNcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBpbmRleCA8IGtleWxlbmd0aCkge1xuICAgICAgbGV0IGNvZGUgPSBrZXlbaW5kZXhdXG4gICAgICAvLyBBLVpcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGl0IGlzIGJpZ2dlciB0aGFuIDB4NWEuXG4gICAgICAvLyBMb3dlcmNhc2UgbGV0dGVycyBoYXZlIGhpZ2hlciBjaGFyIGNvZGVzIHRoYW4gdXBwZXJjYXNlIG9uZXMuXG4gICAgICAvLyBBbHNvIHdlIGFzc3VtZSB0aGF0IGhlYWRlcnMgd2lsbCBtb3N0bHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgIGlmIChjb2RlIDw9IDB4NWEgJiYgY29kZSA+PSAweDQxKSB7XG4gICAgICAgIC8vIExvd2VyY2FzZSBmb3IgdXBwZXJjYXNlLlxuICAgICAgICBjb2RlIHw9IDMyXG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY29kZSA9PT0gbm9kZS5jb2RlKSB7XG4gICAgICAgICAgaWYgKGtleWxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBOb2RlIHNpbmNlIGl0IGlzIHRoZSBsYXN0IGtleS5cbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLm1pZGRsZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUuY29kZSA8IGNvZGUgPyBub2RlLmxlZnQgOiBub2RlLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgVGVybmFyeVNlYXJjaFRyZWUge1xuICAvKiogQHR5cGUge1RzdE5vZGUgfCBudWxsfSAqL1xuICBub2RlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogKi9cbiAgaW5zZXJ0IChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ub2RlID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlLmFkZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAgKiBAcmV0dXJucyB7YW55fVxuICAgKi9cbiAgbG9va3VwIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlPy5zZWFyY2goa2V5KT8udmFsdWUgPz8gbnVsbFxuICB9XG59XG5cbmNvbnN0IHRyZWUgPSBuZXcgVGVybmFyeVNlYXJjaFRyZWUoKVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gIGNvbnN0IGtleSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW3dlbGxrbm93bkhlYWRlck5hbWVzW2ldXVxuICB0cmVlLmluc2VydChrZXksIGtleSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRlcm5hcnlTZWFyY2hUcmVlLFxuICB0cmVlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\")\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\")\nconst timers = __webpack_require__(/*! ../util/timers */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\nconst { tree } = __webpack_require__(/*! ./tree */ \"(rsc)/./node_modules/undici/lib/core/tree.js\")\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.', 2).map(v => Number(v))\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nfunction noop () {}\n\n/**\n * @param {*} body\n * @returns {*}\n */\nfunction wrapRequestBody (body) {\n  if (isStream(body)) {\n    // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n    // so that it can be dispatched again?\n    // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n    if (bodyLength(body) === 0) {\n      body\n        .on('data', function () {\n          assert(false)\n        })\n    }\n\n    if (typeof body.readableDidRead !== 'boolean') {\n      body[kBodyUsed] = false\n      EE.prototype.on.call(body, 'data', function () {\n        this[kBodyUsed] = true\n      })\n    }\n\n    return body\n  } else if (body && typeof body.pipeTo === 'function') {\n    // TODO (fix): We can't access ReadableStream internal state\n    // to determine whether or not it has been disturbed. This is just\n    // a workaround.\n    return new BodyAsyncIterable(body)\n  } else if (body && isFormDataLike(body)) {\n    return body\n  } else if (\n    body &&\n    typeof body !== 'string' &&\n    !ArrayBuffer.isView(body) &&\n    isIterable(body)\n  ) {\n    // TODO: Should we allow re-using iterable if !this.opts.idempotent\n    // or through some other flag?\n    return new BodyAsyncIterable(body)\n  } else {\n    return body\n  }\n}\n\n/**\n * @param {*} obj\n * @returns {obj is import('node:stream').Stream}\n */\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n/**\n * @param {*} object\n * @returns {object is Blob}\n * based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\n */\nfunction isBlobLike (object) {\n  if (object === null) {\n    return false\n  } else if (object instanceof Blob) {\n    return true\n  } else if (typeof object !== 'object') {\n    return false\n  } else {\n    const sTag = object[Symbol.toStringTag]\n\n    return (sTag === 'Blob' || sTag === 'File') && (\n      ('stream' in object && typeof object.stream === 'function') ||\n      ('arrayBuffer' in object && typeof object.arrayBuffer === 'function')\n    )\n  }\n}\n\n/**\n * @param {string} url The path to check for query strings or fragments.\n * @returns {boolean} Returns true if the path contains a query string or fragment.\n */\nfunction pathHasQueryOrFragment (url) {\n  return (\n    url.includes('?') ||\n    url.includes('#')\n  )\n}\n\n/**\n * @param {string} url The URL to add the query params to\n * @param {import('node:querystring').ParsedUrlQueryInput} queryParams The object to serialize into a URL query string\n * @returns {string} The URL with the query params added\n */\nfunction serializePathWithQuery (url, queryParams) {\n  if (pathHasQueryOrFragment(url)) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\n/**\n * @param {number|string|undefined} port\n * @returns {boolean}\n */\nfunction isValidPort (port) {\n  const value = parseInt(port, 10)\n  return (\n    value === Number(port) &&\n    value >= 0 &&\n    value <= 65535\n  )\n}\n\n/**\n * Check if the value is a valid http or https prefixed string.\n *\n * @param {string} value\n * @returns {boolean}\n */\nfunction isHttpOrHttpsPrefixed (value) {\n  return (\n    value != null &&\n    value[0] === 'h' &&\n    value[1] === 't' &&\n    value[2] === 't' &&\n    value[3] === 'p' &&\n    (\n      value[4] === ':' ||\n      (\n        value[4] === 's' &&\n        value[5] === ':'\n      )\n    )\n  )\n}\n\n/**\n * @param {string|URL|Record<string,string>} url\n * @returns {URL}\n */\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    /**\n     * @type {URL}\n     */\n    url = new URL(url)\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol || ''}//${url.hostname || ''}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin[origin.length - 1] === '/') {\n      origin = origin.slice(0, origin.length - 1)\n    }\n\n    if (path && path[0] !== '/') {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    return new URL(`${origin}${path}`)\n  }\n\n  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  return url\n}\n\n/**\n * @param {string|URL|Record<string, string>} url\n * @returns {URL}\n */\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\n/**\n * @param {string} host\n * @returns {string}\n */\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substring(1, idx)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substring(0, idx)\n}\n\n/**\n * IP addresses are not valid server names per RFC6066\n * Currently, the only server names supported are DNS hostnames\n * @param {string|null} host\n * @returns {string|null}\n */\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert(typeof host === 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\n/**\n * @function\n * @template T\n * @param {T} obj\n * @returns {T}\n */\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n/**\n * @param {*} obj\n * @returns {obj is AsyncIterable}\n */\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\n/**\n * @param {*} obj\n * @returns {obj is Iterable}\n */\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\n/**\n * @param {Blob|Buffer|import ('stream').Stream} body\n * @returns {number|null}\n */\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\n/**\n * @param {import ('stream').Stream} body\n * @returns {boolean}\n */\nfunction isDestroyed (body) {\n  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))\n}\n\n/**\n * @param {import ('stream').Stream} stream\n * @param {Error} [err]\n * @returns {void}\n */\nfunction destroy (stream, err) {\n  if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    queueMicrotask(() => {\n      stream.emit('error', err)\n    })\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\n/**\n * @param {string} val\n * @returns {number | null}\n */\nfunction parseKeepAliveTimeout (val) {\n  const m = val.match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */\nfunction headerNameToString (value) {\n  return typeof value === 'string'\n    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()\n    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */\nfunction bufferToLowerCasedHeaderName (value) {\n  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * @param {(Buffer | string)[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */\nfunction parseHeaders (headers, obj) {\n  if (obj === undefined) obj = {}\n\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headerNameToString(headers[i])\n    let val = obj[key]\n\n    if (val) {\n      if (typeof val === 'string') {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('latin1'))\n    } else {\n      const headersValue = headers[i + 1]\n      if (typeof headersValue === 'string') {\n        obj[key] = headersValue\n      } else {\n        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('latin1')) : headersValue.toString('latin1')\n      }\n    }\n  }\n\n  return obj\n}\n\n/**\n * @param {Buffer[]} headers\n * @returns {string[]}\n */\nfunction parseRawHeaders (headers) {\n  const headersLength = headers.length\n  /**\n   * @type {string[]}\n   */\n  const ret = new Array(headersLength)\n\n  let key\n  let val\n\n  for (let n = 0; n < headersLength; n += 2) {\n    key = headers[n]\n    val = headers[n + 1]\n\n    typeof key !== 'string' && (key = key.toString())\n    typeof val !== 'string' && (val = val.toString('latin1'))\n\n    ret[n] = key\n    ret[n + 1] = val\n  }\n\n  return ret\n}\n\n/**\n * @param {string[]} headers\n * @param {Buffer[]} headers\n */\nfunction encodeRawHeaders (headers) {\n  if (!Array.isArray(headers)) {\n    throw new TypeError('expected headers to be an array')\n  }\n  return headers.map(x => Buffer.from(x))\n}\n\n/**\n * @param {*} buffer\n * @returns {buffer is Buffer}\n */\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\n/**\n * Asserts that the handler object is a request handler.\n *\n * @param {object} handler\n * @param {string} method\n * @param {string} [upgrade]\n * @returns {asserts handler is import('../api/api-request').RequestHandler}\n */\nfunction assertRequestHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onRequestStart === 'function') {\n    // TODO (fix): More checks...\n    return\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n/**\n * A body is disturbed if it has been read from and it cannot be re-used without\n * losing state or data.\n * @param {import('node:stream').Readable} body\n * @returns {boolean}\n */\nfunction isDisturbed (body) {\n  // TODO (fix): Why is body[kBodyUsed] needed?\n  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))\n}\n\n/**\n * @typedef {object} SocketInfo\n * @property {string} [localAddress]\n * @property {number} [localPort]\n * @property {string} [remoteAddress]\n * @property {number} [remotePort]\n * @property {string} [remoteFamily]\n * @property {number} [timeout]\n * @property {number} bytesWritten\n * @property {number} bytesRead\n */\n\n/**\n * @param {import('net').Socket} socket\n * @returns {SocketInfo}\n */\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\n/**\n * @param {Iterable} iterable\n * @returns {ReadableStream}\n */\nfunction ReadableStreamFrom (iterable) {\n  // We cannot use ReadableStream.from here because it does not return a byte stream.\n\n  let iterator\n  return new ReadableStream(\n    {\n      start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      pull (controller) {\n        return iterator.next().then(({ done, value }) => {\n          if (done) {\n            return queueMicrotask(() => {\n              controller.close()\n              controller.byobRequest?.respond(0)\n            })\n          } else {\n            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n            if (buf.byteLength) {\n              return controller.enqueue(new Uint8Array(buf))\n            } else {\n              return this.pull(controller)\n            }\n          }\n        })\n      },\n      cancel () {\n        return iterator.return()\n      },\n      type: 'bytes'\n    }\n  )\n}\n\n/**\n * The object should be a FormData instance and contains all the required\n * methods.\n * @param {*} object\n * @returns {object is FormData}\n */\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction addAbortListener (signal, listener) {\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.once('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\nconst validTokenChars = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0-15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16-31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32-47 (!\"#$%&'()*+,-./)\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48-63 (0-9:;<=>?)\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64-79 (@A-O)\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80-95 (P-Z[\\]^_)\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96-111 (`a-o)\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, // 112-127 (p-z{|}~)\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 128-143\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 144-159\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 160-175\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 176-191\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 192-207\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 208-223\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 224-239\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  // 240-255\n])\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n * @returns {boolean}\n */\nfunction isTokenCharCode (c) {\n  return (validTokenChars[c] === 1)\n}\n\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length >= 12) return tokenRegExp.test(characters)\n  if (characters.length === 0) return false\n\n  for (let i = 0; i < characters.length; i++) {\n    if (validTokenChars[characters.charCodeAt(i)] !== 1) {\n      return false\n    }\n  }\n  return true\n}\n\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHeaderValue (characters) {\n  return !headerCharRegex.test(characters)\n}\n\nconst rangeHeaderRegex = /^bytes (\\d+)-(\\d+)\\/(\\d+)?$/\n\n/**\n * @typedef {object} RangeHeader\n * @property {number} start\n * @property {number | null} end\n * @property {number | null} size\n */\n\n/**\n * Parse accordingly to RFC 9110\n * @see https://www.rfc-editor.org/rfc/rfc9110#field.content-range\n * @param {string} [range]\n * @returns {RangeHeader|null}\n */\nfunction parseRangeHeader (range) {\n  if (range == null || range === '') return { start: 0, end: null, size: null }\n\n  const m = range ? range.match(rangeHeaderRegex) : null\n  return m\n    ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n      }\n    : null\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @param {string} name\n * @param {(...args: any[]) => void} listener\n * @returns {T}\n */\nfunction addListener (obj, name, listener) {\n  const listeners = (obj[kListeners] ??= [])\n  listeners.push([name, listener])\n  obj.on(name, listener)\n  return obj\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @returns {T}\n */\nfunction removeAllListeners (obj) {\n  if (obj[kListeners] != null) {\n    for (const [name, listener] of obj[kListeners]) {\n      obj.removeListener(name, listener)\n    }\n    obj[kListeners] = null\n  }\n  return obj\n}\n\n/**\n * @param {import ('../dispatcher/client')} client\n * @param {import ('../core/request')} request\n * @param {Error} err\n */\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\n/**\n * @param {WeakRef<net.Socket>} socketWeakRef\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n * @returns {() => void}\n */\nconst setupConnectTimeout = process.platform === 'win32'\n  ? (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      let s2 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts))\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n        clearImmediate(s2)\n      }\n    }\n  : (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n          onConnectTimeout(socketWeakRef.deref(), opts)\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n      }\n    }\n\n/**\n * @param {net.Socket} socket\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n */\nfunction onConnectTimeout (socket, opts) {\n  // The socket could be already garbage collected\n  if (socket == null) {\n    return\n  }\n\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`\n  } else {\n    message += ` (attempted address: ${opts.hostname}:${opts.port},`\n  }\n\n  message += ` timeout: ${opts.timeout}ms)`\n\n  destroy(socket, new ConnectTimeoutError(message))\n}\n\n/**\n * @param {string} urlString\n * @returns {string}\n */\nfunction getProtocolFromUrlString (urlString) {\n  if (\n    urlString[0] === 'h' &&\n    urlString[1] === 't' &&\n    urlString[2] === 't' &&\n    urlString[3] === 'p'\n  ) {\n    switch (urlString[4]) {\n      case ':':\n        return 'http:'\n      case 's':\n        if (urlString[5] === ':') {\n          return 'https:'\n        }\n    }\n  }\n  // fallback if none of the usual suspects\n  return urlString.slice(0, urlString.indexOf(':') + 1)\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nconst normalizedMethodRecordsBase = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\nconst normalizedMethodRecords = {\n  ...normalizedMethodRecordsBase,\n  patch: 'patch',\n  PATCH: 'PATCH'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null)\nObject.setPrototypeOf(normalizedMethodRecords, null)\n\nmodule.exports = {\n  kEnumerableProperty,\n  isDisturbed,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  headerNameToString,\n  bufferToLowerCasedHeaderName,\n  addListener,\n  removeAllListeners,\n  errorRequest,\n  parseRawHeaders,\n  encodeRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  assertRequestHandler,\n  getSocketInfo,\n  isFormDataLike,\n  pathHasQueryOrFragment,\n  serializePathWithQuery,\n  addAbortListener,\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isTokenCharCode,\n  parseRangeHeader,\n  normalizedMethodRecordsBase,\n  normalizedMethodRecords,\n  isValidPort,\n  isHttpOrHttpsPrefixed,\n  nodeMajor,\n  nodeMinor,\n  safeHTTPMethods: Object.freeze(['GET', 'HEAD', 'OPTIONS', 'TRACE']),\n  wrapRequestBody,\n  setupConnectTimeout,\n  getProtocolFromUrlString\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUN4RSxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwQkFBVTtBQUM5QixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDBDQUFrQjtBQUNoRCxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN2QyxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDeEUsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhO0FBQzVELFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsNERBQVE7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxxREFBcUQ7QUFDOUYsSUFBSTtBQUNKLHVDQUF1QyxjQUFjLEdBQUcsVUFBVTtBQUNsRTs7QUFFQSwwQkFBMEIsYUFBYTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGtEZXN0cm95ZWQsIGtCb2R5VXNlZCwga0xpc3RlbmVycywga0JvZHkgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IEluY29taW5nTWVzc2FnZSB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25vZGU6bmV0JylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdub2RlOnF1ZXJ5c3RyaW5nJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3QgdGltZXJzID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lcnMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgQ29ubmVjdFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyB0cmVlIH0gPSByZXF1aXJlKCcuL3RyZWUnKVxuXG5jb25zdCBbbm9kZU1ham9yLCBub2RlTWlub3JdID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJywgMikubWFwKHYgPT4gTnVtYmVyKHYpKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYm9keVxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0Qm9keSAoYm9keSkge1xuICBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgMTAwLWV4cGVjdCBzdXBwb3J0IHRvIHByb3ZpZGUgYSB3YXkgdG8gZG8gdGhpcyBwcm9wZXJseT9cbiAgICBpZiAoYm9keUxlbmd0aChib2R5KSA9PT0gMCkge1xuICAgICAgYm9keVxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgIEVFLnByb3RvdHlwZS5vbi5jYWxsKGJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBib2R5XG4gIH0gZWxzZSBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBXZSBjYW4ndCBhY2Nlc3MgUmVhZGFibGVTdHJlYW0gaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2UgaWYgKGJvZHkgJiYgaXNGb3JtRGF0YUxpa2UoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keVxuICB9IGVsc2UgaWYgKFxuICAgIGJvZHkgJiZcbiAgICB0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpICYmXG4gICAgaXNJdGVyYWJsZShib2R5KVxuICApIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBib2R5XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybnMge29iaiBpcyBpbXBvcnQoJ25vZGU6c3RyZWFtJykuU3RyZWFtfVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbidcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge29iamVjdCBpcyBCbG9ifVxuICogYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvZmV0Y2gtYmxvYi9ibG9iLzhhYjU4N2QzNDA4MGRlOTQxNDBiNTRmMDcxNjg0NTFlN2QwYjY1NWUvaW5kZXguanMjTDIyOS1MMjQxIChNSVQgTGljZW5zZSlcbiAqL1xuZnVuY3Rpb24gaXNCbG9iTGlrZSAob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNUYWcgPSBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXVxuXG4gICAgcmV0dXJuIChzVGFnID09PSAnQmxvYicgfHwgc1RhZyA9PT0gJ0ZpbGUnKSAmJiAoXG4gICAgICAoJ3N0cmVhbScgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgKCdhcnJheUJ1ZmZlcicgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgcGF0aCB0byBjaGVjayBmb3IgcXVlcnkgc3RyaW5ncyBvciBmcmFnbWVudHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGNvbnRhaW5zIGEgcXVlcnkgc3RyaW5nIG9yIGZyYWdtZW50LlxuICovXG5mdW5jdGlvbiBwYXRoSGFzUXVlcnlPckZyYWdtZW50ICh1cmwpIHtcbiAgcmV0dXJuIChcbiAgICB1cmwuaW5jbHVkZXMoJz8nKSB8fFxuICAgIHVybC5pbmNsdWRlcygnIycpXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYWRkIHRoZSBxdWVyeSBwYXJhbXMgdG9cbiAqIEBwYXJhbSB7aW1wb3J0KCdub2RlOnF1ZXJ5c3RyaW5nJykuUGFyc2VkVXJsUXVlcnlJbnB1dH0gcXVlcnlQYXJhbXMgVGhlIG9iamVjdCB0byBzZXJpYWxpemUgaW50byBhIFVSTCBxdWVyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBVUkwgd2l0aCB0aGUgcXVlcnkgcGFyYW1zIGFkZGVkXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkgKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHBhdGhIYXNRdWVyeU9yRnJhZ21lbnQodXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKVxuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMpXG5cbiAgaWYgKHN0cmluZ2lmaWVkKSB7XG4gICAgdXJsICs9ICc/JyArIHN0cmluZ2lmaWVkXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gcG9ydFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRQb3J0IChwb3J0KSB7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQocG9ydCwgMTApXG4gIHJldHVybiAoXG4gICAgdmFsdWUgPT09IE51bWJlcihwb3J0KSAmJlxuICAgIHZhbHVlID49IDAgJiZcbiAgICB2YWx1ZSA8PSA2NTUzNVxuICApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaHR0cCBvciBodHRwcyBwcmVmaXhlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNIdHRwT3JIdHRwc1ByZWZpeGVkICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB2YWx1ZVswXSA9PT0gJ2gnICYmXG4gICAgdmFsdWVbMV0gPT09ICd0JyAmJlxuICAgIHZhbHVlWzJdID09PSAndCcgJiZcbiAgICB2YWx1ZVszXSA9PT0gJ3AnICYmXG4gICAgKFxuICAgICAgdmFsdWVbNF0gPT09ICc6JyB8fFxuICAgICAgKFxuICAgICAgICB2YWx1ZVs0XSA9PT0gJ3MnICYmXG4gICAgICAgIHZhbHVlWzVdID09PSAnOidcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx8UmVjb3JkPHN0cmluZyxzdHJpbmc+fSB1cmxcbiAqIEByZXR1cm5zIHtVUkx9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMICh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1VSTH1cbiAgICAgKi9cbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmIGlzVmFsaWRQb3J0KHVybC5wb3J0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2wgfHwgJyd9Ly8ke3VybC5ob3N0bmFtZSB8fCAnJ306JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luW29yaWdpbi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4uc2xpY2UoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgcGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICByZXR1cm4gbmV3IFVSTChgJHtvcmlnaW59JHtwYXRofWApXG4gIH1cblxuICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfFJlY29yZDxzdHJpbmcsIHN0cmluZz59IHVybFxuICogQHJldHVybnMge1VSTH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmlnaW4gKHVybCkge1xuICB1cmwgPSBwYXJzZVVSTCh1cmwpXG5cbiAgaWYgKHVybC5wYXRobmFtZSAhPT0gJy8nIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SG9zdG5hbWUgKGhvc3QpIHtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMSwgaWR4KVxuICB9XG5cbiAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKCc6JylcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBob3N0XG5cbiAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDAsIGlkeClcbn1cblxuLyoqXG4gKiBJUCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCBzZXJ2ZXIgbmFtZXMgcGVyIFJGQzYwNjZcbiAqIEN1cnJlbnRseSwgdGhlIG9ubHkgc2VydmVyIG5hbWVzIHN1cHBvcnRlZCBhcmUgRE5TIGhvc3RuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gaG9zdFxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lIChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKVxuXG4gIGNvbnN0IHNlcnZlcm5hbWUgPSBnZXRIb3N0bmFtZShob3N0KVxuICBpZiAobmV0LmlzSVAoc2VydmVybmFtZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJuYW1lXG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBvYmpcbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUgKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJucyB7b2JqIGlzIEFzeW5jSXRlcmFibGV9XG4gKi9cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybnMge29iaiBpcyBJdGVyYWJsZX1cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Jsb2J8QnVmZmVyfGltcG9ydCAoJ3N0cmVhbScpLlN0cmVhbX0gYm9keVxuICogQHJldHVybnMge251bWJlcnxudWxsfVxuICovXG5mdW5jdGlvbiBib2R5TGVuZ3RoIChib2R5KSB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLm9iamVjdE1vZGUgPT09IGZhbHNlICYmIHN0YXRlLmVuZGVkID09PSB0cnVlICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5sZW5ndGgpXG4gICAgICA/IHN0YXRlLmxlbmd0aFxuICAgICAgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCdzdHJlYW0nKS5TdHJlYW19IGJvZHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Rlc3Ryb3llZCAoYm9keSkge1xuICByZXR1cm4gYm9keSAmJiAhIShib2R5LmRlc3Ryb3llZCB8fCBib2R5W2tEZXN0cm95ZWRdIHx8IChzdHJlYW0uaXNEZXN0cm95ZWQ/Lihib2R5KSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCdzdHJlYW0nKS5TdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHtFcnJvcn0gW2Vycl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZXN0cm95IChzdHJlYW0sIGVycikge1xuICBpZiAoc3RyZWFtID09IG51bGwgfHwgIWlzU3RyZWFtKHN0cmVhbSkgfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RyZWFtKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM4NTA1L2ZpbGVzXG4gICAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkICE9PSB0cnVlKSB7XG4gICAgc3RyZWFtW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX0VYUFIgPSAvdGltZW91dD0oXFxkKykvXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQgKHZhbCkge1xuICBjb25zdCBtID0gdmFsLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMTAwMCA6IG51bGxcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBoZWFkZXIgbmFtZSBhbmQgcmV0dXJucyBpdHMgbG93ZXJjYXNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmcgfCBCdWZmZXJ9IHZhbHVlIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoZWFkZXJOYW1lVG9TdHJpbmcgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgPyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt2YWx1ZV0gPz8gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIDogdHJlZS5sb29rdXAodmFsdWUpID8/IHZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKS50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogUmVjZWl2ZSB0aGUgYnVmZmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRzIGxvd2VyY2FzZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBIZWFkZXIgbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSAodmFsdWUpIHtcbiAgcmV0dXJuIHRyZWUubG9va3VwKHZhbHVlKSA/PyB2YWx1ZS50b1N0cmluZygnbGF0aW4xJykudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KEJ1ZmZlciB8IHN0cmluZylbXX0gaGVhZGVyc1xuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59IFtvYmpdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fVxuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGhlYWRlcnMsIG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIG9iaiA9IHt9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcnNbaV0pXG4gICAgbGV0IHZhbCA9IG9ialtrZXldXG5cbiAgICBpZiAodmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gW3ZhbF1cbiAgICAgICAgb2JqW2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKGhlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZGVyc1ZhbHVlID0gaGVhZGVyc1tpICsgMV1cbiAgICAgIGlmICh0eXBlb2YgaGVhZGVyc1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNWYWx1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSBBcnJheS5pc0FycmF5KGhlYWRlcnNWYWx1ZSkgPyBoZWFkZXJzVmFsdWUubWFwKHggPT4geC50b1N0cmluZygnbGF0aW4xJykpIDogaGVhZGVyc1ZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmF3SGVhZGVycyAoaGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzTGVuZ3RoID0gaGVhZGVycy5sZW5ndGhcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICovXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShoZWFkZXJzTGVuZ3RoKVxuXG4gIGxldCBrZXlcbiAgbGV0IHZhbFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVyc0xlbmd0aDsgbiArPSAyKSB7XG4gICAga2V5ID0gaGVhZGVyc1tuXVxuICAgIHZhbCA9IGhlYWRlcnNbbiArIDFdXG5cbiAgICB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiAoa2V5ID0ga2V5LnRvU3RyaW5nKCkpXG4gICAgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgJiYgKHZhbCA9IHZhbC50b1N0cmluZygnbGF0aW4xJykpXG5cbiAgICByZXRbbl0gPSBrZXlcbiAgICByZXRbbiArIDFdID0gdmFsXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICogQHBhcmFtIHtCdWZmZXJbXX0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBlbmNvZGVSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGhlYWRlcnMgdG8gYmUgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiBoZWFkZXJzLm1hcCh4ID0+IEJ1ZmZlci5mcm9tKHgpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7YnVmZmVyIGlzIEJ1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIgKGJ1ZmZlcikge1xuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvcHVsbC8zMTlcbiAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGhhbmRsZXIgb2JqZWN0IGlzIGEgcmVxdWVzdCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZ3JhZGVdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBoYW5kbGVyIGlzIGltcG9ydCgnLi4vYXBpL2FwaS1yZXF1ZXN0JykuUmVxdWVzdEhhbmRsZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFJlcXVlc3RIYW5kbGVyIChoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBNb3JlIGNoZWNrcy4uLlxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgYm9keSBpcyBkaXN0dXJiZWQgaWYgaXQgaGFzIGJlZW4gcmVhZCBmcm9tIGFuZCBpdCBjYW5ub3QgYmUgcmUtdXNlZCB3aXRob3V0XG4gKiBsb3Npbmcgc3RhdGUgb3IgZGF0YS5cbiAqIEBwYXJhbSB7aW1wb3J0KCdub2RlOnN0cmVhbScpLlJlYWRhYmxlfSBib2R5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEaXN0dXJiZWQgKGJvZHkpIHtcbiAgLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0uaXNEaXN0dXJiZWQoYm9keSkgfHwgYm9keVtrQm9keVVzZWRdKSlcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTb2NrZXRJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xvY2FsQWRkcmVzc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbG9jYWxQb3J0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZW1vdGVBZGRyZXNzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW1vdGVQb3J0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZW1vdGVGYW1pbHldXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXNXcml0dGVuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXNSZWFkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEByZXR1cm5zIHtTb2NrZXRJbmZvfVxuICovXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBpdGVyYWJsZVxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20gKGl0ZXJhYmxlKSB7XG4gIC8vIFdlIGNhbm5vdCB1c2UgUmVhZGFibGVTdHJlYW0uZnJvbSBoZXJlIGJlY2F1c2UgaXQgZG9lcyBub3QgcmV0dXJuIGEgYnl0ZSBzdHJlYW0uXG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICAgICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlIDogQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVsbChjb250cm9sbGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBjYW5jZWwgKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfVxuICApXG59XG5cbi8qKlxuICogVGhlIG9iamVjdCBzaG91bGQgYmUgYSBGb3JtRGF0YSBpbnN0YW5jZSBhbmQgY29udGFpbnMgYWxsIHRoZSByZXF1aXJlZFxuICogbWV0aG9kcy5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0IGlzIEZvcm1EYXRhfVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZGVsZXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuaGFzID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5zZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJ1xuICApXG59XG5cbmZ1bmN0aW9uIGFkZEFib3J0TGlzdGVuZXIgKHNpZ25hbCwgbGlzdGVuZXIpIHtcbiAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBzaWduYWwpIHtcbiAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pXG4gICAgcmV0dXJuICgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICB9XG4gIHNpZ25hbC5vbmNlKCdhYm9ydCcsIGxpc3RlbmVyKVxuICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxufVxuXG5jb25zdCB2YWxpZFRva2VuQ2hhcnMgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAtMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYtMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzItNDcgKCFcIiMkJSYnKCkqKywtLi8pXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4LTYzICgwLTk6Ozw9Pj8pXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0LTc5IChAQS1PKVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MC05NSAoUC1aW1xcXV5fKVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5Ni0xMTEgKGBhLW8pXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAsIC8vIDExMi0xMjcgKHAtent8fX4pXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDEyOC0xNDNcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTQ0LTE1OVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNjAtMTc1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE3Ni0xOTFcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTkyLTIwN1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAyMDgtMjIzXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDIyNC0yMzlcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCAgLy8gMjQwLTI1NVxuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkNoYXJDb2RlIChjKSB7XG4gIHJldHVybiAodmFsaWRUb2tlbkNoYXJzW2NdID09PSAxKVxufVxuXG5jb25zdCB0b2tlblJlZ0V4cCA9IC9eW1xcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dKyQvXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSFRUUFRva2VuIChjaGFyYWN0ZXJzKSB7XG4gIGlmIChjaGFyYWN0ZXJzLmxlbmd0aCA+PSAxMikgcmV0dXJuIHRva2VuUmVnRXhwLnRlc3QoY2hhcmFjdGVycylcbiAgaWYgKGNoYXJhY3RlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsaWRUb2tlbkNoYXJzW2NoYXJhY3RlcnMuY2hhckNvZGVBdChpKV0gIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBoZWFkZXJDaGFyUmVnZXggaGF2ZSBiZWVuIGxpZnRlZCBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYWluL2xpYi9faHR0cF9jb21tb24uanNcblxuLyoqXG4gKiBNYXRjaGVzIGlmIHZhbCBjb250YWlucyBhbiBpbnZhbGlkIGZpZWxkLXZjaGFyXG4gKiAgZmllbGQtdmFsdWUgICAgPSAqKCBmaWVsZC1jb250ZW50IC8gb2JzLWZvbGQgKVxuICogIGZpZWxkLWNvbnRlbnQgID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogIGZpZWxkLXZjaGFyICAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICovXG5jb25zdCBoZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAoY2hhcmFjdGVycykge1xuICByZXR1cm4gIWhlYWRlckNoYXJSZWdleC50ZXN0KGNoYXJhY3RlcnMpXG59XG5cbmNvbnN0IHJhbmdlSGVhZGVyUmVnZXggPSAvXmJ5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKyk/JC9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSYW5nZUhlYWRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlciB8IG51bGx9IGVuZFxuICogQHByb3BlcnR5IHtudW1iZXIgfCBudWxsfSBzaXplXG4gKi9cblxuLyoqXG4gKiBQYXJzZSBhY2NvcmRpbmdseSB0byBSRkMgOTExMFxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMCNmaWVsZC5jb250ZW50LXJhbmdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JhbmdlXVxuICogQHJldHVybnMge1JhbmdlSGVhZGVyfG51bGx9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmFuZ2VIZWFkZXIgKHJhbmdlKSB7XG4gIGlmIChyYW5nZSA9PSBudWxsIHx8IHJhbmdlID09PSAnJykgcmV0dXJuIHsgc3RhcnQ6IDAsIGVuZDogbnVsbCwgc2l6ZTogbnVsbCB9XG5cbiAgY29uc3QgbSA9IHJhbmdlID8gcmFuZ2UubWF0Y2gocmFuZ2VIZWFkZXJSZWdleCkgOiBudWxsXG4gIHJldHVybiBtXG4gICAgPyB7XG4gICAgICAgIHN0YXJ0OiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgZW5kOiBtWzJdID8gcGFyc2VJbnQobVsyXSkgOiBudWxsLFxuICAgICAgICBzaXplOiBtWzNdID8gcGFyc2VJbnQobVszXSkgOiBudWxsXG4gICAgICB9XG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyfSBUXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsaXN0ZW5lclxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyIChvYmosIG5hbWUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IChvYmpba0xpc3RlbmVyc10gPz89IFtdKVxuICBsaXN0ZW5lcnMucHVzaChbbmFtZSwgbGlzdGVuZXJdKVxuICBvYmoub24obmFtZSwgbGlzdGVuZXIpXG4gIHJldHVybiBvYmpcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXJ9IFRcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzIChvYmopIHtcbiAgaWYgKG9ialtrTGlzdGVuZXJzXSAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgbGlzdGVuZXJdIG9mIG9ialtrTGlzdGVuZXJzXSkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKVxuICAgIH1cbiAgICBvYmpba0xpc3RlbmVyc10gPSBudWxsXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi4vZGlzcGF0Y2hlci9jbGllbnQnKX0gY2xpZW50XG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4uL2NvcmUvcmVxdWVzdCcpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqL1xuZnVuY3Rpb24gZXJyb3JSZXF1ZXN0IChjbGllbnQsIHJlcXVlc3QsIGVycikge1xuICB0cnkge1xuICAgIHJlcXVlc3Qub25FcnJvcihlcnIpXG4gICAgYXNzZXJ0KHJlcXVlc3QuYWJvcnRlZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2xpZW50LmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWFrUmVmPG5ldC5Tb2NrZXQ+fSBzb2NrZXRXZWFrUmVmXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMudGltZW91dFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuaG9zdG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBvcnRcbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5jb25zdCBzZXR1cENvbm5lY3RUaW1lb3V0ID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICA/IChzb2NrZXRXZWFrUmVmLCBvcHRzKSA9PiB7XG4gICAgICBpZiAoIW9wdHMudGltZW91dCkge1xuICAgICAgICByZXR1cm4gbm9vcFxuICAgICAgfVxuXG4gICAgICBsZXQgczEgPSBudWxsXG4gICAgICBsZXQgczIgPSBudWxsXG4gICAgICBjb25zdCBmYXN0VGltZXIgPSB0aW1lcnMuc2V0RmFzdFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gc2V0SW1tZWRpYXRlIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHByaW9yaXRpemUgc29ja2V0IGVycm9yIGV2ZW50cyBvdmVyIHRpbWVvdXRzXG4gICAgICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgLy8gV2luZG93cyBuZWVkcyBhbiBleHRyYSBzZXRJbW1lZGlhdGUgcHJvYmFibHkgZHVlIHRvIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzIGluIHRoZSBzb2NrZXQgbG9naWNcbiAgICAgICAgICBzMiA9IHNldEltbWVkaWF0ZSgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0KHNvY2tldFdlYWtSZWYuZGVyZWYoKSwgb3B0cykpXG4gICAgICAgIH0pXG4gICAgICB9LCBvcHRzLnRpbWVvdXQpXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aW1lcnMuY2xlYXJGYXN0VGltZW91dChmYXN0VGltZXIpXG4gICAgICAgIGNsZWFySW1tZWRpYXRlKHMxKVxuICAgICAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgICAgIH1cbiAgICB9XG4gIDogKHNvY2tldFdlYWtSZWYsIG9wdHMpID0+IHtcbiAgICAgIGlmICghb3B0cy50aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBub29wXG4gICAgICB9XG5cbiAgICAgIGxldCBzMSA9IG51bGxcbiAgICAgIGNvbnN0IGZhc3RUaW1lciA9IHRpbWVycy5zZXRGYXN0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBzZXRJbW1lZGlhdGUgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJpb3JpdGl6ZSBzb2NrZXQgZXJyb3IgZXZlbnRzIG92ZXIgdGltZW91dHNcbiAgICAgICAgczEgPSBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0V2Vha1JlZi5kZXJlZigpLCBvcHRzKVxuICAgICAgICB9KVxuICAgICAgfSwgb3B0cy50aW1lb3V0KVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdGltZXJzLmNsZWFyRmFzdFRpbWVvdXQoZmFzdFRpbWVyKVxuICAgICAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICAgIH1cbiAgICB9XG5cbi8qKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy50aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5ob3N0bmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucG9ydFxuICovXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQsIG9wdHMpIHtcbiAgLy8gVGhlIHNvY2tldCBjb3VsZCBiZSBhbHJlYWR5IGdhcmJhZ2UgY29sbGVjdGVkXG4gIGlmIChzb2NrZXQgPT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IG1lc3NhZ2UgPSAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICBpZiAoQXJyYXkuaXNBcnJheShzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcykpIHtcbiAgICBtZXNzYWdlICs9IGAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7c29ja2V0LmF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMuam9pbignLCAnKX0sYFxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgKz0gYCAoYXR0ZW1wdGVkIGFkZHJlc3M6ICR7b3B0cy5ob3N0bmFtZX06JHtvcHRzLnBvcnR9LGBcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gYCB0aW1lb3V0OiAke29wdHMudGltZW91dH1tcylgXG5cbiAgZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKG1lc3NhZ2UpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxTdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFByb3RvY29sRnJvbVVybFN0cmluZyAodXJsU3RyaW5nKSB7XG4gIGlmIChcbiAgICB1cmxTdHJpbmdbMF0gPT09ICdoJyAmJlxuICAgIHVybFN0cmluZ1sxXSA9PT0gJ3QnICYmXG4gICAgdXJsU3RyaW5nWzJdID09PSAndCcgJiZcbiAgICB1cmxTdHJpbmdbM10gPT09ICdwJ1xuICApIHtcbiAgICBzd2l0Y2ggKHVybFN0cmluZ1s0XSkge1xuICAgICAgY2FzZSAnOic6XG4gICAgICAgIHJldHVybiAnaHR0cDonXG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgaWYgKHVybFN0cmluZ1s1XSA9PT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuICdodHRwczonXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZmFsbGJhY2sgaWYgbm9uZSBvZiB0aGUgdXN1YWwgc3VzcGVjdHNcbiAgcmV0dXJuIHVybFN0cmluZy5zbGljZSgwLCB1cmxTdHJpbmcuaW5kZXhPZignOicpICsgMSlcbn1cblxuY29uc3Qga0VudW1lcmFibGVQcm9wZXJ0eSA9IE9iamVjdC5jcmVhdGUobnVsbClcbmtFbnVtZXJhYmxlUHJvcGVydHkuZW51bWVyYWJsZSA9IHRydWVcblxuY29uc3Qgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlID0ge1xuICBkZWxldGU6ICdERUxFVEUnLFxuICBERUxFVEU6ICdERUxFVEUnLFxuICBnZXQ6ICdHRVQnLFxuICBHRVQ6ICdHRVQnLFxuICBoZWFkOiAnSEVBRCcsXG4gIEhFQUQ6ICdIRUFEJyxcbiAgb3B0aW9uczogJ09QVElPTlMnLFxuICBPUFRJT05TOiAnT1BUSU9OUycsXG4gIHBvc3Q6ICdQT1NUJyxcbiAgUE9TVDogJ1BPU1QnLFxuICBwdXQ6ICdQVVQnLFxuICBQVVQ6ICdQVVQnXG59XG5cbmNvbnN0IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzID0ge1xuICAuLi5ub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsXG4gIHBhdGNoOiAncGF0Y2gnLFxuICBQQVRDSDogJ1BBVENIJ1xufVxuXG4vLyBOb3RlOiBvYmplY3QgcHJvdG90eXBlcyBzaG91bGQgbm90IGJlIGFibGUgdG8gYmUgcmVmZXJlbmNlZC4gZS5nLiBgT2JqZWN0I2hhc093blByb3BlcnR5YC5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsIG51bGwpXG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9ybWFsaXplZE1ldGhvZFJlY29yZHMsIG51bGwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpc0Rpc3R1cmJlZCxcbiAgaXNCbG9iTGlrZSxcbiAgcGFyc2VPcmlnaW4sXG4gIHBhcnNlVVJMLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBpc1N0cmVhbSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNBc3luY0l0ZXJhYmxlLFxuICBpc0Rlc3Ryb3llZCxcbiAgaGVhZGVyTmFtZVRvU3RyaW5nLFxuICBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lLFxuICBhZGRMaXN0ZW5lcixcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICBlcnJvclJlcXVlc3QsXG4gIHBhcnNlUmF3SGVhZGVycyxcbiAgZW5jb2RlUmF3SGVhZGVycyxcbiAgcGFyc2VIZWFkZXJzLFxuICBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQsXG4gIGRlc3Ryb3ksXG4gIGJvZHlMZW5ndGgsXG4gIGRlZXBDbG9uZSxcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0J1ZmZlcixcbiAgYXNzZXJ0UmVxdWVzdEhhbmRsZXIsXG4gIGdldFNvY2tldEluZm8sXG4gIGlzRm9ybURhdGFMaWtlLFxuICBwYXRoSGFzUXVlcnlPckZyYWdtZW50LFxuICBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5LFxuICBhZGRBYm9ydExpc3RlbmVyLFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzVG9rZW5DaGFyQ29kZSxcbiAgcGFyc2VSYW5nZUhlYWRlcixcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3JkcyxcbiAgaXNWYWxpZFBvcnQsXG4gIGlzSHR0cE9ySHR0cHNQcmVmaXhlZCxcbiAgbm9kZU1ham9yLFxuICBub2RlTWlub3IsXG4gIHNhZmVIVFRQTWV0aG9kczogT2JqZWN0LmZyZWV6ZShbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnVFJBQ0UnXSksXG4gIHdyYXBSZXF1ZXN0Qm9keSxcbiAgc2V0dXBDb25uZWN0VGltZW91dCxcbiAgZ2V0UHJvdG9jb2xGcm9tVXJsU3RyaW5nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError, MaxOriginsReachedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\nconst kOrigins = Symbol('origins')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxOrigins = Infinity, connect, ...options } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof maxOrigins !== 'number' || Number.isNaN(maxOrigins) || maxOrigins <= 0) {\n      throw new InvalidArgumentError('maxOrigins must be a number greater than 0')\n    }\n\n    super()\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), maxOrigins, connect }\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kOrigins] = new Set()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { dispatcher } of this[kClients].values()) {\n      ret += dispatcher[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    if (this[kOrigins].size >= this[kOptions].maxOrigins && !this[kOrigins].has(key)) {\n      throw new MaxOriginsReachedError()\n    }\n\n    const result = this[kClients].get(key)\n    let dispatcher = result && result.dispatcher\n    if (!dispatcher) {\n      const closeClientIfUnused = (connected) => {\n        const result = this[kClients].get(key)\n        if (result) {\n          if (connected) result.count -= 1\n          if (result.count <= 0) {\n            this[kClients].delete(key)\n            result.dispatcher.close()\n          }\n          this[kOrigins].delete(key)\n        }\n      }\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', (origin, targets) => {\n          const result = this[kClients].get(key)\n          if (result) {\n            result.count += 1\n          }\n          this[kOnConnect](origin, targets)\n        })\n        .on('disconnect', (origin, targets, err) => {\n          closeClientIfUnused(true)\n          this[kOnDisconnect](origin, targets, err)\n        })\n        .on('connectionError', (origin, targets, err) => {\n          closeClientIfUnused(false)\n          this[kOnConnectionError](origin, targets, err)\n        })\n\n      this[kClients].set(key, { count: 0, dispatcher })\n      this[kOrigins].add(key)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  [kClose] () {\n    const closePromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      closePromises.push(dispatcher.close())\n    }\n    this[kClients].clear()\n\n    return Promise.all(closePromises)\n  }\n\n  [kDestroy] (err) {\n    const destroyPromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      destroyPromises.push(dispatcher.destroy(err))\n    }\n    this[kClients].clear()\n\n    return Promise.all(destroyPromises)\n  }\n\n  get stats () {\n    const allClientStats = {}\n    for (const { dispatcher } of this[kClients].values()) {\n      if (dispatcher.stats) {\n        allClientStats[dispatcher[kUrl].origin] = dispatcher.stats\n      }\n    }\n    return allClientStats\n  }\n}\n\nmodule.exports = Agent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsK0NBQStDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDakYsUUFBUSx3REFBd0QsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUMzRix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUVBQXVFLElBQUk7QUFDNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxhZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgTWF4T3JpZ2luc1JlYWNoZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrQ2xpZW50cywga1J1bm5pbmcsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCwga1VybCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtPcmlnaW5zID0gU3ltYm9sKCdvcmlnaW5zJylcblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gb3B0cyAmJiBvcHRzLmNvbm5lY3Rpb25zID09PSAxXG4gICAgPyBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbiAgICA6IG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgbWF4T3JpZ2lucyA9IEluZmluaXR5LCBjb25uZWN0LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtYXhPcmlnaW5zICE9PSAnbnVtYmVyJyB8fCBOdW1iZXIuaXNOYU4obWF4T3JpZ2lucykgfHwgbWF4T3JpZ2lucyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heE9yaWdpbnMgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfVxuICAgIH1cblxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgbWF4T3JpZ2lucywgY29ubmVjdCB9XG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcbiAgICB0aGlzW2tPcmlnaW5zXSA9IG5ldyBTZXQoKVxuXG4gICAgdGhpc1trT25EcmFpbl0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCB7IGRpc3BhdGNoZXIgfSBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgcmV0ICs9IGRpc3BhdGNoZXJba1J1bm5pbmddXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgbGV0IGtleVxuICAgIGlmIChvcHRzLm9yaWdpbiAmJiAodHlwZW9mIG9wdHMub3JpZ2luID09PSAnc3RyaW5nJyB8fCBvcHRzLm9yaWdpbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgIGtleSA9IFN0cmluZyhvcHRzLm9yaWdpbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLm9yaWdpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBVUkwuJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trT3JpZ2luc10uc2l6ZSA+PSB0aGlzW2tPcHRpb25zXS5tYXhPcmlnaW5zICYmICF0aGlzW2tPcmlnaW5zXS5oYXMoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IE1heE9yaWdpbnNSZWFjaGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG4gICAgbGV0IGRpc3BhdGNoZXIgPSByZXN1bHQgJiYgcmVzdWx0LmRpc3BhdGNoZXJcbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGNvbnN0IGNsb3NlQ2xpZW50SWZVbnVzZWQgPSAoY29ubmVjdGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoY29ubmVjdGVkKSByZXN1bHQuY291bnQgLT0gMVxuICAgICAgICAgIGlmIChyZXN1bHQuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpc1trQ2xpZW50c10uZGVsZXRlKGtleSlcbiAgICAgICAgICAgIHJlc3VsdC5kaXNwYXRjaGVyLmNsb3NlKClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1trT3JpZ2luc10uZGVsZXRlKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9wdHMub3JpZ2luLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgICAgLm9uKCdkcmFpbicsIHRoaXNba09uRHJhaW5dKVxuICAgICAgICAub24oJ2Nvbm5lY3QnLCAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpc1trQ2xpZW50c10uZ2V0KGtleSlcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuY291bnQgKz0gMVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tPbkNvbm5lY3RdKG9yaWdpbiwgdGFyZ2V0cylcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkaXNjb25uZWN0JywgKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICAgICAgY2xvc2VDbGllbnRJZlVudXNlZCh0cnVlKVxuICAgICAgICAgIHRoaXNba09uRGlzY29ubmVjdF0ob3JpZ2luLCB0YXJnZXRzLCBlcnIpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICAgICAgY2xvc2VDbGllbnRJZlVudXNlZChmYWxzZSlcbiAgICAgICAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0ob3JpZ2luLCB0YXJnZXRzLCBlcnIpXG4gICAgICAgIH0pXG5cbiAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIHsgY291bnQ6IDAsIGRpc3BhdGNoZXIgfSlcbiAgICAgIHRoaXNba09yaWdpbnNdLmFkZChrZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIFtrQ2xvc2VdICgpIHtcbiAgICBjb25zdCBjbG9zZVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IHsgZGlzcGF0Y2hlciB9IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjbG9zZVByb21pc2VzLnB1c2goZGlzcGF0Y2hlci5jbG9zZSgpKVxuICAgIH1cbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcylcbiAgfVxuXG4gIFtrRGVzdHJveV0gKGVycikge1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCB7IGRpc3BhdGNoZXIgfSBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goZGlzcGF0Y2hlci5kZXN0cm95KGVycikpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpXG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIGNvbnN0IGFsbENsaWVudFN0YXRzID0ge31cbiAgICBmb3IgKGNvbnN0IHsgZGlzcGF0Y2hlciB9IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2hlci5zdGF0cykge1xuICAgICAgICBhbGxDbGllbnRTdGF0c1tkaXNwYXRjaGVyW2tVcmxdLm9yaWdpbl0gPSBkaXNwYXRjaGVyLnN0YXRzXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxDbGllbnRTdGF0c1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  getUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    return this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQzFDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLG9DQUFvQyxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGJhbGFuY2VkLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKCdrR3JlYXRlc3RDb21tb25EaXZpc29yJylcbmNvbnN0IGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKCdrQ3VycmVudFdlaWdodCcpXG5jb25zdCBrSW5kZXggPSBTeW1ib2woJ2tJbmRleCcpXG5jb25zdCBrV2VpZ2h0ID0gU3ltYm9sKCdrV2VpZ2h0JylcbmNvbnN0IGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woJ2tNYXhXZWlnaHRQZXJTZXJ2ZXInKVxuY29uc3Qga0Vycm9yUGVuYWx0eSA9IFN5bWJvbCgna0Vycm9yUGVuYWx0eScpXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB0d28gbnVtYmVycyBieVxuICogdXNpbmcgdGhlIEV1Y2xpZGVhbiBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IgKGEsIGIpIHtcbiAgaWYgKGEgPT09IDApIHJldHVybiBiXG5cbiAgd2hpbGUgKGIgIT09IDApIHtcbiAgICBjb25zdCB0ID0gYlxuICAgIGIgPSBhICUgYlxuICAgIGEgPSB0XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSBvcHRzXG4gICAgdGhpc1trSW5kZXhdID0gLTFcbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IDBcblxuICAgIHRoaXNba01heFdlaWdodFBlclNlcnZlcl0gPSB0aGlzW2tPcHRpb25zXS5tYXhXZWlnaHRQZXJTZXJ2ZXIgfHwgMTAwXG4gICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgIHVwc3RyZWFtcyA9IFt1cHN0cmVhbXNdXG4gICAgfVxuXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG5cbiAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSlcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICB9XG5cbiAgYWRkVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBpZiAodGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpXG5cbiAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpXG4gICAgcG9vbC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICB9KVxuXG4gICAgcG9vbC5vbignY29ubmVjdGlvbkVycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdkaXNjb25uZWN0JywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl1cbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdVTkRfRVJSX1NPQ0tFVCcpIHtcbiAgICAgICAgLy8gZGVjcmVhc2UgdGhlIHdlaWdodCBvZiB0aGUgcG9vbC5cbiAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBjbGllbnRba1dlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNba0NsaWVudHNdLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IodGhpc1trQ2xpZW50c11baV1ba1dlaWdodF0sIHJlc3VsdClcbiAgICB9XG5cbiAgICB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdID0gcmVzdWx0XG4gIH1cblxuICByZW1vdmVVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAocG9vbCkge1xuICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG4gIH1cblxuICBnZXQgdXBzdHJlYW1zICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11cbiAgICAgIC5maWx0ZXIoZGlzcGF0Y2hlciA9PiBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZSlcbiAgICAgIC5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBwb29scyBpcyBncmVhdGVyIHRoYW4gMCxcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIGFuIHVwc3RyZWFtXG4gICAgLy8gaXMgYWRkZWQsIHdoaWNoIG1pZ2h0IG5ldmVyIGhhcHBlbi5cbiAgICBpZiAodGhpc1trQ2xpZW50c10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKHBvb2wgPT4gcG9vbFtrTmVlZERyYWluXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG5cbiAgICBpZiAoYWxsQ2xpZW50c0J1c3kpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjb3VudGVyID0gMFxuXG4gICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KHBvb2wgPT4gIXBvb2xba05lZWREcmFpbl0pXG5cbiAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGhcbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIGZpbmQgcG9vbCBpbmRleCB3aXRoIHRoZSBsYXJnZXN0IHdlaWdodFxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tJbmRleF1cbiAgICAgIH1cblxuICAgICAgLy8gZGVjcmVhc2UgdGhlIGN1cnJlbnQgd2VpZ2h0IGV2ZXJ5IGB0aGlzW2tDbGllbnRzXS5sZW5ndGhgLlxuICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgd2VpZ2h0IHRvIHRoZSBuZXh0IGxvd2VyIHdlaWdodC5cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl1cblxuICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+PSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAmJiAoIXBvb2xba05lZWREcmFpbl0pKSB7XG4gICAgICAgIHJldHVybiBwb29sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF1cbiAgICB0aGlzW2tJbmRleF0gPSBtYXhXZWlnaHRJbmRleFxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VkUG9vbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext,\n  kClosed\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(rsc)/./node_modules/undici/lib/llhttp/constants.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nfunction lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined\n\n  let mod\n\n  // We disable wasm SIMD on ppc64 as it seems to be broken on Power 9 architectures.\n  let useWasmSIMD = process.arch !== 'ppc64'\n  // The Env Variable UNDICI_NO_WASM_SIMD allows explicitly overriding the default behavior\n  if (process.env.UNDICI_NO_WASM_SIMD === '1') {\n    useWasmSIMD = true\n  } else if (process.env.UNDICI_NO_WASM_SIMD === '0') {\n    useWasmSIMD = false\n  }\n\n  if (useWasmSIMD) {\n    try {\n      mod = new WebAssembly.Module(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"))\n    } catch {\n    }\n  }\n\n  if (!mod) {\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = new WebAssembly.Module(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"))\n  }\n\n  return new WebAssembly.Instance(mod, {\n    env: {\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_url: (p, at, len) => {\n        return 0\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_status: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_begin: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageBegin()\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_field: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_value: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} statusCode\n       * @param {0|1} upgrade\n       * @param {0|1} shouldKeepAlive\n       * @returns {number}\n       */\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1)\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_body: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_complete: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageComplete()\n      }\n\n    }\n  })\n}\n\nlet llhttpInstance = null\n\n/**\n * @type {Parser|null}\n */\nlet currentParser = null\nlet currentBufferRef = null\n/**\n * @type {number}\n */\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst USE_NATIVE_TIMER = 0\nconst USE_FAST_TIMER = 1\n\n// Use fast timers for headers and body to take eventual event loop\n// latency into account.\nconst TIMEOUT_HEADERS = 2 | USE_FAST_TIMER\nconst TIMEOUT_BODY = 4 | USE_FAST_TIMER\n\n// Use native timers to ignore event loop latency for keep-alive\n// handling.\nconst TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER\n\nclass Parser {\n  /**\n     * @param {import('./client.js')} client\n     * @param {import('net').Socket} socket\n     * @param {*} llhttp\n     */\n  constructor (client, socket, { exports }) {\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    /**\n     * @type {import('net').Socket}\n     */\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = 0\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (delay, type) {\n    // If the existing timer and the new timer are of different timer type\n    // (fast or native) or have different delay, we need to clear the existing\n    // timer and set a new one.\n    if (\n      delay !== this.timeoutValue ||\n      (type & USE_FAST_TIMER) ^ (this.timeoutType & USE_FAST_TIMER)\n    ) {\n      // If a timeout is already set, clear it with clearTimeout of the fast\n      // timer implementation, as it can clear fast and native timers.\n      if (this.timeout) {\n        timers.clearTimeout(this.timeout)\n        this.timeout = null\n      }\n\n      if (delay) {\n        if (type & USE_FAST_TIMER) {\n          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this))\n        } else {\n          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this))\n          this.timeout?.unref()\n        }\n      }\n\n      this.timeoutValue = delay\n    } else if (this.timeout) {\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.timeoutType = type\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser === null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   */\n  execute (chunk) {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    // Allocate a new buffer if the current buffer is too small.\n    if (chunk.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      // Allocate a buffer that is a multiple of 4096 bytes.\n      currentBufferSize = Math.ceil(chunk.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = chunk\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length)\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      if (ret !== constants.ERROR.OK) {\n        const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr)\n\n        if (ret === constants.ERROR.PAUSED_UPGRADE) {\n          this.onUpgrade(data)\n        } else if (ret === constants.ERROR.PAUSED) {\n          this.paused = true\n          socket.unshift(data)\n        } else {\n          const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n          let message = ''\n          if (ptr) {\n            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n            message =\n              'Response does not match the HTTP/1.1 protocol (' +\n              Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n              ')'\n          }\n          throw new HTTPParserError(message, constants.ERROR[ret], data)\n        }\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    this.timeout && timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {0}\n   */\n  onStatus (buf) {\n    this.statusText = buf.toString()\n    return 0\n  }\n\n  /**\n   * @returns {0|-1}\n   */\n  onMessageBegin () {\n    const { socket, client } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {number} len\n   */\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  /**\n   * @param {Buffer} head\n   */\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n    assert(client[kSocket] === socket)\n    assert(!socket.destroyed)\n    assert(!this.paused)\n    assert((headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.shouldKeepAlive = false\n\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {number} statusCode\n   * @param {boolean} upgrade\n   * @param {boolean} shouldKeepAlive\n   * @returns {number}\n   */\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert(this.timeoutType === TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert((this.headers.length & 1) === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n\n    return 0\n  }\n\n  /**\n   * @returns {number}\n   */\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return 0\n    }\n\n    assert(statusCode >= 100)\n    assert((this.headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return 0\n    }\n\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert(client[kRunning] === 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(client[kResume])\n    } else {\n      client[kResume]()\n    }\n\n    return 0\n  }\n}\n\nfunction onParserTimeout (parserWeakRef) {\n  const parser = parserWeakRef.deref()\n  if (!parser) {\n    return\n  }\n\n  const { socket, timeoutType, client, paused } = parser\n\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\n/**\n * @param {import ('./client.js')} client\n * @param {import('net').Socket} socket\n * @returns\n */\nfunction connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = lazyllhttp()\n  }\n\n  if (socket.errored) {\n    throw socket.errored\n  }\n\n  if (socket.destroyed) {\n    throw new SocketError('destroyed')\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  util.addListener(socket, 'error', onHttpSocketError)\n  util.addListener(socket, 'readable', onHttpSocketReadable)\n  util.addListener(socket, 'end', onHttpSocketEnd)\n  util.addListener(socket, 'close', onHttpSocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (request) {\n      return writeH1(client, request)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    /**\n     * @param {Error|undefined} err\n     * @param {() => void} callback\n     */\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.on('close', callback)\n        socket.destroy(err)\n      }\n    },\n    /**\n     * @returns {boolean}\n     */\n    get destroyed () {\n      return socket.destroyed\n    },\n    /**\n     * @param {import('../core/request.js')} request\n     * @returns {boolean}\n     */\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction onHttpSocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  const parser = this[kParser]\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttpSocketReadable () {\n  this[kParser]?.readMore()\n}\n\nfunction onHttpSocketEnd () {\n  const parser = this[kParser]\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onHttpSocketClose () {\n  const parser = this[kParser]\n\n  if (parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    util.errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n/**\n * @param {import('./client.js')} client\n */\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\n/**\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @returns\n */\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH' ||\n    method === 'QUERY' ||\n    method === 'PROPFIND' ||\n    method === 'PROPPATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {import('stream').Stream} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n */\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  /**\n   * @param {Buffer} chunk\n   * @returns {void}\n   */\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns\n   */\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(onFinished, body.errored)\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(onFinished, null)\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\n/**\n * @typedef AbortCallback\n * @type {Function}\n * @param {Error} [err]\n * @returns {void}\n */\n\n/**\n * @param {AbortCallback} abort\n * @param {Uint8Array|null} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {void}\n */\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Blob} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload && request.reset !== false) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Iterable} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  /**\n   *\n   * @param {object} arg\n   * @param {AbortCallback} arg.abort\n   * @param {import('net').Socket} arg.socket\n   * @param {import('../core/request.js')} arg.request\n   * @param {number} arg.contentLength\n   * @param {import('./client.js')} arg.client\n   * @param {boolean} arg.expectsPayload\n   * @param {string} arg.header\n   */\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @returns\n   */\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  /**\n   * @returns {void}\n   */\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkVBQW9COztBQUVoQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsdUZBQTBCOztBQUV4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxtQkFBTyxDQUFDLGlHQUErQjtBQUMxRSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFPLENBQUMsdUZBQTBCO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsS0FBSztBQUN0QixpQkFBaUIsS0FBSztBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxpQkFBaUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksK0NBQStDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksc0NBQXNDOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSwwRkFBMEY7O0FBRXRHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxzQ0FBc0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Es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QkFBMEIsaUJBQWlCO0FBQzNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksK0VBQStFO0FBQzNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGNsaWVudC1oMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vY29yZS9kaWFnbm9zdGljcy5qcycpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuLi91dGlsL3RpbWVycy5qcycpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIEhUVFBQYXJzZXJFcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzLmpzJylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrQ2xpZW50LFxuICBrUGFyc2VyLFxuICBrQmxvY2tpbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtXcml0aW5nLFxuICBrUXVldWUsXG4gIGtOb1JlZixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrU29ja2V0LFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga1Jlc3VtZSxcbiAga0hUVFBDb250ZXh0LFxuICBrQ2xvc2VkXG59ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzLmpzJylcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vbGxodHRwL2NvbnN0YW50cy5qcycpXG5jb25zdCBFTVBUWV9CVUYgPSBCdWZmZXIuYWxsb2MoMClcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdXG5jb25zdCByZW1vdmVBbGxMaXN0ZW5lcnMgPSB1dGlsLnJlbW92ZUFsbExpc3RlbmVyc1xuXG5sZXQgZXh0cmFjdEJvZHlcblxuZnVuY3Rpb24gbGF6eWxsaHR0cCAoKSB7XG4gIGNvbnN0IGxsaHR0cFdhc21EYXRhID0gcHJvY2Vzcy5lbnYuSkVTVF9XT1JLRVJfSUQgPyByZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSA6IHVuZGVmaW5lZFxuXG4gIGxldCBtb2RcblxuICAvLyBXZSBkaXNhYmxlIHdhc20gU0lNRCBvbiBwcGM2NCBhcyBpdCBzZWVtcyB0byBiZSBicm9rZW4gb24gUG93ZXIgOSBhcmNoaXRlY3R1cmVzLlxuICBsZXQgdXNlV2FzbVNJTUQgPSBwcm9jZXNzLmFyY2ggIT09ICdwcGM2NCdcbiAgLy8gVGhlIEVudiBWYXJpYWJsZSBVTkRJQ0lfTk9fV0FTTV9TSU1EIGFsbG93cyBleHBsaWNpdGx5IG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgaWYgKHByb2Nlc3MuZW52LlVORElDSV9OT19XQVNNX1NJTUQgPT09ICcxJykge1xuICAgIHVzZVdhc21TSU1EID0gdHJ1ZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlVORElDSV9OT19XQVNNX1NJTUQgPT09ICcwJykge1xuICAgIHVzZVdhc21TSU1EID0gZmFsc2VcbiAgfVxuXG4gIGlmICh1c2VXYXNtU0lNRCkge1xuICAgIHRyeSB7XG4gICAgICBtb2QgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHJlcXVpcmUoJy4uL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzJykpXG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtb2QpIHtcbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykpXG4gIH1cblxuICByZXR1cm4gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZCwge1xuICAgIGVudjoge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGF0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB3YXNtX29uX3VybDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uU3RhdHVzKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSlcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB3YXNtX29uX21lc3NhZ2VfYmVnaW46IChwKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQmVnaW4oKVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2FzbV9vbl9oZWFkZXJfZmllbGQ6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJGaWVsZChuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGF0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB3YXNtX29uX2hlYWRlcl92YWx1ZTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlclZhbHVlKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSlcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICAgICAgICogQHBhcmFtIHswfDF9IHVwZ3JhZGVcbiAgICAgICAqIEBwYXJhbSB7MHwxfSBzaG91bGRLZWVwQWxpdmVcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25faGVhZGVyc19jb21wbGV0ZTogKHAsIHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyc0NvbXBsZXRlKHN0YXR1c0NvZGUsIHVwZ3JhZGUgPT09IDEsIHNob3VsZEtlZXBBbGl2ZSA9PT0gMSlcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25fYm9keTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkJvZHkobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZTogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICB9XG5cbiAgICB9XG4gIH0pXG59XG5cbmxldCBsbGh0dHBJbnN0YW5jZSA9IG51bGxcblxuLyoqXG4gKiBAdHlwZSB7UGFyc2VyfG51bGx9XG4gKi9cbmxldCBjdXJyZW50UGFyc2VyID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBjdXJyZW50QnVmZmVyU2l6ZSA9IDBcbmxldCBjdXJyZW50QnVmZmVyUHRyID0gbnVsbFxuXG5jb25zdCBVU0VfTkFUSVZFX1RJTUVSID0gMFxuY29uc3QgVVNFX0ZBU1RfVElNRVIgPSAxXG5cbi8vIFVzZSBmYXN0IHRpbWVycyBmb3IgaGVhZGVycyBhbmQgYm9keSB0byB0YWtlIGV2ZW50dWFsIGV2ZW50IGxvb3Bcbi8vIGxhdGVuY3kgaW50byBhY2NvdW50LlxuY29uc3QgVElNRU9VVF9IRUFERVJTID0gMiB8IFVTRV9GQVNUX1RJTUVSXG5jb25zdCBUSU1FT1VUX0JPRFkgPSA0IHwgVVNFX0ZBU1RfVElNRVJcblxuLy8gVXNlIG5hdGl2ZSB0aW1lcnMgdG8gaWdub3JlIGV2ZW50IGxvb3AgbGF0ZW5jeSBmb3Iga2VlcC1hbGl2ZVxuLy8gaGFuZGxpbmcuXG5jb25zdCBUSU1FT1VUX0tFRVBfQUxJVkUgPSA4IHwgVVNFX05BVElWRV9USU1FUlxuXG5jbGFzcyBQYXJzZXIge1xuICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jbGllbnQuanMnKX0gY2xpZW50XG4gICAgICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldH0gc29ja2V0XG4gICAgICogQHBhcmFtIHsqfSBsbGh0dHBcbiAgICAgKi9cbiAgY29uc3RydWN0b3IgKGNsaWVudCwgc29ja2V0LCB7IGV4cG9ydHMgfSkge1xuICAgIHRoaXMubGxodHRwID0gZXhwb3J0c1xuICAgIHRoaXMucHRyID0gdGhpcy5sbGh0dHAubGxodHRwX2FsbG9jKGNvbnN0YW50cy5UWVBFLlJFU1BPTlNFKVxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnbmV0JykuU29ja2V0fVxuICAgICAqL1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbFxuICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnXG4gICAgdGhpcy51cGdyYWRlID0gZmFsc2VcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG4gICAgdGhpcy5oZWFkZXJzTWF4U2l6ZSA9IGNsaWVudFtrTWF4SGVhZGVyc1NpemVdXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLnJlc3VtZSA9IHRoaXMucmVzdW1lLmJpbmQodGhpcylcblxuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5jb25uZWN0aW9uID0gJydcbiAgICB0aGlzLm1heFJlc3BvbnNlU2l6ZSA9IGNsaWVudFtrTWF4UmVzcG9uc2VTaXplXVxuICB9XG5cbiAgc2V0VGltZW91dCAoZGVsYXksIHR5cGUpIHtcbiAgICAvLyBJZiB0aGUgZXhpc3RpbmcgdGltZXIgYW5kIHRoZSBuZXcgdGltZXIgYXJlIG9mIGRpZmZlcmVudCB0aW1lciB0eXBlXG4gICAgLy8gKGZhc3Qgb3IgbmF0aXZlKSBvciBoYXZlIGRpZmZlcmVudCBkZWxheSwgd2UgbmVlZCB0byBjbGVhciB0aGUgZXhpc3RpbmdcbiAgICAvLyB0aW1lciBhbmQgc2V0IGEgbmV3IG9uZS5cbiAgICBpZiAoXG4gICAgICBkZWxheSAhPT0gdGhpcy50aW1lb3V0VmFsdWUgfHxcbiAgICAgICh0eXBlICYgVVNFX0ZBU1RfVElNRVIpIF4gKHRoaXMudGltZW91dFR5cGUgJiBVU0VfRkFTVF9USU1FUilcbiAgICApIHtcbiAgICAgIC8vIElmIGEgdGltZW91dCBpcyBhbHJlYWR5IHNldCwgY2xlYXIgaXQgd2l0aCBjbGVhclRpbWVvdXQgb2YgdGhlIGZhc3RcbiAgICAgIC8vIHRpbWVyIGltcGxlbWVudGF0aW9uLCBhcyBpdCBjYW4gY2xlYXIgZmFzdCBhbmQgbmF0aXZlIHRpbWVycy5cbiAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIGlmICh0eXBlICYgVVNFX0ZBU1RfVElNRVIpIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lcnMuc2V0RmFzdFRpbWVvdXQob25QYXJzZXJUaW1lb3V0LCBkZWxheSwgbmV3IFdlYWtSZWYodGhpcykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChvblBhcnNlclRpbWVvdXQsIGRlbGF5LCBuZXcgV2Vha1JlZih0aGlzKSlcbiAgICAgICAgICB0aGlzLnRpbWVvdXQ/LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IGRlbGF5XG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IHR5cGVcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LmRlc3Ryb3llZCB8fCAhdGhpcy5wYXVzZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX3Jlc3VtZSh0aGlzLnB0cilcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5leGVjdXRlKHRoaXMuc29ja2V0LnJlYWQoKSB8fCBFTVBUWV9CVUYpIC8vIEZsdXNoIHBhcnNlci5cbiAgICB0aGlzLnJlYWRNb3JlKClcbiAgfVxuXG4gIHJlYWRNb3JlICgpIHtcbiAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIHRoaXMucHRyKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuc29ja2V0LnJlYWQoKVxuICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGUoY2h1bmspXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKi9cbiAgZXhlY3V0ZSAoY2h1bmspIHtcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PT0gbnVsbClcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuXG4gICAgY29uc3QgeyBzb2NrZXQsIGxsaHR0cCB9ID0gdGhpc1xuXG4gICAgLy8gQWxsb2NhdGUgYSBuZXcgYnVmZmVyIGlmIHRoZSBjdXJyZW50IGJ1ZmZlciBpcyB0b28gc21hbGwuXG4gICAgaWYgKGNodW5rLmxlbmd0aCA+IGN1cnJlbnRCdWZmZXJTaXplKSB7XG4gICAgICBpZiAoY3VycmVudEJ1ZmZlclB0cikge1xuICAgICAgICBsbGh0dHAuZnJlZShjdXJyZW50QnVmZmVyUHRyKVxuICAgICAgfVxuICAgICAgLy8gQWxsb2NhdGUgYSBidWZmZXIgdGhhdCBpcyBhIG11bHRpcGxlIG9mIDQwOTYgYnl0ZXMuXG4gICAgICBjdXJyZW50QnVmZmVyU2l6ZSA9IE1hdGguY2VpbChjaHVuay5sZW5ndGggLyA0MDk2KSAqIDQwOTZcbiAgICAgIGN1cnJlbnRCdWZmZXJQdHIgPSBsbGh0dHAubWFsbG9jKGN1cnJlbnRCdWZmZXJTaXplKVxuICAgIH1cblxuICAgIG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBjdXJyZW50QnVmZmVyUHRyLCBjdXJyZW50QnVmZmVyU2l6ZSkuc2V0KGNodW5rKVxuXG4gICAgLy8gQ2FsbCBgZXhlY3V0ZWAgb24gdGhlIHdhc20gcGFyc2VyLlxuICAgIC8vIFdlIHBhc3MgdGhlIGBsbGh0dHBfcGFyc2VyYCBwb2ludGVyIGFkZHJlc3MsIHRoZSBwb2ludGVyIGFkZHJlc3Mgb2YgYnVmZmVyIHZpZXcgZGF0YSxcbiAgICAvLyBhbmQgZmluYWxseSB0aGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHBhcnNlLlxuICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gZXJyb3IgY29kZSBvciBgY29uc3RhbnRzLkVSUk9SLk9LYC5cbiAgICB0cnkge1xuICAgICAgbGV0IHJldFxuXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gY2h1bmtcbiAgICAgICAgY3VycmVudFBhcnNlciA9IHRoaXNcbiAgICAgICAgcmV0ID0gbGxodHRwLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLCBjdXJyZW50QnVmZmVyUHRyLCBjaHVuay5sZW5ndGgpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbFxuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAocmV0ICE9PSBjb25zdGFudHMuRVJST1IuT0spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNodW5rLnN1YmFycmF5KGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0cikgLSBjdXJyZW50QnVmZmVyUHRyKVxuXG4gICAgICAgIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRURfVVBHUkFERSkge1xuICAgICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgICAgICAgc29ja2V0LnVuc2hpZnQoZGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwdHIgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9yZWFzb24odGhpcy5wdHIpXG4gICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgICAgICAgIGlmIChwdHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIpLmluZGV4T2YoMClcbiAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnUmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggdGhlIEhUVFAvMS4xIHByb3RvY29sICgnICtcbiAgICAgICAgICAgICAgQnVmZmVyLmZyb20obGxodHRwLm1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBIVFRQUGFyc2VyRXJyb3IobWVzc2FnZSwgY29uc3RhbnRzLkVSUk9SW3JldF0sIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PT0gbnVsbClcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9mcmVlKHRoaXMucHRyKVxuICAgIHRoaXMucHRyID0gbnVsbFxuXG4gICAgdGhpcy50aW1lb3V0ICYmIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAgICogQHJldHVybnMgezB9XG4gICAqL1xuICBvblN0YXR1cyAoYnVmKSB7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gYnVmLnRvU3RyaW5nKClcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHswfC0xfVxuICAgKi9cbiAgb25NZXNzYWdlQmVnaW4gKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgb25IZWFkZXJGaWVsZCAoYnVmKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMCkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBvbkhlYWRlclZhbHVlIChidWYpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMSkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgICAgbGVuICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuaGVhZGVyc1tsZW4gLSAyXVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxMCkge1xuICAgICAgY29uc3QgaGVhZGVyTmFtZSA9IHV0aWwuYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShrZXkpXG4gICAgICBpZiAoaGVhZGVyTmFtZSA9PT0gJ2tlZXAtYWxpdmUnKSB7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlICs9IGJ1Zi50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdjb25uZWN0aW9uJykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gKz0gYnVmLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDE0ICYmIHV0aWwuYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShrZXkpID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgICB0aGlzLmNvbnRlbnRMZW5ndGggKz0gYnVmLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHRyYWNrSGVhZGVyIChsZW4pIHtcbiAgICB0aGlzLmhlYWRlcnNTaXplICs9IGxlblxuICAgIGlmICh0aGlzLmhlYWRlcnNTaXplID49IHRoaXMuaGVhZGVyc01heFNpemUpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLnNvY2tldCwgbmV3IEhlYWRlcnNPdmVyZmxvd0Vycm9yKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkXG4gICAqL1xuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcbiAgICBhc3NlcnQoY2xpZW50W2tTb2NrZXRdID09PSBzb2NrZXQpXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydCghdGhpcy5wYXVzZWQpXG4gICAgYXNzZXJ0KChoZWFkZXJzLmxlbmd0aCAmIDEpID09PSAwKVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG4gICAgYXNzZXJ0KHJlcXVlc3QudXBncmFkZSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZVxuXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgc29ja2V0LnVuc2hpZnQoaGVhZClcblxuICAgIHNvY2tldFtrUGFyc2VyXS5kZXN0cm95KClcbiAgICBzb2NrZXRba1BhcnNlcl0gPSBudWxsXG5cbiAgICBzb2NrZXRba0NsaWVudF0gPSBudWxsXG4gICAgc29ja2V0W2tFcnJvcl0gPSBudWxsXG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoc29ja2V0KVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbCAvLyBUT0RPIChmaXgpOiBUaGlzIGlzIGhhY2t5Li4uXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3VwZ3JhZGUnKSlcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0Lm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZ3JhZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRLZWVwQWxpdmVcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIG9uSGVhZGVyc0NvbXBsZXRlIChzdGF0dXNDb2RlLCB1cGdyYWRlLCBzaG91bGRLZWVwQWxpdmUpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNUZXh0IH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGFzc2VydCghdGhpcy51cGdyYWRlKVxuICAgIGFzc2VydCh0aGlzLnN0YXR1c0NvZGUgPCAyMDApXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCByZXNwb25zZScsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIC8qIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNlcnZlciBpcyBtaXNiZWhhdmluZyAqL1xuICAgIGlmICh1cGdyYWRlICYmICFyZXF1ZXN0LnVwZ3JhZGUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gKFxuICAgICAgc2hvdWxkS2VlcEFsaXZlIHx8XG4gICAgICAvLyBPdmVycmlkZSBsbGh0dHAgdmFsdWUgd2hpY2ggZG9lcyBub3QgYWxsb3cga2VlcEFsaXZlIGZvciBIRUFELlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgJiYgIXNvY2tldFtrUmVzZXRdICYmIHRoaXMuY29ubmVjdGlvbi50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuc3RhdHVzQ29kZSA+PSAyMDApIHtcbiAgICAgIGNvbnN0IGJvZHlUaW1lb3V0ID0gcmVxdWVzdC5ib2R5VGltZW91dCAhPSBudWxsXG4gICAgICAgID8gcmVxdWVzdC5ib2R5VGltZW91dFxuICAgICAgICA6IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gICAgICB0aGlzLnNldFRpbWVvdXQoYm9keVRpbWVvdXQsIFRJTUVPVVRfQk9EWSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpXG4gICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlXG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgYXNzZXJ0KCh0aGlzLmhlYWRlcnMubGVuZ3RoICYgMSkgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBwYXVzZSA9IHJlcXVlc3Qub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2VcblxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2UgPyBjb25zdGFudHMuRVJST1IuUEFVU0VEIDogMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIG9uQm9keSAoYnVmKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgbWF4UmVzcG9uc2VTaXplIH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShidWYpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG4gICAgYXNzZXJ0KCh0aGlzLmhlYWRlcnMubGVuZ3RoICYgMSkgPT09IDApXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiBjb250ZW50TGVuZ3RoICYmIGJ5dGVzUmVhZCAhPT0gcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbkNvbXBsZXRlKGhlYWRlcnMpXG5cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgaWYgKHNvY2tldFtrV3JpdGluZ10pIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuICAgICAgLy8gUmVzcG9uc2UgY29tcGxldGVkIGJlZm9yZSByZXF1ZXN0LlxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmICghc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKHNvY2tldFtrUmVzZXRdICYmIGNsaWVudFtrUnVubmluZ10gPT09IDApIHtcbiAgICAgIC8vIERlc3Ryb3kgc29ja2V0IG9uY2UgYWxsIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuICAgICAgLy8gVGhlIHJlcXVlc3QgYXQgdGhlIHRhaWwgb2YgdGhlIHBpcGVsaW5lIGlzIHRoZSBvbmVcbiAgICAgIC8vIHRoYXQgcmVxdWVzdGVkIHJlc2V0IGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZFxuICAgICAgLy8gaGF2ZSBiZWVuIHF1ZXVlZCBzaW5jZSB0aGVuLlxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddID09IG51bGwgfHwgY2xpZW50W2tQaXBlbGluaW5nXSA9PT0gMSkge1xuICAgICAgLy8gV2UgbXVzdCB3YWl0IGEgZnVsbCBldmVudCBsb29wIGN5Y2xlIHRvIHJldXNlIHRoaXMgc29ja2V0IHRvIG1ha2Ugc3VyZVxuICAgICAgLy8gdGhhdCBub24tc3BlYyBjb21wbGlhbnQgc2VydmVycyBhcmUgbm90IGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24gZXZlbiBpZiB0aGV5XG4gICAgICAvLyBzYWlkIHRoZXkgd29uJ3QuXG4gICAgICBzZXRJbW1lZGlhdGUoY2xpZW50W2tSZXN1bWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gb25QYXJzZXJUaW1lb3V0IChwYXJzZXJXZWFrUmVmKSB7XG4gIGNvbnN0IHBhcnNlciA9IHBhcnNlcldlYWtSZWYuZGVyZWYoKVxuICBpZiAoIXBhcnNlcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBzb2NrZXQsIHRpbWVvdXRUeXBlLCBjbGllbnQsIHBhdXNlZCB9ID0gcGFyc2VyXG5cbiAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICBhc3NlcnQoIXBhdXNlZCwgJ2Nhbm5vdCBiZSBwYXVzZWQgd2hpbGUgd2FpdGluZyBmb3IgaGVhZGVycycpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSGVhZGVyc1RpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKSB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBCb2R5VGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0tFRVBfQUxJVkUpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0pXG4gICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc29ja2V0IGlkbGUgdGltZW91dCcpKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCduZXQnKS5Tb2NrZXR9IHNvY2tldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY29ubmVjdEgxIChjbGllbnQsIHNvY2tldCkge1xuICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgbGxodHRwSW5zdGFuY2UgPSBsYXp5bGxodHRwKClcbiAgfVxuXG4gIGlmIChzb2NrZXQuZXJyb3JlZCkge1xuICAgIHRocm93IHNvY2tldC5lcnJvcmVkXG4gIH1cblxuICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignZGVzdHJveWVkJylcbiAgfVxuXG4gIHNvY2tldFtrTm9SZWZdID0gZmFsc2VcbiAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG4gIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICBzb2NrZXRba1BhcnNlcl0gPSBuZXcgUGFyc2VyKGNsaWVudCwgc29ja2V0LCBsbGh0dHBJbnN0YW5jZSlcblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Vycm9yJywgb25IdHRwU29ja2V0RXJyb3IpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAncmVhZGFibGUnLCBvbkh0dHBTb2NrZXRSZWFkYWJsZSlcbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlbmQnLCBvbkh0dHBTb2NrZXRFbmQpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnY2xvc2UnLCBvbkh0dHBTb2NrZXRDbG9zZSlcblxuICBzb2NrZXRba0Nsb3NlZF0gPSBmYWxzZVxuICBzb2NrZXQub24oJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdoMScsXG4gICAgZGVmYXVsdFBpcGVsaW5pbmc6IDEsXG4gICAgd3JpdGUgKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB3cml0ZUgxKGNsaWVudCwgcmVxdWVzdClcbiAgICB9LFxuICAgIHJlc3VtZSAoKSB7XG4gICAgICByZXN1bWVIMShjbGllbnQpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfHVuZGVmaW5lZH0gZXJyXG4gICAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChzb2NrZXRba0Nsb3NlZF0pIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQub24oJ2Nsb3NlJywgY2FsbGJhY2spXG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycilcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQgKCkge1xuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95ZWRcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL3JlcXVlc3QuanMnKX0gcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGJ1c3kgKHJlcXVlc3QpIHtcbiAgICAgIGlmIChzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldFtrUmVzZXRdIHx8IHNvY2tldFtrQmxvY2tpbmddKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAhcmVxdWVzdC5pZGVtcG90ZW50KSB7XG4gICAgICAgICAgLy8gTm9uLWlkZW1wb3RlbnQgcmVxdWVzdCBjYW5ub3QgYmUgcmV0cmllZC5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBubyBvdGhlciByZXF1ZXN0cyBhcmUgaW5mbGlnaHQgYW5kXG4gICAgICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykpIHtcbiAgICAgICAgICAvLyBEb24ndCBkaXNwYXRjaCBhbiB1cGdyYWRlIHVudGlsIGFsbCBwcmVjZWRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAgICAgLy8gQSBtaXNiZWhhdmluZyBzZXJ2ZXIgbWlnaHQgdXBncmFkZSB0aGUgY29ubmVjdGlvbiBiZWZvcmUgYWxsIHBpcGVsaW5lZFxuICAgICAgICAgIC8vIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHV0aWwuYm9keUxlbmd0aChyZXF1ZXN0LmJvZHkpICE9PSAwICYmXG4gICAgICAgICAgKHV0aWwuaXNTdHJlYW0ocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzQXN5bmNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpIHx8IHV0aWwuaXNGb3JtRGF0YUxpa2UocmVxdWVzdC5ib2R5KSkpIHtcbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpdGggc3RyZWFtIG9yIGl0ZXJhdG9yIGJvZHkgY2FuIGVycm9yIHdoaWxlIG90aGVyIHJlcXVlc3RzXG4gICAgICAgICAgLy8gYXJlIGluZmxpZ2h0IGFuZCBpbmRpcmVjdGx5IGVycm9yIHRob3NlIGFzIHdlbGwuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYnkgd2FpdGluZyBmb3IgaW5mbGlnaHRcbiAgICAgICAgICAvLyB0byBjb21wbGV0ZSBiZWZvcmUgZGlzcGF0Y2hpbmcuXG5cbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpdGggc3RyZWFtIG9yIGl0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgICAgIC8vIGNvdWxkIGNhdXNlIGZhaWx1cmUuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwU29ja2V0RXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgLy8gT24gTWFjIE9TLCB3ZSBnZXQgYW4gRUNPTk5SRVNFVCBldmVuIGlmIHRoZXJlIGlzIGEgZnVsbCBib2R5IHRvIGJlIGZvcndhcmRlZFxuICAvLyB0byB0aGUgdXNlci5cbiAgaWYgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcgJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmb3IgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gZXJyXG5cbiAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxufVxuXG5mdW5jdGlvbiBvbkh0dHBTb2NrZXRSZWFkYWJsZSAoKSB7XG4gIHRoaXNba1BhcnNlcl0/LnJlYWRNb3JlKClcbn1cblxuZnVuY3Rpb24gb25IdHRwU29ja2V0RW5kICgpIHtcbiAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gIGlmIChwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cFNvY2tldENsb3NlICgpIHtcbiAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gIGlmIChwYXJzZXIpIHtcbiAgICBpZiAoIXRoaXNba0Vycm9yXSAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZmFyIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgIH1cblxuICAgIHRoaXNba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgdGhpc1trUGFyc2VyXSA9IG51bGxcbiAgfVxuXG4gIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoJ2Nsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSlcblxuICBjb25zdCBjbGllbnQgPSB0aGlzW2tDbGllbnRdXG5cbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGwgLy8gVE9ETyAoZml4KTogVGhpcyBpcyBoYWNreS4uLlxuXG4gIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJykge1xuICAgIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XVxuXG4gIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuXG4gIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gIGNsaWVudFtrUmVzdW1lXSgpXG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqL1xuZnVuY3Rpb24gcmVzdW1lSDEgKGNsaWVudCkge1xuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICBpZiAoc29ja2V0ICYmICFzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgIGlmICghc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnVucmVmKSB7XG4gICAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICAgIHNvY2tldFtrTm9SZWZdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgc29ja2V0LnJlZigpXG4gICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfS0VFUF9BTElWRSkge1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfS0VFUF9BTElWRSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHNvY2tldFtrUGFyc2VyXS5zdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgICAgIGNvbnN0IGhlYWRlcnNUaW1lb3V0ID0gcmVxdWVzdC5oZWFkZXJzVGltZW91dCAhPSBudWxsXG4gICAgICAgICAgPyByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0XG4gICAgICAgICAgOiBjbGllbnRba0hlYWRlcnNUaW1lb3V0XVxuICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChoZWFkZXJzVGltZW91dCwgVElNRU9VVF9IRUFERVJTKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG5mdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgIT09ICdHRVQnICYmIG1ldGhvZCAhPT0gJ0hFQUQnICYmIG1ldGhvZCAhPT0gJ09QVElPTlMnICYmIG1ldGhvZCAhPT0gJ1RSQUNFJyAmJiBtZXRob2QgIT09ICdDT05ORUNUJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL3JlcXVlc3QuanMnKX0gcmVxdWVzdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gd3JpdGVIMSAoY2xpZW50LCByZXF1ZXN0KSB7XG4gIGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICBsZXQgeyBib2R5LCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoIH0gPSByZXF1ZXN0XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1FVRVJZJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BST1BGSU5EJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BST1BQQVRDSCdcbiAgKVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpKSB7XG4gICAgaWYgKCFleHRyYWN0Qm9keSkge1xuICAgICAgZXh0cmFjdEJvZHkgPSByZXF1aXJlKCcuLi93ZWIvZmV0Y2gvYm9keS5qcycpLmV4dHJhY3RCb2R5XG4gICAgfVxuXG4gICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgPT0gbnVsbCkge1xuICAgICAgaGVhZGVycy5wdXNoKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSlcbiAgICB9XG4gICAgYm9keSA9IGJvZHlTdHJlYW0uc3RyZWFtXG4gICAgY29udGVudExlbmd0aCA9IGJvZHlTdHJlYW0ubGVuZ3RoXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpICYmIHJlcXVlc3QuY29udGVudFR5cGUgPT0gbnVsbCAmJiBib2R5LnR5cGUpIHtcbiAgICBoZWFkZXJzLnB1c2goJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSlcbiAgfVxuXG4gIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUcnkgdG8gcmVhZCBFT0YgaW4gb3JkZXIgdG8gZ2V0IGxlbmd0aC5cbiAgICBib2R5LnJlYWQoMClcbiAgfVxuXG4gIGNvbnN0IGJvZHlMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBjb250ZW50TGVuZ3RoID0gYm9keUxlbmd0aCA/PyBjb250ZW50TGVuZ3RoXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgfVxuXG4gIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG5cbiAgICB1dGlsLmRlc3Ryb3koYm9keSlcbiAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdhYm9ydGVkJykpXG4gIH1cblxuICB0cnkge1xuICAgIHJlcXVlc3Qub25Db25uZWN0KGFib3J0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChtZXRob2QgPT09ICdIRUFEJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvaXNzdWVzLzI1OFxuICAgIC8vIENsb3NlIGFmdGVyIGEgSEVBRCByZXF1ZXN0IHRvIGludGVyb3Agd2l0aCBtaXNiZWhhdmluZyBzZXJ2ZXJzXG4gICAgLy8gdGhhdCBtYXkgc2VuZCBhIGJvZHkgaW4gdGhlIHJlc3BvbnNlLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIC8vIE9uIENPTk5FQ1Qgb3IgdXBncmFkZSwgYmxvY2sgcGlwZWxpbmUgZnJvbSBkaXNwYXRjaGluZyBmdXJ0aGVyXG4gICAgLy8gcmVxdWVzdHMgb24gdGhpcyBjb25uZWN0aW9uLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAocmVzZXQgIT0gbnVsbCkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gcmVzZXRcbiAgfVxuXG4gIGlmIChjbGllbnRba01heFJlcXVlc3RzXSAmJiBzb2NrZXRba0NvdW50ZXJdKysgPj0gY2xpZW50W2tNYXhSZXF1ZXN0c10pIHtcbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChibG9ja2luZykge1xuICAgIHNvY2tldFtrQmxvY2tpbmddID0gdHJ1ZVxuICB9XG5cbiAgbGV0IGhlYWRlciA9IGAke21ldGhvZH0gJHtwYXRofSBIVFRQLzEuMVxcclxcbmBcblxuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgaGVhZGVyICs9IGBob3N0OiAke2hvc3R9XFxyXFxuYFxuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSBjbGllbnRba0hvc3RIZWFkZXJdXG4gIH1cblxuICBpZiAodXBncmFkZSkge1xuICAgIGhlYWRlciArPSBgY29ubmVjdGlvbjogdXBncmFkZVxcclxcbnVwZ3JhZGU6ICR7dXBncmFkZX1cXHJcXG5gXG4gIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSAmJiAhc29ja2V0W2tSZXNldF0pIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGtlZXAtYWxpdmVcXHJcXG4nXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9ICdjb25uZWN0aW9uOiBjbG9zZVxcclxcbidcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBoZWFkZXJzW24gKyAwXVxuICAgICAgY29uc3QgdmFsID0gaGVhZGVyc1tuICsgMV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhlYWRlciArPSBgJHtrZXl9OiAke3ZhbFtpXX1cXHJcXG5gXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciArPSBgJHtrZXl9OiAke3ZhbH1cXHJcXG5gXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3QsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0IH0pXG4gIH1cblxuICBpZiAoIWJvZHkgfHwgYm9keUxlbmd0aCA9PT0gMCkge1xuICAgIHdyaXRlQnVmZmVyKGFib3J0LCBudWxsLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgd3JpdGVCdWZmZXIoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoYWJvcnQsIGJvZHkuc3RyZWFtKCksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUJsb2IoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgd3JpdGVTdHJlYW0oYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHdyaXRlSXRlcmFibGUoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYm9ydENhbGxiYWNrfSBhYm9ydFxuICogQHBhcmFtIHtpbXBvcnQoJ3N0cmVhbScpLlN0cmVhbX0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ3N0cmVhbSBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjb25zdCBvbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgICBib2R5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY29uc3Qgb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAnY2xvc2UnIG1pZ2h0IGJlIGVtaXR0ZWQgKmJlZm9yZSogJ2Vycm9yJyBmb3JcbiAgICAvLyBicm9rZW4gc3RyZWFtcy4gV2FpdCBhIHRpY2sgdG8gYXZvaWQgdGhpcyBjYXNlLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIEl0J3Mgb25seSBzYWZlIHRvIHJlbW92ZSAnZXJyb3InIGxpc3RlbmVyIGFmdGVyXG4gICAgICAvLyAnY2xvc2UnLlxuICAgICAgYm9keS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIH0pXG5cbiAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvbkZpbmlzaGVkKGVycikpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb25zdCBvbkZpbmlzaGVkID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZmluaXNoZWQgPSB0cnVlXG5cbiAgICBhc3NlcnQoc29ja2V0LmRlc3Ryb3llZCB8fCAoc29ja2V0W2tXcml0aW5nXSAmJiBjbGllbnRba1J1bm5pbmddIDw9IDEpKVxuXG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdlcnJvcicsIG9uRmluaXNoZWQpXG5cbiAgICBib2R5XG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSlcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cml0ZXIuZW5kKClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGVyciA9IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuXG4gICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nIHx8IGVyci5tZXNzYWdlICE9PSAncmVzZXQnKSkge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgfVxuICB9XG5cbiAgYm9keVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgYm9keS5yZXN1bWUoKVxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG5cbiAgaWYgKGJvZHkuZXJyb3JFbWl0dGVkID8/IGJvZHkuZXJyb3JlZCkge1xuICAgIHNldEltbWVkaWF0ZShvbkZpbmlzaGVkLCBib2R5LmVycm9yZWQpXG4gIH0gZWxzZSBpZiAoYm9keS5lbmRFbWl0dGVkID8/IGJvZHkucmVhZGFibGVFbmRlZCkge1xuICAgIHNldEltbWVkaWF0ZShvbkZpbmlzaGVkLCBudWxsKVxuICB9XG5cbiAgaWYgKGJvZHkuY2xvc2VFbWl0dGVkID8/IGJvZHkuY2xvc2VkKSB7XG4gICAgc2V0SW1tZWRpYXRlKG9uQ2xvc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBBYm9ydENhbGxiYWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0Fib3J0Q2FsbGJhY2t9IGFib3J0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd3JpdGVCdWZmZXIgKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCkge1xuICB0cnkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IG51bGwsICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgICAgIHNvY2tldC5jb3JrKClcbiAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIHNvY2tldC53cml0ZShib2R5KVxuICAgICAgc29ja2V0LnVuY29yaygpXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcblxuICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCAmJiByZXF1ZXN0LnJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJvcnRDYWxsYmFja30gYWJvcnRcbiAqIEBwYXJhbSB7QmxvYn0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJvcnRDYWxsYmFja30gYWJvcnRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGJvZHlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL3JlcXVlc3QuanMnKX0gcmVxdWVzdFxuICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldH0gc29ja2V0XG4gKiBAcGFyYW0ge251bWJlcn0gY29udGVudExlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHBhcmFtIHtib29sZWFufSBleHBlY3RzUGF5bG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnaXRlcmF0b3IgYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgY2FsbGJhY2sgPSBudWxsXG4gIGZ1bmN0aW9uIG9uRHJhaW4gKCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgd2FpdEZvckRyYWluID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFzc2VydChjYWxsYmFjayA9PT0gbnVsbClcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgcmVqZWN0KHNvY2tldFtrRXJyb3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IHJlc29sdmVcbiAgICB9XG4gIH0pXG5cbiAgc29ja2V0XG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG4gIHRyeSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgfVxuXG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZXIuZW5kKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuICB9IGZpbmFsbHkge1xuICAgIHNvY2tldFxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbmNsYXNzIEFzeW5jV3JpdGVyIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdcbiAgICogQHBhcmFtIHtBYm9ydENhbGxiYWNrfSBhcmcuYWJvcnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldH0gYXJnLnNvY2tldFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9yZXF1ZXN0LmpzJyl9IGFyZy5yZXF1ZXN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcuY29udGVudExlbmd0aFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jbGllbnQuanMnKX0gYXJnLmNsaWVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZy5leHBlY3RzUGF5bG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnLmhlYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pIHtcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBjb250ZW50TGVuZ3RoXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDBcbiAgICB0aGlzLmV4cGVjdHNQYXlsb2FkID0gZXhwZWN0c1BheWxvYWRcbiAgICB0aGlzLmhlYWRlciA9IGhlYWRlclxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHJldHVybnNcbiAgICovXG4gIHdyaXRlIChjaHVuaykge1xuICAgIGNvbnN0IHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuaylcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBXZSBzaG91bGQgZGVmZXIgd3JpdGluZyBjaHVua3MuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICsgbGVuID4gY29udGVudExlbmd0aCkge1xuICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgIH1cblxuICAgIHNvY2tldC5jb3JrKClcblxuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9dHJhbnNmZXItZW5jb2Rpbmc6IGNodW5rZWRcXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKGBcXHJcXG4ke2xlbi50b1N0cmluZygxNil9XFxyXFxuYCwgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gbGVuXG5cbiAgICBjb25zdCByZXQgPSBzb2NrZXQud3JpdGUoY2h1bmspXG5cbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVuZCAoKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgYnl0ZXNXcml0dGVuLCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyLCByZXF1ZXN0IH0gPSB0aGlzXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgICAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIHNlbmQgYSBDb250ZW50LUxlbmd0aCBpbiBhIHJlcXVlc3QgbWVzc2FnZSB3aGVuXG4gICAgICAgIC8vIG5vIFRyYW5zZmVyLUVuY29kaW5nIGlzIHNlbnQgYW5kIHRoZSByZXF1ZXN0IG1ldGhvZCBkZWZpbmVzIGEgbWVhbmluZ1xuICAgICAgICAvLyBmb3IgYW4gZW5jbG9zZWQgcGF5bG9hZCBib2R5LlxuXG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9XFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICBzb2NrZXQud3JpdGUoJ1xcclxcbjBcXHJcXG5cXHJcXG4nLCAnbGF0aW4xJylcbiAgICB9XG5cbiAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCwgYWJvcnQgfSA9IHRoaXNcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKGVycikge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPD0gMSwgJ3BpcGVsaW5lIHNob3VsZCBvbmx5IGNvbnRhaW4gdGhpcyByZXF1ZXN0JylcbiAgICAgIGFib3J0KGVycilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0SDFcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kHTTP2InitialWindowSize,\n  kHTTP2ConnectionWindowSize,\n  kResume,\n  kSize,\n  kHTTPContext,\n  kClosed,\n  kBodyTimeout,\n  kEnableConnectProtocol,\n  kRemoteSettings,\n  kHTTP2Stream\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\n\nconst kOpenStreams = Symbol('open streams')\n\nlet extractBody\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = __webpack_require__(/*! node:http2 */ \"node:http2\")\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS,\n    HTTP2_HEADER_PROTOCOL,\n    NGHTTP2_REFUSED_STREAM,\n    NGHTTP2_CANCEL\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nfunction connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  const http2InitialWindowSize = client[kHTTP2InitialWindowSize]\n  const http2ConnectionWindowSize = client[kHTTP2ConnectionWindowSize]\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams],\n    settings: {\n      // TODO(metcoder95): add support for PUSH\n      enablePush: false,\n      ...(http2InitialWindowSize != null ? { initialWindowSize: http2InitialWindowSize } : null)\n    }\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n  session[kHTTP2Session] = null\n  // We set it to true by default in a best-effort; however once connected to an H2 server\n  // we will check if extended CONNECT protocol is supported or not\n  // and set this value accordingly.\n  session[kEnableConnectProtocol] = false\n  // States whether or not we have received the remote settings from the server\n  session[kRemoteSettings] = false\n\n  // Apply connection-level flow control once connected (if supported).\n  if (http2ConnectionWindowSize) {\n    util.addListener(session, 'connect', applyConnectionWindowSize.bind(session, http2ConnectionWindowSize))\n  }\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHttp2SessionGoAway)\n  util.addListener(session, 'close', onHttp2SessionClose)\n  util.addListener(session, 'remoteSettings', onHttp2RemoteSettings)\n  // TODO (@metcoder95): implement SETTINGS support\n  // util.addListener(session, 'localSettings', onHttp2RemoteSettings)\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', onHttp2SocketError)\n  util.addListener(socket, 'end', onHttp2SocketEnd)\n  util.addListener(socket, 'close', onHttp2SocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    /**\n     * @param {import('../core/request.js')} request\n     * @returns {boolean}\n    */\n    write (request) {\n      return writeH2(client, request)\n    },\n    /**\n     * @returns {void}\n     */\n    resume () {\n      resumeH2(client)\n    },\n    /**\n     * @param {Error | null} err\n     * @param {() => void} callback\n     */\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    /**\n     * @type {boolean}\n     */\n    get destroyed () {\n      return socket.destroyed\n    },\n    /**\n     * @param {import('../core/request.js')} request\n     * @returns {boolean}\n    */\n    busy (request) {\n      if (request != null) {\n        if (client[kRunning] > 0) {\n          // We are already processing requests\n\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          if (request.idempotent === false) return true\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // Possibly, we do not have remote settings confirmed yet.\n          if ((request.upgrade === 'websocket' || request.method === 'CONNECT') && session[kRemoteSettings] === false) return true\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          if (util.bodyLength(request.body) !== 0 &&\n            (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) return true\n        } else {\n          return (request.upgrade === 'websocket' || request.method === 'CONNECT') && session[kRemoteSettings] === false\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction resumeH2 (client) {\n  const socket = client[kSocket]\n\n  if (socket?.destroyed === false) {\n    if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {\n      socket.unref()\n      client[kHTTP2Session].unref()\n    } else {\n      socket.ref()\n      client[kHTTP2Session].ref()\n    }\n  }\n}\n\nfunction applyConnectionWindowSize (connectionWindowSize) {\n  try {\n    if (typeof this.setLocalWindowSize === 'function') {\n      this.setLocalWindowSize(connectionWindowSize)\n    }\n  } catch {\n    // Best-effort only.\n  }\n}\n\nfunction onHttp2RemoteSettings (settings) {\n  // Fallbacks are a safe bet, remote setting will always override\n  this[kClient][kMaxConcurrentStreams] = settings.maxConcurrentStreams ?? this[kClient][kMaxConcurrentStreams]\n  /**\n   * From RFC-8441\n   * A sender MUST NOT send a SETTINGS_ENABLE_CONNECT_PROTOCOL parameter\n   * with the value of 0 after previously sending a value of 1.\n   */\n  // Note: Cannot be tested in Node, it does not supports disabling the extended CONNECT protocol once enabled\n  if (this[kRemoteSettings] === true && this[kEnableConnectProtocol] === true && settings.enableConnectProtocol === false) {\n    const err = new InformationalError('HTTP/2: Server disabled extended CONNECT protocol against RFC-8441')\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n    return\n  }\n\n  this[kEnableConnectProtocol] = settings.enableConnectProtocol ?? this[kEnableConnectProtocol]\n  this[kRemoteSettings] = true\n  this[kClient][kResume]()\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n *\n * @this {import('http2').ClientHttp2Session}\n * @param {number} errorCode\n */\nfunction onHttp2SessionGoAway (errorCode) {\n  // TODO(mcollina): Verify if GOAWAY implements the spec correctly:\n  // https://datatracker.ietf.org/doc/html/rfc7540#section-6.8\n  // Specifically, we do not verify the \"valid\" stream id.\n\n  const err = this[kError] || new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]))\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  // this is an HTTP2 session\n  this.close()\n  this[kHTTP2Session] = null\n\n  util.destroy(this[kSocket], err)\n\n  // Fail head of pipeline.\n  if (client[kRunningIdx] < client[kQueue].length) {\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n    util.errorRequest(client, request, err)\n    client[kPendingIdx] = client[kRunningIdx]\n  }\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n  client.emit('connectionError', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SessionClose () {\n  const { [kClient]: client } = this\n  const { [kSocket]: socket } = client\n\n  const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  }\n}\n\nfunction onHttp2SocketClose () {\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kHTTP2Session][kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (this[kHTTP2Session] !== null) {\n    this[kHTTP2Session].destroy(err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2SocketEnd () {\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout]\n  const session = client[kHTTP2Session]\n  const { method, path, host, upgrade, expectContinue, signal, protocol, headers: reqHeaders } = request\n  let { body } = request\n\n  if (upgrade != null && upgrade !== 'websocket') {\n    util.errorRequest(client, request, new InvalidArgumentError(`Custom upgrade \"${upgrade}\" not supported over HTTP/2`))\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (key === 'cookie') {\n      if (headers[key] != null) {\n        headers[key] = Array.isArray(headers[key]) ? (headers[key].push(val), headers[key]) : [headers[key], val]\n      } else {\n        headers[key] = val\n      }\n\n      continue\n    }\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `, ${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else if (headers[key]) {\n      headers[key] += `, ${val}`\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream = null\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      // Some chunks might still come after abort,\n      // let's ignore them\n      stream.removeAllListeners('data')\n\n      // On Abort, we close the stream to send RST_STREAM frame\n      stream.close()\n\n      // We move the running index to the next request\n      client[kOnError](err)\n      client[kResume]()\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream gets destroyed and the session remains to create new streams\n    util.destroy(body, err)\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    session.ref()\n\n    if (upgrade === 'websocket') {\n      // We cannot upgrade to websocket if extended CONNECT protocol is not supported\n      if (session[kEnableConnectProtocol] === false) {\n        util.errorRequest(client, request, new InformationalError('HTTP/2: Extended CONNECT protocol not supported by server'))\n        session.unref()\n        return false\n      }\n\n      // We force the method to CONNECT\n      // as per RFC-8441\n      // https://datatracker.ietf.org/doc/html/rfc8441#section-4\n      headers[HTTP2_HEADER_METHOD] = 'CONNECT'\n      headers[HTTP2_HEADER_PROTOCOL] = 'websocket'\n      // :path and :scheme headers must be omitted when sending CONNECT but set if extended-CONNECT\n      headers[HTTP2_HEADER_PATH] = path\n\n      if (protocol === 'ws:' || protocol === 'wss:') {\n        headers[HTTP2_HEADER_SCHEME] = protocol === 'ws:' ? 'http' : 'https'\n      } else {\n        headers[HTTP2_HEADER_SCHEME] = protocol === 'http:' ? 'http' : 'https'\n      }\n\n      stream = session.request(headers, { endStream: false, signal })\n      stream[kHTTP2Stream] = true\n\n      stream.once('response', (headers, _flags) => {\n        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n\n        request.onUpgrade(statusCode, parseH2Headers(realHeaders), stream)\n\n        ++session[kOpenStreams]\n        client[kQueue][client[kRunningIdx]++] = null\n      })\n\n      stream.on('error', () => {\n        if (stream.rstCode === NGHTTP2_REFUSED_STREAM || stream.rstCode === NGHTTP2_CANCEL) {\n          // NGHTTP2_REFUSED_STREAM (7) or NGHTTP2_CANCEL (8)\n          // We do not treat those as errors as the server might\n          // not support websockets and refuse the stream\n          abort(new InformationalError(`HTTP/2: \"stream error\" received - code ${stream.rstCode}`))\n        }\n      })\n\n      stream.once('close', () => {\n        session[kOpenStreams] -= 1\n        if (session[kOpenStreams] === 0) session.unref()\n      })\n\n      stream.setTimeout(requestTimeout)\n      return true\n    }\n\n    // TODO: consolidate once we support CONNECT properly\n    // NOTE: We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n    stream[kHTTP2Stream] = true\n    stream.on('response', headers => {\n      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n\n      request.onUpgrade(statusCode, parseH2Headers(realHeaders), stream)\n      ++session[kOpenStreams]\n      client[kQueue][client[kRunningIdx]++] = null\n    })\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n    stream.setTimeout(requestTimeout)\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = protocol === 'http:' ? 'http' : 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (util.isFormDataLike(body)) {\n    extractBody ??= (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n\n    const [bodyStream, contentType] = extractBody(body)\n    headers['content-type'] = contentType\n\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  }\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (!expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n    // And for methods that don't expect a payload, omit Content-Length.\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body || contentLength === 0, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  if (channels.sendHeaders.hasSubscribers) {\n    let header = ''\n    for (const key in headers) {\n      header += `${key}: ${headers[key]}\\r\\n`\n    }\n    channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] })\n  }\n\n  // TODO(metcoder95): add support for sending trailers\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n    stream[kHTTP2Stream] = true\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    stream[kHTTP2Stream] = true\n\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n  stream.setTimeout(requestTimeout)\n\n  // Track whether we received a response (headers)\n  let responseReceived = false\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n    responseReceived = true\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      stream.removeAllListeners('data')\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', () => {\n    stream.removeAllListeners('data')\n    // If we received a response, this is a normal completion\n    if (responseReceived) {\n      if (!request.aborted && !request.completed) {\n        request.onComplete({})\n      }\n\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kResume]()\n    } else {\n      // Stream ended without receiving a response - this is an error\n      // (e.g., server destroyed the stream before sending headers)\n      abort(new InformationalError('HTTP/2: stream half-closed (remote)'))\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kPendingIdx] = client[kRunningIdx]\n      client[kResume]()\n    }\n  })\n\n  stream.once('close', () => {\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    stream.removeAllListeners('data')\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    stream.removeAllListeners('data')\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  stream.on('aborted', () => {\n    stream.removeAllListeners('data')\n  })\n\n  stream.on('timeout', () => {\n    const err = new InformationalError(`HTTP/2: \"stream timeout after ${requestTimeout}\"`)\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n\n    abort(err)\n  })\n\n  stream.once('trailers', trailers => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    request.onComplete(trailers)\n  })\n\n  return true\n\n  function writeBodyH2 () {\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlFQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNoQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3Qjs7QUFFckQ7O0FBRUE7O0FBRUEsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM5QixFQUFFO0FBQ0Y7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxjbGllbnQtaDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3Qge1xuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1F1ZXVlLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1NvY2tldCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtPbkVycm9yLFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtIVFRQMlNlc3Npb24sXG4gIGtIVFRQMkluaXRpYWxXaW5kb3dTaXplLFxuICBrSFRUUDJDb25uZWN0aW9uV2luZG93U2l6ZSxcbiAga1Jlc3VtZSxcbiAga1NpemUsXG4gIGtIVFRQQ29udGV4dCxcbiAga0Nsb3NlZCxcbiAga0JvZHlUaW1lb3V0LFxuICBrRW5hYmxlQ29ubmVjdFByb3RvY29sLFxuICBrUmVtb3RlU2V0dGluZ3MsXG4gIGtIVFRQMlN0cmVhbVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcblxuY29uc3Qga09wZW5TdHJlYW1zID0gU3ltYm9sKCdvcGVuIHN0cmVhbXMnKVxuXG5sZXQgZXh0cmFjdEJvZHlcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnbm9kZTpodHRwMicpXG59IGNhdGNoIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBodHRwMiA9IHsgY29uc3RhbnRzOiB7fSB9XG59XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICAgIEhUVFAyX0hFQURFUl9QQVRILFxuICAgIEhUVFAyX0hFQURFUl9TQ0hFTUUsXG4gICAgSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RILFxuICAgIEhUVFAyX0hFQURFUl9FWFBFQ1QsXG4gICAgSFRUUDJfSEVBREVSX1NUQVRVUyxcbiAgICBIVFRQMl9IRUFERVJfUFJPVE9DT0wsXG4gICAgTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSxcbiAgICBOR0hUVFAyX0NBTkNFTFxuICB9XG59ID0gaHR0cDJcblxuZnVuY3Rpb24gcGFyc2VIMkhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAvLyBoMiBtYXkgY29uY2F0IHRoZSBoZWFkZXIgdmFsdWUgYnkgYXJyYXlcbiAgICAvLyBlLmcuIFNldC1Db29raWVcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3VidmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGVhY2ggaGVhZGVyIHZhbHVlIG9mIGhlYWRlciBuYW1lXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGhlYWRlcnMgaGFuZGxlciBleHBlY3QgbmFtZS12YWx1ZSBwYWlyXG4gICAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbShzdWJ2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbSh2YWx1ZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb25uZWN0SDIgKGNsaWVudCwgc29ja2V0KSB7XG4gIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldFxuXG4gIGNvbnN0IGh0dHAySW5pdGlhbFdpbmRvd1NpemUgPSBjbGllbnRba0hUVFAySW5pdGlhbFdpbmRvd1NpemVdXG4gIGNvbnN0IGh0dHAyQ29ubmVjdGlvbldpbmRvd1NpemUgPSBjbGllbnRba0hUVFAyQ29ubmVjdGlvbldpbmRvd1NpemVdXG5cbiAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyLmNvbm5lY3QoY2xpZW50W2tVcmxdLCB7XG4gICAgY3JlYXRlQ29ubmVjdGlvbjogKCkgPT4gc29ja2V0LFxuICAgIHBlZXJNYXhDb25jdXJyZW50U3RyZWFtczogY2xpZW50W2tNYXhDb25jdXJyZW50U3RyZWFtc10sXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIC8vIFRPRE8obWV0Y29kZXI5NSk6IGFkZCBzdXBwb3J0IGZvciBQVVNIXG4gICAgICBlbmFibGVQdXNoOiBmYWxzZSxcbiAgICAgIC4uLihodHRwMkluaXRpYWxXaW5kb3dTaXplICE9IG51bGwgPyB7IGluaXRpYWxXaW5kb3dTaXplOiBodHRwMkluaXRpYWxXaW5kb3dTaXplIH0gOiBudWxsKVxuICAgIH1cbiAgfSlcblxuICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gPSAwXG4gIHNlc3Npb25ba0NsaWVudF0gPSBjbGllbnRcbiAgc2Vzc2lvbltrU29ja2V0XSA9IHNvY2tldFxuICBzZXNzaW9uW2tIVFRQMlNlc3Npb25dID0gbnVsbFxuICAvLyBXZSBzZXQgaXQgdG8gdHJ1ZSBieSBkZWZhdWx0IGluIGEgYmVzdC1lZmZvcnQ7IGhvd2V2ZXIgb25jZSBjb25uZWN0ZWQgdG8gYW4gSDIgc2VydmVyXG4gIC8vIHdlIHdpbGwgY2hlY2sgaWYgZXh0ZW5kZWQgQ09OTkVDVCBwcm90b2NvbCBpcyBzdXBwb3J0ZWQgb3Igbm90XG4gIC8vIGFuZCBzZXQgdGhpcyB2YWx1ZSBhY2NvcmRpbmdseS5cbiAgc2Vzc2lvbltrRW5hYmxlQ29ubmVjdFByb3RvY29sXSA9IGZhbHNlXG4gIC8vIFN0YXRlcyB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIHJlY2VpdmVkIHRoZSByZW1vdGUgc2V0dGluZ3MgZnJvbSB0aGUgc2VydmVyXG4gIHNlc3Npb25ba1JlbW90ZVNldHRpbmdzXSA9IGZhbHNlXG5cbiAgLy8gQXBwbHkgY29ubmVjdGlvbi1sZXZlbCBmbG93IGNvbnRyb2wgb25jZSBjb25uZWN0ZWQgKGlmIHN1cHBvcnRlZCkuXG4gIGlmIChodHRwMkNvbm5lY3Rpb25XaW5kb3dTaXplKSB7XG4gICAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnY29ubmVjdCcsIGFwcGx5Q29ubmVjdGlvbldpbmRvd1NpemUuYmluZChzZXNzaW9uLCBodHRwMkNvbm5lY3Rpb25XaW5kb3dTaXplKSlcbiAgfVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2Vycm9yJywgb25IdHRwMlNlc3Npb25FcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZnJhbWVFcnJvcicsIG9uSHR0cDJGcmFtZUVycm9yKVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdlbmQnLCBvbkh0dHAyU2Vzc2lvbkVuZClcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZ29hd2F5Jywgb25IdHRwMlNlc3Npb25Hb0F3YXkpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2Nsb3NlJywgb25IdHRwMlNlc3Npb25DbG9zZSlcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAncmVtb3RlU2V0dGluZ3MnLCBvbkh0dHAyUmVtb3RlU2V0dGluZ3MpXG4gIC8vIFRPRE8gKEBtZXRjb2Rlcjk1KTogaW1wbGVtZW50IFNFVFRJTkdTIHN1cHBvcnRcbiAgLy8gdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnbG9jYWxTZXR0aW5ncycsIG9uSHR0cDJSZW1vdGVTZXR0aW5ncylcblxuICBzZXNzaW9uLnVucmVmKClcblxuICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG4gIHNvY2tldFtrSFRUUDJTZXNzaW9uXSA9IHNlc3Npb25cblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Vycm9yJywgb25IdHRwMlNvY2tldEVycm9yKVxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2VuZCcsIG9uSHR0cDJTb2NrZXRFbmQpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnY2xvc2UnLCBvbkh0dHAyU29ja2V0Q2xvc2UpXG5cbiAgc29ja2V0W2tDbG9zZWRdID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDInLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiBJbmZpbml0eSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9yZXF1ZXN0LmpzJyl9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHdyaXRlIChyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gd3JpdGVIMihjbGllbnQsIHJlcXVlc3QpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByZXN1bWUgKCkge1xuICAgICAgcmVzdW1lSDIoY2xpZW50KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvciB8IG51bGx9IGVyclxuICAgICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc29ja2V0W2tDbG9zZWRdKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyKS5vbignY2xvc2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQgKCkge1xuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95ZWRcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL3JlcXVlc3QuanMnKX0gcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgYnVzeSAocmVxdWVzdCkge1xuICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAgICAgICAvLyBXZSBhcmUgYWxyZWFkeSBwcm9jZXNzaW5nIHJlcXVlc3RzXG5cbiAgICAgICAgICAvLyBOb24taWRlbXBvdGVudCByZXF1ZXN0IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIGlmIChyZXF1ZXN0LmlkZW1wb3RlbnQgPT09IGZhbHNlKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgIC8vIERvbid0IGRpc3BhdGNoIGFuIHVwZ3JhZGUgdW50aWwgYWxsIHByZWNlZGluZyByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgICAvLyBQb3NzaWJseSwgd2UgZG8gbm90IGhhdmUgcmVtb3RlIHNldHRpbmdzIGNvbmZpcm1lZCB5ZXQuXG4gICAgICAgICAgaWYgKChyZXF1ZXN0LnVwZ3JhZGUgPT09ICd3ZWJzb2NrZXQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpICYmIHNlc3Npb25ba1JlbW90ZVNldHRpbmdzXSA9PT0gZmFsc2UpIHJldHVybiB0cnVlXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbiBlcnJvciB3aGlsZSBvdGhlciByZXF1ZXN0c1xuICAgICAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXNuJ3QgaGFwcGVuIGJ5IHdhaXRpbmcgZm9yIGluZmxpZ2h0XG4gICAgICAgICAgLy8gdG8gY29tcGxldGUgYmVmb3JlIGRpc3BhdGNoaW5nLlxuXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIGlmICh1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSAhPT0gMCAmJlxuICAgICAgICAgICAgKHV0aWwuaXNTdHJlYW0ocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzQXN5bmNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpIHx8IHV0aWwuaXNGb3JtRGF0YUxpa2UocmVxdWVzdC5ib2R5KSkpIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChyZXF1ZXN0LnVwZ3JhZGUgPT09ICd3ZWJzb2NrZXQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpICYmIHNlc3Npb25ba1JlbW90ZVNldHRpbmdzXSA9PT0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lSDIgKGNsaWVudCkge1xuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICBpZiAoc29ja2V0Py5kZXN0cm95ZWQgPT09IGZhbHNlKSB7XG4gICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDAgfHwgY2xpZW50W2tNYXhDb25jdXJyZW50U3RyZWFtc10gPT09IDApIHtcbiAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICBjbGllbnRba0hUVFAyU2Vzc2lvbl0udW5yZWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQucmVmKClcbiAgICAgIGNsaWVudFtrSFRUUDJTZXNzaW9uXS5yZWYoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUNvbm5lY3Rpb25XaW5kb3dTaXplIChjb25uZWN0aW9uV2luZG93U2l6ZSkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zZXRMb2NhbFdpbmRvd1NpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2V0TG9jYWxXaW5kb3dTaXplKGNvbm5lY3Rpb25XaW5kb3dTaXplKVxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gQmVzdC1lZmZvcnQgb25seS5cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyUmVtb3RlU2V0dGluZ3MgKHNldHRpbmdzKSB7XG4gIC8vIEZhbGxiYWNrcyBhcmUgYSBzYWZlIGJldCwgcmVtb3RlIHNldHRpbmcgd2lsbCBhbHdheXMgb3ZlcnJpZGVcbiAgdGhpc1trQ2xpZW50XVtrTWF4Q29uY3VycmVudFN0cmVhbXNdID0gc2V0dGluZ3MubWF4Q29uY3VycmVudFN0cmVhbXMgPz8gdGhpc1trQ2xpZW50XVtrTWF4Q29uY3VycmVudFN0cmVhbXNdXG4gIC8qKlxuICAgKiBGcm9tIFJGQy04NDQxXG4gICAqIEEgc2VuZGVyIE1VU1QgTk9UIHNlbmQgYSBTRVRUSU5HU19FTkFCTEVfQ09OTkVDVF9QUk9UT0NPTCBwYXJhbWV0ZXJcbiAgICogd2l0aCB0aGUgdmFsdWUgb2YgMCBhZnRlciBwcmV2aW91c2x5IHNlbmRpbmcgYSB2YWx1ZSBvZiAxLlxuICAgKi9cbiAgLy8gTm90ZTogQ2Fubm90IGJlIHRlc3RlZCBpbiBOb2RlLCBpdCBkb2VzIG5vdCBzdXBwb3J0cyBkaXNhYmxpbmcgdGhlIGV4dGVuZGVkIENPTk5FQ1QgcHJvdG9jb2wgb25jZSBlbmFibGVkXG4gIGlmICh0aGlzW2tSZW1vdGVTZXR0aW5nc10gPT09IHRydWUgJiYgdGhpc1trRW5hYmxlQ29ubmVjdFByb3RvY29sXSA9PT0gdHJ1ZSAmJiBzZXR0aW5ncy5lbmFibGVDb25uZWN0UHJvdG9jb2wgPT09IGZhbHNlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcignSFRUUC8yOiBTZXJ2ZXIgZGlzYWJsZWQgZXh0ZW5kZWQgQ09OTkVDVCBwcm90b2NvbCBhZ2FpbnN0IFJGQy04NDQxJylcbiAgICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzW2tFbmFibGVDb25uZWN0UHJvdG9jb2xdID0gc2V0dGluZ3MuZW5hYmxlQ29ubmVjdFByb3RvY29sID8/IHRoaXNba0VuYWJsZUNvbm5lY3RQcm90b2NvbF1cbiAgdGhpc1trUmVtb3RlU2V0dGluZ3NdID0gdHJ1ZVxuICB0aGlzW2tDbGllbnRdW2tSZXN1bWVdKClcbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FcnJvciAoZXJyKSB7XG4gIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJGcmFtZUVycm9yICh0eXBlLCBjb2RlLCBpZCkge1xuICBpZiAoaWQgPT09IDApIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKVxuICAgIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVuZCAoKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpc1trU29ja2V0XSkpXG4gIHRoaXMuZGVzdHJveShlcnIpXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBlcnIpXG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgcm9vdCBjYXVzZSBvZiAjMzAxMVxuICogV2UgbmVlZCB0byBoYW5kbGUgR09BV0FZIGZyYW1lcyBwcm9wZXJseSwgYW5kIHRyaWdnZXIgdGhlIHNlc3Npb24gY2xvc2VcbiAqIGFsb25nIHdpdGggdGhlIHNvY2tldCByaWdodCBhd2F5XG4gKlxuICogQHRoaXMge2ltcG9ydCgnaHR0cDInKS5DbGllbnRIdHRwMlNlc3Npb259XG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JDb2RlXG4gKi9cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uR29Bd2F5IChlcnJvckNvZGUpIHtcbiAgLy8gVE9ETyhtY29sbGluYSk6IFZlcmlmeSBpZiBHT0FXQVkgaW1wbGVtZW50cyB0aGUgc3BlYyBjb3JyZWN0bHk6XG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTYuOFxuICAvLyBTcGVjaWZpY2FsbHksIHdlIGRvIG5vdCB2ZXJpZnkgdGhlIFwidmFsaWRcIiBzdHJlYW0gaWQuXG5cbiAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2Vycm9yQ29kZX1gLCB1dGlsLmdldFNvY2tldEluZm8odGhpc1trU29ja2V0XSkpXG4gIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cblxuICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbFxuXG4gIC8vIHRoaXMgaXMgYW4gSFRUUDIgc2Vzc2lvblxuICB0aGlzLmNsb3NlKClcbiAgdGhpc1trSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgZXJyKVxuXG4gIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgaWYgKGNsaWVudFtrUnVubmluZ0lkeF0gPCBjbGllbnRba1F1ZXVlXS5sZW5ndGgpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG4gIH1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcbiAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkNsb3NlICgpIHtcbiAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCB9ID0gdGhpc1xuICBjb25zdCB7IFtrU29ja2V0XTogc29ja2V0IH0gPSBjbGllbnRcblxuICBjb25zdCBlcnIgPSB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gfHwgdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpXG5cbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGxcblxuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgY29uc3QgY2xpZW50ID0gdGhpc1trSFRUUDJTZXNzaW9uXVtrQ2xpZW50XVxuXG4gIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT09IG51bGwpIHtcbiAgICB0aGlzW2tIVFRQMlNlc3Npb25dLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU29ja2V0RXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTb2NrZXRFbmQgKCkge1xuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxufVxuXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG5mdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgIT09ICdHRVQnICYmIG1ldGhvZCAhPT0gJ0hFQUQnICYmIG1ldGhvZCAhPT0gJ09QVElPTlMnICYmIG1ldGhvZCAhPT0gJ1RSQUNFJyAmJiBtZXRob2QgIT09ICdDT05ORUNUJ1xufVxuXG5mdW5jdGlvbiB3cml0ZUgyIChjbGllbnQsIHJlcXVlc3QpIHtcbiAgY29uc3QgcmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0LmJvZHlUaW1lb3V0ID8/IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gIGNvbnN0IHNlc3Npb24gPSBjbGllbnRba0hUVFAyU2Vzc2lvbl1cbiAgY29uc3QgeyBtZXRob2QsIHBhdGgsIGhvc3QsIHVwZ3JhZGUsIGV4cGVjdENvbnRpbnVlLCBzaWduYWwsIHByb3RvY29sLCBoZWFkZXJzOiByZXFIZWFkZXJzIH0gPSByZXF1ZXN0XG4gIGxldCB7IGJvZHkgfSA9IHJlcXVlc3RcblxuICBpZiAodXBncmFkZSAhPSBudWxsICYmIHVwZ3JhZGUgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEN1c3RvbSB1cGdyYWRlIFwiJHt1cGdyYWRlfVwiIG5vdCBzdXBwb3J0ZWQgb3ZlciBIVFRQLzJgKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7fVxuICBmb3IgKGxldCBuID0gMDsgbiA8IHJlcUhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSByZXFIZWFkZXJzW24gKyAwXVxuICAgIGNvbnN0IHZhbCA9IHJlcUhlYWRlcnNbbiArIDFdXG5cbiAgICBpZiAoa2V5ID09PSAnY29va2llJykge1xuICAgICAgaWYgKGhlYWRlcnNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IEFycmF5LmlzQXJyYXkoaGVhZGVyc1trZXldKSA/IChoZWFkZXJzW2tleV0ucHVzaCh2YWwpLCBoZWFkZXJzW2tleV0pIDogW2hlYWRlcnNba2V5XSwgdmFsXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gdmFsXG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgIGhlYWRlcnNba2V5XSArPSBgLCAke3ZhbFtpXX1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnNba2V5XSkge1xuICAgICAgaGVhZGVyc1trZXldICs9IGAsICR7dmFsfWBcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyc1trZXldID0gdmFsXG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6aHR0cDInKS5DbGllbnRIdHRwMlN0cmVhbX0gKi9cbiAgbGV0IHN0cmVhbSA9IG51bGxcblxuICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9BVVRIT1JJVFldID0gaG9zdCB8fCBgJHtob3N0bmFtZX0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9YFxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gbWV0aG9kXG5cbiAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXJyID0gZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcblxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuXG4gICAgaWYgKHN0cmVhbSAhPSBudWxsKSB7XG4gICAgICAvLyBTb21lIGNodW5rcyBtaWdodCBzdGlsbCBjb21lIGFmdGVyIGFib3J0LFxuICAgICAgLy8gbGV0J3MgaWdub3JlIHRoZW1cbiAgICAgIHN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuXG4gICAgICAvLyBPbiBBYm9ydCwgd2UgY2xvc2UgdGhlIHN0cmVhbSB0byBzZW5kIFJTVF9TVFJFQU0gZnJhbWVcbiAgICAgIHN0cmVhbS5jbG9zZSgpXG5cbiAgICAgIC8vIFdlIG1vdmUgdGhlIHJ1bm5pbmcgaW5kZXggdG8gdGhlIG5leHQgcmVxdWVzdFxuICAgICAgY2xpZW50W2tPbkVycm9yXShlcnIpXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cblxuICAgIC8vIFdlIGRvIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgYXMgd2UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBzZXNzaW9uXG4gICAgLy8gdGhlIHN0cmVhbSBnZXRzIGRlc3Ryb3llZCBhbmQgdGhlIHNlc3Npb24gcmVtYWlucyB0byBjcmVhdGUgbmV3IHN0cmVhbXNcbiAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcuXG4gICAgLy8gV2UgY2FuIGNhbGwgb24gY29ubmVjdCwgYW5kIHdhaXQgZm9yIGFib3J0XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoYWJvcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBzZXNzaW9uLnJlZigpXG5cbiAgICBpZiAodXBncmFkZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIC8vIFdlIGNhbm5vdCB1cGdyYWRlIHRvIHdlYnNvY2tldCBpZiBleHRlbmRlZCBDT05ORUNUIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIGlmIChzZXNzaW9uW2tFbmFibGVDb25uZWN0UHJvdG9jb2xdID09PSBmYWxzZSkge1xuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ0hUVFAvMjogRXh0ZW5kZWQgQ09OTkVDVCBwcm90b2NvbCBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZlcicpKVxuICAgICAgICBzZXNzaW9uLnVucmVmKClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGZvcmNlIHRoZSBtZXRob2QgdG8gQ09OTkVDVFxuICAgICAgLy8gYXMgcGVyIFJGQy04NDQxXG4gICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzg0NDEjc2VjdGlvbi00XG4gICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ0NPTk5FQ1QnXG4gICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QUk9UT0NPTF0gPSAnd2Vic29ja2V0J1xuICAgICAgLy8gOnBhdGggYW5kIDpzY2hlbWUgaGVhZGVycyBtdXN0IGJlIG9taXR0ZWQgd2hlbiBzZW5kaW5nIENPTk5FQ1QgYnV0IHNldCBpZiBleHRlbmRlZC1DT05ORUNUXG4gICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IHBhdGhcblxuICAgICAgaWYgKHByb3RvY29sID09PSAnd3M6JyB8fCBwcm90b2NvbCA9PT0gJ3dzczonKSB7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSBwcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cCcgOiAnaHR0cHMnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9TQ0hFTUVdID0gcHJvdG9jb2wgPT09ICdodHRwOicgPyAnaHR0cCcgOiAnaHR0cHMnXG4gICAgICB9XG5cbiAgICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogZmFsc2UsIHNpZ25hbCB9KVxuICAgICAgc3RyZWFtW2tIVFRQMlN0cmVhbV0gPSB0cnVlXG5cbiAgICAgIHN0cmVhbS5vbmNlKCdyZXNwb25zZScsIChoZWFkZXJzLCBfZmxhZ3MpID0+IHtcbiAgICAgICAgY29uc3QgeyBbSFRUUDJfSEVBREVSX1NUQVRVU106IHN0YXR1c0NvZGUsIC4uLnJlYWxIZWFkZXJzIH0gPSBoZWFkZXJzXG5cbiAgICAgICAgcmVxdWVzdC5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgcGFyc2VIMkhlYWRlcnMocmVhbEhlYWRlcnMpLCBzdHJlYW0pXG5cbiAgICAgICAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICAgIH0pXG5cbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIGlmIChzdHJlYW0ucnN0Q29kZSA9PT0gTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSB8fCBzdHJlYW0ucnN0Q29kZSA9PT0gTkdIVFRQMl9DQU5DRUwpIHtcbiAgICAgICAgICAvLyBOR0hUVFAyX1JFRlVTRURfU1RSRUFNICg3KSBvciBOR0hUVFAyX0NBTkNFTCAoOClcbiAgICAgICAgICAvLyBXZSBkbyBub3QgdHJlYXQgdGhvc2UgYXMgZXJyb3JzIGFzIHRoZSBzZXJ2ZXIgbWlnaHRcbiAgICAgICAgICAvLyBub3Qgc3VwcG9ydCB3ZWJzb2NrZXRzIGFuZCByZWZ1c2UgdGhlIHN0cmVhbVxuICAgICAgICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJzdHJlYW0gZXJyb3JcIiByZWNlaXZlZCAtIGNvZGUgJHtzdHJlYW0ucnN0Q29kZX1gKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuICAgICAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgICAgIH0pXG5cbiAgICAgIHN0cmVhbS5zZXRUaW1lb3V0KHJlcXVlc3RUaW1lb3V0KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zb2xpZGF0ZSBvbmNlIHdlIHN1cHBvcnQgQ09OTkVDVCBwcm9wZXJseVxuICAgIC8vIE5PVEU6IFdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZywgZmlyc3QgcmVxdWVzdFxuICAgIC8vIHdpbGwgY3JlYXRlIGEgbmV3IHN0cmVhbS4gV2UgdHJpZ2dlciBhIHJlcXVlc3QgdG8gY3JlYXRlIHRoZSBzdHJlYW0gYW5kIHdhaXQgdW50aWxcbiAgICAvLyBgcmVhZHlgIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgIC8vIFdlIGRpc2FibGVkIGVuZFN0cmVhbSB0byBhbGxvdyB0aGUgdXNlciB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBmYWxzZSwgc2lnbmFsIH0pXG4gICAgc3RyZWFtW2tIVFRQMlN0cmVhbV0gPSB0cnVlXG4gICAgc3RyZWFtLm9uKCdyZXNwb25zZScsIGhlYWRlcnMgPT4ge1xuICAgICAgY29uc3QgeyBbSFRUUDJfSEVBREVSX1NUQVRVU106IHN0YXR1c0NvZGUsIC4uLnJlYWxIZWFkZXJzIH0gPSBoZWFkZXJzXG5cbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIHBhcnNlSDJIZWFkZXJzKHJlYWxIZWFkZXJzKSwgc3RyZWFtKVxuICAgICAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgfSlcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuICAgICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gICAgfSlcbiAgICBzdHJlYW0uc2V0VGltZW91dChyZXF1ZXN0VGltZW91dClcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTguM1xuICAvLyA6cGF0aCBhbmQgOnNjaGVtZSBoZWFkZXJzIG11c3QgYmUgb21pdHRlZCB3aGVuIHNlbmRpbmcgQ09OTkVDVFxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IHBhdGhcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfU0NIRU1FXSA9IHByb3RvY29sID09PSAnaHR0cDonID8gJ2h0dHAnIDogJ2h0dHBzJ1xuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjFcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy41XG5cbiAgLy8gU2VuZGluZyBhIHBheWxvYWQgYm9keSBvbiBhIHJlcXVlc3QgdGhhdCBkb2VzIG5vdFxuICAvLyBleHBlY3QgaXQgY2FuIGNhdXNlIHVuZGVmaW5lZCBiZWhhdmlvciBvbiBzb21lXG4gIC8vIHNlcnZlcnMgYW5kIGNvcnJ1cHQgY29ubmVjdGlvbiBzdGF0ZS4gRG8gbm90XG4gIC8vIHJlLXVzZSB0aGUgY29ubmVjdGlvbiBmb3IgZnVydGhlciByZXF1ZXN0cy5cblxuICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IChcbiAgICBtZXRob2QgPT09ICdQVVQnIHx8XG4gICAgbWV0aG9kID09PSAnUE9TVCcgfHxcbiAgICBtZXRob2QgPT09ICdQQVRDSCdcbiAgKVxuXG4gIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUcnkgdG8gcmVhZCBFT0YgaW4gb3JkZXIgdG8gZ2V0IGxlbmd0aC5cbiAgICBib2R5LnJlYWQoMClcbiAgfVxuXG4gIGxldCBjb250ZW50TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoYm9keSkpIHtcbiAgICBleHRyYWN0Qm9keSA/Pz0gcmVxdWlyZSgnLi4vd2ViL2ZldGNoL2JvZHkuanMnKS5leHRyYWN0Qm9keVxuXG4gICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBjb250ZW50VHlwZVxuXG4gICAgYm9keSA9IGJvZHlTdHJlYW0uc3RyZWFtXG4gICAgY29udGVudExlbmd0aCA9IGJvZHlTdHJlYW0ubGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG4gICAgLy8gQW5kIGZvciBtZXRob2RzIHRoYXQgZG9uJ3QgZXhwZWN0IGEgcGF5bG9hZCwgb21pdCBDb250ZW50LUxlbmd0aC5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHkgfHwgY29udGVudExlbmd0aCA9PT0gMCwgJ25vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEhdID0gYCR7Y29udGVudExlbmd0aH1gXG4gIH1cblxuICBzZXNzaW9uLnJlZigpXG5cbiAgaWYgKGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgbGV0IGhlYWRlciA9ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7aGVhZGVyc1trZXldfVxcclxcbmBcbiAgICB9XG4gICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3QsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0OiBzZXNzaW9uW2tTb2NrZXRdIH0pXG4gIH1cblxuICAvLyBUT0RPKG1ldGNvZGVyOTUpOiBhZGQgc3VwcG9ydCBmb3Igc2VuZGluZyB0cmFpbGVyc1xuICBjb25zdCBzaG91bGRFbmRTdHJlYW0gPSBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IGJvZHkgPT09IG51bGxcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBzaG91bGRFbmRTdHJlYW0sIHNpZ25hbCB9KVxuICAgIHN0cmVhbVtrSFRUUDJTdHJlYW1dID0gdHJ1ZVxuXG4gICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgd3JpdGVCb2R5SDIpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICBzdHJlYW1ba0hUVFAyU3RyZWFtXSA9IHRydWVcblxuICAgIHdyaXRlQm9keUgyKClcbiAgfVxuXG4gIC8vIEluY3JlbWVudCBjb3VudGVyIGFzIHdlIGhhdmUgbmV3IHN0cmVhbXMgb3BlblxuICArK3Nlc3Npb25ba09wZW5TdHJlYW1zXVxuICBzdHJlYW0uc2V0VGltZW91dChyZXF1ZXN0VGltZW91dClcblxuICAvLyBUcmFjayB3aGV0aGVyIHdlIHJlY2VpdmVkIGEgcmVzcG9uc2UgKGhlYWRlcnMpXG4gIGxldCByZXNwb25zZVJlY2VpdmVkID0gZmFsc2VcblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBjb25zdCB7IFtIVFRQMl9IRUFERVJfU1RBVFVTXTogc3RhdHVzQ29kZSwgLi4ucmVhbEhlYWRlcnMgfSA9IGhlYWRlcnNcbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcbiAgICByZXNwb25zZVJlY2VpdmVkID0gdHJ1ZVxuXG4gICAgLy8gRHVlIHRvIHRoZSBzdHJlYW0gbmF0dXJlLCBpdCBpcyBwb3NzaWJsZSB3ZSBmYWNlIGEgcmFjZSBjb25kaXRpb25cbiAgICAvLyB3aGVyZSB0aGUgc3RyZWFtIGhhcyBiZWVuIGFzc2lnbmVkLCBidXQgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZFxuICAgIC8vIHRoZSByZXF1ZXN0IHJlbWFpbnMgaW4tZmxpZ2h0IGFuZCBoZWFkZXJzIGhhc24ndCBiZWVuIHJlY2VpdmVkIHlldFxuICAgIC8vIGZvciB0aG9zZSBzY2VuYXJpb3MsIGJlc3QgZWZmb3J0IGlzIHRvIGRlc3Ryb3kgdGhlIHN0cmVhbSBpbW1lZGlhdGVseVxuICAgIC8vIGFzIHRoZXJlJ3Mgbm8gdmFsdWUgdG8ga2VlcCBpdCBvcGVuLlxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIHN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Qub25IZWFkZXJzKE51bWJlcihzdGF0dXNDb2RlKSwgcGFyc2VIMkhlYWRlcnMocmVhbEhlYWRlcnMpLCBzdHJlYW0ucmVzdW1lLmJpbmQoc3RyZWFtKSwgJycpID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgLy8gSWYgd2UgcmVjZWl2ZWQgYSByZXNwb25zZSwgdGhpcyBpcyBhIG5vcm1hbCBjb21wbGV0aW9uXG4gICAgaWYgKHJlc3BvbnNlUmVjZWl2ZWQpIHtcbiAgICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmICFyZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgICByZXF1ZXN0Lm9uQ29tcGxldGUoe30pXG4gICAgICB9XG5cbiAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJlYW0gZW5kZWQgd2l0aG91dCByZWNlaXZpbmcgYSByZXNwb25zZSAtIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIChlLmcuLCBzZXJ2ZXIgZGVzdHJveWVkIHRoZSBzdHJlYW0gYmVmb3JlIHNlbmRpbmcgaGVhZGVycylcbiAgICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ0hUVFAvMjogc3RyZWFtIGhhbGYtY2xvc2VkIChyZW1vdGUpJykpXG4gICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgICAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cbiAgICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICBzdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHtcbiAgICAgIHNlc3Npb24udW5yZWYoKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgYWJvcnQoZXJyKVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdmcmFtZUVycm9yJywgKHR5cGUsIGNvZGUpID0+IHtcbiAgICBzdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICBhYm9ydChuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKSlcbiAgfSlcblxuICBzdHJlYW0ub24oJ2Fib3J0ZWQnLCAoKSA9PiB7XG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJzdHJlYW0gdGltZW91dCBhZnRlciAke3JlcXVlc3RUaW1lb3V0fVwiYClcbiAgICBzdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuXG4gICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkge1xuICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgfVxuXG4gICAgYWJvcnQoZXJyKVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCd0cmFpbGVycycsIHRyYWlsZXJzID0+IHtcbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiB3cml0ZUJvZHlIMiAoKSB7XG4gICAgaWYgKCFib2R5IHx8IGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgIHdyaXRlQnVmZmVyKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBudWxsLFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIHdyaXRlQnVmZmVyKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3cml0ZUl0ZXJhYmxlKFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBib2R5LnN0cmVhbSgpLFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQmxvYihcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB3cml0ZVN0cmVhbShcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyIChhYm9ydCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBleHBlY3RzUGF5bG9hZCkge1xuICB0cnkge1xuICAgIGlmIChib2R5ICE9IG51bGwgJiYgdXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgICBoMnN0cmVhbS5jb3JrKClcbiAgICAgIGgyc3RyZWFtLndyaXRlKGJvZHkpXG4gICAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgICAgaDJzdHJlYW0uZW5kKClcblxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGFib3J0KGVycm9yKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtIChhYm9ydCwgc29ja2V0LCBleHBlY3RzUGF5bG9hZCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgY29udGVudExlbmd0aCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnc3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgLy8gRm9yIEhUVFAvMiwgaXMgZW5vdWdoIHRvIHBpcGUgdGhlIHN0cmVhbVxuICBjb25zdCBwaXBlID0gcGlwZWxpbmUoXG4gICAgYm9keSxcbiAgICBoMnN0cmVhbSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShwaXBlLCBlcnIpXG4gICAgICAgIGFib3J0KGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwucmVtb3ZlQWxsTGlzdGVuZXJzKHBpcGUpXG4gICAgICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICB1dGlsLmFkZExpc3RlbmVyKHBpcGUsICdkYXRhJywgb25QaXBlRGF0YSlcblxuICBmdW5jdGlvbiBvblBpcGVEYXRhIChjaHVuaykge1xuICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUJsb2IgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LnNpemUsICdibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcblxuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBoMnN0cmVhbS5jb3JrKClcbiAgICBoMnN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgaDJzdHJlYW0udW5jb3JrKClcbiAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJ1ZmZlcilcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdpdGVyYXRvciBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBjYWxsYmFjayA9IG51bGxcbiAgZnVuY3Rpb24gb25EcmFpbiAoKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB3YWl0Rm9yRHJhaW4gPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXNzZXJ0KGNhbGxiYWNrID09PSBudWxsKVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICByZWplY3Qoc29ja2V0W2tFcnJvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZVxuICAgIH1cbiAgfSlcblxuICBoMnN0cmVhbVxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIHRyeSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBoMnN0cmVhbS53cml0ZShjaHVuaylcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaDJzdHJlYW0uZW5kKClcblxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgaDJzdHJlYW1cbiAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RIMlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst http = __webpack_require__(/*! node:http */ \"node:http\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { ClientStats } = __webpack_require__(/*! ../util/stats.js */ \"(rsc)/./node_modules/undici/lib/util/stats.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(rsc)/./node_modules/undici/lib/core/request.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kHTTP2InitialWindowSize,\n  kHTTP2ConnectionWindowSize,\n  kResume\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\")\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\")\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst getDefaultNodeMaxHeaderSize = http &&\n  http.maxHeaderSize &&\n  Number.isInteger(http.maxHeaderSize) &&\n  http.maxHeaderSize > 0\n  ? () => http.maxHeaderSize\n  : () => { throw new InvalidArgumentError('http module not available or http.maxHeaderSize invalid') }\n\nconst noop = () => {}\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2,\n    useH2c,\n    initialWindowSize,\n    connectionWindowSize\n  } = {}) {\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null) {\n      if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {\n        throw new InvalidArgumentError('invalid maxHeaderSize')\n      }\n    } else {\n      // If maxHeaderSize is not provided, use the default value from the http module\n      // or if that is not available, throw an error.\n      maxHeaderSize = getDefaultNodeMaxHeaderSize()\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    if (useH2c != null && typeof useH2c !== 'boolean') {\n      throw new InvalidArgumentError('useH2c must be a valid boolean value')\n    }\n\n    if (initialWindowSize != null && (!Number.isInteger(initialWindowSize) || initialWindowSize < 1)) {\n      throw new InvalidArgumentError('initialWindowSize must be a positive integer, greater than 0')\n    }\n\n    if (connectionWindowSize != null && (!Number.isInteger(connectionWindowSize) || connectionWindowSize < 1)) {\n      throw new InvalidArgumentError('connectionWindowSize must be a positive integer, greater than 0')\n    }\n\n    super()\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        useH2c,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    // HTTP/2 window sizes are set to higher defaults than Node.js core for better performance:\n    // - initialWindowSize: 262144 (256KB) vs Node.js default 65535 (64KB - 1)\n    //   Allows more data to be sent before requiring acknowledgment, improving throughput\n    //   especially on high-latency networks. This matches common production HTTP/2 servers.\n    // - connectionWindowSize: 524288 (512KB) vs Node.js default (none set)\n    //   Provides better flow control for the entire connection across multiple streams.\n    this[kHTTP2InitialWindowSize] = initialWindowSize != null ? initialWindowSize : 262144\n    this[kHTTP2ConnectionWindowSize] = connectionWindowSize != null ? connectionWindowSize : 524288\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get stats () {\n    return new ClientStats(this)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const request = new Request(this[kUrl].origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\n/**\n * @param {Client} client\n * @returns {void}\n */\nfunction connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIPv6(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  client[kConnector]({\n    host,\n    hostname,\n    protocol,\n    port,\n    servername: client[kServerName],\n    localAddress: client[kLocalAddress]\n  }, (err, socket) => {\n    if (err) {\n      handleConnectError(client, err, { host, hostname, protocol, port })\n      client[kResume]()\n      return\n    }\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', noop), new ClientDestroyedError())\n      client[kResume]()\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? connectH2(client, socket)\n        : connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', noop)\n      handleConnectError(client, err, { host, hostname, protocol, port })\n      client[kResume]()\n      return\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n\n    client.emit('connect', client[kUrl], [client])\n    client[kResume]()\n  })\n}\n\nfunction handleConnectError (client, err, { host, hostname, protocol, port }) {\n  if (client.destroyed) {\n    return\n  }\n\n  client[kConnecting] = false\n\n  if (channels.connectError.hasSubscribers) {\n    channels.connectError.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector],\n      error: err\n    })\n  }\n\n  if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n    assert(client[kRunning] === 0)\n    while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n      const request = client[kQueue][client[kPendingIdx]++]\n      util.errorRequest(client, request, err)\n    }\n  } else {\n    onError(client, err)\n  }\n\n  client.emit('connectionError', client[kUrl], [client], err)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsdUVBQWtCO0FBQ2xELFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFvQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFnQjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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XFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCBodHRwID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3QgeyBDbGllbnRTdGF0cyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0cy5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuLi9jb3JlL3JlcXVlc3QuanMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtDb25uZWN0LFxuICBrUmVzdW1pbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCxcbiAga0hvc3RIZWFkZXIsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrUGlwZWxpbmluZyxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAga01heEhlYWRlcnNTaXplLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gIGtIZWFkZXJzVGltZW91dCxcbiAga0JvZHlUaW1lb3V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga0Nvbm5lY3RvcixcbiAga01heFJlcXVlc3RzLFxuICBrQ291bnRlcixcbiAga0Nsb3NlLFxuICBrRGVzdHJveSxcbiAga0Rpc3BhdGNoLFxuICBrTG9jYWxBZGRyZXNzLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga0hUVFBDb250ZXh0LFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtIVFRQMkluaXRpYWxXaW5kb3dTaXplLFxuICBrSFRUUDJDb25uZWN0aW9uV2luZG93U2l6ZSxcbiAga1Jlc3VtZVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5jb25zdCBjb25uZWN0SDEgPSByZXF1aXJlKCcuL2NsaWVudC1oMS5qcycpXG5jb25zdCBjb25uZWN0SDIgPSByZXF1aXJlKCcuL2NsaWVudC1oMi5qcycpXG5cbmNvbnN0IGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKCdrQ2xvc2VkUmVzb2x2ZScpXG5cbmNvbnN0IGdldERlZmF1bHROb2RlTWF4SGVhZGVyU2l6ZSA9IGh0dHAgJiZcbiAgaHR0cC5tYXhIZWFkZXJTaXplICYmXG4gIE51bWJlci5pc0ludGVnZXIoaHR0cC5tYXhIZWFkZXJTaXplKSAmJlxuICBodHRwLm1heEhlYWRlclNpemUgPiAwXG4gID8gKCkgPT4gaHR0cC5tYXhIZWFkZXJTaXplXG4gIDogKCkgPT4geyB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2h0dHAgbW9kdWxlIG5vdCBhdmFpbGFibGUgb3IgaHR0cC5tYXhIZWFkZXJTaXplIGludmFsaWQnKSB9XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5mdW5jdGlvbiBnZXRQaXBlbGluaW5nIChjbGllbnQpIHtcbiAgcmV0dXJuIGNsaWVudFtrUGlwZWxpbmluZ10gPz8gY2xpZW50W2tIVFRQQ29udGV4dF0/LmRlZmF1bHRQaXBlbGluaW5nID8/IDFcbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jbGllbnQuanMnKS5kZWZhdWx0fVxuICovXG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2xpZW50LmpzJykuQ2xpZW50Lk9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHtcbiAgICBtYXhIZWFkZXJTaXplLFxuICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgIHNvY2tldFRpbWVvdXQsXG4gICAgcmVxdWVzdFRpbWVvdXQsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgaWRsZVRpbWVvdXQsXG4gICAga2VlcEFsaXZlLFxuICAgIGtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgbWF4S2VlcEFsaXZlVGltZW91dCxcbiAgICBrZWVwQWxpdmVNYXhUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gICAgc29ja2V0UGF0aCxcbiAgICBwaXBlbGluaW5nLFxuICAgIHRscyxcbiAgICBzdHJpY3RDb250ZW50TGVuZ3RoLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIG1heENvbmN1cnJlbnRTdHJlYW1zLFxuICAgIGFsbG93SDIsXG4gICAgdXNlSDJjLFxuICAgIGluaXRpYWxXaW5kb3dTaXplLFxuICAgIGNvbm5lY3Rpb25XaW5kb3dTaXplXG4gIH0gPSB7fSkge1xuICAgIGlmIChrZWVwQWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBrZWVwQWxpdmUsIHVzZSBwaXBlbGluaW5nPTAgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBzb2NrZXRUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCByZXF1ZXN0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKGlkbGVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgaWRsZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChtYXhLZWVwQWxpdmVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgbWF4S2VlcEFsaXZlVGltZW91dCwgdXNlIGtlZXBBbGl2ZU1heFRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEhlYWRlclNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heEhlYWRlclNpemUpIHx8IG1heEhlYWRlclNpemUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbWF4SGVhZGVyU2l6ZSBpcyBub3QgcHJvdmlkZWQsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBodHRwIG1vZHVsZVxuICAgICAgLy8gb3IgaWYgdGhhdCBpcyBub3QgYXZhaWxhYmxlLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIG1heEhlYWRlclNpemUgPSBnZXREZWZhdWx0Tm9kZU1heEhlYWRlclNpemUoKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRQYXRoICE9IG51bGwgJiYgdHlwZW9mIHNvY2tldFBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgc29ja2V0UGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3RUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdFRpbWVvdXQpIHx8IGNvbm5lY3RUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0KSB8fCBrZWVwQWxpdmVUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZU1heFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVNYXhUaW1lb3V0KSB8fCBrZWVwQWxpdmVNYXhUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlTWF4VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCcpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnNUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgaWYgKHVzZUgyYyAhPSBudWxsICYmIHR5cGVvZiB1c2VIMmMgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1c2VIMmMgbXVzdCBiZSBhIHZhbGlkIGJvb2xlYW4gdmFsdWUnKVxuICAgIH1cblxuICAgIGlmIChpbml0aWFsV2luZG93U2l6ZSAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihpbml0aWFsV2luZG93U2l6ZSkgfHwgaW5pdGlhbFdpbmRvd1NpemUgPCAxKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbml0aWFsV2luZG93U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0aW9uV2luZG93U2l6ZSAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihjb25uZWN0aW9uV2luZG93U2l6ZSkgfHwgY29ubmVjdGlvbldpbmRvd1NpemUgPCAxKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0aW9uV2luZG93U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIHN1cGVyKClcblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgdXNlSDJjLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHR5cGVvZiBhdXRvU2VsZWN0RmFtaWx5ID09PSAnYm9vbGVhbicgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbih1cmwpXG4gICAgdGhpc1trQ29ubmVjdG9yXSA9IGNvbm5lY3RcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHBpcGVsaW5pbmcgIT0gbnVsbCA/IHBpcGVsaW5pbmcgOiAxXG4gICAgdGhpc1trTWF4SGVhZGVyc1NpemVdID0gbWF4SGVhZGVyU2l6ZVxuICAgIHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XSA9IGtlZXBBbGl2ZVRpbWVvdXQgPT0gbnVsbCA/IDRlMyA6IGtlZXBBbGl2ZVRpbWVvdXRcbiAgICB0aGlzW2tLZWVwQWxpdmVNYXhUaW1lb3V0XSA9IGtlZXBBbGl2ZU1heFRpbWVvdXQgPT0gbnVsbCA/IDYwMGUzIDoga2VlcEFsaXZlTWF4VGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRdID0ga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCA9PSBudWxsID8gMmUzIDoga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICB0aGlzW2tTZXJ2ZXJOYW1lXSA9IG51bGxcbiAgICB0aGlzW2tMb2NhbEFkZHJlc3NdID0gbG9jYWxBZGRyZXNzICE9IG51bGwgPyBsb2NhbEFkZHJlc3MgOiBudWxsXG4gICAgdGhpc1trUmVzdW1pbmddID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tIb3N0SGVhZGVyXSA9IGBob3N0OiAke3RoaXNba1VybF0uaG9zdG5hbWV9JHt0aGlzW2tVcmxdLnBvcnQgPyBgOiR7dGhpc1trVXJsXS5wb3J0fWAgOiAnJ31cXHJcXG5gXG4gICAgdGhpc1trQm9keVRpbWVvdXRdID0gYm9keVRpbWVvdXQgIT0gbnVsbCA/IGJvZHlUaW1lb3V0IDogMzAwZTNcbiAgICB0aGlzW2tIZWFkZXJzVGltZW91dF0gPSBoZWFkZXJzVGltZW91dCAhPSBudWxsID8gaGVhZGVyc1RpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba1N0cmljdENvbnRlbnRMZW5ndGhdID0gc3RyaWN0Q29udGVudExlbmd0aCA9PSBudWxsID8gdHJ1ZSA6IHN0cmljdENvbnRlbnRMZW5ndGhcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trTWF4Q29uY3VycmVudFN0cmVhbXNdID0gbWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCA/IG1heENvbmN1cnJlbnRTdHJlYW1zIDogMTAwIC8vIE1heCBwZWVyQ29uY3VycmVudFN0cmVhbXMgZm9yIGEgTm9kZSBoMiBzZXJ2ZXJcbiAgICAvLyBIVFRQLzIgd2luZG93IHNpemVzIGFyZSBzZXQgdG8gaGlnaGVyIGRlZmF1bHRzIHRoYW4gTm9kZS5qcyBjb3JlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6XG4gICAgLy8gLSBpbml0aWFsV2luZG93U2l6ZTogMjYyMTQ0ICgyNTZLQikgdnMgTm9kZS5qcyBkZWZhdWx0IDY1NTM1ICg2NEtCIC0gMSlcbiAgICAvLyAgIEFsbG93cyBtb3JlIGRhdGEgdG8gYmUgc2VudCBiZWZvcmUgcmVxdWlyaW5nIGFja25vd2xlZGdtZW50LCBpbXByb3ZpbmcgdGhyb3VnaHB1dFxuICAgIC8vICAgZXNwZWNpYWxseSBvbiBoaWdoLWxhdGVuY3kgbmV0d29ya3MuIFRoaXMgbWF0Y2hlcyBjb21tb24gcHJvZHVjdGlvbiBIVFRQLzIgc2VydmVycy5cbiAgICAvLyAtIGNvbm5lY3Rpb25XaW5kb3dTaXplOiA1MjQyODggKDUxMktCKSB2cyBOb2RlLmpzIGRlZmF1bHQgKG5vbmUgc2V0KVxuICAgIC8vICAgUHJvdmlkZXMgYmV0dGVyIGZsb3cgY29udHJvbCBmb3IgdGhlIGVudGlyZSBjb25uZWN0aW9uIGFjcm9zcyBtdWx0aXBsZSBzdHJlYW1zLlxuICAgIHRoaXNba0hUVFAySW5pdGlhbFdpbmRvd1NpemVdID0gaW5pdGlhbFdpbmRvd1NpemUgIT0gbnVsbCA/IGluaXRpYWxXaW5kb3dTaXplIDogMjYyMTQ0XG4gICAgdGhpc1trSFRUUDJDb25uZWN0aW9uV2luZG93U2l6ZV0gPSBjb25uZWN0aW9uV2luZG93U2l6ZSAhPSBudWxsID8gY29ubmVjdGlvbldpbmRvd1NpemUgOiA1MjQyODhcbiAgICB0aGlzW2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgICAvLyBrUXVldWUgaXMgYnVpbHQgdXAgb2YgMyBzZWN0aW9ucyBzZXBhcmF0ZWQgYnlcbiAgICAvLyB0aGUga1J1bm5pbmdJZHggYW5kIGtQZW5kaW5nSWR4IGluZGljZXMuXG4gICAgLy8gfCAgIGNvbXBsZXRlICAgfCAgIHJ1bm5pbmcgICB8ICAgcGVuZGluZyAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICBeIGtSdW5uaW5nSWR4IF4ga1BlbmRpbmdJZHggXiBrUXVldWUubGVuZ3RoXG4gICAgLy8ga1J1bm5pbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBydW5uaW5nIGVsZW1lbnQuXG4gICAgLy8ga1BlbmRpbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBwZW5kaW5nIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIGEgZmFzdCBxdWV1ZSB3aXRoIGFuIGFtb3J0aXplZFxuICAgIC8vIHRpbWUgb2YgTygxKS5cblxuICAgIHRoaXNba1F1ZXVlXSA9IFtdXG4gICAgdGhpc1trUnVubmluZ0lkeF0gPSAwXG4gICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gKHN5bmMpID0+IHJlc3VtZSh0aGlzLCBzeW5jKVxuICAgIHRoaXNba09uRXJyb3JdID0gKGVycikgPT4gb25FcnJvcih0aGlzLCBlcnIpXG4gIH1cblxuICBnZXQgcGlwZWxpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddXG4gIH1cblxuICBzZXQgcGlwZWxpbmluZyAodmFsdWUpIHtcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHZhbHVlXG4gICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICB9XG5cbiAgZ2V0IHN0YXRzICgpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudFN0YXRzKHRoaXMpXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tQZW5kaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tQZW5kaW5nSWR4XSAtIHRoaXNba1J1bm5pbmdJZHhdXG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuICEhdGhpc1trSFRUUENvbnRleHRdICYmICF0aGlzW2tDb25uZWN0aW5nXSAmJiAhdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdGhpc1trSFRUUENvbnRleHRdPy5idXN5KG51bGwpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKGdldFBpcGVsaW5pbmcodGhpcykgfHwgMSkpIHx8XG4gICAgICB0aGlzW2tQZW5kaW5nXSA+IDBcbiAgICApXG4gIH1cblxuICBba0Nvbm5lY3RdIChjYikge1xuICAgIGNvbm5lY3QodGhpcylcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBjYilcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXNba1VybF0ub3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc3VtZSh0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10gJiYgdGhpc1trTmVlZERyYWluXSAhPT0gMiAmJiB0aGlzW2tCdXN5XSkge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IDJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXSA8IDJcbiAgfVxuXG4gIFtrQ2xvc2VdICgpIHtcbiAgICAvLyBUT0RPOiBmb3IgSDIgd2UgbmVlZCB0byBncmFjZWZ1bGx5IGZsdXNoIHRoZSByZW1haW5pbmcgZW5xdWV1ZWRcbiAgICAvLyByZXF1ZXN0IGFuZCBjbG9zZSBlYWNoIHN0cmVhbS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzW2tTaXplXSkge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXNba1F1ZXVlXS5zcGxpY2UodGhpc1trUGVuZGluZ0lkeF0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tIVFRQQ29udGV4dF0pIHtcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3koZXJyLCBjYWxsYmFjaylcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9XG5cbiAgICAgIHRoaXNba1Jlc3VtZV0oKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25FcnJvciAoY2xpZW50LCBlcnIpIHtcbiAgaWYgKFxuICAgIGNsaWVudFtrUnVubmluZ10gPT09IDAgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfU09DS0VUJ1xuICApIHtcbiAgICAvLyBFcnJvciBpcyBub3QgY2F1c2VkIGJ5IHJ1bm5pbmcgcmVxdWVzdCBhbmQgbm90IGEgcmVjb3ZlcmFibGVcbiAgICAvLyBzb2NrZXQgZXJyb3IuXG5cbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nSWR4XSA9PT0gY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgICBhc3NlcnQoY2xpZW50W2tTaXplXSA9PT0gMClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25uZWN0IChjbGllbnQpIHtcbiAgYXNzZXJ0KCFjbGllbnRba0Nvbm5lY3RpbmddKVxuICBhc3NlcnQoIWNsaWVudFtrSFRUUENvbnRleHRdKVxuXG4gIGxldCB7IGhvc3QsIGhvc3RuYW1lLCBwcm90b2NvbCwgcG9ydCB9ID0gY2xpZW50W2tVcmxdXG5cbiAgLy8gUmVzb2x2ZSBpcHY2XG4gIGlmIChob3N0bmFtZVswXSA9PT0gJ1snKSB7XG4gICAgY29uc3QgaWR4ID0gaG9zdG5hbWUuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICBjb25zdCBpcCA9IGhvc3RuYW1lLnN1YnN0cmluZygxLCBpZHgpXG5cbiAgICBhc3NlcnQobmV0LmlzSVB2NihpcCkpXG4gICAgaG9zdG5hbWUgPSBpcFxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0aW5nXSA9IHRydWVcblxuICBpZiAoY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QucHVibGlzaCh7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0b3JdKHtcbiAgICBob3N0LFxuICAgIGhvc3RuYW1lLFxuICAgIHByb3RvY29sLFxuICAgIHBvcnQsXG4gICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBoYW5kbGVDb25uZWN0RXJyb3IoY2xpZW50LCBlcnIsIHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0pXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQub24oJ2Vycm9yJywgbm9vcCksIG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpKVxuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICB0cnkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBzb2NrZXQuYWxwblByb3RvY29sID09PSAnaDInXG4gICAgICAgID8gY29ubmVjdEgyKGNsaWVudCwgc29ja2V0KVxuICAgICAgICA6IGNvbm5lY3RIMShjbGllbnQsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCkub24oJ2Vycm9yJywgbm9vcClcbiAgICAgIGhhbmRsZUNvbm5lY3RFcnJvcihjbGllbnQsIGVyciwgeyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQgfSlcbiAgICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdGVkLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHZlcnNpb246IGNsaWVudFtrSFRUUENvbnRleHRdPy52ZXJzaW9uLFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIHNvY2tldFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdEVycm9yIChjbGllbnQsIGVyciwgeyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQgfSkge1xuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlXG5cbiAgaWYgKGNoYW5uZWxzLmNvbm5lY3RFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgaG9zdCxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwb3J0LFxuICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgIGVycm9yOiBlcnJcbiAgICB9KVxuICB9XG5cbiAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICB3aGlsZSAoY2xpZW50W2tQZW5kaW5nXSA+IDAgJiYgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV0uc2VydmVybmFtZSA9PT0gY2xpZW50W2tTZXJ2ZXJOYW1lXSkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF0rK11cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbkVycm9yKGNsaWVudCwgZXJyKVxuICB9XG5cbiAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0ucmVzdW1lKClcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tCdXN5XSkge1xuICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMlxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tOZWVkRHJhaW5dID09PSAyKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBjbGllbnRba05lZWREcmFpbl0gPSAxXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGVtaXREcmFpbihjbGllbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdERyYWluKGNsaWVudClcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUGVuZGluZ10gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID49IChnZXRQaXBlbGluaW5nKGNsaWVudCkgfHwgMSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXVxuXG4gICAgaWYgKGNsaWVudFtrVXJsXS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgY2xpZW50W2tTZXJ2ZXJOYW1lXSAhPT0gcmVxdWVzdC5zZXJ2ZXJuYW1lKSB7XG4gICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNsaWVudFtrU2VydmVyTmFtZV0gPSByZXF1ZXN0LnNlcnZlcm5hbWVcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdPy5kZXN0cm95KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NlcnZlcm5hbWUgY2hhbmdlZCcpLCAoKSA9PiB7XG4gICAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgICByZXN1bWUoY2xpZW50KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tDb25uZWN0aW5nXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY29ubmVjdChjbGllbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uYnVzeShyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0LmFib3J0ZWQgJiYgY2xpZW50W2tIVFRQQ29udGV4dF0ud3JpdGUocmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst UnwrapHandler = __webpack_require__(/*! ../handler/unwrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\n\nclass DispatcherBase extends Dispatcher {\n  /** @type {boolean} */\n  [kDestroyed] = false;\n\n  /** @type {Array<Function|null} */\n  [kOnDestroyed] = null;\n\n  /** @type {boolean} */\n  [kClosed] = false;\n\n  /** @type {Array<Function>|null} */\n  [kOnClosed] = null\n\n  /** @returns {boolean} */\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  /** @returns {boolean} */\n  get closed () {\n    return this[kClosed]\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      const err = new ClientDestroyedError()\n      queueMicrotask(() => callback(err, null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed] ??= []\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => queueMicrotask(onClosed))\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] ??= []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err)\n      .then(() => queueMicrotask(onDestroyed))\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    handler = UnwrapHandler.unwrap(handler)\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw err\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsUUFBUSxtREFBbUQsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjs7QUFFdEY7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQSxhQUFhLHFCQUFxQjtBQUNsQzs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZGlzcGF0Y2hlci1iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJylcbmNvbnN0IFVud3JhcEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3Vud3JhcC1oYW5kbGVyJylcbmNvbnN0IHtcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0Rlc3Ryb3ksIGtDbG9zZSwga0Nsb3NlZCwga0Rlc3Ryb3llZCwga0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBrT25EZXN0cm95ZWQgPSBTeW1ib2woJ29uRGVzdHJveWVkJylcbmNvbnN0IGtPbkNsb3NlZCA9IFN5bWJvbCgnb25DbG9zZWQnKVxuXG5jbGFzcyBEaXNwYXRjaGVyQmFzZSBleHRlbmRzIERpc3BhdGNoZXIge1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIFtrRGVzdHJveWVkXSA9IGZhbHNlO1xuXG4gIC8qKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb258bnVsbH0gKi9cbiAgW2tPbkRlc3Ryb3llZF0gPSBudWxsO1xuXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgW2tDbG9zZWRdID0gZmFsc2U7XG5cbiAgLyoqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj58bnVsbH0gKi9cbiAgW2tPbkNsb3NlZF0gPSBudWxsXG5cbiAgLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trRGVzdHJveWVkXVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICBnZXQgY2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xvc2VkXVxuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IENsaWVudERlc3Ryb3llZEVycm9yKClcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgbnVsbCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgaWYgKHRoaXNba09uQ2xvc2VkXSkge1xuICAgICAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trQ2xvc2VkXSA9IHRydWVcbiAgICB0aGlzW2tPbkNsb3NlZF0gPz89IFtdXG4gICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkNsb3NlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uQ2xvc2VkXVxuICAgICAgdGhpc1trT25DbG9zZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tDbG9zZV0oKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5kZXN0cm95KCkpXG4gICAgICAudGhlbigoKSA9PiBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZCkpXG4gIH1cblxuICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXJyXG4gICAgICBlcnIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkRlc3Ryb3llZF0pIHtcbiAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSB0cnVlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID8/PSBbXVxuICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25EZXN0cm95ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkRlc3Ryb3llZF1cbiAgICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trRGVzdHJveV0oZXJyKVxuICAgICAgLnRoZW4oKCkgPT4gcXVldWVNaWNyb3Rhc2sob25EZXN0cm95ZWQpKVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGhhbmRsZXIgPSBVbndyYXBIYW5kbGVyLnVud3JhcChoYW5kbGVyKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0LicpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdIHx8IHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50Q2xvc2VkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1trRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci5vbkVycm9yKGVycilcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlckJhc2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\")\nconst WrapHandler = __webpack_require__(/*! ../handler/wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\n\nconst wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler))\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n\n  compose (...args) {\n    // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n    const interceptors = Array.isArray(args[0]) ? args[0] : args\n    let dispatch = this.dispatch.bind(this)\n\n    for (const interceptor of interceptors) {\n      if (interceptor == null) {\n        continue\n      }\n\n      if (typeof interceptor !== 'function') {\n        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`)\n      }\n\n      dispatch = interceptor(dispatch)\n      dispatch = wrapInterceptor(dispatch)\n\n      if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n        throw new TypeError('invalid interceptor')\n      }\n    }\n\n    return new Proxy(this, {\n      get: (target, key) => key === 'dispatch' ? dispatch : target[key]\n    })\n  }\n}\n\nmodule.exports = Dispatcher\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBeUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsbUJBQW1CO0FBQ2xHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZGlzcGF0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IFdyYXBIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci93cmFwLWhhbmRsZXInKVxuXG5jb25zdCB3cmFwSW50ZXJjZXB0b3IgPSAoZGlzcGF0Y2gpID0+IChvcHRzLCBoYW5kbGVyKSA9PiBkaXNwYXRjaChvcHRzLCBXcmFwSGFuZGxlci53cmFwKGhhbmRsZXIpKVxuXG5jbGFzcyBEaXNwYXRjaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZGlzcGF0Y2ggKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBjb21wb3NlICguLi5hcmdzKSB7XG4gICAgLy8gU28gd2UgaGFuZGxlIFtpbnRlcmNlcHRvcjEsIGludGVyY2VwdG9yMl0gb3IgaW50ZXJjZXB0b3IxLCBpbnRlcmNlcHRvcjIsIC4uLlxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJnc1xuICAgIGxldCBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKVxuXG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiBpbnRlcmNlcHRvcnMpIHtcbiAgICAgIGlmIChpbnRlcmNlcHRvciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlcmNlcHRvciwgZXhwZWN0ZWQgZnVuY3Rpb24gcmVjZWl2ZWQgJHt0eXBlb2YgaW50ZXJjZXB0b3J9YClcbiAgICAgIH1cblxuICAgICAgZGlzcGF0Y2ggPSBpbnRlcmNlcHRvcihkaXNwYXRjaClcbiAgICAgIGRpc3BhdGNoID0gd3JhcEludGVyY2VwdG9yKGRpc3BhdGNoKVxuXG4gICAgICBpZiAoZGlzcGF0Y2ggPT0gbnVsbCB8fCB0eXBlb2YgZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicgfHwgZGlzcGF0Y2gubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW50ZXJjZXB0b3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgZ2V0OiAodGFyZ2V0LCBrZXkpID0+IGtleSA9PT0gJ2Rpc3BhdGNoJyA/IGRpc3BhdGNoIDogdGFyZ2V0W2tleV1cbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nconst DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443\n}\n\nclass EnvHttpProxyAgent extends DispatcherBase {\n  #noProxyValue = null\n  #noProxyEntries = null\n  #opts = null\n\n  constructor (opts = {}) {\n    super()\n    this.#opts = opts\n\n    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts\n\n    this[kNoProxyAgent] = new Agent(agentOpts)\n\n    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY\n    if (HTTP_PROXY) {\n      this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY })\n    } else {\n      this[kHttpProxyAgent] = this[kNoProxyAgent]\n    }\n\n    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY\n    if (HTTPS_PROXY) {\n      this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY })\n    } else {\n      this[kHttpsProxyAgent] = this[kHttpProxyAgent]\n    }\n\n    this.#parseNoProxy()\n  }\n\n  [kDispatch] (opts, handler) {\n    const url = new URL(opts.origin)\n    const agent = this.#getProxyAgentForUrl(url)\n    return agent.dispatch(opts, handler)\n  }\n\n  [kClose] () {\n    return Promise.all([\n      this[kNoProxyAgent].close(),\n      !this[kHttpProxyAgent][kClosed] && this[kHttpProxyAgent].close(),\n      !this[kHttpsProxyAgent][kClosed] && this[kHttpsProxyAgent].close()\n    ])\n  }\n\n  [kDestroy] (err) {\n    return Promise.all([\n      this[kNoProxyAgent].destroy(err),\n      !this[kHttpProxyAgent][kDestroyed] && this[kHttpProxyAgent].destroy(err),\n      !this[kHttpsProxyAgent][kDestroyed] && this[kHttpsProxyAgent].destroy(err)\n    ])\n  }\n\n  #getProxyAgentForUrl (url) {\n    let { protocol, host: hostname, port } = url\n\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, '').toLowerCase()\n    port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0\n    if (!this.#shouldProxy(hostname, port)) {\n      return this[kNoProxyAgent]\n    }\n    if (protocol === 'https:') {\n      return this[kHttpsProxyAgent]\n    }\n    return this[kHttpProxyAgent]\n  }\n\n  #shouldProxy (hostname, port) {\n    if (this.#noProxyChanged) {\n      this.#parseNoProxy()\n    }\n\n    if (this.#noProxyEntries.length === 0) {\n      return true // Always proxy if NO_PROXY is not set or empty.\n    }\n    if (this.#noProxyValue === '*') {\n      return false // Never proxy if wildcard is set.\n    }\n\n    for (let i = 0; i < this.#noProxyEntries.length; i++) {\n      const entry = this.#noProxyEntries[i]\n      if (entry.port && entry.port !== port) {\n        continue // Skip if ports don't match.\n      }\n      if (!/^[.*]/.test(entry.hostname)) {\n        // No wildcards, so don't proxy only if there is not an exact match.\n        if (hostname === entry.hostname) {\n          return false\n        }\n      } else {\n        // Don't proxy if the hostname ends with the no_proxy host.\n        if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  #parseNoProxy () {\n    const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv\n    const noProxySplit = noProxyValue.split(/[,\\s]/)\n    const noProxyEntries = []\n\n    for (let i = 0; i < noProxySplit.length; i++) {\n      const entry = noProxySplit[i]\n      if (!entry) {\n        continue\n      }\n      const parsed = entry.match(/^(.+):(\\d+)$/)\n      noProxyEntries.push({\n        hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n        port: parsed ? Number.parseInt(parsed[2], 10) : 0\n      })\n    }\n\n    this.#noProxyValue = noProxyValue\n    this.#noProxyEntries = noProxyEntries\n  }\n\n  get #noProxyChanged () {\n    if (this.#opts.noProxy !== undefined) {\n      return false\n    }\n    return this.#noProxyValue !== this.#noProxyEnv\n  }\n\n  get #noProxyEnv () {\n    return process.env.no_proxy ?? process.env.NO_PROXY ?? ''\n  }\n}\n\nmodule.exports = EnvHttpProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHFHQUFxRyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsWUFBWSwrQ0FBK0M7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUNBQWlDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZW52LWh0dHAtcHJveHktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBrQ2xvc2UsIGtEZXN0cm95LCBrQ2xvc2VkLCBrRGVzdHJveWVkLCBrRGlzcGF0Y2gsIGtOb1Byb3h5QWdlbnQsIGtIdHRwUHJveHlBZ2VudCwga0h0dHBzUHJveHlBZ2VudCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL3Byb3h5LWFnZW50JylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5cbmNvbnN0IERFRkFVTFRfUE9SVFMgPSB7XG4gICdodHRwOic6IDgwLFxuICAnaHR0cHM6JzogNDQzXG59XG5cbmNsYXNzIEVudkh0dHBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAjbm9Qcm94eVZhbHVlID0gbnVsbFxuICAjbm9Qcm94eUVudHJpZXMgPSBudWxsXG4gICNvcHRzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy4jb3B0cyA9IG9wdHNcblxuICAgIGNvbnN0IHsgaHR0cFByb3h5LCBodHRwc1Byb3h5LCBub1Byb3h5LCAuLi5hZ2VudE9wdHMgfSA9IG9wdHNcblxuICAgIHRoaXNba05vUHJveHlBZ2VudF0gPSBuZXcgQWdlbnQoYWdlbnRPcHRzKVxuXG4gICAgY29uc3QgSFRUUF9QUk9YWSA9IGh0dHBQcm94eSA/PyBwcm9jZXNzLmVudi5odHRwX3Byb3h5ID8/IHByb2Nlc3MuZW52LkhUVFBfUFJPWFlcbiAgICBpZiAoSFRUUF9QUk9YWSkge1xuICAgICAgdGhpc1trSHR0cFByb3h5QWdlbnRdID0gbmV3IFByb3h5QWdlbnQoeyAuLi5hZ2VudE9wdHMsIHVyaTogSFRUUF9QUk9YWSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIdHRwUHJveHlBZ2VudF0gPSB0aGlzW2tOb1Byb3h5QWdlbnRdXG4gICAgfVxuXG4gICAgY29uc3QgSFRUUFNfUFJPWFkgPSBodHRwc1Byb3h5ID8/IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5ID8/IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZXG4gICAgaWYgKEhUVFBTX1BST1hZKSB7XG4gICAgICB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdID0gbmV3IFByb3h5QWdlbnQoeyAuLi5hZ2VudE9wdHMsIHVyaTogSFRUUFNfUFJPWFkgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSHR0cHNQcm94eUFnZW50XSA9IHRoaXNba0h0dHBQcm94eUFnZW50XVxuICAgIH1cblxuICAgIHRoaXMuI3BhcnNlTm9Qcm94eSgpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwob3B0cy5vcmlnaW4pXG4gICAgY29uc3QgYWdlbnQgPSB0aGlzLiNnZXRQcm94eUFnZW50Rm9yVXJsKHVybClcbiAgICByZXR1cm4gYWdlbnQuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIFtrQ2xvc2VdICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpc1trTm9Qcm94eUFnZW50XS5jbG9zZSgpLFxuICAgICAgIXRoaXNba0h0dHBQcm94eUFnZW50XVtrQ2xvc2VkXSAmJiB0aGlzW2tIdHRwUHJveHlBZ2VudF0uY2xvc2UoKSxcbiAgICAgICF0aGlzW2tIdHRwc1Byb3h5QWdlbnRdW2tDbG9zZWRdICYmIHRoaXNba0h0dHBzUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIF0pXG4gIH1cblxuICBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpc1trTm9Qcm94eUFnZW50XS5kZXN0cm95KGVyciksXG4gICAgICAhdGhpc1trSHR0cFByb3h5QWdlbnRdW2tEZXN0cm95ZWRdICYmIHRoaXNba0h0dHBQcm94eUFnZW50XS5kZXN0cm95KGVyciksXG4gICAgICAhdGhpc1trSHR0cHNQcm94eUFnZW50XVtrRGVzdHJveWVkXSAmJiB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIF0pXG4gIH1cblxuICAjZ2V0UHJveHlBZ2VudEZvclVybCAodXJsKSB7XG4gICAgbGV0IHsgcHJvdG9jb2wsIGhvc3Q6IGhvc3RuYW1lLCBwb3J0IH0gPSB1cmxcblxuICAgIC8vIFN0cmlwcGluZyBwb3J0cyBpbiB0aGlzIHdheSBpbnN0ZWFkIG9mIHVzaW5nIHBhcnNlZFVybC5ob3N0bmFtZSB0byBtYWtlXG4gICAgLy8gc3VyZSB0aGF0IHRoZSBicmFja2V0cyBhcm91bmQgSVB2NiBhZGRyZXNzZXMgYXJlIGtlcHQuXG4gICAgaG9zdG5hbWUgPSBob3N0bmFtZS5yZXBsYWNlKC86XFxkKiQvLCAnJykudG9Mb3dlckNhc2UoKVxuICAgIHBvcnQgPSBOdW1iZXIucGFyc2VJbnQocG9ydCwgMTApIHx8IERFRkFVTFRfUE9SVFNbcHJvdG9jb2xdIHx8IDBcbiAgICBpZiAoIXRoaXMuI3Nob3VsZFByb3h5KGhvc3RuYW1lLCBwb3J0KSkge1xuICAgICAgcmV0dXJuIHRoaXNba05vUHJveHlBZ2VudF1cbiAgICB9XG4gICAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgcmV0dXJuIHRoaXNba0h0dHBzUHJveHlBZ2VudF1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0h0dHBQcm94eUFnZW50XVxuICB9XG5cbiAgI3Nob3VsZFByb3h5IChob3N0bmFtZSwgcG9ydCkge1xuICAgIGlmICh0aGlzLiNub1Byb3h5Q2hhbmdlZCkge1xuICAgICAgdGhpcy4jcGFyc2VOb1Byb3h5KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jbm9Qcm94eUVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZSAvLyBBbHdheXMgcHJveHkgaWYgTk9fUFJPWFkgaXMgbm90IHNldCBvciBlbXB0eS5cbiAgICB9XG4gICAgaWYgKHRoaXMuI25vUHJveHlWYWx1ZSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gTmV2ZXIgcHJveHkgaWYgd2lsZGNhcmQgaXMgc2V0LlxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jbm9Qcm94eUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy4jbm9Qcm94eUVudHJpZXNbaV1cbiAgICAgIGlmIChlbnRyeS5wb3J0ICYmIGVudHJ5LnBvcnQgIT09IHBvcnQpIHtcbiAgICAgICAgY29udGludWUgLy8gU2tpcCBpZiBwb3J0cyBkb24ndCBtYXRjaC5cbiAgICAgIH1cbiAgICAgIGlmICghL15bLipdLy50ZXN0KGVudHJ5Lmhvc3RuYW1lKSkge1xuICAgICAgICAvLyBObyB3aWxkY2FyZHMsIHNvIGRvbid0IHByb3h5IG9ubHkgaWYgdGhlcmUgaXMgbm90IGFuIGV4YWN0IG1hdGNoLlxuICAgICAgICBpZiAoaG9zdG5hbWUgPT09IGVudHJ5Lmhvc3RuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHByb3h5IGlmIHRoZSBob3N0bmFtZSBlbmRzIHdpdGggdGhlIG5vX3Byb3h5IGhvc3QuXG4gICAgICAgIGlmIChob3N0bmFtZS5lbmRzV2l0aChlbnRyeS5ob3N0bmFtZS5yZXBsYWNlKC9eXFwqLywgJycpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gICNwYXJzZU5vUHJveHkgKCkge1xuICAgIGNvbnN0IG5vUHJveHlWYWx1ZSA9IHRoaXMuI29wdHMubm9Qcm94eSA/PyB0aGlzLiNub1Byb3h5RW52XG4gICAgY29uc3Qgbm9Qcm94eVNwbGl0ID0gbm9Qcm94eVZhbHVlLnNwbGl0KC9bLFxcc10vKVxuICAgIGNvbnN0IG5vUHJveHlFbnRyaWVzID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9Qcm94eVNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IG5vUHJveHlTcGxpdFtpXVxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkID0gZW50cnkubWF0Y2goL14oLispOihcXGQrKSQvKVxuICAgICAgbm9Qcm94eUVudHJpZXMucHVzaCh7XG4gICAgICAgIGhvc3RuYW1lOiAocGFyc2VkID8gcGFyc2VkWzFdIDogZW50cnkpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHBvcnQ6IHBhcnNlZCA/IE51bWJlci5wYXJzZUludChwYXJzZWRbMl0sIDEwKSA6IDBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy4jbm9Qcm94eVZhbHVlID0gbm9Qcm94eVZhbHVlXG4gICAgdGhpcy4jbm9Qcm94eUVudHJpZXMgPSBub1Byb3h5RW50cmllc1xuICB9XG5cbiAgZ2V0ICNub1Byb3h5Q2hhbmdlZCAoKSB7XG4gICAgaWYgKHRoaXMuI29wdHMubm9Qcm94eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI25vUHJveHlWYWx1ZSAhPT0gdGhpcy4jbm9Qcm94eUVudlxuICB9XG5cbiAgZ2V0ICNub1Byb3h5RW52ICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYubm9fcHJveHkgPz8gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgPz8gJydcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVudkh0dHBQcm94eUFnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048\nconst kMask = kSize - 1\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// | undefined | <-- top       |   item    |                  |   item    |\n// | undefined |               |   item    |                  |   item    |\n// | undefined |               | undefined | <-- top  top --> | undefined |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// | undefined |                               |   item    |\n// | undefined |                               |   item    |\n// |   item    | <-- bottom            top --> | undefined |\n// |   item    |                               | undefined |\n// | undefined | <-- top            bottom --> |   item    |\n// | undefined |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\n/**\n * @type {FixedCircularBuffer}\n * @template T\n */\nclass FixedCircularBuffer {\n  /** @type {number} */\n  bottom = 0\n  /** @type {number} */\n  top = 0\n  /** @type {Array<T|undefined>} */\n  list = new Array(kSize).fill(undefined)\n  /** @type {T|null} */\n  next = null\n\n  /** @returns {boolean} */\n  isEmpty () {\n    return this.top === this.bottom\n  }\n\n  /** @returns {boolean} */\n  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom\n  }\n\n  /**\n   * @param {T} data\n   * @returns {void}\n   */\n  push (data) {\n    this.list[this.top] = data\n    this.top = (this.top + 1) & kMask\n  }\n\n  /** @returns {T|null} */\n  shift () {\n    const nextItem = this.list[this.bottom]\n    if (nextItem === undefined) { return null }\n    this.list[this.bottom] = undefined\n    this.bottom = (this.bottom + 1) & kMask\n    return nextItem\n  }\n}\n\n/**\n * @template T\n */\nmodule.exports = class FixedQueue {\n  constructor () {\n    /** @type {FixedCircularBuffer<T>} */\n    this.head = this.tail = new FixedCircularBuffer()\n  }\n\n  /** @returns {boolean} */\n  isEmpty () {\n    return this.head.isEmpty()\n  }\n\n  /** @param {T} data */\n  push (data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer()\n    }\n    this.head.push(data)\n  }\n\n  /** @returns {T|null} */\n  shift () {\n    const tail = this.tail\n    const next = tail.shift()\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next\n      tail.next = null\n    }\n    return next\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZml4ZWQtcXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIEV4dHJhY3RlZCBmcm9tIG5vZGUvbGliL2ludGVybmFsL2ZpeGVkX3F1ZXVlLmpzXG5cbi8vIEN1cnJlbnRseSBvcHRpbWFsIHF1ZXVlIHNpemUsIHRlc3RlZCBvbiBWOCA2LjAgLSA2LjYuIE11c3QgYmUgcG93ZXIgb2YgdHdvLlxuY29uc3Qga1NpemUgPSAyMDQ4XG5jb25zdCBrTWFzayA9IGtTaXplIC0gMVxuXG4vLyBUaGUgRml4ZWRRdWV1ZSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdseS1saW5rZWQgbGlzdCBvZiBmaXhlZC1zaXplXG4vLyBjaXJjdWxhciBidWZmZXJzLiBJdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICBoZWFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxcbi8vICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4vLyArLS0tLS0tLS0tLS0rIDwtLS0tLVxcICAgICAgICstLS0tLS0tLS0tLSsgPC0tLS0tLVxcICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgXFwtLS0tLSB8ICAgbmV4dCAgICB8ICAgICAgICAgXFwtLS0tLS0tIHwgICBuZXh0ICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICB8IHVuZGVmaW5lZCB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCB1bmRlZmluZWQgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8IHVuZGVmaW5lZCB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCB1bmRlZmluZWQgfCA8LS0gdG9wICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8IHVuZGVmaW5lZCB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgdW5kZWZpbmVkIHwgICAgICAgICAgICAgICB8IHVuZGVmaW5lZCB8IDwtLSB0b3AgIHRvcCAtLT4gfCB1bmRlZmluZWQgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gT3IsIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNpcmN1bGFyIGJ1ZmZlciwgaXQgbG9va3Mgc29tZXRoaW5nXG4vLyBsaWtlIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAgaGVhZCAgIHRhaWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgdGFpbFxuLy8gICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8XG4vLyAgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF0gICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgdW5kZWZpbmVkIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCB1bmRlZmluZWQgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgICAgICB0b3AgLS0+IHwgdW5kZWZpbmVkIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1bmRlZmluZWQgfFxuLy8gfCB1bmRlZmluZWQgfCA8LS0gdG9wICAgICAgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8IHVuZGVmaW5lZCB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIEFkZGluZyBhIHZhbHVlIG1lYW5zIG1vdmluZyBgdG9wYCBmb3J3YXJkIGJ5IG9uZSwgcmVtb3ZpbmcgbWVhbnNcbi8vIG1vdmluZyBgYm90dG9tYCBmb3J3YXJkIGJ5IG9uZS4gQWZ0ZXIgcmVhY2hpbmcgdGhlIGVuZCwgdGhlIHF1ZXVlXG4vLyB3cmFwcyBhcm91bmQuXG4vL1xuLy8gV2hlbiBgdG9wID09PSBib3R0b21gIHRoZSBjdXJyZW50IHF1ZXVlIGlzIGVtcHR5IGFuZCB3aGVuXG4vLyBgdG9wICsgMSA9PT0gYm90dG9tYCBpdCdzIGZ1bGwuIFRoaXMgd2FzdGVzIGEgc2luZ2xlIHNwYWNlIG9mIHN0b3JhZ2Vcbi8vIGJ1dCBhbGxvd3MgbXVjaCBxdWlja2VyIGNoZWNrcy5cblxuLyoqXG4gKiBAdHlwZSB7Rml4ZWRDaXJjdWxhckJ1ZmZlcn1cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIEZpeGVkQ2lyY3VsYXJCdWZmZXIge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgYm90dG9tID0gMFxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdG9wID0gMFxuICAvKiogQHR5cGUge0FycmF5PFR8dW5kZWZpbmVkPn0gKi9cbiAgbGlzdCA9IG5ldyBBcnJheShrU2l6ZSkuZmlsbCh1bmRlZmluZWQpXG4gIC8qKiBAdHlwZSB7VHxudWxsfSAqL1xuICBuZXh0ID0gbnVsbFxuXG4gIC8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wID09PSB0aGlzLmJvdHRvbVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICBpc0Z1bGwgKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBkYXRhXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVzaCAoZGF0YSkge1xuICAgIHRoaXMubGlzdFt0aGlzLnRvcF0gPSBkYXRhXG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrXG4gIH1cblxuICAvKiogQHJldHVybnMge1R8bnVsbH0gKi9cbiAgc2hpZnQgKCkge1xuICAgIGNvbnN0IG5leHRJdGVtID0gdGhpcy5saXN0W3RoaXMuYm90dG9tXVxuICAgIGlmIChuZXh0SXRlbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLmxpc3RbdGhpcy5ib3R0b21dID0gdW5kZWZpbmVkXG4gICAgdGhpcy5ib3R0b20gPSAodGhpcy5ib3R0b20gKyAxKSAmIGtNYXNrXG4gICAgcmV0dXJuIG5leHRJdGVtXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpeGVkUXVldWUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqIEB0eXBlIHtGaXhlZENpcmN1bGFyQnVmZmVyPFQ+fSAqL1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKClcbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KClcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge1R9IGRhdGEgKi9cbiAgcHVzaCAoZGF0YSkge1xuICAgIGlmICh0aGlzLmhlYWQuaXNGdWxsKCkpIHtcbiAgICAgIC8vIEhlYWQgaXMgZnVsbDogQ3JlYXRlcyBhIG5ldyBxdWV1ZSwgc2V0cyB0aGUgb2xkIHF1ZXVlJ3MgYC5uZXh0YCB0byBpdCxcbiAgICAgIC8vIGFuZCBzZXRzIGl0IGFzIHRoZSBuZXcgbWFpbiBxdWV1ZS5cbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0ID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKVxuICAgIH1cbiAgICB0aGlzLmhlYWQucHVzaChkYXRhKVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtUfG51bGx9ICovXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsXG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKVxuICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcXVldWUsIGl0IGZvcm1zIHRoZSBuZXcgdGFpbC5cbiAgICAgIHRoaXMudGFpbCA9IHRhaWwubmV4dFxuICAgICAgdGFpbC5uZXh0ID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/h2c-client.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\n\nclass H2CClient extends Client {\n  constructor (origin, clientOpts) {\n    if (typeof origin === 'string') {\n      origin = new URL(origin)\n    }\n\n    if (origin.protocol !== 'http:') {\n      throw new InvalidArgumentError(\n        'h2c-client: Only h2c protocol is supported'\n      )\n    }\n\n    const { connect, maxConcurrentStreams, pipelining, ...opts } =\n            clientOpts ?? {}\n    let defaultMaxConcurrentStreams = 100\n    let defaultPipelining = 100\n\n    if (\n      maxConcurrentStreams != null &&\n            Number.isInteger(maxConcurrentStreams) &&\n            maxConcurrentStreams > 0\n    ) {\n      defaultMaxConcurrentStreams = maxConcurrentStreams\n    }\n\n    if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {\n      defaultPipelining = pipelining\n    }\n\n    if (defaultPipelining > defaultMaxConcurrentStreams) {\n      throw new InvalidArgumentError(\n        'h2c-client: pipelining cannot be greater than maxConcurrentStreams'\n      )\n    }\n\n    super(origin, {\n      ...opts,\n      maxConcurrentStreams: defaultMaxConcurrentStreams,\n      pipelining: defaultPipelining,\n      allowH2: true,\n      useH2c: true\n    })\n  }\n}\n\nmodule.exports = H2CClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2gyYy1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsc0VBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHFEQUFxRDtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxoMmMtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5cbmNsYXNzIEgyQ0NsaWVudCBleHRlbmRzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIGNsaWVudE9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9yaWdpbiA9IG5ldyBVUkwob3JpZ2luKVxuICAgIH1cblxuICAgIGlmIChvcmlnaW4ucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ2gyYy1jbGllbnQ6IE9ubHkgaDJjIHByb3RvY29sIGlzIHN1cHBvcnRlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbm5lY3QsIG1heENvbmN1cnJlbnRTdHJlYW1zLCBwaXBlbGluaW5nLCAuLi5vcHRzIH0gPVxuICAgICAgICAgICAgY2xpZW50T3B0cyA/PyB7fVxuICAgIGxldCBkZWZhdWx0TWF4Q29uY3VycmVudFN0cmVhbXMgPSAxMDBcbiAgICBsZXQgZGVmYXVsdFBpcGVsaW5pbmcgPSAxMDBcblxuICAgIGlmIChcbiAgICAgIG1heENvbmN1cnJlbnRTdHJlYW1zICE9IG51bGwgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIobWF4Q29uY3VycmVudFN0cmVhbXMpICYmXG4gICAgICAgICAgICBtYXhDb25jdXJyZW50U3RyZWFtcyA+IDBcbiAgICApIHtcbiAgICAgIGRlZmF1bHRNYXhDb25jdXJyZW50U3RyZWFtcyA9IG1heENvbmN1cnJlbnRTdHJlYW1zXG4gICAgfVxuXG4gICAgaWYgKHBpcGVsaW5pbmcgIT0gbnVsbCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHBpcGVsaW5pbmcpICYmIHBpcGVsaW5pbmcgPiAwKSB7XG4gICAgICBkZWZhdWx0UGlwZWxpbmluZyA9IHBpcGVsaW5pbmdcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFBpcGVsaW5pbmcgPiBkZWZhdWx0TWF4Q29uY3VycmVudFN0cmVhbXMpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ2gyYy1jbGllbnQ6IHBpcGVsaW5pbmcgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhDb25jdXJyZW50U3RyZWFtcydcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdXBlcihvcmlnaW4sIHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBtYXhDb25jdXJyZW50U3RyZWFtczogZGVmYXVsdE1heENvbmN1cnJlbnRTdHJlYW1zLFxuICAgICAgcGlwZWxpbmluZzogZGVmYXVsdFBpcGVsaW5pbmcsXG4gICAgICBhbGxvd0gyOiB0cnVlLFxuICAgICAgdXNlSDJjOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEgyQ0NsaWVudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { PoolStats } = __webpack_require__(/*! ../util/stats.js */ \"(rsc)/./node_modules/undici/lib/util/stats.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\n\nclass PoolBase extends DispatcherBase {\n  [kQueue] = new FixedQueue();\n\n  [kQueued] = 0;\n\n  [kClients] = [];\n\n  [kNeedDrain] = false;\n\n  [kOnDrain] (client, origin, targets) {\n    const queue = this[kQueue]\n\n    let needDrain = false\n\n    while (!needDrain) {\n      const item = queue.shift()\n      if (!item) {\n        break\n      }\n      this[kQueued]--\n      needDrain = !client.dispatch(item.opts, item.handler)\n    }\n\n    client[kNeedDrain] = needDrain\n\n    if (!needDrain && this[kNeedDrain]) {\n      this[kNeedDrain] = false\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    if (this[kClosedResolve] && queue.isEmpty()) {\n      const closeAll = new Array(this[kClients].length)\n      for (let i = 0; i < this[kClients].length; i++) {\n        closeAll[i] = this[kClients][i].close()\n      }\n      return Promise.all(closeAll)\n        .then(this[kClosedResolve])\n    }\n  }\n\n  [kOnConnect] = (origin, targets) => {\n    this.emit('connect', origin, [this, ...targets])\n  };\n\n  [kOnDisconnect] = (origin, targets, err) => {\n    this.emit('disconnect', origin, [this, ...targets], err)\n  };\n\n  [kOnConnectionError] = (origin, targets, err) => {\n    this.emit('connectionError', origin, [this, ...targets], err)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    let ret = 0\n    for (const { [kConnected]: connected } of this[kClients]) {\n      ret += connected\n    }\n    return ret\n  }\n\n  get [kFree] () {\n    let ret = 0\n    for (const { [kConnected]: connected, [kNeedDrain]: needDrain } of this[kClients]) {\n      ret += connected && !needDrain\n    }\n    return ret\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return new PoolStats(this)\n  }\n\n  [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      const closeAll = new Array(this[kClients].length)\n      for (let i = 0; i < this[kClients].length; i++) {\n        closeAll[i] = this[kClients][i].close()\n      }\n      return Promise.all(closeAll)\n    } else {\n      return new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const destroyAll = new Array(this[kClients].length)\n    for (let i = 0; i < this[kClients].length; i++) {\n      destroyAll[i] = this[kClients][i].destroy(err)\n    }\n    return Promise.all(destroyAll)\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain].bind(this, client))\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client, client[kUrl], [client, this])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHVFQUFrQjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsUUFBUSxrR0FBa0csRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjs7QUFFckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQW1EO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxwb29sLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgUG9vbFN0YXRzIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXRzLmpzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4vZml4ZWQtcXVldWUnKVxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSwga1J1bm5pbmcsIGtQZW5kaW5nLCBrUXVldWVkLCBrQnVzeSwga0ZyZWUsIGtVcmwsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY29uc3Qga0NsaWVudHMgPSBTeW1ib2woJ2NsaWVudHMnKVxuY29uc3Qga05lZWREcmFpbiA9IFN5bWJvbCgnbmVlZERyYWluJylcbmNvbnN0IGtRdWV1ZSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2Nsb3NlZCByZXNvbHZlJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbCgnZ2V0IGRpc3BhdGNoZXInKVxuY29uc3Qga0FkZENsaWVudCA9IFN5bWJvbCgnYWRkIGNsaWVudCcpXG5jb25zdCBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKCdyZW1vdmUgY2xpZW50JylcblxuY2xhc3MgUG9vbEJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIFtrUXVldWVdID0gbmV3IEZpeGVkUXVldWUoKTtcblxuICBba1F1ZXVlZF0gPSAwO1xuXG4gIFtrQ2xpZW50c10gPSBbXTtcblxuICBba05lZWREcmFpbl0gPSBmYWxzZTtcblxuICBba09uRHJhaW5dIChjbGllbnQsIG9yaWdpbiwgdGFyZ2V0cykge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpc1trUXVldWVdXG5cbiAgICBsZXQgbmVlZERyYWluID0gZmFsc2VcblxuICAgIHdoaWxlICghbmVlZERyYWluKSB7XG4gICAgICBjb25zdCBpdGVtID0gcXVldWUuc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB0aGlzW2tRdWV1ZWRdLS1cbiAgICAgIG5lZWREcmFpbiA9ICFjbGllbnQuZGlzcGF0Y2goaXRlbS5vcHRzLCBpdGVtLmhhbmRsZXIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tOZWVkRHJhaW5dID0gbmVlZERyYWluXG5cbiAgICBpZiAoIW5lZWREcmFpbiAmJiB0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gZmFsc2VcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0gJiYgcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCBjbG9zZUFsbCA9IG5ldyBBcnJheSh0aGlzW2tDbGllbnRzXS5sZW5ndGgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNba0NsaWVudHNdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb3NlQWxsW2ldID0gdGhpc1trQ2xpZW50c11baV0uY2xvc2UoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNsb3NlQWxsKVxuICAgICAgICAudGhlbih0aGlzW2tDbG9zZWRSZXNvbHZlXSlcbiAgICB9XG4gIH1cblxuICBba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10pXG4gIH07XG5cbiAgW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgfTtcblxuICBba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tDb25uZWN0ZWRdOiBjb25uZWN0ZWQgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IGNvbm5lY3RlZFxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tGcmVlXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tDb25uZWN0ZWRdOiBjb25uZWN0ZWQsIFtrTmVlZERyYWluXTogbmVlZERyYWluIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBjb25uZWN0ZWQgJiYgIW5lZWREcmFpblxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tQZW5kaW5nXTogcGVuZGluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcGVuZGluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tSdW5uaW5nXTogcnVubmluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcnVubmluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tTaXplXTogc2l6ZSB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gc2l6ZVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIHJldHVybiBuZXcgUG9vbFN0YXRzKHRoaXMpXG4gIH1cblxuICBba0Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNba1F1ZXVlXS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IGNsb3NlQWxsID0gbmV3IEFycmF5KHRoaXNba0NsaWVudHNdLmxlbmd0aClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvc2VBbGxbaV0gPSB0aGlzW2tDbGllbnRzXVtpXS5jbG9zZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2xvc2VBbGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgY29uc3QgZGVzdHJveUFsbCA9IG5ldyBBcnJheSh0aGlzW2tDbGllbnRzXS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzW2tDbGllbnRzXS5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdHJveUFsbFtpXSA9IHRoaXNba0NsaWVudHNdW2ldLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZGVzdHJveUFsbClcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0dldERpc3BhdGNoZXJdKClcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba1F1ZXVlXS5wdXNoKHsgb3B0cywgaGFuZGxlciB9KVxuICAgICAgdGhpc1trUXVldWVkXSsrXG4gICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuICAgIH1cblxuICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgW2tBZGRDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnRcbiAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXS5iaW5kKHRoaXMsIGNsaWVudCkpXG4gICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgdGhpc1trQ2xpZW50c10ucHVzaChjbGllbnQpXG5cbiAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNba09uRHJhaW5dKGNsaWVudCwgY2xpZW50W2tVcmxdLCBbY2xpZW50LCB0aGlzXSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgW2tSZW1vdmVDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnQuY2xvc2UoKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZihjbGllbnQpXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gdGhpc1trQ2xpZW50c10uc29tZShkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher,\n  kRemoveClient\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    clientTtl,\n    ...options\n  } = {}) {\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    super()\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n\n    this.on('connect', (origin, targets) => {\n      if (clientTtl != null && clientTtl > 0) {\n        for (const target of targets) {\n          Object.assign(target, { ttl: Date.now() })\n        }\n      }\n    })\n\n    this.on('connectionError', (origin, targets, error) => {\n      // If a connection error occurs, we remove the client from the pool,\n      // and emit a connectionError event. They will not be re-used.\n      // Fixes https://github.com/nodejs/undici/issues/3895\n      for (const target of targets) {\n        // Do not use kRemoveClient here, as it will close the client,\n        // but the client cannot be closed in this state.\n        const idx = this[kClients].indexOf(target)\n        if (idx !== -1) {\n          this[kClients].splice(idx, 1)\n        }\n      }\n    })\n  }\n\n  [kGetDispatcher] () {\n    const clientTtlOption = this[kOptions].clientTtl\n    for (const client of this[kClients]) {\n      // check ttl of client and if it's stale, remove it from the pool\n      if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && ((Date.now() - client.ttl) > clientTtlOption)) {\n        this[kRemoveClient](client)\n      } else if (!client[kNeedDrain]) {\n        return client\n      }\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN6QixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakM7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWlCOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBbUQ7QUFDekc7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxwb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga0dldERpc3BhdGNoZXIsXG4gIGtSZW1vdmVDbGllbnRcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtVcmwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtDb25uZWN0aW9ucyA9IFN5bWJvbCgnY29ubmVjdGlvbnMnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIGNvbm5lY3Rpb25zLFxuICAgIGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSxcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIHRscyxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBzb2NrZXRQYXRoLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIGFsbG93SDIsXG4gICAgY2xpZW50VHRsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHt9KSB7XG4gICAgaWYgKGNvbm5lY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdGlvbnMpIHx8IGNvbm5lY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7XG4gICAgICAgIC4uLnRscyxcbiAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgICAgIGFsbG93SDIsXG4gICAgICAgIHNvY2tldFBhdGgsXG4gICAgICAgIHRpbWVvdXQ6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAuLi4odHlwZW9mIGF1dG9TZWxlY3RGYW1pbHkgPT09ICdib29sZWFuJyA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHN1cGVyKClcblxuICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGxcbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbihvcmlnaW4pXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0LCBhbGxvd0gyLCBjbGllbnRUdGwgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcblxuICAgIHRoaXMub24oJ2Nvbm5lY3QnLCAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBpZiAoY2xpZW50VHRsICE9IG51bGwgJiYgY2xpZW50VHRsID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHsgdHRsOiBEYXRlLm5vdygpIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbignY29ubmVjdGlvbkVycm9yJywgKG9yaWdpbiwgdGFyZ2V0cywgZXJyb3IpID0+IHtcbiAgICAgIC8vIElmIGEgY29ubmVjdGlvbiBlcnJvciBvY2N1cnMsIHdlIHJlbW92ZSB0aGUgY2xpZW50IGZyb20gdGhlIHBvb2wsXG4gICAgICAvLyBhbmQgZW1pdCBhIGNvbm5lY3Rpb25FcnJvciBldmVudC4gVGhleSB3aWxsIG5vdCBiZSByZS11c2VkLlxuICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzM4OTVcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgLy8gRG8gbm90IHVzZSBrUmVtb3ZlQ2xpZW50IGhlcmUsIGFzIGl0IHdpbGwgY2xvc2UgdGhlIGNsaWVudCxcbiAgICAgICAgLy8gYnV0IHRoZSBjbGllbnQgY2Fubm90IGJlIGNsb3NlZCBpbiB0aGlzIHN0YXRlLlxuICAgICAgICBjb25zdCBpZHggPSB0aGlzW2tDbGllbnRzXS5pbmRleE9mKHRhcmdldClcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIGNvbnN0IGNsaWVudFR0bE9wdGlvbiA9IHRoaXNba09wdGlvbnNdLmNsaWVudFR0bFxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICAvLyBjaGVjayB0dGwgb2YgY2xpZW50IGFuZCBpZiBpdCdzIHN0YWxlLCByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICAgICAgaWYgKGNsaWVudFR0bE9wdGlvbiAhPSBudWxsICYmIGNsaWVudFR0bE9wdGlvbiA+IDAgJiYgY2xpZW50LnR0bCAmJiAoKERhdGUubm93KCkgLSBjbGllbnQudHRsKSA+IGNsaWVudFR0bE9wdGlvbikpIHtcbiAgICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShjbGllbnQpXG4gICAgICB9IGVsc2UgaWYgKCFjbGllbnRba05lZWREcmFpbl0pIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kProxy, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\nconst kTunnelProxy = Symbol('tunnel proxy')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nconst noop = () => {}\n\nfunction defaultAgentFactory (origin, opts) {\n  if (opts.connections === 1) {\n    return new Client(origin, opts)\n  }\n  return new Pool(origin, opts)\n}\n\nclass Http1ProxyWrapper extends DispatcherBase {\n  #client\n\n  constructor (proxyUrl, { headers = {}, connect, factory }) {\n    if (!proxyUrl) {\n      throw new InvalidArgumentError('Proxy URL is mandatory')\n    }\n\n    super()\n\n    this[kProxyHeaders] = headers\n    if (factory) {\n      this.#client = factory(proxyUrl, { connect })\n    } else {\n      this.#client = new Client(proxyUrl, { connect })\n    }\n  }\n\n  [kDispatch] (opts, handler) {\n    const onHeaders = handler.onHeaders\n    handler.onHeaders = function (statusCode, data, resume) {\n      if (statusCode === 407) {\n        if (typeof handler.onError === 'function') {\n          handler.onError(new InvalidArgumentError('Proxy Authentication Required (407)'))\n        }\n        return\n      }\n      if (onHeaders) onHeaders.call(this, statusCode, data, resume)\n    }\n\n    // Rewrite request as an HTTP1 Proxy request, without tunneling.\n    const {\n      origin,\n      path = '/',\n      headers = {}\n    } = opts\n\n    opts.path = origin + path\n\n    if (!('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(origin)\n      headers.host = host\n    }\n    opts.headers = { ...this[kProxyHeaders], ...headers }\n\n    return this.#client[kDispatch](opts, handler)\n  }\n\n  [kClose] () {\n    return this.#client.close()\n  }\n\n  [kDestroy] (err) {\n    return this.#client.destroy(err)\n  }\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const { proxyTunnel = true } = opts\n\n    super()\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n    this[kTunnelProxy] = proxyTunnel\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n\n    const agentFactory = opts.factory || defaultAgentFactory\n    const factory = (origin, options) => {\n      const { protocol } = new URL(origin)\n      if (!this[kTunnelProxy] && protocol === 'http:' && this[kProxy].protocol === 'http:') {\n        return new Http1ProxyWrapper(this[kProxy].uri, {\n          headers: this[kProxyHeaders],\n          connect,\n          factory: agentFactory\n        })\n      }\n      return agentFactory(origin, options)\n    }\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      factory,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const connectParams = {\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host,\n              ...(opts.connections == null || opts.connections > 0 ? { 'proxy-connection': 'keep-alive' } : {})\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          }\n          const { socket, statusCode } = await this[kClient].connect(connectParams)\n          if (statusCode !== 200) {\n            socket.on('error', noop).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n            return\n          }\n\n          if (channels.proxyConnected.hasSubscribers) {\n            channels.proxyConnected.publish({\n              socket,\n              connectParams\n            })\n          }\n\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  [kClose] () {\n    return Promise.all([\n      this[kAgent].close(),\n      this[kClient].close()\n    ])\n  }\n\n  [kDestroy] () {\n    return Promise.all([\n      this[kAgent].destroy(),\n      this[kClient].destroy()\n    ])\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsc0NBQXNDLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekUsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrRUFBUTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsUUFBUSx3RUFBd0UsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUMxRyx1QkFBdUIsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLHNFQUFVO0FBQ2pDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0ZBQXFCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixZQUFZLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xELE1BQU07QUFDTiw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7O0FBRUEsWUFBWSxxQkFBcUI7O0FBRWpDOztBQUVBO0FBQ0EsWUFBWSw0RUFBNEU7O0FBRXhGLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxlQUFlLDZCQUE2QixHQUFHLDZCQUE2QixzQkFBc0I7QUFDOUo7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RCw4Q0FBOEMsb0JBQW9COztBQUVsRTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxtQ0FBbUMsSUFBSTtBQUM5RyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFFQUFxRTtBQUNsRixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccHJveHktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1Byb3h5LCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzJylcblxuY29uc3Qga0FnZW50ID0gU3ltYm9sKCdwcm94eSBhZ2VudCcpXG5jb25zdCBrQ2xpZW50ID0gU3ltYm9sKCdwcm94eSBjbGllbnQnKVxuY29uc3Qga1Byb3h5SGVhZGVycyA9IFN5bWJvbCgncHJveHkgaGVhZGVycycpXG5jb25zdCBrUmVxdWVzdFRscyA9IFN5bWJvbCgncmVxdWVzdCB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga1Byb3h5VGxzID0gU3ltYm9sKCdwcm94eSB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbCgnY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvbicpXG5jb25zdCBrVHVubmVsUHJveHkgPSBTeW1ib2woJ3R1bm5lbCBwcm94eScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbFBvcnQgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MFxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0QWdlbnRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgaWYgKG9wdHMuY29ubmVjdGlvbnMgPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpXG4gIH1cbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgSHR0cDFQcm94eVdyYXBwZXIgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICNjbGllbnRcblxuICBjb25zdHJ1Y3RvciAocHJveHlVcmwsIHsgaGVhZGVycyA9IHt9LCBjb25uZWN0LCBmYWN0b3J5IH0pIHtcbiAgICBpZiAoIXByb3h5VXJsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IFVSTCBpcyBtYW5kYXRvcnknKVxuICAgIH1cblxuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSBoZWFkZXJzXG4gICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgIHRoaXMuI2NsaWVudCA9IGZhY3RvcnkocHJveHlVcmwsIHsgY29ubmVjdCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNjbGllbnQgPSBuZXcgQ2xpZW50KHByb3h5VXJsLCB7IGNvbm5lY3QgfSlcbiAgICB9XG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9uSGVhZGVycyA9IGhhbmRsZXIub25IZWFkZXJzXG4gICAgaGFuZGxlci5vbkhlYWRlcnMgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgZGF0YSwgcmVzdW1lKSB7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDA3KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaGFuZGxlci5vbkVycm9yKG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQgKDQwNyknKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChvbkhlYWRlcnMpIG9uSGVhZGVycy5jYWxsKHRoaXMsIHN0YXR1c0NvZGUsIGRhdGEsIHJlc3VtZSlcbiAgICB9XG5cbiAgICAvLyBSZXdyaXRlIHJlcXVlc3QgYXMgYW4gSFRUUDEgUHJveHkgcmVxdWVzdCwgd2l0aG91dCB0dW5uZWxpbmcuXG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luLFxuICAgICAgcGF0aCA9ICcvJyxcbiAgICAgIGhlYWRlcnMgPSB7fVxuICAgIH0gPSBvcHRzXG5cbiAgICBvcHRzLnBhdGggPSBvcmlnaW4gKyBwYXRoXG5cbiAgICBpZiAoISgnaG9zdCcgaW4gaGVhZGVycykgJiYgISgnSG9zdCcgaW4gaGVhZGVycykpIHtcbiAgICAgIGNvbnN0IHsgaG9zdCB9ID0gbmV3IFVSTChvcmlnaW4pXG4gICAgICBoZWFkZXJzLmhvc3QgPSBob3N0XG4gICAgfVxuICAgIG9wdHMuaGVhZGVycyA9IHsgLi4udGhpc1trUHJveHlIZWFkZXJzXSwgLi4uaGVhZGVycyB9XG5cbiAgICByZXR1cm4gdGhpcy4jY2xpZW50W2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIFtrQ2xvc2VdICgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50LmNsb3NlKClcbiAgfVxuXG4gIFtrRGVzdHJveV0gKGVycikge1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQuZGVzdHJveShlcnIpXG4gIH1cbn1cblxuY2xhc3MgUHJveHlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiAhKG9wdHMgaW5zdGFuY2VvZiBVUkwpICYmICFvcHRzLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgdXJpIGlzIG1hbmRhdG9yeScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjbGllbnRGYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnkgfSA9IG9wdHNcbiAgICBpZiAodHlwZW9mIGNsaWVudEZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy5jbGllbnRGYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcHJveHlUdW5uZWwgPSB0cnVlIH0gPSBvcHRzXG5cbiAgICBzdXBlcigpXG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLiNnZXRVcmwob3B0cylcbiAgICBjb25zdCB7IGhyZWYsIG9yaWdpbiwgcG9ydCwgcHJvdG9jb2wsIHVzZXJuYW1lLCBwYXNzd29yZCwgaG9zdG5hbWU6IHByb3h5SG9zdG5hbWUgfSA9IHVybFxuXG4gICAgdGhpc1trUHJveHldID0geyB1cmk6IGhyZWYsIHByb3RvY29sIH1cbiAgICB0aGlzW2tSZXF1ZXN0VGxzXSA9IG9wdHMucmVxdWVzdFRsc1xuICAgIHRoaXNba1Byb3h5VGxzXSA9IG9wdHMucHJveHlUbHNcbiAgICB0aGlzW2tQcm94eUhlYWRlcnNdID0gb3B0cy5oZWFkZXJzIHx8IHt9XG4gICAgdGhpc1trVHVubmVsUHJveHldID0gcHJveHlUdW5uZWxcblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfSBlbHNlIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gXG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuXG4gICAgY29uc3QgYWdlbnRGYWN0b3J5ID0gb3B0cy5mYWN0b3J5IHx8IGRlZmF1bHRBZ2VudEZhY3RvcnlcbiAgICBjb25zdCBmYWN0b3J5ID0gKG9yaWdpbiwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgeyBwcm90b2NvbCB9ID0gbmV3IFVSTChvcmlnaW4pXG4gICAgICBpZiAoIXRoaXNba1R1bm5lbFByb3h5XSAmJiBwcm90b2NvbCA9PT0gJ2h0dHA6JyAmJiB0aGlzW2tQcm94eV0ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdHRwMVByb3h5V3JhcHBlcih0aGlzW2tQcm94eV0udXJpLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpc1trUHJveHlIZWFkZXJzXSxcbiAgICAgICAgICBjb25uZWN0LFxuICAgICAgICAgIGZhY3Rvcnk6IGFnZW50RmFjdG9yeVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFnZW50RmFjdG9yeShvcmlnaW4sIG9wdGlvbnMpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHVybCwgeyBjb25uZWN0IH0pXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmYWN0b3J5LFxuICAgICAgY29ubmVjdDogYXN5bmMgKG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0ZWRQYXRoID0gb3B0cy5ob3N0XG4gICAgICAgIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICAgICAgcmVxdWVzdGVkUGF0aCArPSBgOiR7ZGVmYXVsdFByb3RvY29sUG9ydChvcHRzLnByb3RvY29sKX1gXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0ge1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHJlcXVlc3RlZFBhdGgsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAuLi50aGlzW2tQcm94eUhlYWRlcnNdLFxuICAgICAgICAgICAgICBob3N0OiBvcHRzLmhvc3QsXG4gICAgICAgICAgICAgIC4uLihvcHRzLmNvbm5lY3Rpb25zID09IG51bGwgfHwgb3B0cy5jb25uZWN0aW9ucyA+IDAgPyB7ICdwcm94eS1jb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnIH0gOiB7fSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiB0aGlzW2tQcm94eVRsc10/LnNlcnZlcm5hbWUgfHwgcHJveHlIb3N0bmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IHNvY2tldCwgc3RhdHVzQ29kZSB9ID0gYXdhaXQgdGhpc1trQ2xpZW50XS5jb25uZWN0KGNvbm5lY3RQYXJhbXMpXG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApLmRlc3Ryb3koKVxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoYFByb3h5IHJlc3BvbnNlICgke3N0YXR1c0NvZGV9KSAhPT0gMjAwIHdoZW4gSFRUUCBUdW5uZWxpbmdgKSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFubmVscy5wcm94eUNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgY2hhbm5lbHMucHJveHlDb25uZWN0ZWQucHVibGlzaCh7XG4gICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgY29ubmVjdFBhcmFtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2VydmVybmFtZVxuICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0VGxzXSkge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0cywgc2VydmVybmFtZSwgaHR0cFNvY2tldDogc29ja2V0IH0sIGNhbGxiYWNrKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJykge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXJyb3IgdG8gYXZvaWQgbG9vcCBpbiBjbGllbnQuanMjY29ubmVjdFxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yKGVycikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKG9wdHMuaGVhZGVycylcbiAgICB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpXG5cbiAgICBpZiAoaGVhZGVycyAmJiAhKCdob3N0JyBpbiBoZWFkZXJzKSAmJiAhKCdIb3N0JyBpbiBoZWFkZXJzKSkge1xuICAgICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKG9wdHMub3JpZ2luKVxuICAgICAgaGVhZGVycy5ob3N0ID0gaG9zdFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9wcm94eS1hZ2VudCcpLlByb3h5QWdlbnQuT3B0aW9ucyB8IHN0cmluZyB8IFVSTH0gb3B0c1xuICAgKiBAcmV0dXJucyB7VVJMfVxuICAgKi9cbiAgI2dldFVybCAob3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKG9wdHMpXG4gICAgfSBlbHNlIGlmIChvcHRzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICByZXR1cm4gb3B0c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChvcHRzLnVyaSlcbiAgICB9XG4gIH1cblxuICBba0Nsb3NlXSAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXNba0FnZW50XS5jbG9zZSgpLFxuICAgICAgdGhpc1trQ2xpZW50XS5jbG9zZSgpXG4gICAgXSlcbiAgfVxuXG4gIFtrRGVzdHJveV0gKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzW2tBZ2VudF0uZGVzdHJveSgpLFxuICAgICAgdGhpc1trQ2xpZW50XS5kZXN0cm95KClcbiAgICBdKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgLy8gV2hlbiB1c2luZyB1bmRpY2kuZmV0Y2gsIHRoZSBoZWFkZXJzIGxpc3QgaXMgc3RvcmVkXG4gIC8vIGFzIGFuIGFycmF5LlxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBoZWFkZXJzUGFpciA9IHt9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1BhaXJcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKlxuICogUHJldmlvdXMgdmVyc2lvbnMgb2YgUHJveHlBZ2VudCBzdWdnZXN0cyB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBpbiByZXF1ZXN0IGhlYWRlcnNcbiAqIE5ldmVydGhlbGVzcywgaXQgd2FzIGNoYW5nZWQgYW5kIHRvIGF2b2lkIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSBieSBlbmQgdXNlcnNcbiAqIHRoaXMgY2hlY2sgd2FzIGNyZWF0ZWQuXG4gKiBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQgKGhlYWRlcnMpIHtcbiAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJylcbiAgaWYgKGV4aXN0UHJveHlBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3InKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nclass RetryAgent extends Dispatcher {\n  #agent = null\n  #options = null\n  constructor (agent, options = {}) {\n    super(options)\n    this.#agent = agent\n    this.#options = options\n  }\n\n  dispatch (opts, handler) {\n    const retry = new RetryHandler({\n      ...opts,\n      retryOptions: this.#options\n    }, {\n      dispatch: this.#agent.dispatch.bind(this.#agent),\n      handler\n    })\n    return this.#agent.dispatch(opts, retry)\n  }\n\n  close () {\n    return this.#agent.close()\n  }\n\n  destroy () {\n    return this.#agent.destroy()\n  }\n}\n\nmodule.exports = RetryAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxyZXRyeS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5jbGFzcyBSZXRyeUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICNhZ2VudCA9IG51bGxcbiAgI29wdGlvbnMgPSBudWxsXG4gIGNvbnN0cnVjdG9yIChhZ2VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLiNhZ2VudCA9IGFnZW50XG4gICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmV0cnkgPSBuZXcgUmV0cnlIYW5kbGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZXRyeU9wdGlvbnM6IHRoaXMuI29wdGlvbnNcbiAgICB9LCB7XG4gICAgICBkaXNwYXRjaDogdGhpcy4jYWdlbnQuZGlzcGF0Y2guYmluZCh0aGlzLiNhZ2VudCksXG4gICAgICBoYW5kbGVyXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGlzcGF0Y2gob3B0cywgcmV0cnkpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmNsb3NlKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5kZXN0cm95KClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/round-robin-pool.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/round-robin-pool.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher,\n  kRemoveClient\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\nconst kIndex = Symbol('index')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass RoundRobinPool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    clientTtl,\n    ...options\n  } = {}) {\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    super()\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n    this[kIndex] = -1\n\n    this.on('connect', (origin, targets) => {\n      if (clientTtl != null && clientTtl > 0) {\n        for (const target of targets) {\n          Object.assign(target, { ttl: Date.now() })\n        }\n      }\n    })\n\n    this.on('connectionError', (origin, targets, error) => {\n      for (const target of targets) {\n        const idx = this[kClients].indexOf(target)\n        if (idx !== -1) {\n          this[kClients].splice(idx, 1)\n        }\n      }\n    })\n  }\n\n  [kGetDispatcher] () {\n    const clientTtlOption = this[kOptions].clientTtl\n    const clientsLength = this[kClients].length\n\n    // If we have no clients yet, create one\n    if (clientsLength === 0) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n\n    // Round-robin through existing clients\n    let checked = 0\n    while (checked < clientsLength) {\n      this[kIndex] = (this[kIndex] + 1) % clientsLength\n      const client = this[kClients][this[kIndex]]\n\n      // Check if client is stale (TTL expired)\n      if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && ((Date.now() - client.ttl) > clientTtlOption)) {\n        this[kRemoveClient](client)\n        checked++\n        continue\n      }\n\n      // Return client if it's not draining\n      if (!client[kNeedDrain]) {\n        return client\n      }\n\n      checked++\n    }\n\n    // All clients are busy, create a new one if we haven't reached the limit\n    if (!this[kConnections] || clientsLength < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = RoundRobinPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JvdW5kLXJvYmluLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN6QixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakM7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWlCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1EQUFtRDtBQUN6RztBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccm91bmQtcm9iaW4tcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyLFxuICBrUmVtb3ZlQ2xpZW50XG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrVXJsIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QnKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrQ29ubmVjdGlvbnMgPSBTeW1ib2woJ2Nvbm5lY3Rpb25zJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcbmNvbnN0IGtJbmRleCA9IFN5bWJvbCgnaW5kZXgnKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUm91bmRSb2JpblBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIHtcbiAgICBjb25uZWN0aW9ucyxcbiAgICBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksXG4gICAgY29ubmVjdCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICB0bHMsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgc29ja2V0UGF0aCxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICBhbGxvd0gyLFxuICAgIGNsaWVudFR0bCxcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHR5cGVvZiBhdXRvU2VsZWN0RmFtaWx5ID09PSAnYm9vbGVhbicgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tDb25uZWN0aW9uc10gPSBjb25uZWN0aW9ucyB8fCBudWxsXG4gICAgdGhpc1trVXJsXSA9IHV0aWwucGFyc2VPcmlnaW4ob3JpZ2luKVxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgY29ubmVjdCwgYWxsb3dIMiwgY2xpZW50VHRsIH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trSW5kZXhdID0gLTFcblxuICAgIHRoaXMub24oJ2Nvbm5lY3QnLCAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBpZiAoY2xpZW50VHRsICE9IG51bGwgJiYgY2xpZW50VHRsID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHsgdHRsOiBEYXRlLm5vdygpIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbignY29ubmVjdGlvbkVycm9yJywgKG9yaWdpbiwgdGFyZ2V0cywgZXJyb3IpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZih0YXJnZXQpXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICBjb25zdCBjbGllbnRUdGxPcHRpb24gPSB0aGlzW2tPcHRpb25zXS5jbGllbnRUdGxcbiAgICBjb25zdCBjbGllbnRzTGVuZ3RoID0gdGhpc1trQ2xpZW50c10ubGVuZ3RoXG5cbiAgICAvLyBJZiB3ZSBoYXZlIG5vIGNsaWVudHMgeWV0LCBjcmVhdGUgb25lXG4gICAgaWYgKGNsaWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XSh0aGlzW2tVcmxdLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgIHRoaXNba0FkZENsaWVudF0oZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gUm91bmQtcm9iaW4gdGhyb3VnaCBleGlzdGluZyBjbGllbnRzXG4gICAgbGV0IGNoZWNrZWQgPSAwXG4gICAgd2hpbGUgKGNoZWNrZWQgPCBjbGllbnRzTGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSBjbGllbnRzTGVuZ3RoXG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIENoZWNrIGlmIGNsaWVudCBpcyBzdGFsZSAoVFRMIGV4cGlyZWQpXG4gICAgICBpZiAoY2xpZW50VHRsT3B0aW9uICE9IG51bGwgJiYgY2xpZW50VHRsT3B0aW9uID4gMCAmJiBjbGllbnQudHRsICYmICgoRGF0ZS5ub3coKSAtIGNsaWVudC50dGwpID4gY2xpZW50VHRsT3B0aW9uKSkge1xuICAgICAgICB0aGlzW2tSZW1vdmVDbGllbnRdKGNsaWVudClcbiAgICAgICAgY2hlY2tlZCsrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBjbGllbnQgaWYgaXQncyBub3QgZHJhaW5pbmdcbiAgICAgIGlmICghY2xpZW50W2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRcbiAgICAgIH1cblxuICAgICAgY2hlY2tlZCsrXG4gICAgfVxuXG4gICAgLy8gQWxsIGNsaWVudHMgYXJlIGJ1c3ksIGNyZWF0ZSBhIG5ldyBvbmUgaWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBsaW1pdFxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IGNsaWVudHNMZW5ndGggPCB0aGlzW2tDb25uZWN0aW9uc10pIHtcbiAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XSh0aGlzW2tVcmxdLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgIHRoaXNba0FkZENsaWVudF0oZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm91bmRSb2JpblBvb2xcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/round-robin-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/encoding/index.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/encoding/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Uint8Array} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nmodule.exports = {\n  utf8DecodeBytes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9lbmNvZGluZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZW5jb2RpbmdcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlclxuICovXG5mdW5jdGlvbiB1dGY4RGVjb2RlQnl0ZXMgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMS4gTGV0IGJ1ZmZlciBiZSB0aGUgcmVzdWx0IG9mIHBlZWtpbmcgdGhyZWUgYnl0ZXMgZnJvbVxuICAvLyAgICBpb1F1ZXVlLCBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuXG4gIC8vIDIuIElmIGJ1ZmZlciBpcyAweEVGIDB4QkIgMHhCRiwgdGhlbiByZWFkIHRocmVlXG4gIC8vICAgIGJ5dGVzIGZyb20gaW9RdWV1ZS4gKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gIGlmIChidWZmZXJbMF0gPT09IDB4RUYgJiYgYnVmZmVyWzFdID09PSAweEJCICYmIGJ1ZmZlclsyXSA9PT0gMHhCRikge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgzKVxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgVVRGLTjigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cbiAgY29uc3Qgb3V0cHV0ID0gdGV4dERlY29kZXIuZGVjb2RlKGJ1ZmZlcilcblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1dGY4RGVjb2RlQnl0ZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/encoding/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\n// These are the globals that can be installed by undici.install().\n// Not exported by index.js to avoid use outside of this module.\nconst installedExports = /** @type {const} */ (\n  [\n    'fetch',\n    'Headers',\n    'Response',\n    'Request',\n    'FormData',\n    'WebSocket',\n    'CloseEvent',\n    'ErrorEvent',\n    'MessageEvent',\n    'EventSource'\n  ]\n)\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher,\n  installedExports\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBb0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZ2xvYmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXZSBpbmNsdWRlIGEgdmVyc2lvbiBudW1iZXIgZm9yIHRoZSBEaXNwYXRjaGVyIEFQSS4gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLFxuLy8gdGhpcyB2ZXJzaW9uIG51bWJlciBtdXN0IGJlIGluY3JlYXNlZCB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxEaXNwYXRjaGVyID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbERpc3BhdGNoZXIuMScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyL2FnZW50JylcblxuaWYgKGdldEdsb2JhbERpc3BhdGNoZXIoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IEFnZW50KCkpXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbERpc3BhdGNoZXIgKGFnZW50KSB7XG4gIGlmICghYWdlbnQgfHwgdHlwZW9mIGFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBhZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbERpc3BhdGNoZXIsIHtcbiAgICB2YWx1ZTogYWdlbnQsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxEaXNwYXRjaGVyICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsRGlzcGF0Y2hlcl1cbn1cblxuLy8gVGhlc2UgYXJlIHRoZSBnbG9iYWxzIHRoYXQgY2FuIGJlIGluc3RhbGxlZCBieSB1bmRpY2kuaW5zdGFsbCgpLlxuLy8gTm90IGV4cG9ydGVkIGJ5IGluZGV4LmpzIHRvIGF2b2lkIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuY29uc3QgaW5zdGFsbGVkRXhwb3J0cyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChcbiAgW1xuICAgICdmZXRjaCcsXG4gICAgJ0hlYWRlcnMnLFxuICAgICdSZXNwb25zZScsXG4gICAgJ1JlcXVlc3QnLFxuICAgICdGb3JtRGF0YScsXG4gICAgJ1dlYlNvY2tldCcsXG4gICAgJ0Nsb3NlRXZlbnQnLFxuICAgICdFcnJvckV2ZW50JyxcbiAgICAnTWVzc2FnZUV2ZW50JyxcbiAgICAnRXZlbnRTb3VyY2UnXG4gIF1cbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIsXG4gIGdldEdsb2JhbERpc3BhdGNoZXIsXG4gIGluc3RhbGxlZEV4cG9ydHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/cache-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/cache-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable\n} = __webpack_require__(/*! ../util/cache */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\nconst { parseHttpDate } = __webpack_require__(/*! ../util/date.js */ \"(rsc)/./node_modules/undici/lib/util/date.js\")\n\nfunction noop () {}\n\n// Status codes that we can use some heuristics on to cache\nconst HEURISTICALLY_CACHEABLE_STATUS_CODES = [\n  200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501\n]\n\n// Status codes which semantic is not handled by the cache\n// https://datatracker.ietf.org/doc/html/rfc9111#section-3\n// This list should not grow beyond 206 unless the RFC is updated\n// by a newer one including more. Please introduce another list if\n// implementing caching of responses with the 'must-understand' directive.\nconst NOT_UNDERSTOOD_STATUS_CODES = [\n  206\n]\n\nconst MAX_RESPONSE_AGE = 2147483647000\n\n/**\n * @typedef {import('../../types/dispatcher.d.ts').default.DispatchHandler} DispatchHandler\n *\n * @implements {DispatchHandler}\n */\nclass CacheHandler {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n   */\n  #cacheKey\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}\n   */\n  #cacheType\n\n  /**\n   * @type {number | undefined}\n   */\n  #cacheByDefault\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}\n   */\n  #store\n\n  /**\n   * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n   */\n  #handler\n\n  /**\n   * @type {import('node:stream').Writable | undefined}\n   */\n  #writeStream\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n   */\n  constructor ({ store, type, cacheByDefault }, cacheKey, handler) {\n    this.#store = store\n    this.#cacheType = type\n    this.#cacheByDefault = cacheByDefault\n    this.#cacheKey = cacheKey\n    this.#handler = handler\n  }\n\n  onRequestStart (controller, context) {\n    this.#writeStream?.destroy()\n    this.#writeStream = undefined\n    this.#handler.onRequestStart?.(controller, context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {number} statusCode\n   * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n   * @param {string} statusMessage\n   */\n  onResponseStart (\n    controller,\n    statusCode,\n    resHeaders,\n    statusMessage\n  ) {\n    const downstreamOnHeaders = () =>\n      this.#handler.onResponseStart?.(\n        controller,\n        statusCode,\n        resHeaders,\n        statusMessage\n      )\n    const handler = this\n\n    if (\n      !util.safeHTTPMethods.includes(this.#cacheKey.method) &&\n      statusCode >= 200 &&\n      statusCode <= 399\n    ) {\n      // Successful response to an unsafe method, delete it from cache\n      //  https://www.rfc-editor.org/rfc/rfc9111.html#name-invalidating-stored-response\n      try {\n        this.#store.delete(this.#cacheKey)?.catch?.(noop)\n      } catch {\n        // Fail silently\n      }\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlHeader = resHeaders['cache-control']\n    const heuristicallyCacheable = resHeaders['last-modified'] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode)\n    if (\n      !cacheControlHeader &&\n      !resHeaders['expires'] &&\n      !heuristicallyCacheable &&\n      !this.#cacheByDefault\n    ) {\n      // Don't have anything to tell us this response is cachable and we're not\n      //  caching by default\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {}\n    if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {\n      return downstreamOnHeaders()\n    }\n\n    const now = Date.now()\n    const resAge = resHeaders.age ? getAge(resHeaders.age) : undefined\n    if (resAge && resAge >= MAX_RESPONSE_AGE) {\n      // Response considered stale\n      return downstreamOnHeaders()\n    }\n\n    const resDate = typeof resHeaders.date === 'string'\n      ? parseHttpDate(resHeaders.date)\n      : undefined\n\n    const staleAt =\n      determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ??\n      this.#cacheByDefault\n    if (staleAt === undefined || (resAge && resAge > staleAt)) {\n      return downstreamOnHeaders()\n    }\n\n    const baseTime = resDate ? resDate.getTime() : now\n    const absoluteStaleAt = staleAt + baseTime\n    if (now >= absoluteStaleAt) {\n      // Response is already stale\n      return downstreamOnHeaders()\n    }\n\n    let varyDirectives\n    if (this.#cacheKey.headers && resHeaders.vary) {\n      varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers)\n      if (!varyDirectives) {\n        // Parse error\n        return downstreamOnHeaders()\n      }\n    }\n\n    const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt)\n    const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives)\n\n    /**\n     * @type {import('../../types/cache-interceptor.d.ts').default.CacheValue}\n     */\n    const value = {\n      statusCode,\n      statusMessage,\n      headers: strippedHeaders,\n      vary: varyDirectives,\n      cacheControlDirectives,\n      cachedAt: resAge ? now - resAge : now,\n      staleAt: absoluteStaleAt,\n      deleteAt\n    }\n\n    // Not modified, re-use the cached value\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-handling-304-not-modified\n    if (statusCode === 304) {\n      /**\n       * @type {import('../../types/cache-interceptor.d.ts').default.CacheValue}\n       */\n      const cachedValue = this.#store.get(this.#cacheKey)\n      if (!cachedValue) {\n        // Do not create a new cache entry, as a 304 won't have a body - so cannot be cached.\n        return downstreamOnHeaders()\n      }\n\n      // Re-use the cached value: statuscode, statusmessage, headers and body\n      value.statusCode = cachedValue.statusCode\n      value.statusMessage = cachedValue.statusMessage\n      value.etag = cachedValue.etag\n      value.headers = { ...cachedValue.headers, ...strippedHeaders }\n\n      downstreamOnHeaders()\n\n      this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value)\n\n      if (!this.#writeStream || !cachedValue?.body) {\n        return\n      }\n\n      const bodyIterator = cachedValue.body.values()\n\n      const streamCachedBody = () => {\n        for (const chunk of bodyIterator) {\n          const full = this.#writeStream.write(chunk) === false\n          this.#handler.onResponseData?.(controller, chunk)\n          // when stream is full stop writing until we get a 'drain' event\n          if (full) {\n            break\n          }\n        }\n      }\n\n      this.#writeStream\n        .on('error', function () {\n          handler.#writeStream = undefined\n          handler.#store.delete(handler.#cacheKey)\n        })\n        .on('drain', () => {\n          streamCachedBody()\n        })\n        .on('close', function () {\n          if (handler.#writeStream === this) {\n            handler.#writeStream = undefined\n          }\n        })\n\n      streamCachedBody()\n    } else {\n      if (typeof resHeaders.etag === 'string' && isEtagUsable(resHeaders.etag)) {\n        value.etag = resHeaders.etag\n      }\n\n      this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value)\n\n      if (!this.#writeStream) {\n        return downstreamOnHeaders()\n      }\n\n      this.#writeStream\n        .on('drain', () => controller.resume())\n        .on('error', function () {\n          // TODO (fix): Make error somehow observable?\n          handler.#writeStream = undefined\n\n          // Delete the value in case the cache store is holding onto state from\n          //  the call to createWriteStream\n          handler.#store.delete(handler.#cacheKey)\n        })\n        .on('close', function () {\n          if (handler.#writeStream === this) {\n            handler.#writeStream = undefined\n          }\n\n          // TODO (fix): Should we resume even if was paused downstream?\n          controller.resume()\n        })\n\n      downstreamOnHeaders()\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#writeStream?.write(chunk) === false) {\n      controller.pause()\n    }\n\n    this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    this.#writeStream?.end()\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    this.#writeStream?.destroy(err)\n    this.#writeStream = undefined\n    this.#handler.onResponseError?.(controller, err)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n *\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} statusCode\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n */\nfunction canCacheResponse (cacheType, statusCode, resHeaders, cacheControlDirectives) {\n  // Status code must be final and understood.\n  if (statusCode < 200 || NOT_UNDERSTOOD_STATUS_CODES.includes(statusCode)) {\n    return false\n  }\n  // Responses with neither status codes that are heuristically cacheable, nor \"explicit enough\" caching\n  // directives, are not cacheable. \"Explicit enough\": see https://www.rfc-editor.org/rfc/rfc9111.html#section-3\n  if (!HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode) && !resHeaders['expires'] &&\n    !cacheControlDirectives.public &&\n    cacheControlDirectives['max-age'] === undefined &&\n    // RFC 9111: a private response directive, if the cache is not shared\n    !(cacheControlDirectives.private && cacheType === 'private') &&\n    !(cacheControlDirectives['s-maxage'] !== undefined && cacheType === 'shared')\n  ) {\n    return false\n  }\n\n  if (cacheControlDirectives['no-store']) {\n    return false\n  }\n\n  if (cacheType === 'shared' && cacheControlDirectives.private === true) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#section-4.1-5\n  if (resHeaders.vary?.includes('*')) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n  if (resHeaders.authorization) {\n    if (!cacheControlDirectives.public || typeof resHeaders.authorization !== 'string') {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['no-cache']) &&\n      cacheControlDirectives['no-cache'].includes('authorization')\n    ) {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['private']) &&\n      cacheControlDirectives['private'].includes('authorization')\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {string | string[]} ageHeader\n * @returns {number | undefined}\n */\nfunction getAge (ageHeader) {\n  const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader)\n\n  return isNaN(age) ? undefined : age * 1000\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} now\n * @param {number | undefined} age\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {Date | undefined} responseDate\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n *\n * @returns {number | undefined} time that the value is stale at in seconds or undefined if it shouldn't be cached\n */\nfunction determineStaleAt (cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {\n  if (cacheType === 'shared') {\n    // Prioritize s-maxage since we're a shared cache\n    //  s-maxage > max-age > Expire\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.2.10-3\n    const sMaxAge = cacheControlDirectives['s-maxage']\n    if (sMaxAge !== undefined) {\n      return sMaxAge > 0 ? sMaxAge * 1000 : undefined\n    }\n  }\n\n  const maxAge = cacheControlDirectives['max-age']\n  if (maxAge !== undefined) {\n    return maxAge > 0 ? maxAge * 1000 : undefined\n  }\n\n  if (typeof resHeaders.expires === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.3\n    const expiresDate = parseHttpDate(resHeaders.expires)\n    if (expiresDate) {\n      if (now >= expiresDate.getTime()) {\n        return undefined\n      }\n\n      if (responseDate) {\n        if (responseDate >= expiresDate) {\n          return undefined\n        }\n\n        if (age !== undefined && age > (expiresDate - responseDate)) {\n          return undefined\n        }\n      }\n\n      return expiresDate.getTime() - now\n    }\n  }\n\n  if (typeof resHeaders['last-modified'] === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-calculating-heuristic-fresh\n    const lastModified = new Date(resHeaders['last-modified'])\n    if (isValidDate(lastModified)) {\n      if (lastModified.getTime() >= now) {\n        return undefined\n      }\n\n      const responseAge = now - lastModified.getTime()\n\n      return responseAge * 0.1\n    }\n  }\n\n  if (cacheControlDirectives.immutable) {\n    // https://www.rfc-editor.org/rfc/rfc8246.html#section-2.2\n    return 31536000\n  }\n\n  return undefined\n}\n\n/**\n * @param {number} now\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @param {number} staleAt\n */\nfunction determineDeleteAt (now, cacheControlDirectives, staleAt) {\n  let staleWhileRevalidate = -Infinity\n  let staleIfError = -Infinity\n  let immutable = -Infinity\n\n  if (cacheControlDirectives['stale-while-revalidate']) {\n    staleWhileRevalidate = staleAt + (cacheControlDirectives['stale-while-revalidate'] * 1000)\n  }\n\n  if (cacheControlDirectives['stale-if-error']) {\n    staleIfError = staleAt + (cacheControlDirectives['stale-if-error'] * 1000)\n  }\n\n  if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {\n    immutable = now + 31536000000\n  }\n\n  return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable)\n}\n\n/**\n * Strips headers required to be removed in cached responses\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @returns {Record<string, string | string []>}\n */\nfunction stripNecessaryHeaders (resHeaders, cacheControlDirectives) {\n  const headersToRemove = [\n    'connection',\n    'proxy-authenticate',\n    'proxy-authentication-info',\n    'proxy-authorization',\n    'proxy-connection',\n    'te',\n    'transfer-encoding',\n    'upgrade',\n    // We'll add age back when serving it\n    'age'\n  ]\n\n  if (resHeaders['connection']) {\n    if (Array.isArray(resHeaders['connection'])) {\n      // connection: a\n      // connection: b\n      headersToRemove.push(...resHeaders['connection'].map(header => header.trim()))\n    } else {\n      // connection: a, b\n      headersToRemove.push(...resHeaders['connection'].split(',').map(header => header.trim()))\n    }\n  }\n\n  if (Array.isArray(cacheControlDirectives['no-cache'])) {\n    headersToRemove.push(...cacheControlDirectives['no-cache'])\n  }\n\n  if (Array.isArray(cacheControlDirectives['private'])) {\n    headersToRemove.push(...cacheControlDirectives['private'])\n  }\n\n  let strippedHeaders\n  for (const headerName of headersToRemove) {\n    if (resHeaders[headerName]) {\n      strippedHeaders ??= { ...resHeaders }\n      delete strippedHeaders[headerName]\n    }\n  }\n\n  return strippedHeaders ?? resHeaders\n}\n\n/**\n * @param {Date} date\n * @returns {boolean}\n */\nfunction isValidDate (date) {\n  return date instanceof Date && Number.isFinite(date.valueOf())\n}\n\nmodule.exports = CacheHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2NhY2hlLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0VBQWU7QUFDM0IsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsK0RBQStEO0FBQzVFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMEVBQTBFO0FBQ3ZGLGFBQWEsK0RBQStEO0FBQzVFLGFBQWEsK0RBQStEO0FBQzVFO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1REFBdUQ7QUFDcEUsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXGNhY2hlLWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBwYXJzZUNhY2hlQ29udHJvbEhlYWRlcixcbiAgcGFyc2VWYXJ5SGVhZGVyLFxuICBpc0V0YWdVc2FibGVcbn0gPSByZXF1aXJlKCcuLi91dGlsL2NhY2hlJylcbmNvbnN0IHsgcGFyc2VIdHRwRGF0ZSB9ID0gcmVxdWlyZSgnLi4vdXRpbC9kYXRlLmpzJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vLyBTdGF0dXMgY29kZXMgdGhhdCB3ZSBjYW4gdXNlIHNvbWUgaGV1cmlzdGljcyBvbiB0byBjYWNoZVxuY29uc3QgSEVVUklTVElDQUxMWV9DQUNIRUFCTEVfU1RBVFVTX0NPREVTID0gW1xuICAyMDAsIDIwMywgMjA0LCAyMDYsIDMwMCwgMzAxLCAzMDgsIDQwNCwgNDA1LCA0MTAsIDQxNCwgNTAxXG5dXG5cbi8vIFN0YXR1cyBjb2RlcyB3aGljaCBzZW1hbnRpYyBpcyBub3QgaGFuZGxlZCBieSB0aGUgY2FjaGVcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjOTExMSNzZWN0aW9uLTNcbi8vIFRoaXMgbGlzdCBzaG91bGQgbm90IGdyb3cgYmV5b25kIDIwNiB1bmxlc3MgdGhlIFJGQyBpcyB1cGRhdGVkXG4vLyBieSBhIG5ld2VyIG9uZSBpbmNsdWRpbmcgbW9yZS4gUGxlYXNlIGludHJvZHVjZSBhbm90aGVyIGxpc3QgaWZcbi8vIGltcGxlbWVudGluZyBjYWNoaW5nIG9mIHJlc3BvbnNlcyB3aXRoIHRoZSAnbXVzdC11bmRlcnN0YW5kJyBkaXJlY3RpdmUuXG5jb25zdCBOT1RfVU5ERVJTVE9PRF9TVEFUVVNfQ09ERVMgPSBbXG4gIDIwNlxuXVxuXG5jb25zdCBNQVhfUkVTUE9OU0VfQUdFID0gMjE0NzQ4MzY0NzAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfSBEaXNwYXRjaEhhbmRsZXJcbiAqXG4gKiBAaW1wbGVtZW50cyB7RGlzcGF0Y2hIYW5kbGVyfVxuICovXG5jbGFzcyBDYWNoZUhhbmRsZXIge1xuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9XG4gICAqL1xuICAjY2FjaGVLZXlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVIYW5kbGVyT3B0aW9uc1sndHlwZSddfVxuICAgKi9cbiAgI2NhY2hlVHlwZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgI2NhY2hlQnlEZWZhdWx0XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlU3RvcmV9XG4gICAqL1xuICAjc3RvcmVcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9XG4gICAqL1xuICAjaGFuZGxlclxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnN0cmVhbScpLldyaXRhYmxlIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgI3dyaXRlU3RyZWFtXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUhhbmRsZXJPcHRpb25zfSBvcHRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0gY2FjaGVLZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfSBoYW5kbGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBzdG9yZSwgdHlwZSwgY2FjaGVCeURlZmF1bHQgfSwgY2FjaGVLZXksIGhhbmRsZXIpIHtcbiAgICB0aGlzLiNzdG9yZSA9IHN0b3JlXG4gICAgdGhpcy4jY2FjaGVUeXBlID0gdHlwZVxuICAgIHRoaXMuI2NhY2hlQnlEZWZhdWx0ID0gY2FjaGVCeURlZmF1bHRcbiAgICB0aGlzLiNjYWNoZUtleSA9IGNhY2hlS2V5XG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uUmVxdWVzdFN0YXJ0IChjb250cm9sbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy4jd3JpdGVTdHJlYW0/LmRlc3Ryb3koKVxuICAgIHRoaXMuI3dyaXRlU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKGNvbnRyb2xsZXIsIGNvbnRleHQpXG4gIH1cblxuICBvblJlcXVlc3RVcGdyYWRlIChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFVwZ3JhZGU/Lihjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9oZWFkZXIuZC50cycpLkluY29taW5nSHR0cEhlYWRlcnN9IHJlc0hlYWRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c01lc3NhZ2VcbiAgICovXG4gIG9uUmVzcG9uc2VTdGFydCAoXG4gICAgY29udHJvbGxlcixcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc0hlYWRlcnMsXG4gICAgc3RhdHVzTWVzc2FnZVxuICApIHtcbiAgICBjb25zdCBkb3duc3RyZWFtT25IZWFkZXJzID0gKCkgPT5cbiAgICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oXG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIHJlc0hlYWRlcnMsXG4gICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgIClcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpc1xuXG4gICAgaWYgKFxuICAgICAgIXV0aWwuc2FmZUhUVFBNZXRob2RzLmluY2x1ZGVzKHRoaXMuI2NhY2hlS2V5Lm1ldGhvZCkgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMjAwICYmXG4gICAgICBzdGF0dXNDb2RlIDw9IDM5OVxuICAgICkge1xuICAgICAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZSB0byBhbiB1bnNhZmUgbWV0aG9kLCBkZWxldGUgaXQgZnJvbSBjYWNoZVxuICAgICAgLy8gIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjbmFtZS1pbnZhbGlkYXRpbmctc3RvcmVkLXJlc3BvbnNlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLiNzdG9yZS5kZWxldGUodGhpcy4jY2FjaGVLZXkpPy5jYXRjaD8uKG5vb3ApXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRmFpbCBzaWxlbnRseVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlQ29udHJvbEhlYWRlciA9IHJlc0hlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXVxuICAgIGNvbnN0IGhldXJpc3RpY2FsbHlDYWNoZWFibGUgPSByZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10gJiYgSEVVUklTVElDQUxMWV9DQUNIRUFCTEVfU1RBVFVTX0NPREVTLmluY2x1ZGVzKHN0YXR1c0NvZGUpXG4gICAgaWYgKFxuICAgICAgIWNhY2hlQ29udHJvbEhlYWRlciAmJlxuICAgICAgIXJlc0hlYWRlcnNbJ2V4cGlyZXMnXSAmJlxuICAgICAgIWhldXJpc3RpY2FsbHlDYWNoZWFibGUgJiZcbiAgICAgICF0aGlzLiNjYWNoZUJ5RGVmYXVsdFxuICAgICkge1xuICAgICAgLy8gRG9uJ3QgaGF2ZSBhbnl0aGluZyB0byB0ZWxsIHVzIHRoaXMgcmVzcG9uc2UgaXMgY2FjaGFibGUgYW5kIHdlJ3JlIG5vdFxuICAgICAgLy8gIGNhY2hpbmcgYnkgZGVmYXVsdFxuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlQ29udHJvbERpcmVjdGl2ZXMgPSBjYWNoZUNvbnRyb2xIZWFkZXIgPyBwYXJzZUNhY2hlQ29udHJvbEhlYWRlcihjYWNoZUNvbnRyb2xIZWFkZXIpIDoge31cbiAgICBpZiAoIWNhbkNhY2hlUmVzcG9uc2UodGhpcy4jY2FjaGVUeXBlLCBzdGF0dXNDb2RlLCByZXNIZWFkZXJzLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSkge1xuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCByZXNBZ2UgPSByZXNIZWFkZXJzLmFnZSA/IGdldEFnZShyZXNIZWFkZXJzLmFnZSkgOiB1bmRlZmluZWRcbiAgICBpZiAocmVzQWdlICYmIHJlc0FnZSA+PSBNQVhfUkVTUE9OU0VfQUdFKSB7XG4gICAgICAvLyBSZXNwb25zZSBjb25zaWRlcmVkIHN0YWxlXG4gICAgICByZXR1cm4gZG93bnN0cmVhbU9uSGVhZGVycygpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzRGF0ZSA9IHR5cGVvZiByZXNIZWFkZXJzLmRhdGUgPT09ICdzdHJpbmcnXG4gICAgICA/IHBhcnNlSHR0cERhdGUocmVzSGVhZGVycy5kYXRlKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGNvbnN0IHN0YWxlQXQgPVxuICAgICAgZGV0ZXJtaW5lU3RhbGVBdCh0aGlzLiNjYWNoZVR5cGUsIG5vdywgcmVzQWdlLCByZXNIZWFkZXJzLCByZXNEYXRlLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSA/P1xuICAgICAgdGhpcy4jY2FjaGVCeURlZmF1bHRcbiAgICBpZiAoc3RhbGVBdCA9PT0gdW5kZWZpbmVkIHx8IChyZXNBZ2UgJiYgcmVzQWdlID4gc3RhbGVBdCkpIHtcbiAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVGltZSA9IHJlc0RhdGUgPyByZXNEYXRlLmdldFRpbWUoKSA6IG5vd1xuICAgIGNvbnN0IGFic29sdXRlU3RhbGVBdCA9IHN0YWxlQXQgKyBiYXNlVGltZVxuICAgIGlmIChub3cgPj0gYWJzb2x1dGVTdGFsZUF0KSB7XG4gICAgICAvLyBSZXNwb25zZSBpcyBhbHJlYWR5IHN0YWxlXG4gICAgICByZXR1cm4gZG93bnN0cmVhbU9uSGVhZGVycygpXG4gICAgfVxuXG4gICAgbGV0IHZhcnlEaXJlY3RpdmVzXG4gICAgaWYgKHRoaXMuI2NhY2hlS2V5LmhlYWRlcnMgJiYgcmVzSGVhZGVycy52YXJ5KSB7XG4gICAgICB2YXJ5RGlyZWN0aXZlcyA9IHBhcnNlVmFyeUhlYWRlcihyZXNIZWFkZXJzLnZhcnksIHRoaXMuI2NhY2hlS2V5LmhlYWRlcnMpXG4gICAgICBpZiAoIXZhcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFBhcnNlIGVycm9yXG4gICAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVBdCA9IGRldGVybWluZURlbGV0ZUF0KGJhc2VUaW1lLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLCBhYnNvbHV0ZVN0YWxlQXQpXG4gICAgY29uc3Qgc3RyaXBwZWRIZWFkZXJzID0gc3RyaXBOZWNlc3NhcnlIZWFkZXJzKHJlc0hlYWRlcnMsIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMpXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZVZhbHVlfVxuICAgICAqL1xuICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c01lc3NhZ2UsXG4gICAgICBoZWFkZXJzOiBzdHJpcHBlZEhlYWRlcnMsXG4gICAgICB2YXJ5OiB2YXJ5RGlyZWN0aXZlcyxcbiAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMsXG4gICAgICBjYWNoZWRBdDogcmVzQWdlID8gbm93IC0gcmVzQWdlIDogbm93LFxuICAgICAgc3RhbGVBdDogYWJzb2x1dGVTdGFsZUF0LFxuICAgICAgZGVsZXRlQXRcbiAgICB9XG5cbiAgICAvLyBOb3QgbW9kaWZpZWQsIHJlLXVzZSB0aGUgY2FjaGVkIHZhbHVlXG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLWhhbmRsaW5nLTMwNC1ub3QtbW9kaWZpZWRcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWV9XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNhY2hlZFZhbHVlID0gdGhpcy4jc3RvcmUuZ2V0KHRoaXMuI2NhY2hlS2V5KVxuICAgICAgaWYgKCFjYWNoZWRWYWx1ZSkge1xuICAgICAgICAvLyBEbyBub3QgY3JlYXRlIGEgbmV3IGNhY2hlIGVudHJ5LCBhcyBhIDMwNCB3b24ndCBoYXZlIGEgYm9keSAtIHNvIGNhbm5vdCBiZSBjYWNoZWQuXG4gICAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICAgIH1cblxuICAgICAgLy8gUmUtdXNlIHRoZSBjYWNoZWQgdmFsdWU6IHN0YXR1c2NvZGUsIHN0YXR1c21lc3NhZ2UsIGhlYWRlcnMgYW5kIGJvZHlcbiAgICAgIHZhbHVlLnN0YXR1c0NvZGUgPSBjYWNoZWRWYWx1ZS5zdGF0dXNDb2RlXG4gICAgICB2YWx1ZS5zdGF0dXNNZXNzYWdlID0gY2FjaGVkVmFsdWUuc3RhdHVzTWVzc2FnZVxuICAgICAgdmFsdWUuZXRhZyA9IGNhY2hlZFZhbHVlLmV0YWdcbiAgICAgIHZhbHVlLmhlYWRlcnMgPSB7IC4uLmNhY2hlZFZhbHVlLmhlYWRlcnMsIC4uLnN0cmlwcGVkSGVhZGVycyB9XG5cbiAgICAgIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuXG4gICAgICB0aGlzLiN3cml0ZVN0cmVhbSA9IHRoaXMuI3N0b3JlLmNyZWF0ZVdyaXRlU3RyZWFtKHRoaXMuI2NhY2hlS2V5LCB2YWx1ZSlcblxuICAgICAgaWYgKCF0aGlzLiN3cml0ZVN0cmVhbSB8fCAhY2FjaGVkVmFsdWU/LmJvZHkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHlJdGVyYXRvciA9IGNhY2hlZFZhbHVlLmJvZHkudmFsdWVzKClcblxuICAgICAgY29uc3Qgc3RyZWFtQ2FjaGVkQm9keSA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBib2R5SXRlcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmdWxsID0gdGhpcy4jd3JpdGVTdHJlYW0ud3JpdGUoY2h1bmspID09PSBmYWxzZVxuICAgICAgICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZURhdGE/Lihjb250cm9sbGVyLCBjaHVuaylcbiAgICAgICAgICAvLyB3aGVuIHN0cmVhbSBpcyBmdWxsIHN0b3Agd3JpdGluZyB1bnRpbCB3ZSBnZXQgYSAnZHJhaW4nIGV2ZW50XG4gICAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3dyaXRlU3RyZWFtXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlci4jd3JpdGVTdHJlYW0gPSB1bmRlZmluZWRcbiAgICAgICAgICBoYW5kbGVyLiNzdG9yZS5kZWxldGUoaGFuZGxlci4jY2FjaGVLZXkpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgICAgc3RyZWFtQ2FjaGVkQm9keSgpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXIuI3dyaXRlU3RyZWFtID09PSB0aGlzKSB7XG4gICAgICAgICAgICBoYW5kbGVyLiN3cml0ZVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgc3RyZWFtQ2FjaGVkQm9keSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzSGVhZGVycy5ldGFnID09PSAnc3RyaW5nJyAmJiBpc0V0YWdVc2FibGUocmVzSGVhZGVycy5ldGFnKSkge1xuICAgICAgICB2YWx1ZS5ldGFnID0gcmVzSGVhZGVycy5ldGFnXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3dyaXRlU3RyZWFtID0gdGhpcy4jc3RvcmUuY3JlYXRlV3JpdGVTdHJlYW0odGhpcy4jY2FjaGVLZXksIHZhbHVlKVxuXG4gICAgICBpZiAoIXRoaXMuI3dyaXRlU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICAgIH1cblxuICAgICAgdGhpcy4jd3JpdGVTdHJlYW1cbiAgICAgICAgLm9uKCdkcmFpbicsICgpID0+IGNvbnRyb2xsZXIucmVzdW1lKCkpXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogTWFrZSBlcnJvciBzb21laG93IG9ic2VydmFibGU/XG4gICAgICAgICAgaGFuZGxlci4jd3JpdGVTdHJlYW0gPSB1bmRlZmluZWRcblxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FjaGUgc3RvcmUgaXMgaG9sZGluZyBvbnRvIHN0YXRlIGZyb21cbiAgICAgICAgICAvLyAgdGhlIGNhbGwgdG8gY3JlYXRlV3JpdGVTdHJlYW1cbiAgICAgICAgICBoYW5kbGVyLiNzdG9yZS5kZWxldGUoaGFuZGxlci4jY2FjaGVLZXkpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXIuI3dyaXRlU3RyZWFtID09PSB0aGlzKSB7XG4gICAgICAgICAgICBoYW5kbGVyLiN3cml0ZVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IFNob3VsZCB3ZSByZXN1bWUgZXZlbiBpZiB3YXMgcGF1c2VkIGRvd25zdHJlYW0/XG4gICAgICAgICAgY29udHJvbGxlci5yZXN1bWUoKVxuICAgICAgICB9KVxuXG4gICAgICBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICBpZiAodGhpcy4jd3JpdGVTdHJlYW0/LndyaXRlKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRyb2xsZXIucGF1c2UoKVxuICAgIH1cblxuICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZURhdGE/Lihjb250cm9sbGVyLCBjaHVuaylcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgdGhpcy4jd3JpdGVTdHJlYW0/LmVuZCgpXG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oY29udHJvbGxlciwgdHJhaWxlcnMpXG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIHRoaXMuI3dyaXRlU3RyZWFtPy5kZXN0cm95KGVycilcbiAgICB0aGlzLiN3cml0ZVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZUVycm9yPy4oY29udHJvbGxlciwgZXJyKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtc3RvcmluZy1yZXNwb25zZXMtdG8tYXV0aGVuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlT3B0aW9uc1sndHlwZSddfSBjYWNoZVR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvaGVhZGVyLmQudHMnKS5JbmNvbWluZ0h0dHBIZWFkZXJzfSByZXNIZWFkZXJzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc30gY2FjaGVDb250cm9sRGlyZWN0aXZlc1xuICovXG5mdW5jdGlvbiBjYW5DYWNoZVJlc3BvbnNlIChjYWNoZVR5cGUsIHN0YXR1c0NvZGUsIHJlc0hlYWRlcnMsIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMpIHtcbiAgLy8gU3RhdHVzIGNvZGUgbXVzdCBiZSBmaW5hbCBhbmQgdW5kZXJzdG9vZC5cbiAgaWYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgTk9UX1VOREVSU1RPT0RfU1RBVFVTX0NPREVTLmluY2x1ZGVzKHN0YXR1c0NvZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gUmVzcG9uc2VzIHdpdGggbmVpdGhlciBzdGF0dXMgY29kZXMgdGhhdCBhcmUgaGV1cmlzdGljYWxseSBjYWNoZWFibGUsIG5vciBcImV4cGxpY2l0IGVub3VnaFwiIGNhY2hpbmdcbiAgLy8gZGlyZWN0aXZlcywgYXJlIG5vdCBjYWNoZWFibGUuIFwiRXhwbGljaXQgZW5vdWdoXCI6IHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI3NlY3Rpb24tM1xuICBpZiAoIUhFVVJJU1RJQ0FMTFlfQ0FDSEVBQkxFX1NUQVRVU19DT0RFUy5pbmNsdWRlcyhzdGF0dXNDb2RlKSAmJiAhcmVzSGVhZGVyc1snZXhwaXJlcyddICYmXG4gICAgIWNhY2hlQ29udHJvbERpcmVjdGl2ZXMucHVibGljICYmXG4gICAgY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbWF4LWFnZSddID09PSB1bmRlZmluZWQgJiZcbiAgICAvLyBSRkMgOTExMTogYSBwcml2YXRlIHJlc3BvbnNlIGRpcmVjdGl2ZSwgaWYgdGhlIGNhY2hlIGlzIG5vdCBzaGFyZWRcbiAgICAhKGNhY2hlQ29udHJvbERpcmVjdGl2ZXMucHJpdmF0ZSAmJiBjYWNoZVR5cGUgPT09ICdwcml2YXRlJykgJiZcbiAgICAhKGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3MtbWF4YWdlJ10gIT09IHVuZGVmaW5lZCAmJiBjYWNoZVR5cGUgPT09ICdzaGFyZWQnKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWyduby1zdG9yZSddKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoY2FjaGVUeXBlID09PSAnc2hhcmVkJyAmJiBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLnByaXZhdGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjc2VjdGlvbi00LjEtNVxuICBpZiAocmVzSGVhZGVycy52YXJ5Py5pbmNsdWRlcygnKicpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtc3RvcmluZy1yZXNwb25zZXMtdG8tYXV0aGVuXG4gIGlmIChyZXNIZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICBpZiAoIWNhY2hlQ29udHJvbERpcmVjdGl2ZXMucHVibGljIHx8IHR5cGVvZiByZXNIZWFkZXJzLmF1dGhvcml6YXRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ25vLWNhY2hlJ10pICYmXG4gICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWyduby1jYWNoZSddLmluY2x1ZGVzKCdhdXRob3JpemF0aW9uJylcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoY2FjaGVDb250cm9sRGlyZWN0aXZlc1sncHJpdmF0ZSddKSAmJlxuICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlc1sncHJpdmF0ZSddLmluY2x1ZGVzKCdhdXRob3JpemF0aW9uJylcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gYWdlSGVhZGVyXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXRBZ2UgKGFnZUhlYWRlcikge1xuICBjb25zdCBhZ2UgPSBwYXJzZUludChBcnJheS5pc0FycmF5KGFnZUhlYWRlcikgPyBhZ2VIZWFkZXJbMF0gOiBhZ2VIZWFkZXIpXG5cbiAgcmV0dXJuIGlzTmFOKGFnZSkgPyB1bmRlZmluZWQgOiBhZ2UgKiAxMDAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlT3B0aW9uc1sndHlwZSddfSBjYWNoZVR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3dcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBhZ2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9oZWFkZXIuZC50cycpLkluY29taW5nSHR0cEhlYWRlcnN9IHJlc0hlYWRlcnNcbiAqIEBwYXJhbSB7RGF0ZSB8IHVuZGVmaW5lZH0gcmVzcG9uc2VEYXRlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc30gY2FjaGVDb250cm9sRGlyZWN0aXZlc1xuICpcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWUgdGhhdCB0aGUgdmFsdWUgaXMgc3RhbGUgYXQgaW4gc2Vjb25kcyBvciB1bmRlZmluZWQgaWYgaXQgc2hvdWxkbid0IGJlIGNhY2hlZFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGFsZUF0IChjYWNoZVR5cGUsIG5vdywgYWdlLCByZXNIZWFkZXJzLCByZXNwb25zZURhdGUsIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMpIHtcbiAgaWYgKGNhY2hlVHlwZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAvLyBQcmlvcml0aXplIHMtbWF4YWdlIHNpbmNlIHdlJ3JlIGEgc2hhcmVkIGNhY2hlXG4gICAgLy8gIHMtbWF4YWdlID4gbWF4LWFnZSA+IEV4cGlyZVxuICAgIC8vICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI3NlY3Rpb24tNS4yLjIuMTAtM1xuICAgIGNvbnN0IHNNYXhBZ2UgPSBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzLW1heGFnZSddXG4gICAgaWYgKHNNYXhBZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHNNYXhBZ2UgPiAwID8gc01heEFnZSAqIDEwMDAgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXhBZ2UgPSBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydtYXgtYWdlJ11cbiAgaWYgKG1heEFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG1heEFnZSA+IDAgPyBtYXhBZ2UgKiAxMDAwIDogdW5kZWZpbmVkXG4gIH1cblxuICBpZiAodHlwZW9mIHJlc0hlYWRlcnMuZXhwaXJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI3NlY3Rpb24tNS4zXG4gICAgY29uc3QgZXhwaXJlc0RhdGUgPSBwYXJzZUh0dHBEYXRlKHJlc0hlYWRlcnMuZXhwaXJlcylcbiAgICBpZiAoZXhwaXJlc0RhdGUpIHtcbiAgICAgIGlmIChub3cgPj0gZXhwaXJlc0RhdGUuZ2V0VGltZSgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlRGF0ZSkge1xuICAgICAgICBpZiAocmVzcG9uc2VEYXRlID49IGV4cGlyZXNEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFnZSAhPT0gdW5kZWZpbmVkICYmIGFnZSA+IChleHBpcmVzRGF0ZSAtIHJlc3BvbnNlRGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cGlyZXNEYXRlLmdldFRpbWUoKSAtIG5vd1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddID09PSAnc3RyaW5nJykge1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjbmFtZS1jYWxjdWxhdGluZy1oZXVyaXN0aWMtZnJlc2hcbiAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBuZXcgRGF0ZShyZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pXG4gICAgaWYgKGlzVmFsaWREYXRlKGxhc3RNb2RpZmllZCkpIHtcbiAgICAgIGlmIChsYXN0TW9kaWZpZWQuZ2V0VGltZSgpID49IG5vdykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlQWdlID0gbm93IC0gbGFzdE1vZGlmaWVkLmdldFRpbWUoKVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2VBZ2UgKiAwLjFcbiAgICB9XG4gIH1cblxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlcy5pbW11dGFibGUpIHtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjODI0Ni5odG1sI3NlY3Rpb24tMi4yXG4gICAgcmV0dXJuIDMxNTM2MDAwXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vd1xuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlQ29udHJvbERpcmVjdGl2ZXN9IGNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFsZUF0XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZURlbGV0ZUF0IChub3csIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMsIHN0YWxlQXQpIHtcbiAgbGV0IHN0YWxlV2hpbGVSZXZhbGlkYXRlID0gLUluZmluaXR5XG4gIGxldCBzdGFsZUlmRXJyb3IgPSAtSW5maW5pdHlcbiAgbGV0IGltbXV0YWJsZSA9IC1JbmZpbml0eVxuXG4gIGlmIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzdGFsZS13aGlsZS1yZXZhbGlkYXRlJ10pIHtcbiAgICBzdGFsZVdoaWxlUmV2YWxpZGF0ZSA9IHN0YWxlQXQgKyAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZSddICogMTAwMClcbiAgfVxuXG4gIGlmIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzdGFsZS1pZi1lcnJvciddKSB7XG4gICAgc3RhbGVJZkVycm9yID0gc3RhbGVBdCArIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzdGFsZS1pZi1lcnJvciddICogMTAwMClcbiAgfVxuXG4gIGlmIChzdGFsZVdoaWxlUmV2YWxpZGF0ZSA9PT0gLUluZmluaXR5ICYmIHN0YWxlSWZFcnJvciA9PT0gLUluZmluaXR5KSB7XG4gICAgaW1tdXRhYmxlID0gbm93ICsgMzE1MzYwMDAwMDBcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heChzdGFsZUF0LCBzdGFsZVdoaWxlUmV2YWxpZGF0ZSwgc3RhbGVJZkVycm9yLCBpbW11dGFibGUpXG59XG5cbi8qKlxuICogU3RyaXBzIGhlYWRlcnMgcmVxdWlyZWQgdG8gYmUgcmVtb3ZlZCBpbiBjYWNoZWQgcmVzcG9uc2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvaGVhZGVyLmQudHMnKS5JbmNvbWluZ0h0dHBIZWFkZXJzfSByZXNIZWFkZXJzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc30gY2FjaGVDb250cm9sRGlyZWN0aXZlc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZyBbXT59XG4gKi9cbmZ1bmN0aW9uIHN0cmlwTmVjZXNzYXJ5SGVhZGVycyAocmVzSGVhZGVycywgY2FjaGVDb250cm9sRGlyZWN0aXZlcykge1xuICBjb25zdCBoZWFkZXJzVG9SZW1vdmUgPSBbXG4gICAgJ2Nvbm5lY3Rpb24nLFxuICAgICdwcm94eS1hdXRoZW50aWNhdGUnLFxuICAgICdwcm94eS1hdXRoZW50aWNhdGlvbi1pbmZvJyxcbiAgICAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICAgJ3Byb3h5LWNvbm5lY3Rpb24nLFxuICAgICd0ZScsXG4gICAgJ3RyYW5zZmVyLWVuY29kaW5nJyxcbiAgICAndXBncmFkZScsXG4gICAgLy8gV2UnbGwgYWRkIGFnZSBiYWNrIHdoZW4gc2VydmluZyBpdFxuICAgICdhZ2UnXG4gIF1cblxuICBpZiAocmVzSGVhZGVyc1snY29ubmVjdGlvbiddKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzSGVhZGVyc1snY29ubmVjdGlvbiddKSkge1xuICAgICAgLy8gY29ubmVjdGlvbjogYVxuICAgICAgLy8gY29ubmVjdGlvbjogYlxuICAgICAgaGVhZGVyc1RvUmVtb3ZlLnB1c2goLi4ucmVzSGVhZGVyc1snY29ubmVjdGlvbiddLm1hcChoZWFkZXIgPT4gaGVhZGVyLnRyaW0oKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbm5lY3Rpb246IGEsIGJcbiAgICAgIGhlYWRlcnNUb1JlbW92ZS5wdXNoKC4uLnJlc0hlYWRlcnNbJ2Nvbm5lY3Rpb24nXS5zcGxpdCgnLCcpLm1hcChoZWFkZXIgPT4gaGVhZGVyLnRyaW0oKSkpXG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbm8tY2FjaGUnXSkpIHtcbiAgICBoZWFkZXJzVG9SZW1vdmUucHVzaCguLi5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzWyduby1jYWNoZSddKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2FjaGVDb250cm9sRGlyZWN0aXZlc1sncHJpdmF0ZSddKSkge1xuICAgIGhlYWRlcnNUb1JlbW92ZS5wdXNoKC4uLmNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3ByaXZhdGUnXSlcbiAgfVxuXG4gIGxldCBzdHJpcHBlZEhlYWRlcnNcbiAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIGhlYWRlcnNUb1JlbW92ZSkge1xuICAgIGlmIChyZXNIZWFkZXJzW2hlYWRlck5hbWVdKSB7XG4gICAgICBzdHJpcHBlZEhlYWRlcnMgPz89IHsgLi4ucmVzSGVhZGVycyB9XG4gICAgICBkZWxldGUgc3RyaXBwZWRIZWFkZXJzW2hlYWRlck5hbWVdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmlwcGVkSGVhZGVycyA/PyByZXNIZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZERhdGUgKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIE51bWJlci5pc0Zpbml0ZShkYXRlLnZhbHVlT2YoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZUhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/cache-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/handler/cache-revalidation-handler.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * This takes care of revalidation requests we send to the origin. If we get\n *  a response indicating that what we have is cached (via a HTTP 304), we can\n *  continue using the cached value. Otherwise, we'll receive the new response\n *  here, which we then just pass on to the next handler (most likely a\n *  CacheHandler). Note that this assumes the proper headers were already\n *  included in the request to tell the origin that we want to revalidate the\n *  response (i.e. if-modified-since or if-none-match).\n *\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-validation\n *\n * @implements {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n */\nclass CacheRevalidationHandler {\n  #successful = false\n\n  /**\n   * @type {((boolean, any) => void) | null}\n   */\n  #callback\n\n  /**\n   * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}\n   */\n  #handler\n\n  #context\n\n  /**\n   * @type {boolean}\n   */\n  #allowErrorStatusCodes\n\n  /**\n   * @param {(boolean) => void} callback Function to call if the cached value is valid\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler\n   * @param {boolean} allowErrorStatusCodes\n   */\n  constructor (callback, handler, allowErrorStatusCodes) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.#callback = callback\n    this.#handler = handler\n    this.#allowErrorStatusCodes = allowErrorStatusCodes\n  }\n\n  onRequestStart (_, context) {\n    this.#successful = false\n    this.#context = context\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (\n    controller,\n    statusCode,\n    headers,\n    statusMessage\n  ) {\n    assert(this.#callback != null)\n\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-handling-a-validation-respo\n    // https://datatracker.ietf.org/doc/html/rfc5861#section-4\n    this.#successful = statusCode === 304 ||\n      (this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504)\n    this.#callback(this.#successful, this.#context)\n    this.#callback = null\n\n    if (this.#successful) {\n      return true\n    }\n\n    this.#handler.onRequestStart?.(controller, this.#context)\n    this.#handler.onResponseStart?.(\n      controller,\n      statusCode,\n      headers,\n      statusMessage\n    )\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#successful) {\n      return\n    }\n\n    return this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#successful) {\n      return\n    }\n\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#successful) {\n      return\n    }\n\n    if (this.#callback) {\n      this.#callback(false)\n      this.#callback = null\n    }\n\n    if (typeof this.#handler.onResponseError === 'function') {\n      this.#handler.onResponseError(controller, err)\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports = CacheRevalidationHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2NhY2hlLXJldmFsaWRhdGlvbi1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLGdFQUFnRTtBQUM3RSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaGFuZGxlclxcY2FjaGUtcmV2YWxpZGF0aW9uLWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuLyoqXG4gKiBUaGlzIHRha2VzIGNhcmUgb2YgcmV2YWxpZGF0aW9uIHJlcXVlc3RzIHdlIHNlbmQgdG8gdGhlIG9yaWdpbi4gSWYgd2UgZ2V0XG4gKiAgYSByZXNwb25zZSBpbmRpY2F0aW5nIHRoYXQgd2hhdCB3ZSBoYXZlIGlzIGNhY2hlZCAodmlhIGEgSFRUUCAzMDQpLCB3ZSBjYW5cbiAqICBjb250aW51ZSB1c2luZyB0aGUgY2FjaGVkIHZhbHVlLiBPdGhlcndpc2UsIHdlJ2xsIHJlY2VpdmUgdGhlIG5ldyByZXNwb25zZVxuICogIGhlcmUsIHdoaWNoIHdlIHRoZW4ganVzdCBwYXNzIG9uIHRvIHRoZSBuZXh0IGhhbmRsZXIgKG1vc3QgbGlrZWx5IGFcbiAqICBDYWNoZUhhbmRsZXIpLiBOb3RlIHRoYXQgdGhpcyBhc3N1bWVzIHRoZSBwcm9wZXIgaGVhZGVycyB3ZXJlIGFscmVhZHlcbiAqICBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdCB0byB0ZWxsIHRoZSBvcmlnaW4gdGhhdCB3ZSB3YW50IHRvIHJldmFsaWRhdGUgdGhlXG4gKiAgcmVzcG9uc2UgKGkuZS4gaWYtbW9kaWZpZWQtc2luY2Ugb3IgaWYtbm9uZS1tYXRjaCkuXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtdmFsaWRhdGlvblxuICpcbiAqIEBpbXBsZW1lbnRzIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfVxuICovXG5jbGFzcyBDYWNoZVJldmFsaWRhdGlvbkhhbmRsZXIge1xuICAjc3VjY2Vzc2Z1bCA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHsoKGJvb2xlYW4sIGFueSkgPT4gdm9pZCkgfCBudWxsfVxuICAgKi9cbiAgI2NhbGxiYWNrXG5cbiAgLyoqXG4gICAqIEB0eXBlIHsoaW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoSGFuZGxlcil9XG4gICAqL1xuICAjaGFuZGxlclxuXG4gICNjb250ZXh0XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgI2FsbG93RXJyb3JTdGF0dXNDb2Rlc1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhib29sZWFuKSA9PiB2b2lkfSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBjYWNoZWQgdmFsdWUgaXMgdmFsaWRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyc30gaGFuZGxlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RXJyb3JTdGF0dXNDb2Rlc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBoYW5kbGVyLCBhbGxvd0Vycm9yU3RhdHVzQ29kZXMpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIHRoaXMuI2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuI2FsbG93RXJyb3JTdGF0dXNDb2RlcyA9IGFsbG93RXJyb3JTdGF0dXNDb2Rlc1xuICB9XG5cbiAgb25SZXF1ZXN0U3RhcnQgKF8sIGNvbnRleHQpIHtcbiAgICB0aGlzLiNzdWNjZXNzZnVsID0gZmFsc2VcbiAgICB0aGlzLiNjb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RVcGdyYWRlPy4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0IChcbiAgICBjb250cm9sbGVyLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXNNZXNzYWdlXG4gICkge1xuICAgIGFzc2VydCh0aGlzLiNjYWxsYmFjayAhPSBudWxsKVxuXG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLWhhbmRsaW5nLWEtdmFsaWRhdGlvbi1yZXNwb1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNTg2MSNzZWN0aW9uLTRcbiAgICB0aGlzLiNzdWNjZXNzZnVsID0gc3RhdHVzQ29kZSA9PT0gMzA0IHx8XG4gICAgICAodGhpcy4jYWxsb3dFcnJvclN0YXR1c0NvZGVzICYmIHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KVxuICAgIHRoaXMuI2NhbGxiYWNrKHRoaXMuI3N1Y2Nlc3NmdWwsIHRoaXMuI2NvbnRleHQpXG4gICAgdGhpcy4jY2FsbGJhY2sgPSBudWxsXG5cbiAgICBpZiAodGhpcy4jc3VjY2Vzc2Z1bCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4oY29udHJvbGxlciwgdGhpcy4jY29udGV4dClcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKFxuICAgICAgY29udHJvbGxlcixcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc3RhdHVzTWVzc2FnZVxuICAgIClcbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBjaHVuaykge1xuICAgIGlmICh0aGlzLiNzdWNjZXNzZnVsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKGNvbnRyb2xsZXIsIGNodW5rKVxuICB9XG5cbiAgb25SZXNwb25zZUVuZCAoY29udHJvbGxlciwgdHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy4jc3VjY2Vzc2Z1bCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oY29udHJvbGxlciwgdHJhaWxlcnMpXG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIGlmICh0aGlzLiNzdWNjZXNzZnVsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy4jY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuI2NhbGxiYWNrKGZhbHNlKVxuICAgICAgdGhpcy4jY2FsbGJhY2sgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVJldmFsaWRhdGlvbkhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst WrapHandler = __webpack_require__(/*! ./wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\n\n/**\n * @deprecated\n */\nmodule.exports = class DecoratorHandler {\n  #handler\n  #onCompleteCalled = false\n  #onErrorCalled = false\n  #onResponseStartCalled = false\n\n  constructor (handler) {\n    if (typeof handler !== 'object' || handler === null) {\n      throw new TypeError('handler must be an object')\n    }\n    this.#handler = WrapHandler.wrap(handler)\n  }\n\n  onRequestStart (...args) {\n    this.#handler.onRequestStart?.(...args)\n  }\n\n  onRequestUpgrade (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onRequestUpgrade?.(...args)\n  }\n\n  onResponseStart (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n    assert(!this.#onResponseStartCalled)\n\n    this.#onResponseStartCalled = true\n\n    return this.#handler.onResponseStart?.(...args)\n  }\n\n  onResponseData (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onResponseData?.(...args)\n  }\n\n  onResponseEnd (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    this.#onCompleteCalled = true\n    return this.#handler.onResponseEnd?.(...args)\n  }\n\n  onResponseError (...args) {\n    this.#onErrorCalled = true\n    return this.#handler.onResponseError?.(...args)\n  }\n\n  /**\n   * @deprecated\n   */\n  onBodySent () {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZ0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXGRlY29yYXRvci1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCBXcmFwSGFuZGxlciA9IHJlcXVpcmUoJy4vd3JhcC1oYW5kbGVyJylcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERlY29yYXRvckhhbmRsZXIge1xuICAjaGFuZGxlclxuICAjb25Db21wbGV0ZUNhbGxlZCA9IGZhbHNlXG4gICNvbkVycm9yQ2FsbGVkID0gZmFsc2VcbiAgI29uUmVzcG9uc2VTdGFydENhbGxlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnIHx8IGhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICB0aGlzLiNoYW5kbGVyID0gV3JhcEhhbmRsZXIud3JhcChoYW5kbGVyKVxuICB9XG5cbiAgb25SZXF1ZXN0U3RhcnQgKC4uLmFyZ3MpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVxdWVzdFVwZ3JhZGUgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKC4uLmFyZ3MpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuICAgIGFzc2VydCghdGhpcy4jb25SZXNwb25zZVN0YXJ0Q2FsbGVkKVxuXG4gICAgdGhpcy4jb25SZXNwb25zZVN0YXJ0Q2FsbGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhICguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KCF0aGlzLiNvbkNvbXBsZXRlQ2FsbGVkKVxuICAgIGFzc2VydCghdGhpcy4jb25FcnJvckNhbGxlZClcblxuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuXG4gICAgdGhpcy4jb25Db21wbGV0ZUNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VFcnJvciAoLi4uYXJncykge1xuICAgIHRoaXMuI29uRXJyb3JDYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZUVycm9yPy4oLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgb25Cb2R5U2VudCAoKSB7fVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/deduplication-handler.js":
/*!******************************************************************!*\
  !*** ./node_modules/undici/lib/handler/deduplication-handler.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @typedef {import('../../types/dispatcher.d.ts').default.DispatchHandler} DispatchHandler\n */\n\n/**\n * Handler that buffers response data and notifies multiple waiting handlers.\n * Used for request deduplication.\n *\n * @implements {DispatchHandler}\n */\nclass DeduplicationHandler {\n  /**\n   * @type {DispatchHandler}\n   */\n  #primaryHandler\n\n  /**\n   * @type {DispatchHandler[]}\n   */\n  #waitingHandlers = []\n\n  /**\n   * @type {Buffer[]}\n   */\n  #chunks = []\n\n  /**\n   * @type {number}\n   */\n  #statusCode = 0\n\n  /**\n   * @type {Record<string, string | string[]>}\n   */\n  #headers = {}\n\n  /**\n   * @type {string}\n   */\n  #statusMessage = ''\n\n  /**\n   * @type {boolean}\n   */\n  #aborted = false\n\n  /**\n   * @type {import('../../types/dispatcher.d.ts').default.DispatchController | null}\n   */\n  #controller = null\n\n  /**\n   * @type {(() => void) | null}\n   */\n  #onComplete = null\n\n  /**\n   * @param {DispatchHandler} primaryHandler The primary handler\n   * @param {() => void} onComplete Callback when request completes\n   */\n  constructor (primaryHandler, onComplete) {\n    this.#primaryHandler = primaryHandler\n    this.#onComplete = onComplete\n  }\n\n  /**\n   * Add a waiting handler that will receive the buffered response\n   * @param {DispatchHandler} handler\n   */\n  addWaitingHandler (handler) {\n    this.#waitingHandlers.push(handler)\n  }\n\n  /**\n   * @param {() => void} abort\n   * @param {any} context\n   */\n  onRequestStart (controller, context) {\n    this.#controller = controller\n    this.#primaryHandler.onRequestStart?.(controller, context)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {number} statusCode\n   * @param {import('../../types/header.d.ts').IncomingHttpHeaders} headers\n   * @param {Socket} socket\n   */\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#primaryHandler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {number} statusCode\n   * @param {Record<string, string | string[]>} headers\n   * @param {string} statusMessage\n   */\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.#statusCode = statusCode\n    this.#headers = headers\n    this.#statusMessage = statusMessage\n    this.#primaryHandler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {Buffer} chunk\n   */\n  onResponseData (controller, chunk) {\n    // Buffer the chunk for waiting handlers\n    this.#chunks.push(Buffer.from(chunk))\n    this.#primaryHandler.onResponseData?.(controller, chunk)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {object} trailers\n   */\n  onResponseEnd (controller, trailers) {\n    this.#primaryHandler.onResponseEnd?.(controller, trailers)\n    this.#notifyWaitingHandlers()\n    this.#onComplete?.()\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {Error} err\n   */\n  onResponseError (controller, err) {\n    this.#aborted = true\n    this.#primaryHandler.onResponseError?.(controller, err)\n    this.#notifyWaitingHandlersError(err)\n    this.#onComplete?.()\n  }\n\n  /**\n   * Notify all waiting handlers with the buffered response\n   */\n  #notifyWaitingHandlers () {\n    const body = Buffer.concat(this.#chunks)\n\n    for (const handler of this.#waitingHandlers) {\n      // Create a simple controller for each waiting handler\n      const waitingController = {\n        resume () {},\n        pause () {},\n        get paused () { return false },\n        get aborted () { return false },\n        get reason () { return null },\n        abort () {}\n      }\n\n      try {\n        handler.onRequestStart?.(waitingController, null)\n\n        if (waitingController.aborted) {\n          continue\n        }\n\n        handler.onResponseStart?.(\n          waitingController,\n          this.#statusCode,\n          this.#headers,\n          this.#statusMessage\n        )\n\n        if (waitingController.aborted) {\n          continue\n        }\n\n        if (body.length > 0) {\n          handler.onResponseData?.(waitingController, body)\n        }\n\n        handler.onResponseEnd?.(waitingController, {})\n      } catch {\n        // Ignore errors from waiting handlers\n      }\n    }\n\n    this.#waitingHandlers = []\n    this.#chunks = []\n  }\n\n  /**\n   * Notify all waiting handlers of an error\n   * @param {Error} err\n   */\n  #notifyWaitingHandlersError (err) {\n    for (const handler of this.#waitingHandlers) {\n      const waitingController = {\n        resume () {},\n        pause () {},\n        get paused () { return false },\n        get aborted () { return true },\n        get reason () { return err },\n        abort () {}\n      }\n\n      try {\n        handler.onRequestStart?.(waitingController, null)\n        handler.onResponseError?.(waitingController, err)\n      } catch {\n        // Ignore errors from waiting handlers\n      }\n    }\n\n    this.#waitingHandlers = []\n    this.#chunks = []\n  }\n}\n\nmodule.exports = DeduplicationHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlZHVwbGljYXRpb24taGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLGFBQWEsK0RBQStEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0VBQWtFO0FBQy9FLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVEQUF1RDtBQUNwRSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrRUFBa0U7QUFDL0UsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0VBQWtFO0FBQy9FLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHdCQUF3QixjQUFjO0FBQ3RDLHlCQUF5QixjQUFjO0FBQ3ZDLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JELFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHdCQUF3QixjQUFjO0FBQ3RDLHlCQUF5QixhQUFhO0FBQ3RDLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXGRlZHVwbGljYXRpb24taGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoSGFuZGxlcn0gRGlzcGF0Y2hIYW5kbGVyXG4gKi9cblxuLyoqXG4gKiBIYW5kbGVyIHRoYXQgYnVmZmVycyByZXNwb25zZSBkYXRhIGFuZCBub3RpZmllcyBtdWx0aXBsZSB3YWl0aW5nIGhhbmRsZXJzLlxuICogVXNlZCBmb3IgcmVxdWVzdCBkZWR1cGxpY2F0aW9uLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtEaXNwYXRjaEhhbmRsZXJ9XG4gKi9cbmNsYXNzIERlZHVwbGljYXRpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtEaXNwYXRjaEhhbmRsZXJ9XG4gICAqL1xuICAjcHJpbWFyeUhhbmRsZXJcblxuICAvKipcbiAgICogQHR5cGUge0Rpc3BhdGNoSGFuZGxlcltdfVxuICAgKi9cbiAgI3dhaXRpbmdIYW5kbGVycyA9IFtdXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCdWZmZXJbXX1cbiAgICovXG4gICNjaHVua3MgPSBbXVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgI3N0YXR1c0NvZGUgPSAwXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59XG4gICAqL1xuICAjaGVhZGVycyA9IHt9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAjc3RhdHVzTWVzc2FnZSA9ICcnXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgI2Fib3J0ZWQgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoQ29udHJvbGxlciB8IG51bGx9XG4gICAqL1xuICAjY29udHJvbGxlciA9IG51bGxcblxuICAvKipcbiAgICogQHR5cGUgeygoKSA9PiB2b2lkKSB8IG51bGx9XG4gICAqL1xuICAjb25Db21wbGV0ZSA9IG51bGxcblxuICAvKipcbiAgICogQHBhcmFtIHtEaXNwYXRjaEhhbmRsZXJ9IHByaW1hcnlIYW5kbGVyIFRoZSBwcmltYXJ5IGhhbmRsZXJcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBvbkNvbXBsZXRlIENhbGxiYWNrIHdoZW4gcmVxdWVzdCBjb21wbGV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwcmltYXJ5SGFuZGxlciwgb25Db21wbGV0ZSkge1xuICAgIHRoaXMuI3ByaW1hcnlIYW5kbGVyID0gcHJpbWFyeUhhbmRsZXJcbiAgICB0aGlzLiNvbkNvbXBsZXRlID0gb25Db21wbGV0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHdhaXRpbmcgaGFuZGxlciB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgYnVmZmVyZWQgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtEaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAgICovXG4gIGFkZFdhaXRpbmdIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy4jd2FpdGluZ0hhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGFib3J0XG4gICAqIEBwYXJhbSB7YW55fSBjb250ZXh0XG4gICAqL1xuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSBjb250cm9sbGVyXG4gICAgdGhpcy4jcHJpbWFyeUhhbmRsZXIub25SZXF1ZXN0U3RhcnQ/Lihjb250cm9sbGVyLCBjb250ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoQ29udHJvbGxlcn0gY29udHJvbGxlclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvaGVhZGVyLmQudHMnKS5JbmNvbWluZ0h0dHBIZWFkZXJzfSBoZWFkZXJzXG4gICAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAgICovXG4gIG9uUmVxdWVzdFVwZ3JhZGUgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuI3ByaW1hcnlIYW5kbGVyLm9uUmVxdWVzdFVwZ3JhZGU/Lihjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fSBoZWFkZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNNZXNzYWdlXG4gICAqL1xuICBvblJlc3BvbnNlU3RhcnQgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICB0aGlzLiNzdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuI2hlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy4jc3RhdHVzTWVzc2FnZSA9IHN0YXR1c01lc3NhZ2VcbiAgICB0aGlzLiNwcmltYXJ5SGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/Lihjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoQ29udHJvbGxlcn0gY29udHJvbGxlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICovXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBjaHVuaykge1xuICAgIC8vIEJ1ZmZlciB0aGUgY2h1bmsgZm9yIHdhaXRpbmcgaGFuZGxlcnNcbiAgICB0aGlzLiNjaHVua3MucHVzaChCdWZmZXIuZnJvbShjaHVuaykpXG4gICAgdGhpcy4jcHJpbWFyeUhhbmRsZXIub25SZXNwb25zZURhdGE/Lihjb250cm9sbGVyLCBjaHVuaylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaENvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRyYWlsZXJzXG4gICAqL1xuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIHRoaXMuI3ByaW1hcnlIYW5kbGVyLm9uUmVzcG9uc2VFbmQ/Lihjb250cm9sbGVyLCB0cmFpbGVycylcbiAgICB0aGlzLiNub3RpZnlXYWl0aW5nSGFuZGxlcnMoKVxuICAgIHRoaXMuI29uQ29tcGxldGU/LigpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZVxuICAgIHRoaXMuI3ByaW1hcnlIYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycilcbiAgICB0aGlzLiNub3RpZnlXYWl0aW5nSGFuZGxlcnNFcnJvcihlcnIpXG4gICAgdGhpcy4jb25Db21wbGV0ZT8uKClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgYWxsIHdhaXRpbmcgaGFuZGxlcnMgd2l0aCB0aGUgYnVmZmVyZWQgcmVzcG9uc2VcbiAgICovXG4gICNub3RpZnlXYWl0aW5nSGFuZGxlcnMgKCkge1xuICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2NodW5rcylcblxuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLiN3YWl0aW5nSGFuZGxlcnMpIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBjb250cm9sbGVyIGZvciBlYWNoIHdhaXRpbmcgaGFuZGxlclxuICAgICAgY29uc3Qgd2FpdGluZ0NvbnRyb2xsZXIgPSB7XG4gICAgICAgIHJlc3VtZSAoKSB7fSxcbiAgICAgICAgcGF1c2UgKCkge30sXG4gICAgICAgIGdldCBwYXVzZWQgKCkgeyByZXR1cm4gZmFsc2UgfSxcbiAgICAgICAgZ2V0IGFib3J0ZWQgKCkgeyByZXR1cm4gZmFsc2UgfSxcbiAgICAgICAgZ2V0IHJlYXNvbiAoKSB7IHJldHVybiBudWxsIH0sXG4gICAgICAgIGFib3J0ICgpIHt9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQ/Lih3YWl0aW5nQ29udHJvbGxlciwgbnVsbClcblxuICAgICAgICBpZiAod2FpdGluZ0NvbnRyb2xsZXIuYWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKFxuICAgICAgICAgIHdhaXRpbmdDb250cm9sbGVyLFxuICAgICAgICAgIHRoaXMuI3N0YXR1c0NvZGUsXG4gICAgICAgICAgdGhpcy4jaGVhZGVycyxcbiAgICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlXG4gICAgICAgIClcblxuICAgICAgICBpZiAod2FpdGluZ0NvbnRyb2xsZXIuYWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKHdhaXRpbmdDb250cm9sbGVyLCBib2R5KVxuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlci5vblJlc3BvbnNlRW5kPy4od2FpdGluZ0NvbnRyb2xsZXIsIHt9KVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgZnJvbSB3YWl0aW5nIGhhbmRsZXJzXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jd2FpdGluZ0hhbmRsZXJzID0gW11cbiAgICB0aGlzLiNjaHVua3MgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgd2FpdGluZyBoYW5kbGVycyBvZiBhbiBlcnJvclxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICovXG4gICNub3RpZnlXYWl0aW5nSGFuZGxlcnNFcnJvciAoZXJyKSB7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuI3dhaXRpbmdIYW5kbGVycykge1xuICAgICAgY29uc3Qgd2FpdGluZ0NvbnRyb2xsZXIgPSB7XG4gICAgICAgIHJlc3VtZSAoKSB7fSxcbiAgICAgICAgcGF1c2UgKCkge30sXG4gICAgICAgIGdldCBwYXVzZWQgKCkgeyByZXR1cm4gZmFsc2UgfSxcbiAgICAgICAgZ2V0IGFib3J0ZWQgKCkgeyByZXR1cm4gdHJ1ZSB9LFxuICAgICAgICBnZXQgcmVhc29uICgpIHsgcmV0dXJuIGVyciB9LFxuICAgICAgICBhYm9ydCAoKSB7fVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4od2FpdGluZ0NvbnRyb2xsZXIsIG51bGwpXG4gICAgICAgIGhhbmRsZXIub25SZXNwb25zZUVycm9yPy4od2FpdGluZ0NvbnRyb2xsZXIsIGVycilcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGZyb20gd2FpdGluZyBoYW5kbGVyc1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI3dhaXRpbmdIYW5kbGVycyA9IFtdXG4gICAgdGhpcy4jY2h1bmtzID0gW11cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlZHVwbGljYXRpb25IYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/deduplication-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nconst noop = () => {}\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  static buildDispatch (dispatcher, maxRedirections) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    const dispatch = dispatcher.dispatch.bind(dispatcher)\n    return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler))\n  }\n\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    this.dispatch = dispatch\n    this.location = null\n    const { maxRedirections: _, ...cleanOpts } = opts\n    this.opts = cleanOpts // opts must be a copy, exclude maxRedirections\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body) &&\n      !util.isFormDataLike(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onRequestStart (controller, context) {\n    this.handler.onRequestStart?.(controller, { ...context, history: this.history })\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n      throw new Error('max redirects')\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.2\n    // https://fetch.spec.whatwg.org/#http-redirect-fetch\n    // In case of HTTP 301 or 302 with POST, change the method to GET\n    if ((statusCode === 301 || statusCode === 302) && this.opts.method === 'POST') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1\n      ? null\n      : headers.location\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Check for redirect loops by seeing if we've already visited this URL in our history\n    // This catches the case where Client/Pool try to handle cross-origin redirects but fail\n    // and keep redirecting to the same URL in an infinite loop\n    const redirectUrlString = `${origin}${path}`\n    for (const historyUrl of this.history) {\n      if (historyUrl.toString() === redirectUrlString) {\n        throw new InvalidArgumentError(`Redirect loop detected. Cannot redirect to ${origin}. This typically happens when using a Client or Pool with cross-origin redirects. Use an Agent for cross-origin redirects.`)\n      }\n    }\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.query = null\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      this.handler.onResponseData?.(controller, chunk)\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, error) {\n    this.handler.onResponseError?.(controller, error)\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  if (header.length === 4) {\n    return util.headerNameToString(header) === 'host'\n  }\n  if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n    return true\n  }\n  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n    const name = util.headerNameToString(header)\n    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'\n  }\n  return false\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    const entries = typeof headers[Symbol.iterator] === 'function' ? headers : Object.entries(headers)\n    for (const [key, value] of entries) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, value)\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxtQ0FBbUM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDLDZCQUE2QixTQUFTLEVBQUUsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sRUFBRSxLQUFLO0FBQy9DO0FBQ0E7QUFDQSxxRkFBcUYsT0FBTztBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXHJlZGlyZWN0LWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY29uc3QgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMgPSBbMzAwLCAzMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY2xhc3MgQm9keUFzeW5jSXRlcmFibGUge1xuICBjb25zdHJ1Y3RvciAoYm9keSkge1xuICAgIHRoaXNba0JvZHldID0gYm9keVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IGZhbHNlXG4gIH1cblxuICBhc3luYyAqIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgIGFzc2VydCghdGhpc1trQm9keVVzZWRdLCAnZGlzdHVyYmVkJylcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgeWllbGQgKiB0aGlzW2tCb2R5XVxuICB9XG59XG5cbmNsYXNzIFJlZGlyZWN0SGFuZGxlciB7XG4gIHN0YXRpYyBidWlsZERpc3BhdGNoIChkaXNwYXRjaGVyLCBtYXhSZWRpcmVjdGlvbnMpIHtcbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gZGlzcGF0Y2hlci5kaXNwYXRjaC5iaW5kKGRpc3BhdGNoZXIpXG4gICAgcmV0dXJuIChvcHRzLCBvcmlnaW5hbEhhbmRsZXIpID0+IGRpc3BhdGNoKG9wdHMsIG5ldyBSZWRpcmVjdEhhbmRsZXIoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgb3JpZ2luYWxIYW5kbGVyKSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2hcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zOiBfLCAuLi5jbGVhbk9wdHMgfSA9IG9wdHNcbiAgICB0aGlzLm9wdHMgPSBjbGVhbk9wdHMgLy8gb3B0cyBtdXN0IGJlIGEgY29weSwgZXhjbHVkZSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0odGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgICBpZiAodXRpbC5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVxuICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgICBFRS5wcm90b3R5cGUub24uY2FsbCh0aGlzLm9wdHMuYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLm9wdHMuYm9keSAmJlxuICAgICAgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgIHV0aWwuaXNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgICF1dGlsLmlzRm9ybURhdGFMaWtlKHRoaXMub3B0cy5ib2R5KVxuICAgICkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGFsbG93IHJlLXVzaW5nIGl0ZXJhYmxlIGlmICF0aGlzLm9wdHMuaWRlbXBvdGVudFxuICAgICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKGNvbnRyb2xsZXIsIHsgLi4uY29udGV4dCwgaGlzdG9yeTogdGhpcy5oaXN0b3J5IH0pXG4gIH1cblxuICBvblJlcXVlc3RVcGdyYWRlIChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydCAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgIGlmICh0aGlzLm9wdHMudGhyb3dPbk1heFJlZGlyZWN0ICYmIHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IHJlZGlyZWN0cycpXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuMlxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXJlZGlyZWN0LWZldGNoXG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMSBvciAzMDIgd2l0aCBQT1NULCBjaGFuZ2UgdGhlIG1ldGhvZCB0byBHRVRcbiAgICBpZiAoKHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIpICYmIHRoaXMub3B0cy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgICBpZiAodXRpbC5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMub3B0cy5ib2R5Lm9uKCdlcnJvcicsIG5vb3ApKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuICAgIC8vIEluIGNhc2Ugb2YgSFRUUCAzMDMsIGFsd2F5cyByZXBsYWNlIG1ldGhvZCB0byBiZSBlaXRoZXIgSEVBRCBvciBHRVRcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMzAzICYmIHRoaXMub3B0cy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgICBpZiAodXRpbC5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMub3B0cy5ib2R5Lm9uKCdlcnJvcicsIG5vb3ApKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkgfHwgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTFcbiAgICAgID8gbnVsbFxuICAgICAgOiBoZWFkZXJzLmxvY2F0aW9uXG5cbiAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gQ2hlY2sgZm9yIHJlZGlyZWN0IGxvb3BzIGJ5IHNlZWluZyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhpcyBVUkwgaW4gb3VyIGhpc3RvcnlcbiAgICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNhc2Ugd2hlcmUgQ2xpZW50L1Bvb2wgdHJ5IHRvIGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVkaXJlY3RzIGJ1dCBmYWlsXG4gICAgLy8gYW5kIGtlZXAgcmVkaXJlY3RpbmcgdG8gdGhlIHNhbWUgVVJMIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICBjb25zdCByZWRpcmVjdFVybFN0cmluZyA9IGAke29yaWdpbn0ke3BhdGh9YFxuICAgIGZvciAoY29uc3QgaGlzdG9yeVVybCBvZiB0aGlzLmhpc3RvcnkpIHtcbiAgICAgIGlmIChoaXN0b3J5VXJsLnRvU3RyaW5nKCkgPT09IHJlZGlyZWN0VXJsU3RyaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgUmVkaXJlY3QgbG9vcCBkZXRlY3RlZC4gQ2Fubm90IHJlZGlyZWN0IHRvICR7b3JpZ2lufS4gVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIHVzaW5nIGEgQ2xpZW50IG9yIFBvb2wgd2l0aCBjcm9zcy1vcmlnaW4gcmVkaXJlY3RzLiBVc2UgYW4gQWdlbnQgZm9yIGNyb3NzLW9yaWdpbiByZWRpcmVjdHMuYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgaGVhZGVycyByZWZlcnJpbmcgdG8gdGhlIG9yaWdpbmFsIFVSTC5cbiAgICAvLyBCeSBkZWZhdWx0IGl0IGlzIEhvc3Qgb25seSwgdW5sZXNzIGl0J3MgYSAzMDMgKHNlZSBiZWxvdyksIHdoaWNoIHJlbW92ZXMgYWxzbyBhbGwgQ29udGVudC0qIGhlYWRlcnMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcbiAgICB0aGlzLm9wdHMuaGVhZGVycyA9IGNsZWFuUmVxdWVzdEhlYWRlcnModGhpcy5vcHRzLmhlYWRlcnMsIHN0YXR1c0NvZGUgPT09IDMwMywgdGhpcy5vcHRzLm9yaWdpbiAhPT0gb3JpZ2luKVxuICAgIHRoaXMub3B0cy5wYXRoID0gcGF0aFxuICAgIHRoaXMub3B0cy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0bHkgY2hvb3NlcyBub3QgdG8gc3BlY2lmeSBhIGZvcm1hdCBmb3Igc3VjaCBib2R5IGFuZCBsZWF2ZSBpdCB0b1xuICAgICAgICBzZXJ2ZXJzIGFuZCBicm93c2VycyBpbXBsZW1lbnRvcnMsIHdlIGlnbm9yZSB0aGUgYm9keSBhcyB0aGVyZSBpcyBubyBzcGVjaWZpZWQgd2F5IHRvIGV2ZW50dWFsbHkgcGFyc2UgaXQuXG4gICAgICAqL1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZURhdGE/Lihjb250cm9sbGVyLCBjaHVuaylcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgdHJhaWxlcnMgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIGluIGNhc2Ugb2YgcmVkaXJlY3Rpb25zXG4gICAgICAgIGFuZCBuZWl0aGVyIGFyZSB1c2VmdWwgaWYgcHJlc2VudC5cblxuICAgICAgICBTZWUgY29tbWVudCBvbiBvbkRhdGEgbWV0aG9kIGFib3ZlIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgICAgKi9cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB0cmFpbGVycylcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycm9yKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlciAoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGlmIChoZWFkZXIubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikgPT09ICdob3N0J1xuICB9XG4gIGlmIChyZW1vdmVDb250ZW50ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikuc3RhcnRzV2l0aCgnY29udGVudC0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHVua25vd25PcmlnaW4gJiYgKGhlYWRlci5sZW5ndGggPT09IDEzIHx8IGhlYWRlci5sZW5ndGggPT09IDYgfHwgaGVhZGVyLmxlbmd0aCA9PT0gMTkpKSB7XG4gICAgY29uc3QgbmFtZSA9IHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcilcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dGhvcml6YXRpb24nIHx8IG5hbWUgPT09ICdjb29raWUnIHx8IG5hbWUgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJ1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyAoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICBjb25zdCByZXQgPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZW50cmllcyA9IHR5cGVvZiBoZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgPyBoZWFkZXJzIDogT2JqZWN0LmVudHJpZXMoaGVhZGVycylcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihrZXksIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChoZWFkZXJzID09IG51bGwsICdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3RIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst WrapHandler = __webpack_require__(/*! ./wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\nconst {\n  isDisturbed,\n  parseRangeHeader,\n  wrapRequestBody\n} = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const retryTime = new Date(retryAfter).getTime()\n  return isNaN(retryTime) ? 0 : retryTime - Date.now()\n}\n\nclass RetryHandler {\n  constructor (opts, { dispatch, handler }) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes,\n      throwOnError\n    } = retryOptions ?? {}\n\n    this.error = null\n    this.dispatch = dispatch\n    this.handler = WrapHandler.wrap(handler)\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.retryOpts = {\n      throwOnError: throwOnError ?? true,\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.headersSent = false\n    this.start = 0\n    this.end = null\n    this.etag = null\n  }\n\n  onResponseStartWithRetry (controller, statusCode, headers, statusMessage, err) {\n    if (this.retryOpts.throwOnError) {\n      // Preserve old behavior for status codes that are not eligible for retry\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      } else {\n        this.error = err\n      }\n\n      return\n    }\n\n    if (isDisturbed(this.opts.body)) {\n      this.headersSent = true\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    function shouldRetry (passedErr) {\n      if (passedErr) {\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n        controller.resume()\n        return\n      }\n\n      this.error = err\n      controller.resume()\n    }\n\n    controller.pause()\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n\n  onRequestStart (controller, context) {\n    if (!this.headersSent) {\n      this.handler.onRequestStart?.(controller, context)\n    }\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(headers['retry-after'])\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.error = null\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      const err = new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: {\n          count: this.retryCount\n        }\n      })\n\n      this.onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err)\n      return\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.headersSent) {\n      // Only Partial Content 206 supposed to provide Content-Range,\n      // any other status code that partially consumed the payload\n      // should not be retried because it would result in downstream\n      // wrongly concatenate multiple responses.\n      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {\n        throw new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('Content-Range mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('ETag mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const { start, size, end = size ? size - 1 : null } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      return\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          this.headersSent = true\n          this.handler.onResponseStart?.(\n            controller,\n            statusCode,\n            headers,\n            statusMessage\n          )\n          return\n        }\n\n        const { start, size, end = size ? size - 1 : null } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) - 1 : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = true\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (\n        this.etag != null &&\n        this.etag[0] === 'W' &&\n        this.etag[1] === '/'\n      ) {\n        this.etag = null\n      }\n\n      this.headersSent = true\n      this.handler.onResponseStart?.(\n        controller,\n        statusCode,\n        headers,\n        statusMessage\n      )\n    } else {\n      throw new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: { count: this.retryCount }\n      })\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.error) {\n      return\n    }\n\n    this.start += chunk.length\n\n    this.handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.error && this.retryOpts.throwOnError) {\n      throw this.error\n    }\n\n    if (!this.error) {\n      this.retryCount = 0\n      return this.handler.onResponseEnd?.(controller, trailers)\n    }\n\n    this.retry(controller)\n  }\n\n  retry (controller) {\n    if (this.start !== 0) {\n      const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n      // Weak etag check - weak etags will make comparison algorithms never match\n      if (this.etag != null) {\n        headers['if-match'] = this.etag\n      }\n\n      this.opts = {\n        ...this.opts,\n        headers: {\n          ...this.opts.headers,\n          ...headers\n        }\n      }\n    }\n\n    try {\n      this.retryCountCheckpoint = this.retryCount\n      this.dispatch(this.opts, this)\n    } catch (err) {\n      this.handler.onResponseError?.(controller, err)\n    }\n  }\n\n  onResponseError (controller, err) {\n    if (controller?.aborted || isDisturbed(this.opts.body)) {\n      this.handler.onResponseError?.(controller, err)\n      return\n    }\n\n    function shouldRetry (returnedErr) {\n      if (!returnedErr) {\n        this.retry(controller)\n        return\n      }\n\n      this.handler?.onResponseError?.(controller, returnedErr)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n}\n\nmodule.exports = RetryHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDL0QsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0MsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGFBQWE7QUFDMUQsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLFVBQVU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7O0FBRUEsY0FBYyw0Q0FBNEM7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLFdBQVcsR0FBRyxlQUFlOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxoYW5kbGVyXFxyZXRyeS1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCB7IGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFJlcXVlc3RSZXRyeUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBXcmFwSGFuZGxlciA9IHJlcXVpcmUoJy4vd3JhcC1oYW5kbGVyJylcbmNvbnN0IHtcbiAgaXNEaXN0dXJiZWQsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIHdyYXBSZXF1ZXN0Qm9keVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIgKHJldHJ5QWZ0ZXIpIHtcbiAgY29uc3QgcmV0cnlUaW1lID0gbmV3IERhdGUocmV0cnlBZnRlcikuZ2V0VGltZSgpXG4gIHJldHVybiBpc05hTihyZXRyeVRpbWUpID8gMCA6IHJldHJ5VGltZSAtIERhdGUubm93KClcbn1cblxuY2xhc3MgUmV0cnlIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIHsgZGlzcGF0Y2gsIGhhbmRsZXIgfSkge1xuICAgIGNvbnN0IHsgcmV0cnlPcHRpb25zLCAuLi5kaXNwYXRjaE9wdHMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICAvLyBSZXRyeSBzY29wZWRcbiAgICAgIHJldHJ5OiByZXRyeUZuLFxuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICBtaW5UaW1lb3V0LFxuICAgICAgdGltZW91dEZhY3RvcixcbiAgICAgIC8vIFJlc3BvbnNlIHNjb3BlZFxuICAgICAgbWV0aG9kcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICByZXRyeUFmdGVyLFxuICAgICAgc3RhdHVzQ29kZXMsXG4gICAgICB0aHJvd09uRXJyb3JcbiAgICB9ID0gcmV0cnlPcHRpb25zID8/IHt9XG5cbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICAgIHRoaXMuaGFuZGxlciA9IFdyYXBIYW5kbGVyLndyYXAoaGFuZGxlcilcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRpc3BhdGNoT3B0cywgYm9keTogd3JhcFJlcXVlc3RCb2R5KG9wdHMuYm9keSkgfVxuICAgIHRoaXMucmV0cnlPcHRzID0ge1xuICAgICAgdGhyb3dPbkVycm9yOiB0aHJvd09uRXJyb3IgPz8gdHJ1ZSxcbiAgICAgIHJldHJ5OiByZXRyeUZuID8/IFJldHJ5SGFuZGxlcltrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5XSxcbiAgICAgIHJldHJ5QWZ0ZXI6IHJldHJ5QWZ0ZXIgPz8gdHJ1ZSxcbiAgICAgIG1heFRpbWVvdXQ6IG1heFRpbWVvdXQgPz8gMzAgKiAxMDAwLCAvLyAzMHMsXG4gICAgICBtaW5UaW1lb3V0OiBtaW5UaW1lb3V0ID8/IDUwMCwgLy8gLjVzXG4gICAgICB0aW1lb3V0RmFjdG9yOiB0aW1lb3V0RmFjdG9yID8/IDIsXG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDUsXG4gICAgICAvLyBXaGF0IGVycm9ycyB3ZSBzaG91bGQgcmV0cnlcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHMgPz8gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BVVCcsICdERUxFVEUnLCAnVFJBQ0UnXSxcbiAgICAgIC8vIEluZGljYXRlcyB3aGljaCBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIHN0YXR1c0NvZGVzOiBzdGF0dXNDb2RlcyA/PyBbNTAwLCA1MDIsIDUwMywgNTA0LCA0MjldLFxuICAgICAgLy8gTGlzdCBvZiBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIGVycm9yQ29kZXM6IGVycm9yQ29kZXMgPz8gW1xuICAgICAgICAnRUNPTk5SRVNFVCcsXG4gICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgJ0VORVRET1dOJyxcbiAgICAgICAgJ0VORVRVTlJFQUNIJyxcbiAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICdFSE9TVFVOUkVBQ0gnLFxuICAgICAgICAnRVBJUEUnLFxuICAgICAgICAnVU5EX0VSUl9TT0NLRVQnXG4gICAgICBdXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSAwXG4gICAgdGhpcy5oZWFkZXJzU2VudCA9IGZhbHNlXG4gICAgdGhpcy5zdGFydCA9IDBcbiAgICB0aGlzLmVuZCA9IG51bGxcbiAgICB0aGlzLmV0YWcgPSBudWxsXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnRXaXRoUmV0cnkgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UsIGVycikge1xuICAgIGlmICh0aGlzLnJldHJ5T3B0cy50aHJvd09uRXJyb3IpIHtcbiAgICAgIC8vIFByZXNlcnZlIG9sZCBiZWhhdmlvciBmb3Igc3RhdHVzIGNvZGVzIHRoYXQgYXJlIG5vdCBlbGlnaWJsZSBmb3IgcmV0cnlcbiAgICAgIGlmICh0aGlzLnJldHJ5T3B0cy5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1NlbnQgPSB0cnVlXG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZFJldHJ5IChwYXNzZWRFcnIpIHtcbiAgICAgIGlmIChwYXNzZWRFcnIpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gICAgICAgIGNvbnRyb2xsZXIucmVzdW1lKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJcbiAgICAgIGNvbnRyb2xsZXIucmVzdW1lKClcbiAgICB9XG5cbiAgICBjb250cm9sbGVyLnBhdXNlKClcbiAgICB0aGlzLnJldHJ5T3B0cy5yZXRyeShcbiAgICAgIGVycixcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHsgY291bnRlcjogdGhpcy5yZXRyeUNvdW50IH0sXG4gICAgICAgIG9wdHM6IHsgcmV0cnlPcHRpb25zOiB0aGlzLnJldHJ5T3B0cywgLi4udGhpcy5vcHRzIH1cbiAgICAgIH0sXG4gICAgICBzaG91bGRSZXRyeS5iaW5kKHRoaXMpXG4gICAgKVxuICB9XG5cbiAgb25SZXF1ZXN0U3RhcnQgKGNvbnRyb2xsZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuaGVhZGVyc1NlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKGNvbnRyb2xsZXIsIGNvbnRleHQpXG4gICAgfVxuICB9XG5cbiAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uUmVxdWVzdFVwZ3JhZGU/Lihjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBzdGF0aWMgW2tSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnldIChlcnIsIHsgc3RhdGUsIG9wdHMgfSwgY2IpIHtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGNvZGUsIGhlYWRlcnMgfSA9IGVyclxuICAgIGNvbnN0IHsgbWV0aG9kLCByZXRyeU9wdGlvbnMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWluVGltZW91dCxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgc3RhdHVzQ29kZXMsXG4gICAgICBlcnJvckNvZGVzLFxuICAgICAgbWV0aG9kc1xuICAgIH0gPSByZXRyeU9wdGlvbnNcbiAgICBjb25zdCB7IGNvdW50ZXIgfSA9IHN0YXRlXG5cbiAgICAvLyBBbnkgY29kZSB0aGF0IGlzIG5vdCBhIFVuZGljaSdzIG9yaWdpbmF0ZWQgYW5kIGFsbG93ZWQgdG8gcmV0cnlcbiAgICBpZiAoY29kZSAmJiBjb2RlICE9PSAnVU5EX0VSUl9SRVFfUkVUUlknICYmICFlcnJvckNvZGVzLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBtZXRob2QgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBtZXRob2QgaXMgbm90IGluIHRoZSBsaXN0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0aG9kcykgJiYgIW1ldGhvZHMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgYSBzZXQgb2Ygc3RhdHVzIGNvZGUgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBzdGF0dXMgY29kZSBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoXG4gICAgICBzdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoc3RhdHVzQ29kZXMpICYmXG4gICAgICAhc3RhdHVzQ29kZXMuaW5jbHVkZXMoc3RhdHVzQ29kZSlcbiAgICApIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIG1heCBudW1iZXIgb2YgcmV0cmllc1xuICAgIGlmIChjb3VudGVyID4gbWF4UmV0cmllcykge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJldHJ5QWZ0ZXJIZWFkZXIgPSBoZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ11cbiAgICBpZiAocmV0cnlBZnRlckhlYWRlcikge1xuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlcihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlci5pc05hTihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgICA/IGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIoaGVhZGVyc1sncmV0cnktYWZ0ZXInXSlcbiAgICAgICAgOiByZXRyeUFmdGVySGVhZGVyICogMWUzIC8vIFJldHJ5LUFmdGVyIGlzIGluIHNlY29uZHNcbiAgICB9XG5cbiAgICBjb25zdCByZXRyeVRpbWVvdXQgPVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA+IDBcbiAgICAgICAgPyBNYXRoLm1pbihyZXRyeUFmdGVySGVhZGVyLCBtYXhUaW1lb3V0KVxuICAgICAgICA6IE1hdGgubWluKG1pblRpbWVvdXQgKiB0aW1lb3V0RmFjdG9yICoqIChjb3VudGVyIC0gMSksIG1heFRpbWVvdXQpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGNiKG51bGwpLCByZXRyeVRpbWVvdXQpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBjb3VudDogdGhpcy5yZXRyeUNvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXNwb25zZVN0YXJ0V2l0aFJldHJ5KGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UsIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENoZWNrcG9pbnQgZm9yIHJlc3VtZSBmcm9tIHdoZXJlIHdlIGxlZnQgaXRcbiAgICBpZiAodGhpcy5oZWFkZXJzU2VudCkge1xuICAgICAgLy8gT25seSBQYXJ0aWFsIENvbnRlbnQgMjA2IHN1cHBvc2VkIHRvIHByb3ZpZGUgQ29udGVudC1SYW5nZSxcbiAgICAgIC8vIGFueSBvdGhlciBzdGF0dXMgY29kZSB0aGF0IHBhcnRpYWxseSBjb25zdW1lZCB0aGUgcGF5bG9hZFxuICAgICAgLy8gc2hvdWxkIG5vdCBiZSByZXRyaWVkIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGRvd25zdHJlYW1cbiAgICAgIC8vIHdyb25nbHkgY29uY2F0ZW5hdGUgbXVsdGlwbGUgcmVzcG9uc2VzLlxuICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwNiAmJiAodGhpcy5zdGFydCA+IDAgfHwgc3RhdHVzQ29kZSAhPT0gMjAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ3NlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByYW5nZSBoZWFkZXIgYW5kIHRoZSBwYXlsb2FkIHdhcyBwYXJ0aWFsbHkgY29uc3VtZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSBwYXJzZVJhbmdlSGVhZGVyKGhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSlcbiAgICAgIC8vIElmIG5vIGNvbnRlbnQgcmFuZ2VcbiAgICAgIGlmICghY29udGVudFJhbmdlKSB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyB0aHJvdyBoZXJlIGFzIHdlIHdhbnQgdG8gaW5kaWNhdGUgdGhhdCB3ZSBlbnRyZWQgdW5leHBlY3RlZCBwYXRoXG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignQ29udGVudC1SYW5nZSBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIExldCdzIHN0YXJ0IHdpdGggYSB3ZWFrIGV0YWcgY2hlY2tcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCAmJiB0aGlzLmV0YWcgIT09IGhlYWRlcnMuZXRhZykge1xuICAgICAgICAvLyBXZSBhbHdheXMgdGhyb3cgaGVyZSBhcyB3ZSB3YW50IHRvIGluZGljYXRlIHRoYXQgd2UgZW50cmVkIHVuZXhwZWN0ZWQgcGF0aFxuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ0VUYWcgbWlzbWF0Y2gnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHN0YXJ0LCBzaXplLCBlbmQgPSBzaXplID8gc2l6ZSAtIDEgOiBudWxsIH0gPSBjb250ZW50UmFuZ2VcblxuICAgICAgYXNzZXJ0KHRoaXMuc3RhcnQgPT09IHN0YXJ0LCAnY29udGVudC1yYW5nZSBtaXNtYXRjaCcpXG4gICAgICBhc3NlcnQodGhpcy5lbmQgPT0gbnVsbCB8fCB0aGlzLmVuZCA9PT0gZW5kLCAnY29udGVudC1yYW5nZSBtaXNtYXRjaCcpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZCA9PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMjA2KSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgcmVjZWl2ZSAyMDZcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXJzZVJhbmdlSGVhZGVyKGhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSlcblxuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuaGVhZGVyc1NlbnQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKFxuICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgPyBzaXplIC0gMSA6IG51bGwgfSA9IHJhbmdlXG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICBzdGFydCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShzdGFydCksXG4gICAgICAgICAgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnXG4gICAgICAgIClcbiAgICAgICAgYXNzZXJ0KGVuZCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShlbmQpLCAnaW52YWxpZCBjb250ZW50LWxlbmd0aCcpXG5cbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0XG4gICAgICAgIHRoaXMuZW5kID0gZW5kXG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG1ha2Ugb3VyIGJlc3QgdG8gY2hlY2twb2ludCB0aGUgYm9keSBmb3IgZnVydGhlciByYW5nZSBoZWFkZXJzXG4gICAgICBpZiAodGhpcy5lbmQgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICAgICAgICB0aGlzLmVuZCA9IGNvbnRlbnRMZW5ndGggIT0gbnVsbCA/IE51bWJlcihjb250ZW50TGVuZ3RoKSAtIDEgOiBudWxsXG4gICAgICB9XG5cbiAgICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodGhpcy5zdGFydCkpXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMuZW5kID09IG51bGwgfHwgTnVtYmVyLmlzRmluaXRlKHRoaXMuZW5kKSxcbiAgICAgICAgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnXG4gICAgICApXG5cbiAgICAgIHRoaXMucmVzdW1lID0gdHJ1ZVxuICAgICAgdGhpcy5ldGFnID0gaGVhZGVycy5ldGFnICE9IG51bGwgPyBoZWFkZXJzLmV0YWcgOiBudWxsXG5cbiAgICAgIC8vIFdlYWsgZXRhZ3MgYXJlIG5vdCB1c2VmdWwgZm9yIGNvbXBhcmlzb24gbm9yIGNhY2hlXG4gICAgICAvLyBmb3IgaW5zdGFuY2Ugbm90IHNhZmUgdG8gYXNzdW1lIGlmIHRoZSByZXNwb25zZSBpcyBieXRlLXBlci1ieXRlXG4gICAgICAvLyBlcXVhbFxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmV0YWcgIT0gbnVsbCAmJlxuICAgICAgICB0aGlzLmV0YWdbMF0gPT09ICdXJyAmJlxuICAgICAgICB0aGlzLmV0YWdbMV0gPT09ICcvJ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZXRhZyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcbiAgICAgIHRoaXMuaGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/LihcbiAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ1JlcXVlc3QgZmFpbGVkJywgc3RhdHVzQ29kZSwge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCArPSBjaHVuay5sZW5ndGhcblxuICAgIHRoaXMuaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKGNvbnRyb2xsZXIsIGNodW5rKVxuICB9XG5cbiAgb25SZXNwb25zZUVuZCAoY29udHJvbGxlciwgdHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy5lcnJvciAmJiB0aGlzLnJldHJ5T3B0cy50aHJvd09uRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDBcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25SZXNwb25zZUVuZD8uKGNvbnRyb2xsZXIsIHRyYWlsZXJzKVxuICAgIH1cblxuICAgIHRoaXMucmV0cnkoY29udHJvbGxlcilcbiAgfVxuXG4gIHJldHJ5IChjb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IDApIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IHJhbmdlOiBgYnl0ZXM9JHt0aGlzLnN0YXJ0fS0ke3RoaXMuZW5kID8/ICcnfWAgfVxuXG4gICAgICAvLyBXZWFrIGV0YWcgY2hlY2sgLSB3ZWFrIGV0YWdzIHdpbGwgbWFrZSBjb21wYXJpc29uIGFsZ29yaXRobXMgbmV2ZXIgbWF0Y2hcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzWydpZi1tYXRjaCddID0gdGhpcy5ldGFnXG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0cyA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4udGhpcy5vcHRzLmhlYWRlcnMsXG4gICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSB0aGlzLnJldHJ5Q291bnRcbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycilcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIGlmIChjb250cm9sbGVyPy5hYm9ydGVkIHx8IGlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZFJldHJ5IChyZXR1cm5lZEVycikge1xuICAgICAgaWYgKCFyZXR1cm5lZEVycikge1xuICAgICAgICB0aGlzLnJldHJ5KGNvbnRyb2xsZXIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbmRsZXI/Lm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIHJldHVybmVkRXJyKVxuICAgIH1cblxuICAgIC8vIFdlIHJlY29uY2lsZSBpbiBjYXNlIG9mIGEgbWl4IGJldHdlZW4gbmV0d29yayBlcnJvcnNcbiAgICAvLyBhbmQgc2VydmVyIGVycm9yIHJlc3BvbnNlXG4gICAgaWYgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPiAwKSB7XG4gICAgICAvLyBXZSBjb3VudCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IGNoZWNrcG9pbnQgYW5kIHRoZSBjdXJyZW50IHJldHJ5IGNvdW50XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPVxuICAgICAgICB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ICtcbiAgICAgICAgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeU9wdHMucmV0cnkoXG4gICAgICBlcnIsXG4gICAgICB7XG4gICAgICAgIHN0YXRlOiB7IGNvdW50ZXI6IHRoaXMucmV0cnlDb3VudCB9LFxuICAgICAgICBvcHRzOiB7IHJldHJ5T3B0aW9uczogdGhpcy5yZXRyeU9wdHMsIC4uLnRoaXMub3B0cyB9XG4gICAgICB9LFxuICAgICAgc2hvdWxkUmV0cnkuYmluZCh0aGlzKVxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5SGFuZGxlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/handler/unwrap-handler.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { parseHeaders } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kResume = Symbol('resume')\n\nclass UnwrapController {\n  #paused = false\n  #reason = null\n  #aborted = false\n  #abort\n\n  [kResume] = null\n\n  constructor (abort) {\n    this.#abort = abort\n  }\n\n  pause () {\n    this.#paused = true\n  }\n\n  resume () {\n    if (this.#paused) {\n      this.#paused = false\n      this[kResume]?.()\n    }\n  }\n\n  abort (reason) {\n    if (!this.#aborted) {\n      this.#aborted = true\n      this.#reason = reason\n      this.#abort(reason)\n    }\n  }\n\n  get aborted () {\n    return this.#aborted\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  get paused () {\n    return this.#paused\n  }\n}\n\nmodule.exports = class UnwrapHandler {\n  #handler\n  #controller\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static unwrap (handler) {\n    // TODO (fix): More checks...\n    return !handler.onRequestStart ? handler : new UnwrapHandler(handler)\n  }\n\n  onConnect (abort, context) {\n    this.#controller = new UnwrapController(abort)\n    this.#handler.onRequestStart?.(this.#controller, context)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    this.#controller[kResume] = resume\n    this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage)\n    return !this.#controller.paused\n  }\n\n  onData (data) {\n    this.#handler.onResponseData?.(this.#controller, data)\n    return !this.#controller.paused\n  }\n\n  onComplete (rawTrailers) {\n    this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers))\n  }\n\n  onError (err) {\n    if (!this.#handler.onResponseError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onResponseError?.(this.#controller, err)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3Vud3JhcC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDL0MsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXHVud3JhcC1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBhcnNlSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga1Jlc3VtZSA9IFN5bWJvbCgncmVzdW1lJylcblxuY2xhc3MgVW53cmFwQ29udHJvbGxlciB7XG4gICNwYXVzZWQgPSBmYWxzZVxuICAjcmVhc29uID0gbnVsbFxuICAjYWJvcnRlZCA9IGZhbHNlXG4gICNhYm9ydFxuXG4gIFtrUmVzdW1lXSA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoYWJvcnQpIHtcbiAgICB0aGlzLiNhYm9ydCA9IGFib3J0XG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpcy4jcGF1c2VkID0gdHJ1ZVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy4jcGF1c2VkKSB7XG4gICAgICB0aGlzLiNwYXVzZWQgPSBmYWxzZVxuICAgICAgdGhpc1trUmVzdW1lXT8uKClcbiAgICB9XG4gIH1cblxuICBhYm9ydCAocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLiNhYm9ydGVkKSB7XG4gICAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZVxuICAgICAgdGhpcy4jcmVhc29uID0gcmVhc29uXG4gICAgICB0aGlzLiNhYm9ydChyZWFzb24pXG4gICAgfVxuICB9XG5cbiAgZ2V0IGFib3J0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLiNhYm9ydGVkXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhc29uXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGF1c2VkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVbndyYXBIYW5kbGVyIHtcbiAgI2hhbmRsZXJcbiAgI2NvbnRyb2xsZXJcblxuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBzdGF0aWMgdW53cmFwIChoYW5kbGVyKSB7XG4gICAgLy8gVE9ETyAoZml4KTogTW9yZSBjaGVja3MuLi5cbiAgICByZXR1cm4gIWhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPyBoYW5kbGVyIDogbmV3IFVud3JhcEhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLiNjb250cm9sbGVyID0gbmV3IFVud3JhcENvbnRyb2xsZXIoYWJvcnQpXG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKHRoaXMuI2NvbnRyb2xsZXIsIGNvbnRleHQpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuI2hhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKHRoaXMuI2NvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSwgc29ja2V0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICB0aGlzLiNjb250cm9sbGVyW2tSZXN1bWVdID0gcmVzdW1lXG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/Lih0aGlzLiNjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBwYXJzZUhlYWRlcnMocmF3SGVhZGVycyksIHN0YXR1c01lc3NhZ2UpXG4gICAgcmV0dXJuICF0aGlzLiNjb250cm9sbGVyLnBhdXNlZFxuICB9XG5cbiAgb25EYXRhIChkYXRhKSB7XG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKHRoaXMuI2NvbnRyb2xsZXIsIGRhdGEpXG4gICAgcmV0dXJuICF0aGlzLiNjb250cm9sbGVyLnBhdXNlZFxuICB9XG5cbiAgb25Db21wbGV0ZSAocmF3VHJhaWxlcnMpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFbmQ/Lih0aGlzLiNjb250cm9sbGVyLCBwYXJzZUhlYWRlcnMocmF3VHJhaWxlcnMpKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKHRoaXMuI2NvbnRyb2xsZXIsIGVycilcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/wrap-handler.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/handler/wrap-handler.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nmodule.exports = class WrapHandler {\n  #handler\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static wrap (handler) {\n    // TODO (fix): More checks...\n    return handler.onRequestStart ? handler : new WrapHandler(handler)\n  }\n\n  // Unwrap Interface\n\n  onConnect (abort, context) {\n    return this.#handler.onConnect?.(abort, context)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onData (data) {\n    return this.#handler.onData?.(data)\n  }\n\n  onComplete (trailers) {\n    return this.#handler.onComplete?.(trailers)\n  }\n\n  onError (err) {\n    if (!this.#handler.onError) {\n      throw err\n    }\n\n    return this.#handler.onError?.(err)\n  }\n\n  // Wrap Interface\n\n  onRequestStart (controller, context) {\n    this.#handler.onConnect?.((reason) => controller.abort(reason), context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseData (controller, data) {\n    if (this.#handler.onData?.(data) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    const rawTrailers = []\n    for (const [key, val] of Object.entries(trailers)) {\n      rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onComplete?.(rawTrailers)\n  }\n\n  onResponseError (controller, err) {\n    if (!this.#handler.onError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onError?.(err)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3dyYXAtaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXHdyYXAtaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFdyYXBIYW5kbGVyIHtcbiAgI2hhbmRsZXJcblxuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBzdGF0aWMgd3JhcCAoaGFuZGxlcikge1xuICAgIC8vIFRPRE8gKGZpeCk6IE1vcmUgY2hlY2tzLi4uXG4gICAgcmV0dXJuIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPyBoYW5kbGVyIDogbmV3IFdyYXBIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICAvLyBVbndyYXAgSW50ZXJmYWNlXG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdD8uKGFib3J0LCBjb250ZXh0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uVXBncmFkZT8uKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRGF0YSAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uRGF0YT8uKGRhdGEpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGU/Lih0cmFpbGVycylcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGlmICghdGhpcy4jaGFuZGxlci5vbkVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkVycm9yPy4oZXJyKVxuICB9XG5cbiAgLy8gV3JhcCBJbnRlcmZhY2VcblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuI2hhbmRsZXIub25Db25uZWN0Py4oKHJlYXNvbikgPT4gY29udHJvbGxlci5hYm9ydChyZWFzb24pLCBjb250ZXh0KVxuICB9XG5cbiAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgcmF3SGVhZGVycyA9IFtdXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICByYXdIZWFkZXJzLnB1c2goQnVmZmVyLmZyb20oa2V5KSwgQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLm1hcCh2ID0+IEJ1ZmZlci5mcm9tKHYpKSA6IEJ1ZmZlci5mcm9tKHZhbCkpXG4gICAgfVxuXG4gICAgdGhpcy4jaGFuZGxlci5vblVwZ3JhZGU/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCByYXdIZWFkZXJzID0gW11cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgIHJhd0hlYWRlcnMucHVzaChCdWZmZXIuZnJvbShrZXkpLCBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKHYgPT4gQnVmZmVyLmZyb20odikpIDogQnVmZmVyLmZyb20odmFsKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCAoKSA9PiBjb250cm9sbGVyLnJlc3VtZSgpLCBzdGF0dXNNZXNzYWdlKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRyb2xsZXIucGF1c2UoKVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuI2hhbmRsZXIub25EYXRhPy4oZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICBjb250cm9sbGVyLnBhdXNlKClcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIGNvbnN0IHJhd1RyYWlsZXJzID0gW11cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModHJhaWxlcnMpKSB7XG4gICAgICByYXdUcmFpbGVycy5wdXNoKEJ1ZmZlci5mcm9tKGtleSksIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5tYXAodiA9PiBCdWZmZXIuZnJvbSh2KSkgOiBCdWZmZXIuZnJvbSh2YWwpKVxuICAgIH1cblxuICAgIHRoaXMuI2hhbmRsZXIub25Db21wbGV0ZT8uKHJhd1RyYWlsZXJzKVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICBpZiAoIXRoaXMuI2hhbmRsZXIub25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3I/LihlcnIpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/cache.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/cache.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst CacheHandler = __webpack_require__(/*! ../handler/cache-handler */ \"(rsc)/./node_modules/undici/lib/handler/cache-handler.js\")\nconst MemoryCacheStore = __webpack_require__(/*! ../cache/memory-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\")\nconst CacheRevalidationHandler = __webpack_require__(/*! ../handler/cache-revalidation-handler */ \"(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js\")\nconst { assertCacheStore, assertCacheMethods, makeCacheKey, normalizeHeaders, parseCacheControlHeader } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\nconst { AbortError } = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * @param {(string | RegExp)[] | undefined} origins\n * @param {string} name\n */\nfunction assertCacheOrigins (origins, name) {\n  if (origins === undefined) return\n  if (!Array.isArray(origins)) {\n    throw new TypeError(`expected ${name} to be an array or undefined, got ${typeof origins}`)\n  }\n  for (let i = 0; i < origins.length; i++) {\n    const origin = origins[i]\n    if (typeof origin !== 'string' && !(origin instanceof RegExp)) {\n      throw new TypeError(`expected ${name}[${i}] to be a string or RegExp, got ${typeof origin}`)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @typedef {(options: import('../../types/dispatcher.d.ts').default.DispatchOptions, handler: import('../../types/dispatcher.d.ts').default.DispatchHandler) => void} DispatchFn\n */\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} cacheControlDirectives\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @returns {boolean}\n */\nfunction needsRevalidation (result, cacheControlDirectives, { headers = {} }) {\n  // Always revalidate requests with the no-cache request directive.\n  if (cacheControlDirectives?.['no-cache']) {\n    return true\n  }\n\n  // Always revalidate requests with unqualified no-cache response directive.\n  if (result.cacheControlDirectives?.['no-cache'] && !Array.isArray(result.cacheControlDirectives['no-cache'])) {\n    return true\n  }\n\n  // Always revalidate requests with conditional headers.\n  if (headers['if-modified-since'] || headers['if-none-match']) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} cacheControlDirectives\n * @returns {boolean}\n */\nfunction isStale (result, cacheControlDirectives) {\n  const now = Date.now()\n  if (now > result.staleAt) {\n    // Response is stale\n    if (cacheControlDirectives?.['max-stale']) {\n      // There's a threshold where we can serve stale responses, let's see if\n      //  we're in it\n      // https://www.rfc-editor.org/rfc/rfc9111.html#name-max-stale\n      const gracePeriod = result.staleAt + (cacheControlDirectives['max-stale'] * 1000)\n      return now > gracePeriod\n    }\n\n    return true\n  }\n\n  if (cacheControlDirectives?.['min-fresh']) {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.3\n\n    // At this point, staleAt is always > now\n    const timeLeftTillStale = result.staleAt - now\n    const threshold = cacheControlDirectives['min-fresh'] * 1000\n\n    return timeLeftTillStale <= threshold\n  }\n\n  return false\n}\n\n/**\n * Check if we're within the stale-while-revalidate window for a stale response\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @returns {boolean}\n */\nfunction withinStaleWhileRevalidateWindow (result) {\n  const staleWhileRevalidate = result.cacheControlDirectives?.['stale-while-revalidate']\n  if (!staleWhileRevalidate) {\n    return false\n  }\n\n  const now = Date.now()\n  const staleWhileRevalidateExpiry = result.staleAt + (staleWhileRevalidate * 1000)\n  return now <= staleWhileRevalidateExpiry\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n */\nfunction handleUncachedResponse (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl\n) {\n  if (reqCacheControl?.['only-if-cached']) {\n    let aborted = false\n    try {\n      if (typeof handler.onConnect === 'function') {\n        handler.onConnect(() => {\n          aborted = true\n        })\n\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onHeaders === 'function') {\n        handler.onHeaders(504, [], nop, 'Gateway Timeout')\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onComplete === 'function') {\n        handler.onComplete([])\n      }\n    } catch (err) {\n      if (typeof handler.onError === 'function') {\n        handler.onError(err)\n      }\n    }\n\n    return true\n  }\n\n  return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n}\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {number} age\n * @param {any} context\n * @param {boolean} isStale\n */\nfunction sendCachedValue (handler, opts, result, age, context, isStale) {\n  // TODO (perf): Readable.from path can be optimized...\n  const stream = util.isStream(result.body)\n    ? result.body\n    : Readable.from(result.body ?? [])\n\n  assert(!stream.destroyed, 'stream should not be destroyed')\n  assert(!stream.readableDidRead, 'stream should not be readableDidRead')\n\n  const controller = {\n    resume () {\n      stream.resume()\n    },\n    pause () {\n      stream.pause()\n    },\n    get paused () {\n      return stream.isPaused()\n    },\n    get aborted () {\n      return stream.destroyed\n    },\n    get reason () {\n      return stream.errored\n    },\n    abort (reason) {\n      stream.destroy(reason ?? new AbortError())\n    }\n  }\n\n  stream\n    .on('error', function (err) {\n      if (!this.readableEnded) {\n        if (typeof handler.onResponseError === 'function') {\n          handler.onResponseError(controller, err)\n        } else {\n          throw err\n        }\n      }\n    })\n    .on('close', function () {\n      if (!this.errored) {\n        handler.onResponseEnd?.(controller, {})\n      }\n    })\n\n  handler.onRequestStart?.(controller, context)\n\n  if (stream.destroyed) {\n    return\n  }\n\n  // Add the age header\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-age\n  const headers = { ...result.headers, age: String(age) }\n\n  if (isStale) {\n    // Add warning header\n    //  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning\n    headers.warning = '110 - \"response is stale\"'\n  }\n\n  handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage)\n\n  if (opts.method === 'HEAD') {\n    stream.destroy()\n  } else {\n    stream.on('data', function (chunk) {\n      handler.onResponseData?.(controller, chunk)\n    })\n  }\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined} result\n */\nfunction handleResult (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl,\n  result\n) {\n  if (!result) {\n    return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl)\n  }\n\n  const now = Date.now()\n  if (now > result.deleteAt) {\n    // Response is expired, cache store shouldn't have given this to us\n    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n  }\n\n  const age = Math.round((now - result.cachedAt) / 1000)\n  if (reqCacheControl?.['max-age'] && age >= reqCacheControl['max-age']) {\n    // Response is considered expired for this specific request\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.1\n    return dispatch(opts, handler)\n  }\n\n  const stale = isStale(result, reqCacheControl)\n  const revalidate = needsRevalidation(result, reqCacheControl, opts)\n\n  // Check if the response is stale\n  if (stale || revalidate) {\n    if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {\n      // If body is a stream we can't revalidate...\n      // TODO (fix): This could be less strict...\n      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n    }\n\n    // RFC 5861: If we're within stale-while-revalidate window, serve stale immediately\n    // and revalidate in background, unless immediate revalidation is necessary\n    if (!revalidate && withinStaleWhileRevalidateWindow(result)) {\n      // Serve stale response immediately\n      sendCachedValue(handler, opts, result, age, null, true)\n\n      // Start background revalidation (fire-and-forget)\n      queueMicrotask(() => {\n        let headers = {\n          ...opts.headers,\n          'if-modified-since': new Date(result.cachedAt).toUTCString()\n        }\n\n        if (result.etag) {\n          headers['if-none-match'] = result.etag\n        }\n\n        if (result.vary) {\n          headers = {\n            ...headers,\n            ...result.vary\n          }\n        }\n\n        // Background revalidation - update cache if we get new data\n        dispatch(\n          {\n            ...opts,\n            headers\n          },\n          new CacheHandler(globalOpts, cacheKey, {\n            // Silent handler that just updates the cache\n            onRequestStart () {},\n            onRequestUpgrade () {},\n            onResponseStart () {},\n            onResponseData () {},\n            onResponseEnd () {},\n            onResponseError () {}\n          })\n        )\n      })\n\n      return true\n    }\n\n    let withinStaleIfErrorThreshold = false\n    const staleIfErrorExpiry = result.cacheControlDirectives['stale-if-error'] ?? reqCacheControl?.['stale-if-error']\n    if (staleIfErrorExpiry) {\n      withinStaleIfErrorThreshold = now < (result.staleAt + (staleIfErrorExpiry * 1000))\n    }\n\n    let headers = {\n      ...opts.headers,\n      'if-modified-since': new Date(result.cachedAt).toUTCString()\n    }\n\n    if (result.etag) {\n      headers['if-none-match'] = result.etag\n    }\n\n    if (result.vary) {\n      headers = {\n        ...headers,\n        ...result.vary\n      }\n    }\n\n    // We need to revalidate the response\n    return dispatch(\n      {\n        ...opts,\n        headers\n      },\n      new CacheRevalidationHandler(\n        (success, context) => {\n          if (success) {\n            // TODO: successful revalidation should be considered fresh (not give stale warning).\n            sendCachedValue(handler, opts, result, age, context, stale)\n          } else if (util.isStream(result.body)) {\n            result.body.on('error', nop).destroy()\n          }\n        },\n        new CacheHandler(globalOpts, cacheKey, handler),\n        withinStaleIfErrorThreshold\n      )\n    )\n  }\n\n  // Dump request body.\n  if (util.isStream(opts.body)) {\n    opts.body.on('error', nop).destroy()\n  }\n\n  sendCachedValue(handler, opts, result, age, null, false)\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions} [opts]\n * @returns {import('../../types/dispatcher.d.ts').default.DispatcherComposeInterceptor}\n */\nmodule.exports = (opts = {}) => {\n  const {\n    store = new MemoryCacheStore(),\n    methods = ['GET'],\n    cacheByDefault = undefined,\n    type = 'shared',\n    origins = undefined\n  } = opts\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? 'null' : typeof opts}`)\n  }\n\n  assertCacheStore(store, 'opts.store')\n  assertCacheMethods(methods, 'opts.methods')\n  assertCacheOrigins(origins, 'opts.origins')\n\n  if (typeof cacheByDefault !== 'undefined' && typeof cacheByDefault !== 'number') {\n    throw new TypeError(`expected opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`)\n  }\n\n  if (typeof type !== 'undefined' && type !== 'shared' && type !== 'private') {\n    throw new TypeError(`expected opts.type to be shared, private, or undefined, got ${typeof type}`)\n  }\n\n  const globalOpts = {\n    store,\n    methods,\n    cacheByDefault,\n    type\n  }\n\n  const safeMethodsToNotCache = util.safeHTTPMethods.filter(method => methods.includes(method) === false)\n\n  return dispatch => {\n    return (opts, handler) => {\n      if (!opts.origin || safeMethodsToNotCache.includes(opts.method)) {\n        // Not a method we want to cache or we don't have the origin, skip\n        return dispatch(opts, handler)\n      }\n\n      // Check if origin is in whitelist\n      if (origins !== undefined) {\n        const requestOrigin = opts.origin.toString().toLowerCase()\n        let isAllowed = false\n\n        for (let i = 0; i < origins.length; i++) {\n          const allowed = origins[i]\n          if (typeof allowed === 'string') {\n            if (allowed.toLowerCase() === requestOrigin) {\n              isAllowed = true\n              break\n            }\n          } else if (allowed.test(requestOrigin)) {\n            isAllowed = true\n            break\n          }\n        }\n\n        if (!isAllowed) {\n          return dispatch(opts, handler)\n        }\n      }\n\n      opts = {\n        ...opts,\n        headers: normalizeHeaders(opts)\n      }\n\n      const reqCacheControl = opts.headers?.['cache-control']\n        ? parseCacheControlHeader(opts.headers['cache-control'])\n        : undefined\n\n      if (reqCacheControl?.['no-store']) {\n        return dispatch(opts, handler)\n      }\n\n      /**\n       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n       */\n      const cacheKey = makeCacheKey(opts)\n      const result = store.get(cacheKey)\n\n      if (result && typeof result.then === 'function') {\n        return result\n          .then(result => handleResult(dispatch,\n            globalOpts,\n            cacheKey,\n            handler,\n            opts,\n            reqCacheControl,\n            result\n          ))\n      } else {\n        return handleResult(\n          dispatch,\n          globalOpts,\n          cacheKey,\n          handler,\n          opts,\n          reqCacheControl,\n          result\n        )\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELHlCQUF5QixtQkFBTyxDQUFDLGdHQUE2QjtBQUM5RCxpQ0FBaUMsbUJBQU8sQ0FBQyxvSEFBdUM7QUFDaEYsUUFBUSxnR0FBZ0csRUFBRSxtQkFBTyxDQUFDLHVFQUFrQjtBQUNwSSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlFQUFtQjs7QUFFbEQ7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxtQ0FBbUMsZUFBZTtBQUM1RjtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBLHNDQUFzQyxLQUFLLEdBQUcsRUFBRSxrQ0FBa0MsY0FBYztBQUNoRztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLDBKQUEwSjtBQUN2Szs7QUFFQTtBQUNBLFdBQVcsZ0VBQWdFO0FBQzNFLFdBQVcseUZBQXlGO0FBQ3BHLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdFQUFnRTtBQUMzRSxXQUFXLHlGQUF5RjtBQUNwRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzRUFBc0UscUNBQXFDO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVGQUF1RixzQkFBc0I7QUFDN0c7O0FBRUE7QUFDQSx1RkFBdUYsWUFBWTtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaW50ZXJjZXB0b3JcXGNhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IENhY2hlSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvY2FjaGUtaGFuZGxlcicpXG5jb25zdCBNZW1vcnlDYWNoZVN0b3JlID0gcmVxdWlyZSgnLi4vY2FjaGUvbWVtb3J5LWNhY2hlLXN0b3JlJylcbmNvbnN0IENhY2hlUmV2YWxpZGF0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvY2FjaGUtcmV2YWxpZGF0aW9uLWhhbmRsZXInKVxuY29uc3QgeyBhc3NlcnRDYWNoZVN0b3JlLCBhc3NlcnRDYWNoZU1ldGhvZHMsIG1ha2VDYWNoZUtleSwgbm9ybWFsaXplSGVhZGVycywgcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWwvY2FjaGUuanMnKVxuY29uc3QgeyBBYm9ydEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5cbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdIHwgdW5kZWZpbmVkfSBvcmlnaW5zXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBhc3NlcnRDYWNoZU9yaWdpbnMgKG9yaWdpbnMsIG5hbWUpIHtcbiAgaWYgKG9yaWdpbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW5zKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gYXJyYXkgb3IgdW5kZWZpbmVkLCBnb3QgJHt0eXBlb2Ygb3JpZ2luc31gKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2lucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9yaWdpbnNbaV1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycgJiYgIShvcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCAke25hbWV9WyR7aX1dIHRvIGJlIGEgc3RyaW5nIG9yIFJlZ0V4cCwgZ290ICR7dHlwZW9mIG9yaWdpbn1gKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBub3AgPSAoKSA9PiB7fVxuXG4vKipcbiAqIEB0eXBlZGVmIHsob3B0aW9uczogaW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoT3B0aW9ucywgaGFuZGxlcjogaW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoSGFuZGxlcikgPT4gdm9pZH0gRGlzcGF0Y2hGblxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlcyB8IHVuZGVmaW5lZH0gY2FjaGVDb250cm9sRGlyZWN0aXZlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuUmVxdWVzdE9wdGlvbnN9IG9wdHNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBuZWVkc1JldmFsaWRhdGlvbiAocmVzdWx0LCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLCB7IGhlYWRlcnMgPSB7fSB9KSB7XG4gIC8vIEFsd2F5cyByZXZhbGlkYXRlIHJlcXVlc3RzIHdpdGggdGhlIG5vLWNhY2hlIHJlcXVlc3QgZGlyZWN0aXZlLlxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlcz8uWyduby1jYWNoZSddKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEFsd2F5cyByZXZhbGlkYXRlIHJlcXVlc3RzIHdpdGggdW5xdWFsaWZpZWQgbm8tY2FjaGUgcmVzcG9uc2UgZGlyZWN0aXZlLlxuICBpZiAocmVzdWx0LmNhY2hlQ29udHJvbERpcmVjdGl2ZXM/Llsnbm8tY2FjaGUnXSAmJiAhQXJyYXkuaXNBcnJheShyZXN1bHQuY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbm8tY2FjaGUnXSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gQWx3YXlzIHJldmFsaWRhdGUgcmVxdWVzdHMgd2l0aCBjb25kaXRpb25hbCBoZWFkZXJzLlxuICBpZiAoaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXSB8fCBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlcyB8IHVuZGVmaW5lZH0gY2FjaGVDb250cm9sRGlyZWN0aXZlc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RhbGUgKHJlc3VsdCwgY2FjaGVDb250cm9sRGlyZWN0aXZlcykge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gIGlmIChub3cgPiByZXN1bHQuc3RhbGVBdCkge1xuICAgIC8vIFJlc3BvbnNlIGlzIHN0YWxlXG4gICAgaWYgKGNhY2hlQ29udHJvbERpcmVjdGl2ZXM/LlsnbWF4LXN0YWxlJ10pIHtcbiAgICAgIC8vIFRoZXJlJ3MgYSB0aHJlc2hvbGQgd2hlcmUgd2UgY2FuIHNlcnZlIHN0YWxlIHJlc3BvbnNlcywgbGV0J3Mgc2VlIGlmXG4gICAgICAvLyAgd2UncmUgaW4gaXRcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjbmFtZS1tYXgtc3RhbGVcbiAgICAgIGNvbnN0IGdyYWNlUGVyaW9kID0gcmVzdWx0LnN0YWxlQXQgKyAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbWF4LXN0YWxlJ10gKiAxMDAwKVxuICAgICAgcmV0dXJuIG5vdyA+IGdyYWNlUGVyaW9kXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzPy5bJ21pbi1mcmVzaCddKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNzZWN0aW9uLTUuMi4xLjNcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHN0YWxlQXQgaXMgYWx3YXlzID4gbm93XG4gICAgY29uc3QgdGltZUxlZnRUaWxsU3RhbGUgPSByZXN1bHQuc3RhbGVBdCAtIG5vd1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ21pbi1mcmVzaCddICogMTAwMFxuXG4gICAgcmV0dXJuIHRpbWVMZWZ0VGlsbFN0YWxlIDw9IHRocmVzaG9sZFxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgd2l0aGluIHRoZSBzdGFsZS13aGlsZS1yZXZhbGlkYXRlIHdpbmRvdyBmb3IgYSBzdGFsZSByZXNwb25zZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gd2l0aGluU3RhbGVXaGlsZVJldmFsaWRhdGVXaW5kb3cgKHJlc3VsdCkge1xuICBjb25zdCBzdGFsZVdoaWxlUmV2YWxpZGF0ZSA9IHJlc3VsdC5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzPy5bJ3N0YWxlLXdoaWxlLXJldmFsaWRhdGUnXVxuICBpZiAoIXN0YWxlV2hpbGVSZXZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gIGNvbnN0IHN0YWxlV2hpbGVSZXZhbGlkYXRlRXhwaXJ5ID0gcmVzdWx0LnN0YWxlQXQgKyAoc3RhbGVXaGlsZVJldmFsaWRhdGUgKiAxMDAwKVxuICByZXR1cm4gbm93IDw9IHN0YWxlV2hpbGVSZXZhbGlkYXRlRXhwaXJ5XG59XG5cbi8qKlxuICogQHBhcmFtIHtEaXNwYXRjaEZufSBkaXNwYXRjaFxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlSGFuZGxlck9wdGlvbnN9IGdsb2JhbE9wdHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0gY2FjaGVLZXlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoSGFuZGxlcn0gaGFuZGxlclxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuUmVxdWVzdE9wdGlvbnN9IG9wdHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUNvbnRyb2xEaXJlY3RpdmVzIHwgdW5kZWZpbmVkfSByZXFDYWNoZUNvbnRyb2xcbiAqL1xuZnVuY3Rpb24gaGFuZGxlVW5jYWNoZWRSZXNwb25zZSAoXG4gIGRpc3BhdGNoLFxuICBnbG9iYWxPcHRzLFxuICBjYWNoZUtleSxcbiAgaGFuZGxlcixcbiAgb3B0cyxcbiAgcmVxQ2FjaGVDb250cm9sXG4pIHtcbiAgaWYgKHJlcUNhY2hlQ29udHJvbD8uWydvbmx5LWlmLWNhY2hlZCddKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25Db25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIub25Db25uZWN0KCgpID0+IHtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyLm9uSGVhZGVycyg1MDQsIFtdLCBub3AsICdHYXRld2F5IFRpbWVvdXQnKVxuICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIub25Db21wbGV0ZShbXSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaChvcHRzLCBuZXcgQ2FjaGVIYW5kbGVyKGdsb2JhbE9wdHMsIGNhY2hlS2V5LCBoYW5kbGVyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LlJlcXVlc3RPcHRpb25zfSBvcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZ2VcbiAqIEBwYXJhbSB7YW55fSBjb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhbGVcbiAqL1xuZnVuY3Rpb24gc2VuZENhY2hlZFZhbHVlIChoYW5kbGVyLCBvcHRzLCByZXN1bHQsIGFnZSwgY29udGV4dCwgaXNTdGFsZSkge1xuICAvLyBUT0RPIChwZXJmKTogUmVhZGFibGUuZnJvbSBwYXRoIGNhbiBiZSBvcHRpbWl6ZWQuLi5cbiAgY29uc3Qgc3RyZWFtID0gdXRpbC5pc1N0cmVhbShyZXN1bHQuYm9keSlcbiAgICA/IHJlc3VsdC5ib2R5XG4gICAgOiBSZWFkYWJsZS5mcm9tKHJlc3VsdC5ib2R5ID8/IFtdKVxuXG4gIGFzc2VydCghc3RyZWFtLmRlc3Ryb3llZCwgJ3N0cmVhbSBzaG91bGQgbm90IGJlIGRlc3Ryb3llZCcpXG4gIGFzc2VydCghc3RyZWFtLnJlYWRhYmxlRGlkUmVhZCwgJ3N0cmVhbSBzaG91bGQgbm90IGJlIHJlYWRhYmxlRGlkUmVhZCcpXG5cbiAgY29uc3QgY29udHJvbGxlciA9IHtcbiAgICByZXN1bWUgKCkge1xuICAgICAgc3RyZWFtLnJlc3VtZSgpXG4gICAgfSxcbiAgICBwYXVzZSAoKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH0sXG4gICAgZ2V0IHBhdXNlZCAoKSB7XG4gICAgICByZXR1cm4gc3RyZWFtLmlzUGF1c2VkKClcbiAgICB9LFxuICAgIGdldCBhYm9ydGVkICgpIHtcbiAgICAgIHJldHVybiBzdHJlYW0uZGVzdHJveWVkXG4gICAgfSxcbiAgICBnZXQgcmVhc29uICgpIHtcbiAgICAgIHJldHVybiBzdHJlYW0uZXJyb3JlZFxuICAgIH0sXG4gICAgYWJvcnQgKHJlYXNvbikge1xuICAgICAgc3RyZWFtLmRlc3Ryb3kocmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtXG4gICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5yZWFkYWJsZUVuZGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vblJlc3BvbnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuZXJyb3JlZCkge1xuICAgICAgICBoYW5kbGVyLm9uUmVzcG9uc2VFbmQ/Lihjb250cm9sbGVyLCB7fSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQ/Lihjb250cm9sbGVyLCBjb250ZXh0KVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBBZGQgdGhlIGFnZSBoZWFkZXJcbiAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLWFnZVxuICBjb25zdCBoZWFkZXJzID0geyAuLi5yZXN1bHQuaGVhZGVycywgYWdlOiBTdHJpbmcoYWdlKSB9XG5cbiAgaWYgKGlzU3RhbGUpIHtcbiAgICAvLyBBZGQgd2FybmluZyBoZWFkZXJcbiAgICAvLyAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1dhcm5pbmdcbiAgICBoZWFkZXJzLndhcm5pbmcgPSAnMTEwIC0gXCJyZXNwb25zZSBpcyBzdGFsZVwiJ1xuICB9XG5cbiAgaGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/Lihjb250cm9sbGVyLCByZXN1bHQuc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdWx0LnN0YXR1c01lc3NhZ2UpXG5cbiAgaWYgKG9wdHMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBoYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oY29udHJvbGxlciwgY2h1bmspXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGlzcGF0Y2hGbn0gZGlzcGF0Y2hcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUhhbmRsZXJPcHRpb25zfSBnbG9iYWxPcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGNhY2hlS2V5XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LlJlcXVlc3RPcHRpb25zfSBvcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlcyB8IHVuZGVmaW5lZH0gcmVxQ2FjaGVDb250cm9sXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0IHwgdW5kZWZpbmVkfSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVzdWx0IChcbiAgZGlzcGF0Y2gsXG4gIGdsb2JhbE9wdHMsXG4gIGNhY2hlS2V5LFxuICBoYW5kbGVyLFxuICBvcHRzLFxuICByZXFDYWNoZUNvbnRyb2wsXG4gIHJlc3VsdFxuKSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIGhhbmRsZVVuY2FjaGVkUmVzcG9uc2UoZGlzcGF0Y2gsIGdsb2JhbE9wdHMsIGNhY2hlS2V5LCBoYW5kbGVyLCBvcHRzLCByZXFDYWNoZUNvbnRyb2wpXG4gIH1cblxuICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gIGlmIChub3cgPiByZXN1bHQuZGVsZXRlQXQpIHtcbiAgICAvLyBSZXNwb25zZSBpcyBleHBpcmVkLCBjYWNoZSBzdG9yZSBzaG91bGRuJ3QgaGF2ZSBnaXZlbiB0aGlzIHRvIHVzXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIG5ldyBDYWNoZUhhbmRsZXIoZ2xvYmFsT3B0cywgY2FjaGVLZXksIGhhbmRsZXIpKVxuICB9XG5cbiAgY29uc3QgYWdlID0gTWF0aC5yb3VuZCgobm93IC0gcmVzdWx0LmNhY2hlZEF0KSAvIDEwMDApXG4gIGlmIChyZXFDYWNoZUNvbnRyb2w/LlsnbWF4LWFnZSddICYmIGFnZSA+PSByZXFDYWNoZUNvbnRyb2xbJ21heC1hZ2UnXSkge1xuICAgIC8vIFJlc3BvbnNlIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBmb3IgdGhpcyBzcGVjaWZpYyByZXF1ZXN0XG4gICAgLy8gIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjc2VjdGlvbi01LjIuMS4xXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBjb25zdCBzdGFsZSA9IGlzU3RhbGUocmVzdWx0LCByZXFDYWNoZUNvbnRyb2wpXG4gIGNvbnN0IHJldmFsaWRhdGUgPSBuZWVkc1JldmFsaWRhdGlvbihyZXN1bHQsIHJlcUNhY2hlQ29udHJvbCwgb3B0cylcblxuICAvLyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgaXMgc3RhbGVcbiAgaWYgKHN0YWxlIHx8IHJldmFsaWRhdGUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmVhbShvcHRzLmJvZHkpICYmIHV0aWwuYm9keUxlbmd0aChvcHRzLmJvZHkpICE9PSAwKSB7XG4gICAgICAvLyBJZiBib2R5IGlzIGEgc3RyZWFtIHdlIGNhbid0IHJldmFsaWRhdGUuLi5cbiAgICAgIC8vIFRPRE8gKGZpeCk6IFRoaXMgY291bGQgYmUgbGVzcyBzdHJpY3QuLi5cbiAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBuZXcgQ2FjaGVIYW5kbGVyKGdsb2JhbE9wdHMsIGNhY2hlS2V5LCBoYW5kbGVyKSlcbiAgICB9XG5cbiAgICAvLyBSRkMgNTg2MTogSWYgd2UncmUgd2l0aGluIHN0YWxlLXdoaWxlLXJldmFsaWRhdGUgd2luZG93LCBzZXJ2ZSBzdGFsZSBpbW1lZGlhdGVseVxuICAgIC8vIGFuZCByZXZhbGlkYXRlIGluIGJhY2tncm91bmQsIHVubGVzcyBpbW1lZGlhdGUgcmV2YWxpZGF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgIGlmICghcmV2YWxpZGF0ZSAmJiB3aXRoaW5TdGFsZVdoaWxlUmV2YWxpZGF0ZVdpbmRvdyhyZXN1bHQpKSB7XG4gICAgICAvLyBTZXJ2ZSBzdGFsZSByZXNwb25zZSBpbW1lZGlhdGVseVxuICAgICAgc2VuZENhY2hlZFZhbHVlKGhhbmRsZXIsIG9wdHMsIHJlc3VsdCwgYWdlLCBudWxsLCB0cnVlKVxuXG4gICAgICAvLyBTdGFydCBiYWNrZ3JvdW5kIHJldmFsaWRhdGlvbiAoZmlyZS1hbmQtZm9yZ2V0KVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBsZXQgaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5vcHRzLmhlYWRlcnMsXG4gICAgICAgICAgJ2lmLW1vZGlmaWVkLXNpbmNlJzogbmV3IERhdGUocmVzdWx0LmNhY2hlZEF0KS50b1VUQ1N0cmluZygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmV0YWcpIHtcbiAgICAgICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSByZXN1bHQuZXRhZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC52YXJ5KSB7XG4gICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAuLi5yZXN1bHQudmFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2tncm91bmQgcmV2YWxpZGF0aW9uIC0gdXBkYXRlIGNhY2hlIGlmIHdlIGdldCBuZXcgZGF0YVxuICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3IENhY2hlSGFuZGxlcihnbG9iYWxPcHRzLCBjYWNoZUtleSwge1xuICAgICAgICAgICAgLy8gU2lsZW50IGhhbmRsZXIgdGhhdCBqdXN0IHVwZGF0ZXMgdGhlIGNhY2hlXG4gICAgICAgICAgICBvblJlcXVlc3RTdGFydCAoKSB7fSxcbiAgICAgICAgICAgIG9uUmVxdWVzdFVwZ3JhZGUgKCkge30sXG4gICAgICAgICAgICBvblJlc3BvbnNlU3RhcnQgKCkge30sXG4gICAgICAgICAgICBvblJlc3BvbnNlRGF0YSAoKSB7fSxcbiAgICAgICAgICAgIG9uUmVzcG9uc2VFbmQgKCkge30sXG4gICAgICAgICAgICBvblJlc3BvbnNlRXJyb3IgKCkge31cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCB3aXRoaW5TdGFsZUlmRXJyb3JUaHJlc2hvbGQgPSBmYWxzZVxuICAgIGNvbnN0IHN0YWxlSWZFcnJvckV4cGlyeSA9IHJlc3VsdC5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzdGFsZS1pZi1lcnJvciddID8/IHJlcUNhY2hlQ29udHJvbD8uWydzdGFsZS1pZi1lcnJvciddXG4gICAgaWYgKHN0YWxlSWZFcnJvckV4cGlyeSkge1xuICAgICAgd2l0aGluU3RhbGVJZkVycm9yVGhyZXNob2xkID0gbm93IDwgKHJlc3VsdC5zdGFsZUF0ICsgKHN0YWxlSWZFcnJvckV4cGlyeSAqIDEwMDApKVxuICAgIH1cblxuICAgIGxldCBoZWFkZXJzID0ge1xuICAgICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICAgJ2lmLW1vZGlmaWVkLXNpbmNlJzogbmV3IERhdGUocmVzdWx0LmNhY2hlZEF0KS50b1VUQ1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5ldGFnKSB7XG4gICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSByZXN1bHQuZXRhZ1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQudmFyeSkge1xuICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgLi4ucmVzdWx0LnZhcnlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJldmFsaWRhdGUgdGhlIHJlc3BvbnNlXG4gICAgcmV0dXJuIGRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9LFxuICAgICAgbmV3IENhY2hlUmV2YWxpZGF0aW9uSGFuZGxlcihcbiAgICAgICAgKHN1Y2Nlc3MsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gVE9ETzogc3VjY2Vzc2Z1bCByZXZhbGlkYXRpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWQgZnJlc2ggKG5vdCBnaXZlIHN0YWxlIHdhcm5pbmcpLlxuICAgICAgICAgICAgc2VuZENhY2hlZFZhbHVlKGhhbmRsZXIsIG9wdHMsIHJlc3VsdCwgYWdlLCBjb250ZXh0LCBzdGFsZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0ocmVzdWx0LmJvZHkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYm9keS5vbignZXJyb3InLCBub3ApLmRlc3Ryb3koKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbmV3IENhY2hlSGFuZGxlcihnbG9iYWxPcHRzLCBjYWNoZUtleSwgaGFuZGxlciksXG4gICAgICAgIHdpdGhpblN0YWxlSWZFcnJvclRocmVzaG9sZFxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8vIER1bXAgcmVxdWVzdCBib2R5LlxuICBpZiAodXRpbC5pc1N0cmVhbShvcHRzLmJvZHkpKSB7XG4gICAgb3B0cy5ib2R5Lm9uKCdlcnJvcicsIG5vcCkuZGVzdHJveSgpXG4gIH1cblxuICBzZW5kQ2FjaGVkVmFsdWUoaGFuZGxlciwgb3B0cywgcmVzdWx0LCBhZ2UsIG51bGwsIGZhbHNlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZU9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaGVyQ29tcG9zZUludGVyY2VwdG9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0b3JlID0gbmV3IE1lbW9yeUNhY2hlU3RvcmUoKSxcbiAgICBtZXRob2RzID0gWydHRVQnXSxcbiAgICBjYWNoZUJ5RGVmYXVsdCA9IHVuZGVmaW5lZCxcbiAgICB0eXBlID0gJ3NoYXJlZCcsXG4gICAgb3JpZ2lucyA9IHVuZGVmaW5lZFxuICB9ID0gb3B0c1xuXG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgb3B0cyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHR5cGUgb2Ygb3B0cyB0byBiZSBhbiBPYmplY3QsIGdvdCAke29wdHMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygb3B0c31gKVxuICB9XG5cbiAgYXNzZXJ0Q2FjaGVTdG9yZShzdG9yZSwgJ29wdHMuc3RvcmUnKVxuICBhc3NlcnRDYWNoZU1ldGhvZHMobWV0aG9kcywgJ29wdHMubWV0aG9kcycpXG4gIGFzc2VydENhY2hlT3JpZ2lucyhvcmlnaW5zLCAnb3B0cy5vcmlnaW5zJylcblxuICBpZiAodHlwZW9mIGNhY2hlQnlEZWZhdWx0ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY2FjaGVCeURlZmF1bHQgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgb3B0cy5jYWNoZUJ5RGVmYXVsdCB0byBiZSBudW1iZXIgb3IgdW5kZWZpbmVkLCBnb3QgJHt0eXBlb2YgY2FjaGVCeURlZmF1bHR9YClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZSAhPT0gJ3NoYXJlZCcgJiYgdHlwZSAhPT0gJ3ByaXZhdGUnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgb3B0cy50eXBlIHRvIGJlIHNoYXJlZCwgcHJpdmF0ZSwgb3IgdW5kZWZpbmVkLCBnb3QgJHt0eXBlb2YgdHlwZX1gKVxuICB9XG5cbiAgY29uc3QgZ2xvYmFsT3B0cyA9IHtcbiAgICBzdG9yZSxcbiAgICBtZXRob2RzLFxuICAgIGNhY2hlQnlEZWZhdWx0LFxuICAgIHR5cGVcbiAgfVxuXG4gIGNvbnN0IHNhZmVNZXRob2RzVG9Ob3RDYWNoZSA9IHV0aWwuc2FmZUhUVFBNZXRob2RzLmZpbHRlcihtZXRob2QgPT4gbWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpID09PSBmYWxzZSlcblxuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiAob3B0cywgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKCFvcHRzLm9yaWdpbiB8fCBzYWZlTWV0aG9kc1RvTm90Q2FjaGUuaW5jbHVkZXMob3B0cy5tZXRob2QpKSB7XG4gICAgICAgIC8vIE5vdCBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhY2hlIG9yIHdlIGRvbid0IGhhdmUgdGhlIG9yaWdpbiwgc2tpcFxuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgb3JpZ2luIGlzIGluIHdoaXRlbGlzdFxuICAgICAgaWYgKG9yaWdpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0T3JpZ2luID0gb3B0cy5vcmlnaW4udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxldCBpc0FsbG93ZWQgPSBmYWxzZVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSBvcmlnaW5zW2ldXG4gICAgICAgICAgaWYgKHR5cGVvZiBhbGxvd2VkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGFsbG93ZWQudG9Mb3dlckNhc2UoKSA9PT0gcmVxdWVzdE9yaWdpbikge1xuICAgICAgICAgICAgICBpc0FsbG93ZWQgPSB0cnVlXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGxvd2VkLnRlc3QocmVxdWVzdE9yaWdpbikpIHtcbiAgICAgICAgICAgIGlzQWxsb3dlZCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvcHRzID0ge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzOiBub3JtYWxpemVIZWFkZXJzKG9wdHMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcUNhY2hlQ29udHJvbCA9IG9wdHMuaGVhZGVycz8uWydjYWNoZS1jb250cm9sJ11cbiAgICAgICAgPyBwYXJzZUNhY2hlQ29udHJvbEhlYWRlcihvcHRzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSlcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgaWYgKHJlcUNhY2hlQ29udHJvbD8uWyduby1zdG9yZSddKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fVxuICAgICAgICovXG4gICAgICBjb25zdCBjYWNoZUtleSA9IG1ha2VDYWNoZUtleShvcHRzKVxuICAgICAgY29uc3QgcmVzdWx0ID0gc3RvcmUuZ2V0KGNhY2hlS2V5KVxuXG4gICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IGhhbmRsZVJlc3VsdChkaXNwYXRjaCxcbiAgICAgICAgICAgIGdsb2JhbE9wdHMsXG4gICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgcmVxQ2FjaGVDb250cm9sLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoXG4gICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgZ2xvYmFsT3B0cyxcbiAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgcmVxQ2FjaGVDb250cm9sLFxuICAgICAgICAgIHJlc3VsdFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/decompress.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/decompress.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { createInflate, createGunzip, createBrotliDecompress, createZstdDecompress } = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../util/runtime-features */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\n/** @typedef {import('node:stream').Transform} Transform */\n/** @typedef {import('node:stream').Transform} Controller */\n/** @typedef {Transform&import('node:zlib').Zlib} DecompressorStream */\n\n/** @type {Record<string, () => DecompressorStream>} */\nconst supportedEncodings = {\n  gzip: createGunzip,\n  'x-gzip': createGunzip,\n  br: createBrotliDecompress,\n  deflate: createInflate,\n  compress: createInflate,\n  'x-compress': createInflate,\n  ...(runtimeFeatures.has('zstd') ? { zstd: createZstdDecompress } : {})\n}\n\nconst defaultSkipStatusCodes = /** @type {const} */ ([204, 304])\n\nlet warningEmitted = /** @type {boolean} */ (false)\n\n/**\n * @typedef {Object} DecompressHandlerOptions\n * @property {number[]|Readonly<number[]>} [skipStatusCodes=[204, 304]] - List of status codes to skip decompression for\n * @property {boolean} [skipErrorResponses] - Whether to skip decompression for error responses (status codes >= 400)\n */\n\nclass DecompressHandler extends DecoratorHandler {\n  /** @type {Transform[]} */\n  #decompressors = []\n  /** @type {Readonly<number[]>} */\n  #skipStatusCodes\n  /** @type {boolean} */\n  #skipErrorResponses\n\n  constructor (handler, { skipStatusCodes = defaultSkipStatusCodes, skipErrorResponses = true } = {}) {\n    super(handler)\n    this.#skipStatusCodes = skipStatusCodes\n    this.#skipErrorResponses = skipErrorResponses\n  }\n\n  /**\n   * Determines if decompression should be skipped based on encoding and status code\n   * @param {string} contentEncoding - Content-Encoding header value\n   * @param {number} statusCode - HTTP status code of the response\n   * @returns {boolean} - True if decompression should be skipped\n   */\n  #shouldSkipDecompression (contentEncoding, statusCode) {\n    if (!contentEncoding || statusCode < 200) return true\n    if (this.#skipStatusCodes.includes(statusCode)) return true\n    if (this.#skipErrorResponses && statusCode >= 400) return true\n    return false\n  }\n\n  /**\n   * Creates a chain of decompressors for multiple content encodings\n   *\n   * @param {string} encodings - Comma-separated list of content encodings\n   * @returns {Array<DecompressorStream>} - Array of decompressor streams\n   * @throws {Error} - If the number of content-encodings exceeds the maximum allowed\n   */\n  #createDecompressionChain (encodings) {\n    const parts = encodings.split(',')\n\n    // Limit the number of content-encodings to prevent resource exhaustion.\n    // CVE fix similar to urllib3 (GHSA-gm62-xv2j-4w53) and curl (CVE-2022-32206).\n    const maxContentEncodings = 5\n    if (parts.length > maxContentEncodings) {\n      throw new Error(`too many content-encodings in response: ${parts.length}, maximum allowed is ${maxContentEncodings}`)\n    }\n\n    /** @type {DecompressorStream[]} */\n    const decompressors = []\n\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const encoding = parts[i].trim()\n      if (!encoding) continue\n\n      if (!supportedEncodings[encoding]) {\n        decompressors.length = 0 // Clear if unsupported encoding\n        return decompressors // Unsupported encoding\n      }\n\n      decompressors.push(supportedEncodings[encoding]())\n    }\n\n    return decompressors\n  }\n\n  /**\n   * Sets up event handlers for a decompressor stream using readable events\n   * @param {DecompressorStream} decompressor - The decompressor stream\n   * @param {Controller} controller - The controller to coordinate with\n   * @returns {void}\n   */\n  #setupDecompressorEvents (decompressor, controller) {\n    decompressor.on('readable', () => {\n      let chunk\n      while ((chunk = decompressor.read()) !== null) {\n        const result = super.onResponseData(controller, chunk)\n        if (result === false) {\n          break\n        }\n      }\n    })\n\n    decompressor.on('error', (error) => {\n      super.onResponseError(controller, error)\n    })\n  }\n\n  /**\n   * Sets up event handling for a single decompressor\n   * @param {Controller} controller - The controller to handle events\n   * @returns {void}\n   */\n  #setupSingleDecompressor (controller) {\n    const decompressor = this.#decompressors[0]\n    this.#setupDecompressorEvents(decompressor, controller)\n\n    decompressor.on('end', () => {\n      super.onResponseEnd(controller, {})\n    })\n  }\n\n  /**\n   * Sets up event handling for multiple chained decompressors using pipeline\n   * @param {Controller} controller - The controller to handle events\n   * @returns {void}\n   */\n  #setupMultipleDecompressors (controller) {\n    const lastDecompressor = this.#decompressors[this.#decompressors.length - 1]\n    this.#setupDecompressorEvents(lastDecompressor, controller)\n\n    pipeline(this.#decompressors, (err) => {\n      if (err) {\n        super.onResponseError(controller, err)\n        return\n      }\n      super.onResponseEnd(controller, {})\n    })\n  }\n\n  /**\n   * Cleans up decompressor references to prevent memory leaks\n   * @returns {void}\n   */\n  #cleanupDecompressors () {\n    this.#decompressors.length = 0\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {number} statusCode\n   * @param {Record<string, string | string[] | undefined>} headers\n   * @param {string} statusMessage\n   * @returns {void}\n   */\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const contentEncoding = headers['content-encoding']\n\n    // If content encoding is not supported or status code is in skip list\n    if (this.#shouldSkipDecompression(contentEncoding, statusCode)) {\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    const decompressors = this.#createDecompressionChain(contentEncoding.toLowerCase())\n\n    if (decompressors.length === 0) {\n      this.#cleanupDecompressors()\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    this.#decompressors = decompressors\n\n    // Remove compression headers since we're decompressing\n    const { 'content-encoding': _, 'content-length': __, ...newHeaders } = headers\n\n    if (this.#decompressors.length === 1) {\n      this.#setupSingleDecompressor(controller)\n    } else {\n      this.#setupMultipleDecompressors(controller)\n    }\n\n    return super.onResponseStart(controller, statusCode, newHeaders, statusMessage)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Buffer} chunk\n   * @returns {void}\n   */\n  onResponseData (controller, chunk) {\n    if (this.#decompressors.length > 0) {\n      this.#decompressors[0].write(chunk)\n      return\n    }\n    super.onResponseData(controller, chunk)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Record<string, string | string[]> | undefined} trailers\n   * @returns {void}\n   */\n  onResponseEnd (controller, trailers) {\n    if (this.#decompressors.length > 0) {\n      this.#decompressors[0].end()\n      this.#cleanupDecompressors()\n      return\n    }\n    super.onResponseEnd(controller, trailers)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Error} err\n   * @returns {void}\n   */\n  onResponseError (controller, err) {\n    if (this.#decompressors.length > 0) {\n      for (const decompressor of this.#decompressors) {\n        decompressor.destroy(err)\n      }\n      this.#cleanupDecompressors()\n    }\n    super.onResponseError(controller, err)\n  }\n}\n\n/**\n * Creates a decompression interceptor for HTTP responses\n * @param {DecompressHandlerOptions} [options] - Options for the interceptor\n * @returns {Function} - Interceptor function\n */\nfunction createDecompressInterceptor (options = {}) {\n  // Emit experimental warning only once\n  if (!warningEmitted) {\n    process.emitWarning(\n      'DecompressInterceptor is experimental and subject to change',\n      'ExperimentalWarning'\n    )\n    warningEmitted = true\n  }\n\n  return (dispatch) => {\n    return (opts, handler) => {\n      const decompressHandler = new DecompressHandler(handler, options)\n      return dispatch(opts, decompressHandler)\n    }\n  }\n}\n\nmodule.exports = createDecompressInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kZWNvbXByZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNEVBQTRFLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUN6RyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzFDLHlCQUF5QixtQkFBTyxDQUFDLGtHQUE4QjtBQUMvRCxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsMEZBQTBCOztBQUU5RCxjQUFjLGlDQUFpQztBQUMvQyxjQUFjLGlDQUFpQztBQUMvQyxjQUFjLG9DQUFvQzs7QUFFbEQsV0FBVywwQ0FBMEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCLElBQUk7QUFDdkU7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpELGdDQUFnQyxTQUFTOztBQUV6QztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQSwwQkFBMEIsc0VBQXNFLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLDJCQUEyQjtBQUMxQyxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWEsdUJBQXVCLG9CQUFvQjtBQUN6SDs7QUFFQSxlQUFlLHNCQUFzQjtBQUNyQzs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxZQUFZO0FBQ3pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSwrQ0FBK0M7QUFDNUQsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLDZEQUE2RDs7QUFFekU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsK0NBQStDO0FBQzVELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxhQUFhLFVBQVU7QUFDdkI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxkZWNvbXByZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZUluZmxhdGUsIGNyZWF0ZUd1bnppcCwgY3JlYXRlQnJvdGxpRGVjb21wcmVzcywgY3JlYXRlWnN0ZERlY29tcHJlc3MgfSA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9kZWNvcmF0b3ItaGFuZGxlcicpXG5jb25zdCB7IHJ1bnRpbWVGZWF0dXJlcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9ydW50aW1lLWZlYXR1cmVzJylcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ25vZGU6c3RyZWFtJykuVHJhbnNmb3JtfSBUcmFuc2Zvcm0gKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdub2RlOnN0cmVhbScpLlRyYW5zZm9ybX0gQ29udHJvbGxlciAqL1xuLyoqIEB0eXBlZGVmIHtUcmFuc2Zvcm0maW1wb3J0KCdub2RlOnpsaWInKS5abGlifSBEZWNvbXByZXNzb3JTdHJlYW0gKi9cblxuLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCAoKSA9PiBEZWNvbXByZXNzb3JTdHJlYW0+fSAqL1xuY29uc3Qgc3VwcG9ydGVkRW5jb2RpbmdzID0ge1xuICBnemlwOiBjcmVhdGVHdW56aXAsXG4gICd4LWd6aXAnOiBjcmVhdGVHdW56aXAsXG4gIGJyOiBjcmVhdGVCcm90bGlEZWNvbXByZXNzLFxuICBkZWZsYXRlOiBjcmVhdGVJbmZsYXRlLFxuICBjb21wcmVzczogY3JlYXRlSW5mbGF0ZSxcbiAgJ3gtY29tcHJlc3MnOiBjcmVhdGVJbmZsYXRlLFxuICAuLi4ocnVudGltZUZlYXR1cmVzLmhhcygnenN0ZCcpID8geyB6c3RkOiBjcmVhdGVac3RkRGVjb21wcmVzcyB9IDoge30pXG59XG5cbmNvbnN0IGRlZmF1bHRTa2lwU3RhdHVzQ29kZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWzIwNCwgMzA0XSlcblxubGV0IHdhcm5pbmdFbWl0dGVkID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoZmFsc2UpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVjb21wcmVzc0hhbmRsZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcltdfFJlYWRvbmx5PG51bWJlcltdPn0gW3NraXBTdGF0dXNDb2Rlcz1bMjA0LCAzMDRdXSAtIExpc3Qgb2Ygc3RhdHVzIGNvZGVzIHRvIHNraXAgZGVjb21wcmVzc2lvbiBmb3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBFcnJvclJlc3BvbnNlc10gLSBXaGV0aGVyIHRvIHNraXAgZGVjb21wcmVzc2lvbiBmb3IgZXJyb3IgcmVzcG9uc2VzIChzdGF0dXMgY29kZXMgPj0gNDAwKVxuICovXG5cbmNsYXNzIERlY29tcHJlc3NIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gIC8qKiBAdHlwZSB7VHJhbnNmb3JtW119ICovXG4gICNkZWNvbXByZXNzb3JzID0gW11cbiAgLyoqIEB0eXBlIHtSZWFkb25seTxudW1iZXJbXT59ICovXG4gICNza2lwU3RhdHVzQ29kZXNcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAjc2tpcEVycm9yUmVzcG9uc2VzXG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXIsIHsgc2tpcFN0YXR1c0NvZGVzID0gZGVmYXVsdFNraXBTdGF0dXNDb2Rlcywgc2tpcEVycm9yUmVzcG9uc2VzID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuICAgIHRoaXMuI3NraXBTdGF0dXNDb2RlcyA9IHNraXBTdGF0dXNDb2Rlc1xuICAgIHRoaXMuI3NraXBFcnJvclJlc3BvbnNlcyA9IHNraXBFcnJvclJlc3BvbnNlc1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgZGVjb21wcmVzc2lvbiBzaG91bGQgYmUgc2tpcHBlZCBiYXNlZCBvbiBlbmNvZGluZyBhbmQgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRFbmNvZGluZyAtIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlIC0gSFRUUCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBkZWNvbXByZXNzaW9uIHNob3VsZCBiZSBza2lwcGVkXG4gICAqL1xuICAjc2hvdWxkU2tpcERlY29tcHJlc3Npb24gKGNvbnRlbnRFbmNvZGluZywgc3RhdHVzQ29kZSkge1xuICAgIGlmICghY29udGVudEVuY29kaW5nIHx8IHN0YXR1c0NvZGUgPCAyMDApIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMuI3NraXBTdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSkgcmV0dXJuIHRydWVcbiAgICBpZiAodGhpcy4jc2tpcEVycm9yUmVzcG9uc2VzICYmIHN0YXR1c0NvZGUgPj0gNDAwKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjaGFpbiBvZiBkZWNvbXByZXNzb3JzIGZvciBtdWx0aXBsZSBjb250ZW50IGVuY29kaW5nc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdzIC0gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgY29udGVudCBlbmNvZGluZ3NcbiAgICogQHJldHVybnMge0FycmF5PERlY29tcHJlc3NvclN0cmVhbT59IC0gQXJyYXkgb2YgZGVjb21wcmVzc29yIHN0cmVhbXNcbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIG51bWJlciBvZiBjb250ZW50LWVuY29kaW5ncyBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWRcbiAgICovXG4gICNjcmVhdGVEZWNvbXByZXNzaW9uQ2hhaW4gKGVuY29kaW5ncykge1xuICAgIGNvbnN0IHBhcnRzID0gZW5jb2RpbmdzLnNwbGl0KCcsJylcblxuICAgIC8vIExpbWl0IHRoZSBudW1iZXIgb2YgY29udGVudC1lbmNvZGluZ3MgdG8gcHJldmVudCByZXNvdXJjZSBleGhhdXN0aW9uLlxuICAgIC8vIENWRSBmaXggc2ltaWxhciB0byB1cmxsaWIzIChHSFNBLWdtNjIteHYyai00dzUzKSBhbmQgY3VybCAoQ1ZFLTIwMjItMzIyMDYpLlxuICAgIGNvbnN0IG1heENvbnRlbnRFbmNvZGluZ3MgPSA1XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IG1heENvbnRlbnRFbmNvZGluZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29udGVudC1lbmNvZGluZ3MgaW4gcmVzcG9uc2U6ICR7cGFydHMubGVuZ3RofSwgbWF4aW11bSBhbGxvd2VkIGlzICR7bWF4Q29udGVudEVuY29kaW5nc31gKVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb21wcmVzc29yU3RyZWFtW119ICovXG4gICAgY29uc3QgZGVjb21wcmVzc29ycyA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVuY29kaW5nID0gcGFydHNbaV0udHJpbSgpXG4gICAgICBpZiAoIWVuY29kaW5nKSBjb250aW51ZVxuXG4gICAgICBpZiAoIXN1cHBvcnRlZEVuY29kaW5nc1tlbmNvZGluZ10pIHtcbiAgICAgICAgZGVjb21wcmVzc29ycy5sZW5ndGggPSAwIC8vIENsZWFyIGlmIHVuc3VwcG9ydGVkIGVuY29kaW5nXG4gICAgICAgIHJldHVybiBkZWNvbXByZXNzb3JzIC8vIFVuc3VwcG9ydGVkIGVuY29kaW5nXG4gICAgICB9XG5cbiAgICAgIGRlY29tcHJlc3NvcnMucHVzaChzdXBwb3J0ZWRFbmNvZGluZ3NbZW5jb2RpbmddKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29tcHJlc3NvcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGV2ZW50IGhhbmRsZXJzIGZvciBhIGRlY29tcHJlc3NvciBzdHJlYW0gdXNpbmcgcmVhZGFibGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7RGVjb21wcmVzc29yU3RyZWFtfSBkZWNvbXByZXNzb3IgLSBUaGUgZGVjb21wcmVzc29yIHN0cmVhbVxuICAgKiBAcGFyYW0ge0NvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBjb29yZGluYXRlIHdpdGhcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAjc2V0dXBEZWNvbXByZXNzb3JFdmVudHMgKGRlY29tcHJlc3NvciwgY29udHJvbGxlcikge1xuICAgIGRlY29tcHJlc3Nvci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICBsZXQgY2h1bmtcbiAgICAgIHdoaWxlICgoY2h1bmsgPSBkZWNvbXByZXNzb3IucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5vblJlc3BvbnNlRGF0YShjb250cm9sbGVyLCBjaHVuaylcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGRlY29tcHJlc3Nvci5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnJvcilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgZXZlbnQgaGFuZGxpbmcgZm9yIGEgc2luZ2xlIGRlY29tcHJlc3NvclxuICAgKiBAcGFyYW0ge0NvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBoYW5kbGUgZXZlbnRzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgI3NldHVwU2luZ2xlRGVjb21wcmVzc29yIChjb250cm9sbGVyKSB7XG4gICAgY29uc3QgZGVjb21wcmVzc29yID0gdGhpcy4jZGVjb21wcmVzc29yc1swXVxuICAgIHRoaXMuI3NldHVwRGVjb21wcmVzc29yRXZlbnRzKGRlY29tcHJlc3NvciwgY29udHJvbGxlcilcblxuICAgIGRlY29tcHJlc3Nvci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgc3VwZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB7fSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgZXZlbnQgaGFuZGxpbmcgZm9yIG11bHRpcGxlIGNoYWluZWQgZGVjb21wcmVzc29ycyB1c2luZyBwaXBlbGluZVxuICAgKiBAcGFyYW0ge0NvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBoYW5kbGUgZXZlbnRzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgI3NldHVwTXVsdGlwbGVEZWNvbXByZXNzb3JzIChjb250cm9sbGVyKSB7XG4gICAgY29uc3QgbGFzdERlY29tcHJlc3NvciA9IHRoaXMuI2RlY29tcHJlc3NvcnNbdGhpcy4jZGVjb21wcmVzc29ycy5sZW5ndGggLSAxXVxuICAgIHRoaXMuI3NldHVwRGVjb21wcmVzc29yRXZlbnRzKGxhc3REZWNvbXByZXNzb3IsIGNvbnRyb2xsZXIpXG5cbiAgICBwaXBlbGluZSh0aGlzLiNkZWNvbXByZXNzb3JzLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc3VwZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB7fSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBkZWNvbXByZXNzb3IgcmVmZXJlbmNlcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gICNjbGVhbnVwRGVjb21wcmVzc29ycyAoKSB7XG4gICAgdGhpcy4jZGVjb21wcmVzc29ycy5sZW5ndGggPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+fSBoZWFkZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNNZXNzYWdlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgb25SZXNwb25zZVN0YXJ0IChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgY29udGVudEVuY29kaW5nID0gaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddXG5cbiAgICAvLyBJZiBjb250ZW50IGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb3Igc3RhdHVzIGNvZGUgaXMgaW4gc2tpcCBsaXN0XG4gICAgaWYgKHRoaXMuI3Nob3VsZFNraXBEZWNvbXByZXNzaW9uKGNvbnRlbnRFbmNvZGluZywgc3RhdHVzQ29kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5vblJlc3BvbnNlU3RhcnQoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvbXByZXNzb3JzID0gdGhpcy4jY3JlYXRlRGVjb21wcmVzc2lvbkNoYWluKGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpKVxuXG4gICAgaWYgKGRlY29tcHJlc3NvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLiNjbGVhbnVwRGVjb21wcmVzc29ycygpXG4gICAgICByZXR1cm4gc3VwZXIub25SZXNwb25zZVN0YXJ0KGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gICAgfVxuXG4gICAgdGhpcy4jZGVjb21wcmVzc29ycyA9IGRlY29tcHJlc3NvcnNcblxuICAgIC8vIFJlbW92ZSBjb21wcmVzc2lvbiBoZWFkZXJzIHNpbmNlIHdlJ3JlIGRlY29tcHJlc3NpbmdcbiAgICBjb25zdCB7ICdjb250ZW50LWVuY29kaW5nJzogXywgJ2NvbnRlbnQtbGVuZ3RoJzogX18sIC4uLm5ld0hlYWRlcnMgfSA9IGhlYWRlcnNcblxuICAgIGlmICh0aGlzLiNkZWNvbXByZXNzb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy4jc2V0dXBTaW5nbGVEZWNvbXByZXNzb3IoY29udHJvbGxlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jc2V0dXBNdWx0aXBsZURlY29tcHJlc3NvcnMoY29udHJvbGxlcilcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIub25SZXNwb25zZVN0YXJ0KGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIG5ld0hlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBjaHVuaykge1xuICAgIGlmICh0aGlzLiNkZWNvbXByZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuI2RlY29tcHJlc3NvcnNbMF0ud3JpdGUoY2h1bmspXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3VwZXIub25SZXNwb25zZURhdGEoY29udHJvbGxlciwgY2h1bmspXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+IHwgdW5kZWZpbmVkfSB0cmFpbGVyc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI2RlY29tcHJlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy4jZGVjb21wcmVzc29yc1swXS5lbmQoKVxuICAgICAgdGhpcy4jY2xlYW51cERlY29tcHJlc3NvcnMoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN1cGVyLm9uUmVzcG9uc2VFbmQoY29udHJvbGxlciwgdHJhaWxlcnMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9uUmVzcG9uc2VFcnJvciAoY29udHJvbGxlciwgZXJyKSB7XG4gICAgaWYgKHRoaXMuI2RlY29tcHJlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBkZWNvbXByZXNzb3Igb2YgdGhpcy4jZGVjb21wcmVzc29ycykge1xuICAgICAgICBkZWNvbXByZXNzb3IuZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgICB0aGlzLiNjbGVhbnVwRGVjb21wcmVzc29ycygpXG4gICAgfVxuICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVjb21wcmVzc2lvbiBpbnRlcmNlcHRvciBmb3IgSFRUUCByZXNwb25zZXNcbiAqIEBwYXJhbSB7RGVjb21wcmVzc0hhbmRsZXJPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgaW50ZXJjZXB0b3JcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBJbnRlcmNlcHRvciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWNvbXByZXNzSW50ZXJjZXB0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAvLyBFbWl0IGV4cGVyaW1lbnRhbCB3YXJuaW5nIG9ubHkgb25jZVxuICBpZiAoIXdhcm5pbmdFbWl0dGVkKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdEZWNvbXByZXNzSW50ZXJjZXB0b3IgaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZScsXG4gICAgICAnRXhwZXJpbWVudGFsV2FybmluZydcbiAgICApXG4gICAgd2FybmluZ0VtaXR0ZWQgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIChvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCBkZWNvbXByZXNzSGFuZGxlciA9IG5ldyBEZWNvbXByZXNzSGFuZGxlcihoYW5kbGVyLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGRlY29tcHJlc3NIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlY29tcHJlc3NJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/decompress.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/deduplicate.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/deduplicate.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst DeduplicationHandler = __webpack_require__(/*! ../handler/deduplication-handler */ \"(rsc)/./node_modules/undici/lib/handler/deduplication-handler.js\")\nconst { normalizeHeaders, makeCacheKey, makeDeduplicationKey } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\n\nconst pendingRequestsChannel = diagnosticsChannel.channel('undici:request:pending-requests')\n\n/**\n * @param {import('../../types/interceptors.d.ts').default.DeduplicateInterceptorOpts} [opts]\n * @returns {import('../../types/dispatcher.d.ts').default.DispatcherComposeInterceptor}\n */\nmodule.exports = (opts = {}) => {\n  const {\n    methods = ['GET'],\n    skipHeaderNames = [],\n    excludeHeaderNames = []\n  } = opts\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? 'null' : typeof opts}`)\n  }\n\n  if (!Array.isArray(methods)) {\n    throw new TypeError(`expected opts.methods to be an array, got ${typeof methods}`)\n  }\n\n  for (const method of methods) {\n    if (!util.safeHTTPMethods.includes(method)) {\n      throw new TypeError(`expected opts.methods to only contain safe HTTP methods, got ${method}`)\n    }\n  }\n\n  if (!Array.isArray(skipHeaderNames)) {\n    throw new TypeError(`expected opts.skipHeaderNames to be an array, got ${typeof skipHeaderNames}`)\n  }\n\n  if (!Array.isArray(excludeHeaderNames)) {\n    throw new TypeError(`expected opts.excludeHeaderNames to be an array, got ${typeof excludeHeaderNames}`)\n  }\n\n  // Convert to lowercase Set for case-insensitive header matching\n  const skipHeaderNamesSet = new Set(skipHeaderNames.map(name => name.toLowerCase()))\n\n  // Convert to lowercase Set for case-insensitive header exclusion from deduplication key\n  const excludeHeaderNamesSet = new Set(excludeHeaderNames.map(name => name.toLowerCase()))\n\n  const safeMethodsToNotDeduplicate = util.safeHTTPMethods.filter(method => methods.includes(method) === false)\n\n  /**\n   * Map of pending requests for deduplication\n   * @type {Map<string, DeduplicationHandler>}\n   */\n  const pendingRequests = new Map()\n\n  return dispatch => {\n    return (opts, handler) => {\n      if (!opts.origin || safeMethodsToNotDeduplicate.includes(opts.method)) {\n        return dispatch(opts, handler)\n      }\n\n      opts = {\n        ...opts,\n        headers: normalizeHeaders(opts)\n      }\n\n      // Skip deduplication if request contains any of the specified headers\n      if (skipHeaderNamesSet.size > 0) {\n        for (const headerName of Object.keys(opts.headers)) {\n          if (skipHeaderNamesSet.has(headerName.toLowerCase())) {\n            return dispatch(opts, handler)\n          }\n        }\n      }\n\n      const cacheKey = makeCacheKey(opts)\n      const dedupeKey = makeDeduplicationKey(cacheKey, excludeHeaderNamesSet)\n\n      // Check if there's already a pending request for this key\n      const pendingHandler = pendingRequests.get(dedupeKey)\n      if (pendingHandler) {\n        // Add this handler to the waiting list\n        pendingHandler.addWaitingHandler(handler)\n        return true\n      }\n\n      // Create a new deduplication handler\n      const deduplicationHandler = new DeduplicationHandler(\n        handler,\n        () => {\n          // Clean up when request completes\n          pendingRequests.delete(dedupeKey)\n          if (pendingRequestsChannel.hasSubscribers) {\n            pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: 'removed' })\n          }\n        }\n      )\n\n      // Register the pending request\n      pendingRequests.set(dedupeKey, deduplicationHandler)\n      if (pendingRequestsChannel.hasSubscribers) {\n        pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: 'added' })\n      }\n\n      return dispatch(opts, deduplicationHandler)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kZWR1cGxpY2F0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWiwyQkFBMkIsbUJBQU8sQ0FBQywwREFBMEI7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLDBHQUFrQztBQUN2RSxRQUFRLHVEQUF1RCxFQUFFLG1CQUFPLENBQUMsdUVBQWtCOztBQUUzRjs7QUFFQTtBQUNBLFdBQVcsNEVBQTRFO0FBQ3ZGLGFBQWE7QUFDYjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzRUFBc0UscUNBQXFDO0FBQzNHOztBQUVBO0FBQ0EscUVBQXFFLGVBQWU7QUFDcEY7O0FBRUE7QUFDQTtBQUNBLDBGQUEwRixPQUFPO0FBQ2pHO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsdUJBQXVCO0FBQ3BHOztBQUVBO0FBQ0EsZ0ZBQWdGLDBCQUEwQjtBQUMxRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZEQUE2RDtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJEQUEyRDtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxkZWR1cGxpY2F0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnbm9kZTpkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgRGVkdXBsaWNhdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2RlZHVwbGljYXRpb24taGFuZGxlcicpXG5jb25zdCB7IG5vcm1hbGl6ZUhlYWRlcnMsIG1ha2VDYWNoZUtleSwgbWFrZURlZHVwbGljYXRpb25LZXkgfSA9IHJlcXVpcmUoJy4uL3V0aWwvY2FjaGUuanMnKVxuXG5jb25zdCBwZW5kaW5nUmVxdWVzdHNDaGFubmVsID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnBlbmRpbmctcmVxdWVzdHMnKVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9pbnRlcmNlcHRvcnMuZC50cycpLmRlZmF1bHQuRGVkdXBsaWNhdGVJbnRlcmNlcHRvck9wdHN9IFtvcHRzXVxuICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaGVyQ29tcG9zZUludGVyY2VwdG9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG1ldGhvZHMgPSBbJ0dFVCddLFxuICAgIHNraXBIZWFkZXJOYW1lcyA9IFtdLFxuICAgIGV4Y2x1ZGVIZWFkZXJOYW1lcyA9IFtdXG4gIH0gPSBvcHRzXG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBvcHRzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdHlwZSBvZiBvcHRzIHRvIGJlIGFuIE9iamVjdCwgZ290ICR7b3B0cyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBvcHRzfWApXG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBvcHRzLm1ldGhvZHMgdG8gYmUgYW4gYXJyYXksIGdvdCAke3R5cGVvZiBtZXRob2RzfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgaWYgKCF1dGlsLnNhZmVIVFRQTWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBvcHRzLm1ldGhvZHMgdG8gb25seSBjb250YWluIHNhZmUgSFRUUCBtZXRob2RzLCBnb3QgJHttZXRob2R9YClcbiAgICB9XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2tpcEhlYWRlck5hbWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIG9wdHMuc2tpcEhlYWRlck5hbWVzIHRvIGJlIGFuIGFycmF5LCBnb3QgJHt0eXBlb2Ygc2tpcEhlYWRlck5hbWVzfWApXG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhjbHVkZUhlYWRlck5hbWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIG9wdHMuZXhjbHVkZUhlYWRlck5hbWVzIHRvIGJlIGFuIGFycmF5LCBnb3QgJHt0eXBlb2YgZXhjbHVkZUhlYWRlck5hbWVzfWApXG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGxvd2VyY2FzZSBTZXQgZm9yIGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIG1hdGNoaW5nXG4gIGNvbnN0IHNraXBIZWFkZXJOYW1lc1NldCA9IG5ldyBTZXQoc2tpcEhlYWRlck5hbWVzLm1hcChuYW1lID0+IG5hbWUudG9Mb3dlckNhc2UoKSkpXG5cbiAgLy8gQ29udmVydCB0byBsb3dlcmNhc2UgU2V0IGZvciBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBleGNsdXNpb24gZnJvbSBkZWR1cGxpY2F0aW9uIGtleVxuICBjb25zdCBleGNsdWRlSGVhZGVyTmFtZXNTZXQgPSBuZXcgU2V0KGV4Y2x1ZGVIZWFkZXJOYW1lcy5tYXAobmFtZSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkpKVxuXG4gIGNvbnN0IHNhZmVNZXRob2RzVG9Ob3REZWR1cGxpY2F0ZSA9IHV0aWwuc2FmZUhUVFBNZXRob2RzLmZpbHRlcihtZXRob2QgPT4gbWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpID09PSBmYWxzZSlcblxuICAvKipcbiAgICogTWFwIG9mIHBlbmRpbmcgcmVxdWVzdHMgZm9yIGRlZHVwbGljYXRpb25cbiAgICogQHR5cGUge01hcDxzdHJpbmcsIERlZHVwbGljYXRpb25IYW5kbGVyPn1cbiAgICovXG4gIGNvbnN0IHBlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXAoKVxuXG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIChvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgICBpZiAoIW9wdHMub3JpZ2luIHx8IHNhZmVNZXRob2RzVG9Ob3REZWR1cGxpY2F0ZS5pbmNsdWRlcyhvcHRzLm1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhlYWRlcnM6IG5vcm1hbGl6ZUhlYWRlcnMob3B0cylcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBkZWR1cGxpY2F0aW9uIGlmIHJlcXVlc3QgY29udGFpbnMgYW55IG9mIHRoZSBzcGVjaWZpZWQgaGVhZGVyc1xuICAgICAgaWYgKHNraXBIZWFkZXJOYW1lc1NldC5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKSkge1xuICAgICAgICAgIGlmIChza2lwSGVhZGVyTmFtZXNTZXQuaGFzKGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZUtleSA9IG1ha2VDYWNoZUtleShvcHRzKVxuICAgICAgY29uc3QgZGVkdXBlS2V5ID0gbWFrZURlZHVwbGljYXRpb25LZXkoY2FjaGVLZXksIGV4Y2x1ZGVIZWFkZXJOYW1lc1NldClcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyByZXF1ZXN0IGZvciB0aGlzIGtleVxuICAgICAgY29uc3QgcGVuZGluZ0hhbmRsZXIgPSBwZW5kaW5nUmVxdWVzdHMuZ2V0KGRlZHVwZUtleSlcbiAgICAgIGlmIChwZW5kaW5nSGFuZGxlcikge1xuICAgICAgICAvLyBBZGQgdGhpcyBoYW5kbGVyIHRvIHRoZSB3YWl0aW5nIGxpc3RcbiAgICAgICAgcGVuZGluZ0hhbmRsZXIuYWRkV2FpdGluZ0hhbmRsZXIoaGFuZGxlcilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGRlZHVwbGljYXRpb24gaGFuZGxlclxuICAgICAgY29uc3QgZGVkdXBsaWNhdGlvbkhhbmRsZXIgPSBuZXcgRGVkdXBsaWNhdGlvbkhhbmRsZXIoXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBDbGVhbiB1cCB3aGVuIHJlcXVlc3QgY29tcGxldGVzXG4gICAgICAgICAgcGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShkZWR1cGVLZXkpXG4gICAgICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0c0NoYW5uZWwuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0c0NoYW5uZWwucHVibGlzaCh7IHNpemU6IHBlbmRpbmdSZXF1ZXN0cy5zaXplLCBrZXk6IGRlZHVwZUtleSwgdHlwZTogJ3JlbW92ZWQnIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBwZW5kaW5nIHJlcXVlc3RcbiAgICAgIHBlbmRpbmdSZXF1ZXN0cy5zZXQoZGVkdXBlS2V5LCBkZWR1cGxpY2F0aW9uSGFuZGxlcilcbiAgICAgIGlmIChwZW5kaW5nUmVxdWVzdHNDaGFubmVsLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0c0NoYW5uZWwucHVibGlzaCh7IHNpemU6IHBlbmRpbmdSZXF1ZXN0cy5zaXplLCBrZXk6IGRlZHVwZUtleSwgdHlwZTogJ2FkZGVkJyB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgZGVkdXBsaWNhdGlvbkhhbmRsZXIpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/deduplicate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dns.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dns.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isIP } = __webpack_require__(/*! node:net */ \"node:net\")\nconst { lookup } = __webpack_require__(/*! node:dns */ \"node:dns\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { InvalidArgumentError, InformationalError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst maxInt = Math.pow(2, 31) - 1\n\nclass DNSStorage {\n  #maxItems = 0\n  #records = new Map()\n\n  constructor (opts) {\n    this.#maxItems = opts.maxItems\n  }\n\n  get size () {\n    return this.#records.size\n  }\n\n  get (hostname) {\n    return this.#records.get(hostname) ?? null\n  }\n\n  set (hostname, records) {\n    this.#records.set(hostname, records)\n  }\n\n  delete (hostname) {\n    this.#records.delete(hostname)\n  }\n\n  // Delegate to storage decide can we do more lookups or not\n  full () {\n    return this.size >= this.#maxItems\n  }\n}\n\nclass DNSInstance {\n  #maxTTL = 0\n  #maxItems = 0\n  dualStack = true\n  affinity = null\n  lookup = null\n  pick = null\n  storage = null\n\n  constructor (opts) {\n    this.#maxTTL = opts.maxTTL\n    this.#maxItems = opts.maxItems\n    this.dualStack = opts.dualStack\n    this.affinity = opts.affinity\n    this.lookup = opts.lookup ?? this.#defaultLookup\n    this.pick = opts.pick ?? this.#defaultPick\n    this.storage = opts.storage ?? new DNSStorage(opts)\n  }\n\n  runLookup (origin, opts, cb) {\n    const ips = this.storage.get(origin.hostname)\n\n    // If full, we just return the origin\n    if (ips == null && this.storage.full()) {\n      cb(null, origin)\n      return\n    }\n\n    const newOpts = {\n      affinity: this.affinity,\n      dualStack: this.dualStack,\n      lookup: this.lookup,\n      pick: this.pick,\n      ...opts.dns,\n      maxTTL: this.#maxTTL,\n      maxItems: this.#maxItems\n    }\n\n    // If no IPs we lookup\n    if (ips == null) {\n      this.lookup(origin, newOpts, (err, addresses) => {\n        if (err || addresses == null || addresses.length === 0) {\n          cb(err ?? new InformationalError('No DNS entries found'))\n          return\n        }\n\n        this.setRecords(origin, addresses)\n        const records = this.storage.get(origin.hostname)\n\n        const ip = this.pick(\n          origin,\n          records,\n          newOpts.affinity\n        )\n\n        let port\n        if (typeof ip.port === 'number') {\n          port = `:${ip.port}`\n        } else if (origin.port !== '') {\n          port = `:${origin.port}`\n        } else {\n          port = ''\n        }\n\n        cb(\n          null,\n          new URL(`${origin.protocol}//${\n            ip.family === 6 ? `[${ip.address}]` : ip.address\n          }${port}`)\n        )\n      })\n    } else {\n      // If there's IPs we pick\n      const ip = this.pick(\n        origin,\n        ips,\n        newOpts.affinity\n      )\n\n      // If no IPs we lookup - deleting old records\n      if (ip == null) {\n        this.storage.delete(origin.hostname)\n        this.runLookup(origin, opts, cb)\n        return\n      }\n\n      let port\n      if (typeof ip.port === 'number') {\n        port = `:${ip.port}`\n      } else if (origin.port !== '') {\n        port = `:${origin.port}`\n      } else {\n        port = ''\n      }\n\n      cb(\n        null,\n        new URL(`${origin.protocol}//${\n          ip.family === 6 ? `[${ip.address}]` : ip.address\n        }${port}`)\n      )\n    }\n  }\n\n  #defaultLookup (origin, opts, cb) {\n    lookup(\n      origin.hostname,\n      {\n        all: true,\n        family: this.dualStack === false ? this.affinity : 0,\n        order: 'ipv4first'\n      },\n      (err, addresses) => {\n        if (err) {\n          return cb(err)\n        }\n\n        const results = new Map()\n\n        for (const addr of addresses) {\n          // On linux we found duplicates, we attempt to remove them with\n          // the latest record\n          results.set(`${addr.address}:${addr.family}`, addr)\n        }\n\n        cb(null, results.values())\n      }\n    )\n  }\n\n  #defaultPick (origin, hostnameRecords, affinity) {\n    let ip = null\n    const { records, offset } = hostnameRecords\n\n    let family\n    if (this.dualStack) {\n      if (affinity == null) {\n        // Balance between ip families\n        if (offset == null || offset === maxInt) {\n          hostnameRecords.offset = 0\n          affinity = 4\n        } else {\n          hostnameRecords.offset++\n          affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4\n        }\n      }\n\n      if (records[affinity] != null && records[affinity].ips.length > 0) {\n        family = records[affinity]\n      } else {\n        family = records[affinity === 4 ? 6 : 4]\n      }\n    } else {\n      family = records[affinity]\n    }\n\n    // If no IPs we return null\n    if (family == null || family.ips.length === 0) {\n      return ip\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    ip = family.ips[position] ?? null\n\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n      return this.pick(origin, hostnameRecords, affinity)\n    }\n\n    return ip\n  }\n\n  pickFamily (origin, ipFamily) {\n    const records = this.storage.get(origin.hostname)?.records\n    if (!records) {\n      return null\n    }\n\n    const family = records[ipFamily]\n    if (!family) {\n      return null\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    const ip = family.ips[position] ?? null\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n    }\n\n    return ip\n  }\n\n  setRecords (origin, addresses) {\n    const timestamp = Date.now()\n    const records = { records: { 4: null, 6: null } }\n    let minTTL = this.#maxTTL\n    for (const record of addresses) {\n      record.timestamp = timestamp\n      if (typeof record.ttl === 'number') {\n        // The record TTL is expected to be in ms\n        record.ttl = Math.min(record.ttl, this.#maxTTL)\n        minTTL = Math.min(minTTL, record.ttl)\n      } else {\n        record.ttl = this.#maxTTL\n      }\n\n      const familyRecords = records.records[record.family] ?? { ips: [] }\n\n      familyRecords.ips.push(record)\n      records.records[record.family] = familyRecords\n    }\n\n    // We provide a default TTL if external storage will be used without TTL per record-level support\n    this.storage.set(origin.hostname, records, { ttl: minTTL })\n  }\n\n  deleteRecords (origin) {\n    this.storage.delete(origin.hostname)\n  }\n\n  getHandler (meta, opts) {\n    return new DNSDispatchHandler(this, meta, opts)\n  }\n}\n\nclass DNSDispatchHandler extends DecoratorHandler {\n  #state = null\n  #opts = null\n  #dispatch = null\n  #origin = null\n  #controller = null\n  #newOrigin = null\n  #firstTry = true\n\n  constructor (state, { origin, handler, dispatch, newOrigin }, opts) {\n    super(handler)\n    this.#origin = origin\n    this.#newOrigin = newOrigin\n    this.#opts = { ...opts }\n    this.#state = state\n    this.#dispatch = dispatch\n  }\n\n  onResponseError (controller, err) {\n    switch (err.code) {\n      case 'ETIMEDOUT':\n      case 'ECONNREFUSED': {\n        if (this.#state.dualStack) {\n          if (!this.#firstTry) {\n            super.onResponseError(controller, err)\n            return\n          }\n          this.#firstTry = false\n\n          // Pick an ip address from the other family\n          const otherFamily = this.#newOrigin.hostname[0] === '[' ? 4 : 6\n          const ip = this.#state.pickFamily(this.#origin, otherFamily)\n          if (ip == null) {\n            super.onResponseError(controller, err)\n            return\n          }\n\n          let port\n          if (typeof ip.port === 'number') {\n            port = `:${ip.port}`\n          } else if (this.#origin.port !== '') {\n            port = `:${this.#origin.port}`\n          } else {\n            port = ''\n          }\n\n          const dispatchOpts = {\n            ...this.#opts,\n            origin: `${this.#origin.protocol}//${\n                ip.family === 6 ? `[${ip.address}]` : ip.address\n              }${port}`\n          }\n          this.#dispatch(dispatchOpts, this)\n          return\n        }\n\n        // if dual-stack disabled, we error out\n        super.onResponseError(controller, err)\n        break\n      }\n      case 'ENOTFOUND':\n        this.#state.deleteRecords(this.#origin)\n        super.onResponseError(controller, err)\n        break\n      default:\n        super.onResponseError(controller, err)\n        break\n    }\n  }\n}\n\nmodule.exports = interceptorOpts => {\n  if (\n    interceptorOpts?.maxTTL != null &&\n    (typeof interceptorOpts?.maxTTL !== 'number' || interceptorOpts?.maxTTL < 0)\n  ) {\n    throw new InvalidArgumentError('Invalid maxTTL. Must be a positive number')\n  }\n\n  if (\n    interceptorOpts?.maxItems != null &&\n    (typeof interceptorOpts?.maxItems !== 'number' ||\n      interceptorOpts?.maxItems < 1)\n  ) {\n    throw new InvalidArgumentError(\n      'Invalid maxItems. Must be a positive number and greater than zero'\n    )\n  }\n\n  if (\n    interceptorOpts?.affinity != null &&\n    interceptorOpts?.affinity !== 4 &&\n    interceptorOpts?.affinity !== 6\n  ) {\n    throw new InvalidArgumentError('Invalid affinity. Must be either 4 or 6')\n  }\n\n  if (\n    interceptorOpts?.dualStack != null &&\n    typeof interceptorOpts?.dualStack !== 'boolean'\n  ) {\n    throw new InvalidArgumentError('Invalid dualStack. Must be a boolean')\n  }\n\n  if (\n    interceptorOpts?.lookup != null &&\n    typeof interceptorOpts?.lookup !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid lookup. Must be a function')\n  }\n\n  if (\n    interceptorOpts?.pick != null &&\n    typeof interceptorOpts?.pick !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid pick. Must be a function')\n  }\n\n  if (\n    interceptorOpts?.storage != null &&\n    (typeof interceptorOpts?.storage?.get !== 'function' ||\n      typeof interceptorOpts?.storage?.set !== 'function' ||\n      typeof interceptorOpts?.storage?.full !== 'function' ||\n      typeof interceptorOpts?.storage?.delete !== 'function'\n    )\n  ) {\n    throw new InvalidArgumentError('Invalid storage. Must be a object with methods: { get, set, full, delete }')\n  }\n\n  const dualStack = interceptorOpts?.dualStack ?? true\n  let affinity\n  if (dualStack) {\n    affinity = interceptorOpts?.affinity ?? null\n  } else {\n    affinity = interceptorOpts?.affinity ?? 4\n  }\n\n  const opts = {\n    maxTTL: interceptorOpts?.maxTTL ?? 10e3, // Expressed in ms\n    lookup: interceptorOpts?.lookup ?? null,\n    pick: interceptorOpts?.pick ?? null,\n    dualStack,\n    affinity,\n    maxItems: interceptorOpts?.maxItems ?? Infinity,\n    storage: interceptorOpts?.storage\n  }\n\n  const instance = new DNSInstance(opts)\n\n  return dispatch => {\n    return function dnsInterceptor (origDispatchOpts, handler) {\n      const origin =\n        origDispatchOpts.origin.constructor === URL\n          ? origDispatchOpts.origin\n          : new URL(origDispatchOpts.origin)\n\n      if (isIP(origin.hostname) !== 0) {\n        return dispatch(origDispatchOpts, handler)\n      }\n\n      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {\n        if (err) {\n          return handler.onResponseError(null, err)\n        }\n\n        const dispatchOpts = {\n          ...origDispatchOpts,\n          servername: origin.hostname, // For SNI on TLS\n          origin: newOrigin.origin,\n          headers: {\n            host: origin.host,\n            ...origDispatchOpts.headers\n          }\n        }\n\n        dispatch(\n          dispatchOpts,\n          instance.getHandler(\n            { origin, dispatch, handler, newOrigin },\n            origDispatchOpts\n          )\n        )\n      })\n\n      return true\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kbnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLDBCQUFVO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEJBQVU7QUFDckMseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCO0FBQy9ELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsVUFBVTtBQUNWLHFCQUFxQixZQUFZO0FBQ2pDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDLGtDQUFrQyxXQUFXO0FBQzdDLFdBQVcsRUFBRSxLQUFLO0FBQ2xCO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixRQUFRO0FBQ1IsbUJBQW1CLFlBQVk7QUFD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Q3BEO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxcZG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBpc0lQIH0gPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IGxvb2t1cCB9ID0gcmVxdWlyZSgnbm9kZTpkbnMnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW5mb3JtYXRpb25hbEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBtYXhJbnQgPSBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbmNsYXNzIEROU1N0b3JhZ2Uge1xuICAjbWF4SXRlbXMgPSAwXG4gICNyZWNvcmRzID0gbmV3IE1hcCgpXG5cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLiNtYXhJdGVtcyA9IG9wdHMubWF4SXRlbXNcbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVjb3Jkcy5zaXplXG4gIH1cblxuICBnZXQgKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlY29yZHMuZ2V0KGhvc3RuYW1lKSA/PyBudWxsXG4gIH1cblxuICBzZXQgKGhvc3RuYW1lLCByZWNvcmRzKSB7XG4gICAgdGhpcy4jcmVjb3Jkcy5zZXQoaG9zdG5hbWUsIHJlY29yZHMpXG4gIH1cblxuICBkZWxldGUgKGhvc3RuYW1lKSB7XG4gICAgdGhpcy4jcmVjb3Jkcy5kZWxldGUoaG9zdG5hbWUpXG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0byBzdG9yYWdlIGRlY2lkZSBjYW4gd2UgZG8gbW9yZSBsb29rdXBzIG9yIG5vdFxuICBmdWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID49IHRoaXMuI21heEl0ZW1zXG4gIH1cbn1cblxuY2xhc3MgRE5TSW5zdGFuY2Uge1xuICAjbWF4VFRMID0gMFxuICAjbWF4SXRlbXMgPSAwXG4gIGR1YWxTdGFjayA9IHRydWVcbiAgYWZmaW5pdHkgPSBudWxsXG4gIGxvb2t1cCA9IG51bGxcbiAgcGljayA9IG51bGxcbiAgc3RvcmFnZSA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuI21heFRUTCA9IG9wdHMubWF4VFRMXG4gICAgdGhpcy4jbWF4SXRlbXMgPSBvcHRzLm1heEl0ZW1zXG4gICAgdGhpcy5kdWFsU3RhY2sgPSBvcHRzLmR1YWxTdGFja1xuICAgIHRoaXMuYWZmaW5pdHkgPSBvcHRzLmFmZmluaXR5XG4gICAgdGhpcy5sb29rdXAgPSBvcHRzLmxvb2t1cCA/PyB0aGlzLiNkZWZhdWx0TG9va3VwXG4gICAgdGhpcy5waWNrID0gb3B0cy5waWNrID8/IHRoaXMuI2RlZmF1bHRQaWNrXG4gICAgdGhpcy5zdG9yYWdlID0gb3B0cy5zdG9yYWdlID8/IG5ldyBETlNTdG9yYWdlKG9wdHMpXG4gIH1cblxuICBydW5Mb29rdXAgKG9yaWdpbiwgb3B0cywgY2IpIHtcbiAgICBjb25zdCBpcHMgPSB0aGlzLnN0b3JhZ2UuZ2V0KG9yaWdpbi5ob3N0bmFtZSlcblxuICAgIC8vIElmIGZ1bGwsIHdlIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5cbiAgICBpZiAoaXBzID09IG51bGwgJiYgdGhpcy5zdG9yYWdlLmZ1bGwoKSkge1xuICAgICAgY2IobnVsbCwgb3JpZ2luKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbmV3T3B0cyA9IHtcbiAgICAgIGFmZmluaXR5OiB0aGlzLmFmZmluaXR5LFxuICAgICAgZHVhbFN0YWNrOiB0aGlzLmR1YWxTdGFjayxcbiAgICAgIGxvb2t1cDogdGhpcy5sb29rdXAsXG4gICAgICBwaWNrOiB0aGlzLnBpY2ssXG4gICAgICAuLi5vcHRzLmRucyxcbiAgICAgIG1heFRUTDogdGhpcy4jbWF4VFRMLFxuICAgICAgbWF4SXRlbXM6IHRoaXMuI21heEl0ZW1zXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gSVBzIHdlIGxvb2t1cFxuICAgIGlmIChpcHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb29rdXAob3JpZ2luLCBuZXdPcHRzLCAoZXJyLCBhZGRyZXNzZXMpID0+IHtcbiAgICAgICAgaWYgKGVyciB8fCBhZGRyZXNzZXMgPT0gbnVsbCB8fCBhZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY2IoZXJyID8/IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ05vIEROUyBlbnRyaWVzIGZvdW5kJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFJlY29yZHMob3JpZ2luLCBhZGRyZXNzZXMpXG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLnN0b3JhZ2UuZ2V0KG9yaWdpbi5ob3N0bmFtZSlcblxuICAgICAgICBjb25zdCBpcCA9IHRoaXMucGljayhcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgcmVjb3JkcyxcbiAgICAgICAgICBuZXdPcHRzLmFmZmluaXR5XG4gICAgICAgIClcblxuICAgICAgICBsZXQgcG9ydFxuICAgICAgICBpZiAodHlwZW9mIGlwLnBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcG9ydCA9IGA6JHtpcC5wb3J0fWBcbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW4ucG9ydCAhPT0gJycpIHtcbiAgICAgICAgICBwb3J0ID0gYDoke29yaWdpbi5wb3J0fWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3J0ID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3IFVSTChgJHtvcmlnaW4ucHJvdG9jb2x9Ly8ke1xuICAgICAgICAgICAgaXAuZmFtaWx5ID09PSA2ID8gYFske2lwLmFkZHJlc3N9XWAgOiBpcC5hZGRyZXNzXG4gICAgICAgICAgfSR7cG9ydH1gKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIElQcyB3ZSBwaWNrXG4gICAgICBjb25zdCBpcCA9IHRoaXMucGljayhcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBpcHMsXG4gICAgICAgIG5ld09wdHMuYWZmaW5pdHlcbiAgICAgIClcblxuICAgICAgLy8gSWYgbm8gSVBzIHdlIGxvb2t1cCAtIGRlbGV0aW5nIG9sZCByZWNvcmRzXG4gICAgICBpZiAoaXAgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKG9yaWdpbi5ob3N0bmFtZSlcbiAgICAgICAgdGhpcy5ydW5Mb29rdXAob3JpZ2luLCBvcHRzLCBjYilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBwb3J0XG4gICAgICBpZiAodHlwZW9mIGlwLnBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBvcnQgPSBgOiR7aXAucG9ydH1gXG4gICAgICB9IGVsc2UgaWYgKG9yaWdpbi5wb3J0ICE9PSAnJykge1xuICAgICAgICBwb3J0ID0gYDoke29yaWdpbi5wb3J0fWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcnQgPSAnJ1xuICAgICAgfVxuXG4gICAgICBjYihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IFVSTChgJHtvcmlnaW4ucHJvdG9jb2x9Ly8ke1xuICAgICAgICAgIGlwLmZhbWlseSA9PT0gNiA/IGBbJHtpcC5hZGRyZXNzfV1gIDogaXAuYWRkcmVzc1xuICAgICAgICB9JHtwb3J0fWApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgI2RlZmF1bHRMb29rdXAgKG9yaWdpbiwgb3B0cywgY2IpIHtcbiAgICBsb29rdXAoXG4gICAgICBvcmlnaW4uaG9zdG5hbWUsXG4gICAgICB7XG4gICAgICAgIGFsbDogdHJ1ZSxcbiAgICAgICAgZmFtaWx5OiB0aGlzLmR1YWxTdGFjayA9PT0gZmFsc2UgPyB0aGlzLmFmZmluaXR5IDogMCxcbiAgICAgICAgb3JkZXI6ICdpcHY0Zmlyc3QnXG4gICAgICB9LFxuICAgICAgKGVyciwgYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBhZGRyZXNzZXMpIHtcbiAgICAgICAgICAvLyBPbiBsaW51eCB3ZSBmb3VuZCBkdXBsaWNhdGVzLCB3ZSBhdHRlbXB0IHRvIHJlbW92ZSB0aGVtIHdpdGhcbiAgICAgICAgICAvLyB0aGUgbGF0ZXN0IHJlY29yZFxuICAgICAgICAgIHJlc3VsdHMuc2V0KGAke2FkZHIuYWRkcmVzc306JHthZGRyLmZhbWlseX1gLCBhZGRyKVxuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgcmVzdWx0cy52YWx1ZXMoKSlcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICAjZGVmYXVsdFBpY2sgKG9yaWdpbiwgaG9zdG5hbWVSZWNvcmRzLCBhZmZpbml0eSkge1xuICAgIGxldCBpcCA9IG51bGxcbiAgICBjb25zdCB7IHJlY29yZHMsIG9mZnNldCB9ID0gaG9zdG5hbWVSZWNvcmRzXG5cbiAgICBsZXQgZmFtaWx5XG4gICAgaWYgKHRoaXMuZHVhbFN0YWNrKSB7XG4gICAgICBpZiAoYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAvLyBCYWxhbmNlIGJldHdlZW4gaXAgZmFtaWxpZXNcbiAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsIHx8IG9mZnNldCA9PT0gbWF4SW50KSB7XG4gICAgICAgICAgaG9zdG5hbWVSZWNvcmRzLm9mZnNldCA9IDBcbiAgICAgICAgICBhZmZpbml0eSA9IDRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBob3N0bmFtZVJlY29yZHMub2Zmc2V0KytcbiAgICAgICAgICBhZmZpbml0eSA9IChob3N0bmFtZVJlY29yZHMub2Zmc2V0ICYgMSkgPT09IDEgPyA2IDogNFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmRzW2FmZmluaXR5XSAhPSBudWxsICYmIHJlY29yZHNbYWZmaW5pdHldLmlwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZhbWlseSA9IHJlY29yZHNbYWZmaW5pdHldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYW1pbHkgPSByZWNvcmRzW2FmZmluaXR5ID09PSA0ID8gNiA6IDRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbWlseSA9IHJlY29yZHNbYWZmaW5pdHldXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gSVBzIHdlIHJldHVybiBudWxsXG4gICAgaWYgKGZhbWlseSA9PSBudWxsIHx8IGZhbWlseS5pcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaXBcbiAgICB9XG5cbiAgICBpZiAoZmFtaWx5Lm9mZnNldCA9PSBudWxsIHx8IGZhbWlseS5vZmZzZXQgPT09IG1heEludCkge1xuICAgICAgZmFtaWx5Lm9mZnNldCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgZmFtaWx5Lm9mZnNldCsrXG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBmYW1pbHkub2Zmc2V0ICUgZmFtaWx5Lmlwcy5sZW5ndGhcbiAgICBpcCA9IGZhbWlseS5pcHNbcG9zaXRpb25dID8/IG51bGxcblxuICAgIGlmIChpcCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXBcbiAgICB9XG5cbiAgICBpZiAoRGF0ZS5ub3coKSAtIGlwLnRpbWVzdGFtcCA+IGlwLnR0bCkgeyAvLyByZWNvcmQgVFRMIGlzIGFscmVhZHkgaW4gbXNcbiAgICAgIC8vIFdlIGRlbGV0ZSBleHBpcmVkIHJlY29yZHNcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhleSBoYXZlIGRpZmZlcmVudCBUVEwsIHNvIHdlIG1hbmFnZSB0aGVtIGluZGl2aWR1YWxseVxuICAgICAgZmFtaWx5Lmlwcy5zcGxpY2UocG9zaXRpb24sIDEpXG4gICAgICByZXR1cm4gdGhpcy5waWNrKG9yaWdpbiwgaG9zdG5hbWVSZWNvcmRzLCBhZmZpbml0eSlcbiAgICB9XG5cbiAgICByZXR1cm4gaXBcbiAgfVxuXG4gIHBpY2tGYW1pbHkgKG9yaWdpbiwgaXBGYW1pbHkpIHtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5zdG9yYWdlLmdldChvcmlnaW4uaG9zdG5hbWUpPy5yZWNvcmRzXG4gICAgaWYgKCFyZWNvcmRzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGZhbWlseSA9IHJlY29yZHNbaXBGYW1pbHldXG4gICAgaWYgKCFmYW1pbHkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGZhbWlseS5vZmZzZXQgPT0gbnVsbCB8fCBmYW1pbHkub2Zmc2V0ID09PSBtYXhJbnQpIHtcbiAgICAgIGZhbWlseS5vZmZzZXQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbWlseS5vZmZzZXQrK1xuICAgIH1cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gZmFtaWx5Lm9mZnNldCAlIGZhbWlseS5pcHMubGVuZ3RoXG4gICAgY29uc3QgaXAgPSBmYW1pbHkuaXBzW3Bvc2l0aW9uXSA/PyBudWxsXG4gICAgaWYgKGlwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpcFxuICAgIH1cblxuICAgIGlmIChEYXRlLm5vdygpIC0gaXAudGltZXN0YW1wID4gaXAudHRsKSB7IC8vIHJlY29yZCBUVEwgaXMgYWxyZWFkeSBpbiBtc1xuICAgICAgLy8gV2UgZGVsZXRlIGV4cGlyZWQgcmVjb3Jkc1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGV5IGhhdmUgZGlmZmVyZW50IFRUTCwgc28gd2UgbWFuYWdlIHRoZW0gaW5kaXZpZHVhbGx5XG4gICAgICBmYW1pbHkuaXBzLnNwbGljZShwb3NpdGlvbiwgMSlcbiAgICB9XG5cbiAgICByZXR1cm4gaXBcbiAgfVxuXG4gIHNldFJlY29yZHMgKG9yaWdpbiwgYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IHJlY29yZHMgPSB7IHJlY29yZHM6IHsgNDogbnVsbCwgNjogbnVsbCB9IH1cbiAgICBsZXQgbWluVFRMID0gdGhpcy4jbWF4VFRMXG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgYWRkcmVzc2VzKSB7XG4gICAgICByZWNvcmQudGltZXN0YW1wID0gdGltZXN0YW1wXG4gICAgICBpZiAodHlwZW9mIHJlY29yZC50dGwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFRoZSByZWNvcmQgVFRMIGlzIGV4cGVjdGVkIHRvIGJlIGluIG1zXG4gICAgICAgIHJlY29yZC50dGwgPSBNYXRoLm1pbihyZWNvcmQudHRsLCB0aGlzLiNtYXhUVEwpXG4gICAgICAgIG1pblRUTCA9IE1hdGgubWluKG1pblRUTCwgcmVjb3JkLnR0bClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZC50dGwgPSB0aGlzLiNtYXhUVExcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmFtaWx5UmVjb3JkcyA9IHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA/PyB7IGlwczogW10gfVxuXG4gICAgICBmYW1pbHlSZWNvcmRzLmlwcy5wdXNoKHJlY29yZClcbiAgICAgIHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA9IGZhbWlseVJlY29yZHNcbiAgICB9XG5cbiAgICAvLyBXZSBwcm92aWRlIGEgZGVmYXVsdCBUVEwgaWYgZXh0ZXJuYWwgc3RvcmFnZSB3aWxsIGJlIHVzZWQgd2l0aG91dCBUVEwgcGVyIHJlY29yZC1sZXZlbCBzdXBwb3J0XG4gICAgdGhpcy5zdG9yYWdlLnNldChvcmlnaW4uaG9zdG5hbWUsIHJlY29yZHMsIHsgdHRsOiBtaW5UVEwgfSlcbiAgfVxuXG4gIGRlbGV0ZVJlY29yZHMgKG9yaWdpbikge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxldGUob3JpZ2luLmhvc3RuYW1lKVxuICB9XG5cbiAgZ2V0SGFuZGxlciAobWV0YSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgRE5TRGlzcGF0Y2hIYW5kbGVyKHRoaXMsIG1ldGEsIG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgRE5TRGlzcGF0Y2hIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNzdGF0ZSA9IG51bGxcbiAgI29wdHMgPSBudWxsXG4gICNkaXNwYXRjaCA9IG51bGxcbiAgI29yaWdpbiA9IG51bGxcbiAgI2NvbnRyb2xsZXIgPSBudWxsXG4gICNuZXdPcmlnaW4gPSBudWxsXG4gICNmaXJzdFRyeSA9IHRydWVcblxuICBjb25zdHJ1Y3RvciAoc3RhdGUsIHsgb3JpZ2luLCBoYW5kbGVyLCBkaXNwYXRjaCwgbmV3T3JpZ2luIH0sIG9wdHMpIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuICAgIHRoaXMuI29yaWdpbiA9IG9yaWdpblxuICAgIHRoaXMuI25ld09yaWdpbiA9IG5ld09yaWdpblxuICAgIHRoaXMuI29wdHMgPSB7IC4uLm9wdHMgfVxuICAgIHRoaXMuI3N0YXRlID0gc3RhdGVcbiAgICB0aGlzLiNkaXNwYXRjaCA9IGRpc3BhdGNoXG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VUSU1FRE9VVCc6XG4gICAgICBjYXNlICdFQ09OTlJFRlVTRUQnOiB7XG4gICAgICAgIGlmICh0aGlzLiNzdGF0ZS5kdWFsU3RhY2spIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2ZpcnN0VHJ5KSB7XG4gICAgICAgICAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI2ZpcnN0VHJ5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIFBpY2sgYW4gaXAgYWRkcmVzcyBmcm9tIHRoZSBvdGhlciBmYW1pbHlcbiAgICAgICAgICBjb25zdCBvdGhlckZhbWlseSA9IHRoaXMuI25ld09yaWdpbi5ob3N0bmFtZVswXSA9PT0gJ1snID8gNCA6IDZcbiAgICAgICAgICBjb25zdCBpcCA9IHRoaXMuI3N0YXRlLnBpY2tGYW1pbHkodGhpcy4jb3JpZ2luLCBvdGhlckZhbWlseSlcbiAgICAgICAgICBpZiAoaXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3VwZXIub25SZXNwb25zZUVycm9yKGNvbnRyb2xsZXIsIGVycilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwb3J0XG4gICAgICAgICAgaWYgKHR5cGVvZiBpcC5wb3J0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcG9ydCA9IGA6JHtpcC5wb3J0fWBcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI29yaWdpbi5wb3J0ICE9PSAnJykge1xuICAgICAgICAgICAgcG9ydCA9IGA6JHt0aGlzLiNvcmlnaW4ucG9ydH1gXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcnQgPSAnJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRpc3BhdGNoT3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuI29wdHMsXG4gICAgICAgICAgICBvcmlnaW46IGAke3RoaXMuI29yaWdpbi5wcm90b2NvbH0vLyR7XG4gICAgICAgICAgICAgICAgaXAuZmFtaWx5ID09PSA2ID8gYFske2lwLmFkZHJlc3N9XWAgOiBpcC5hZGRyZXNzXG4gICAgICAgICAgICAgIH0ke3BvcnR9YFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiNkaXNwYXRjaChkaXNwYXRjaE9wdHMsIHRoaXMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBkdWFsLXN0YWNrIGRpc2FibGVkLCB3ZSBlcnJvciBvdXRcbiAgICAgICAgc3VwZXIub25SZXNwb25zZUVycm9yKGNvbnRyb2xsZXIsIGVycilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0VOT1RGT1VORCc6XG4gICAgICAgIHRoaXMuI3N0YXRlLmRlbGV0ZVJlY29yZHModGhpcy4jb3JpZ2luKVxuICAgICAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIub25SZXNwb25zZUVycm9yKGNvbnRyb2xsZXIsIGVycilcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcmNlcHRvck9wdHMgPT4ge1xuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5tYXhUVEwgIT0gbnVsbCAmJlxuICAgICh0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5tYXhUVEwgIT09ICdudW1iZXInIHx8IGludGVyY2VwdG9yT3B0cz8ubWF4VFRMIDwgMClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIG1heFRUTC4gTXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gIH1cblxuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5tYXhJdGVtcyAhPSBudWxsICYmXG4gICAgKHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/Lm1heEl0ZW1zICE9PSAnbnVtYmVyJyB8fFxuICAgICAgaW50ZXJjZXB0b3JPcHRzPy5tYXhJdGVtcyA8IDEpXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICdJbnZhbGlkIG1heEl0ZW1zLiBNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIGFuZCBncmVhdGVyIHRoYW4gemVybydcbiAgICApXG4gIH1cblxuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5hZmZpbml0eSAhPSBudWxsICYmXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5hZmZpbml0eSAhPT0gNCAmJlxuICAgIGludGVyY2VwdG9yT3B0cz8uYWZmaW5pdHkgIT09IDZcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIGFmZmluaXR5LiBNdXN0IGJlIGVpdGhlciA0IG9yIDYnKVxuICB9XG5cbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8uZHVhbFN0YWNrICE9IG51bGwgJiZcbiAgICB0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5kdWFsU3RhY2sgIT09ICdib29sZWFuJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgZHVhbFN0YWNrLiBNdXN0IGJlIGEgYm9vbGVhbicpXG4gIH1cblxuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5sb29rdXAgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/Lmxvb2t1cCAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgbG9va3VwLiBNdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8ucGljayAhPSBudWxsICYmXG4gICAgdHlwZW9mIGludGVyY2VwdG9yT3B0cz8ucGljayAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgcGljay4gTXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/LnN0b3JhZ2UgIT0gbnVsbCAmJlxuICAgICh0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5zdG9yYWdlPy5nZXQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/LnN0b3JhZ2U/LnNldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGludGVyY2VwdG9yT3B0cz8uc3RvcmFnZT8uZnVsbCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGludGVyY2VwdG9yT3B0cz8uc3RvcmFnZT8uZGVsZXRlICE9PSAnZnVuY3Rpb24nXG4gICAgKVxuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgc3RvcmFnZS4gTXVzdCBiZSBhIG9iamVjdCB3aXRoIG1ldGhvZHM6IHsgZ2V0LCBzZXQsIGZ1bGwsIGRlbGV0ZSB9JylcbiAgfVxuXG4gIGNvbnN0IGR1YWxTdGFjayA9IGludGVyY2VwdG9yT3B0cz8uZHVhbFN0YWNrID8/IHRydWVcbiAgbGV0IGFmZmluaXR5XG4gIGlmIChkdWFsU3RhY2spIHtcbiAgICBhZmZpbml0eSA9IGludGVyY2VwdG9yT3B0cz8uYWZmaW5pdHkgPz8gbnVsbFxuICB9IGVsc2Uge1xuICAgIGFmZmluaXR5ID0gaW50ZXJjZXB0b3JPcHRzPy5hZmZpbml0eSA/PyA0XG4gIH1cblxuICBjb25zdCBvcHRzID0ge1xuICAgIG1heFRUTDogaW50ZXJjZXB0b3JPcHRzPy5tYXhUVEwgPz8gMTBlMywgLy8gRXhwcmVzc2VkIGluIG1zXG4gICAgbG9va3VwOiBpbnRlcmNlcHRvck9wdHM/Lmxvb2t1cCA/PyBudWxsLFxuICAgIHBpY2s6IGludGVyY2VwdG9yT3B0cz8ucGljayA/PyBudWxsLFxuICAgIGR1YWxTdGFjayxcbiAgICBhZmZpbml0eSxcbiAgICBtYXhJdGVtczogaW50ZXJjZXB0b3JPcHRzPy5tYXhJdGVtcyA/PyBJbmZpbml0eSxcbiAgICBzdG9yYWdlOiBpbnRlcmNlcHRvck9wdHM/LnN0b3JhZ2VcbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IEROU0luc3RhbmNlKG9wdHMpXG5cbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZG5zSW50ZXJjZXB0b3IgKG9yaWdEaXNwYXRjaE9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9XG4gICAgICAgIG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luLmNvbnN0cnVjdG9yID09PSBVUkxcbiAgICAgICAgICA/IG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luXG4gICAgICAgICAgOiBuZXcgVVJMKG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luKVxuXG4gICAgICBpZiAoaXNJUChvcmlnaW4uaG9zdG5hbWUpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcmlnRGlzcGF0Y2hPcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5ydW5Mb29rdXAob3JpZ2luLCBvcmlnRGlzcGF0Y2hPcHRzLCAoZXJyLCBuZXdPcmlnaW4pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcihudWxsLCBlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaXNwYXRjaE9wdHMgPSB7XG4gICAgICAgICAgLi4ub3JpZ0Rpc3BhdGNoT3B0cyxcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBvcmlnaW4uaG9zdG5hbWUsIC8vIEZvciBTTkkgb24gVExTXG4gICAgICAgICAgb3JpZ2luOiBuZXdPcmlnaW4ub3JpZ2luLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGhvc3Q6IG9yaWdpbi5ob3N0LFxuICAgICAgICAgICAgLi4ub3JpZ0Rpc3BhdGNoT3B0cy5oZWFkZXJzXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgZGlzcGF0Y2hPcHRzLFxuICAgICAgICAgIGluc3RhbmNlLmdldEhhbmRsZXIoXG4gICAgICAgICAgICB7IG9yaWdpbiwgZGlzcGF0Y2gsIGhhbmRsZXIsIG5ld09yaWdpbiB9LFxuICAgICAgICAgICAgb3JpZ0Rpc3BhdGNoT3B0c1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\n\nclass DumpHandler extends DecoratorHandler {\n  #maxSize = 1024 * 1024\n  #dumped = false\n  #size = 0\n  #controller = null\n  aborted = false\n  reason = false\n\n  constructor ({ maxSize, signal }, handler) {\n    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n      throw new InvalidArgumentError('maxSize must be a number greater than 0')\n    }\n\n    super(handler)\n\n    this.#maxSize = maxSize ?? this.#maxSize\n    // this.#handler = handler\n  }\n\n  #abort (reason) {\n    this.aborted = true\n    this.reason = reason\n  }\n\n  onRequestStart (controller, context) {\n    controller.abort = this.#abort.bind(this)\n    this.#controller = controller\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const contentLength = headers['content-length']\n\n    if (contentLength != null && contentLength > this.#maxSize) {\n      throw new RequestAbortedError(\n        `Response size (${contentLength}) larger than maxSize (${\n          this.#maxSize\n        })`\n      )\n    }\n\n    if (this.aborted === true) {\n      return true\n    }\n\n    return super.onResponseStart(controller, statusCode, headers, statusMessage)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#dumped) {\n      return\n    }\n\n    // On network errors before connect, controller will be null\n    err = this.#controller?.reason ?? err\n\n    super.onResponseError(controller, err)\n  }\n\n  onResponseData (controller, chunk) {\n    this.#size = this.#size + chunk.length\n\n    if (this.#size >= this.#maxSize) {\n      this.#dumped = true\n\n      if (this.aborted === true) {\n        super.onResponseError(controller, this.reason)\n      } else {\n        super.onResponseEnd(controller, {})\n      }\n    }\n\n    return true\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#dumped) {\n      return\n    }\n\n    if (this.#controller.aborted === true) {\n      super.onResponseError(controller, this.reason)\n      return\n    }\n\n    super.onResponseEnd(controller, trailers)\n  }\n}\n\nfunction createDumpInterceptor (\n  { maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n  }\n) {\n  return dispatch => {\n    return function Intercept (opts, handler) {\n      const { dumpMaxSize = defaultMaxSize } = opts\n\n      const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler)\n\n      return dispatch(opts, dumpHandler)\n    }\n  }\n}\n\nmodule.exports = createDumpInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDOUUseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7O0FBRTdDLDRDQUE0QywyQ0FBMkM7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaW50ZXJjZXB0b3JcXGR1bXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcblxuY2xhc3MgRHVtcEhhbmRsZXIgZXh0ZW5kcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI21heFNpemUgPSAxMDI0ICogMTAyNFxuICAjZHVtcGVkID0gZmFsc2VcbiAgI3NpemUgPSAwXG4gICNjb250cm9sbGVyID0gbnVsbFxuICBhYm9ydGVkID0gZmFsc2VcbiAgcmVhc29uID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvciAoeyBtYXhTaXplLCBzaWduYWwgfSwgaGFuZGxlcikge1xuICAgIGlmIChtYXhTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUobWF4U2l6ZSkgfHwgbWF4U2l6ZSA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgc3VwZXIoaGFuZGxlcilcblxuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplID8/IHRoaXMuI21heFNpemVcbiAgICAvLyB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICB9XG5cbiAgI2Fib3J0IChyZWFzb24pIHtcbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gICAgdGhpcy5yZWFzb24gPSByZWFzb25cbiAgfVxuXG4gIG9uUmVxdWVzdFN0YXJ0IChjb250cm9sbGVyLCBjb250ZXh0KSB7XG4gICAgY29udHJvbGxlci5hYm9ydCA9IHRoaXMuI2Fib3J0LmJpbmQodGhpcylcbiAgICB0aGlzLiNjb250cm9sbGVyID0gY29udHJvbGxlclxuXG4gICAgcmV0dXJuIHN1cGVyLm9uUmVxdWVzdFN0YXJ0KGNvbnRyb2xsZXIsIGNvbnRleHQpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoID4gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoXG4gICAgICAgIGBSZXNwb25zZSBzaXplICgke2NvbnRlbnRMZW5ndGh9KSBsYXJnZXIgdGhhbiBtYXhTaXplICgke1xuICAgICAgICAgIHRoaXMuI21heFNpemVcbiAgICAgICAgfSlgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWJvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIub25SZXNwb25zZVN0YXJ0KGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIGlmICh0aGlzLiNkdW1wZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIE9uIG5ldHdvcmsgZXJyb3JzIGJlZm9yZSBjb25uZWN0LCBjb250cm9sbGVyIHdpbGwgYmUgbnVsbFxuICAgIGVyciA9IHRoaXMuI2NvbnRyb2xsZXI/LnJlYXNvbiA/PyBlcnJcblxuICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICB0aGlzLiNzaXplID0gdGhpcy4jc2l6ZSArIGNodW5rLmxlbmd0aFxuXG4gICAgaWYgKHRoaXMuI3NpemUgPj0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jZHVtcGVkID0gdHJ1ZVxuXG4gICAgICBpZiAodGhpcy5hYm9ydGVkID09PSB0cnVlKSB7XG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCB0aGlzLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFbmQoY29udHJvbGxlciwge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI2R1bXBlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2NvbnRyb2xsZXIuYWJvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgc3VwZXIub25SZXNwb25zZUVycm9yKGNvbnRyb2xsZXIsIHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3VwZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB0cmFpbGVycylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdW1wSW50ZXJjZXB0b3IgKFxuICB7IG1heFNpemU6IGRlZmF1bHRNYXhTaXplIH0gPSB7XG4gICAgbWF4U2l6ZTogMTAyNCAqIDEwMjRcbiAgfVxuKSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBkdW1wTWF4U2l6ZSA9IGRlZmF1bHRNYXhTaXplIH0gPSBvcHRzXG5cbiAgICAgIGNvbnN0IGR1bXBIYW5kbGVyID0gbmV3IER1bXBIYW5kbGVyKHsgbWF4U2l6ZTogZHVtcE1heFNpemUsIHNpZ25hbDogb3B0cy5zaWduYWwgfSwgaGFuZGxlcilcblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGR1bXBIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUR1bXBJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections } = {}) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections, ...rest } = opts\n\n      if (maxRedirections == null || maxRedirections === 0) {\n        return dispatch(opts, handler)\n      }\n\n      const dispatchOpts = { ...rest } // Stop sub dispatcher from also redirecting.\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler)\n      return dispatch(dispatchOpts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBNkI7O0FBRTdELHNDQUFzQywwQ0FBMEMsSUFBSTtBQUNwRjtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaW50ZXJjZXB0b3JcXHJlZGlyZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXInKVxuXG5mdW5jdGlvbiBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yICh7IG1heFJlZGlyZWN0aW9uczogZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0ge30pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucywgLi4ucmVzdCB9ID0gb3B0c1xuXG4gICAgICBpZiAobWF4UmVkaXJlY3Rpb25zID09IG51bGwgfHwgbWF4UmVkaXJlY3Rpb25zID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXNwYXRjaE9wdHMgPSB7IC4uLnJlc3QgfSAvLyBTdG9wIHN1YiBkaXNwYXRjaGVyIGZyb20gYWxzbyByZWRpcmVjdGluZy5cbiAgICAgIGNvbnN0IHJlZGlyZWN0SGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgZGlzcGF0Y2hPcHRzLCBoYW5kbGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoKGRpc3BhdGNoT3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/response-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/response-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// const { parseHeaders } = require('../core/util')\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { ResponseError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nclass ResponseErrorHandler extends DecoratorHandler {\n  #statusCode\n  #contentType\n  #decoder\n  #headers\n  #body\n\n  constructor (_opts, { handler }) {\n    super(handler)\n  }\n\n  #checkContentType (contentType) {\n    return (this.#contentType ?? '').indexOf(contentType) === 0\n  }\n\n  onRequestStart (controller, context) {\n    this.#statusCode = 0\n    this.#contentType = null\n    this.#decoder = null\n    this.#headers = null\n    this.#body = ''\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.#statusCode = statusCode\n    this.#headers = headers\n    this.#contentType = headers['content-type']\n\n    if (this.#statusCode < 400) {\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    if (this.#checkContentType('application/json') || this.#checkContentType('text/plain')) {\n      this.#decoder = new TextDecoder('utf-8')\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#statusCode < 400) {\n      return super.onResponseData(controller, chunk)\n    }\n\n    this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? ''\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#statusCode >= 400) {\n      this.#body += this.#decoder?.decode(undefined, { stream: false }) ?? ''\n\n      if (this.#checkContentType('application/json')) {\n        try {\n          this.#body = JSON.parse(this.#body)\n        } catch {\n          // Do nothing...\n        }\n      }\n\n      let err\n      const stackTraceLimit = Error.stackTraceLimit\n      Error.stackTraceLimit = 0\n      try {\n        err = new ResponseError('Response Error', this.#statusCode, {\n          body: this.#body,\n          headers: this.#headers\n        })\n      } finally {\n        Error.stackTraceLimit = stackTraceLimit\n      }\n\n      super.onResponseError(controller, err)\n    } else {\n      super.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, err) {\n    super.onResponseError(controller, err)\n  }\n}\n\nmodule.exports = () => {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      return dispatch(opts, new ResponseErrorHandler(opts, { handler }))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXNwb25zZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLGVBQWU7QUFDMUIseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCO0FBQy9ELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxlQUFlOztBQUV0RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxccmVzcG9uc2UtZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGNvbnN0IHsgcGFyc2VIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgeyBSZXNwb25zZUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIFJlc3BvbnNlRXJyb3JIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNzdGF0dXNDb2RlXG4gICNjb250ZW50VHlwZVxuICAjZGVjb2RlclxuICAjaGVhZGVyc1xuICAjYm9keVxuXG4gIGNvbnN0cnVjdG9yIChfb3B0cywgeyBoYW5kbGVyIH0pIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuICB9XG5cbiAgI2NoZWNrQ29udGVudFR5cGUgKGNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb250ZW50VHlwZSA/PyAnJykuaW5kZXhPZihjb250ZW50VHlwZSkgPT09IDBcbiAgfVxuXG4gIG9uUmVxdWVzdFN0YXJ0IChjb250cm9sbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy4jc3RhdHVzQ29kZSA9IDBcbiAgICB0aGlzLiNjb250ZW50VHlwZSA9IG51bGxcbiAgICB0aGlzLiNkZWNvZGVyID0gbnVsbFxuICAgIHRoaXMuI2hlYWRlcnMgPSBudWxsXG4gICAgdGhpcy4jYm9keSA9ICcnXG5cbiAgICByZXR1cm4gc3VwZXIub25SZXF1ZXN0U3RhcnQoY29udHJvbGxlciwgY29udGV4dClcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydCAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy4jaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLiNjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG5cbiAgICBpZiAodGhpcy4jc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgICAgcmV0dXJuIHN1cGVyLm9uUmVzcG9uc2VTdGFydChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNjaGVja0NvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJykgfHwgdGhpcy4jY2hlY2tDb250ZW50VHlwZSgndGV4dC9wbGFpbicpKSB7XG4gICAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZURhdGEgKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgaWYgKHRoaXMuI3N0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAgIHJldHVybiBzdXBlci5vblJlc3BvbnNlRGF0YShjb250cm9sbGVyLCBjaHVuaylcbiAgICB9XG5cbiAgICB0aGlzLiNib2R5ICs9IHRoaXMuI2RlY29kZXI/LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkgPz8gJydcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI3N0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICB0aGlzLiNib2R5ICs9IHRoaXMuI2RlY29kZXI/LmRlY29kZSh1bmRlZmluZWQsIHsgc3RyZWFtOiBmYWxzZSB9KSA/PyAnJ1xuXG4gICAgICBpZiAodGhpcy4jY2hlY2tDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy4jYm9keSA9IEpTT04ucGFyc2UodGhpcy4jYm9keSlcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZy4uLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBlcnJcbiAgICAgIGNvbnN0IHN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMFxuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyID0gbmV3IFJlc3BvbnNlRXJyb3IoJ1Jlc3BvbnNlIEVycm9yJywgdGhpcy4jc3RhdHVzQ29kZSwge1xuICAgICAgICAgIGJvZHk6IHRoaXMuI2JvZHksXG4gICAgICAgICAgaGVhZGVyczogdGhpcy4jaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0XG4gICAgICB9XG5cbiAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLm9uUmVzcG9uc2VFbmQoY29udHJvbGxlciwgdHJhaWxlcnMpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCkgPT4ge1xuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIG5ldyBSZXNwb25zZUVycm9ySGFuZGxlcihvcHRzLCB7IGhhbmRsZXIgfSkpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/response-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nmodule.exports = globalOpts => {\n  return dispatch => {\n    return function retryInterceptor (opts, handler) {\n      return dispatch(\n        opts,\n        new RetryHandler(\n          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },\n          {\n            handler,\n            dispatch\n          }\n        )\n      )\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUIsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxyZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IFJldHJ5SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmV0cnktaGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT3B0cyA9PiB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJldHJ5SW50ZXJjZXB0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaChcbiAgICAgICAgb3B0cyxcbiAgICAgICAgbmV3IFJldHJ5SGFuZGxlcihcbiAgICAgICAgICB7IC4uLm9wdHMsIHJldHJ5T3B0aW9uczogeyAuLi5nbG9iYWxPcHRzLCAuLi5vcHRzLnJldHJ5T3B0aW9ucyB9IH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.MINOR = exports.MAJOR = exports.HTAB_SP_VCHAR_OBS_TEXT = exports.QUOTED_STRING = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.HEX = exports.URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.STATUSES_HTTP = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.HEADER_STATE = exports.FINISH = exports.STATUSES = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/undici/lib/llhttp/utils.js\");\n// Emums\nexports.ERROR = {\n    OK: 0,\n    INTERNAL: 1,\n    STRICT: 2,\n    CR_EXPECTED: 25,\n    LF_EXPECTED: 3,\n    UNEXPECTED_CONTENT_LENGTH: 4,\n    UNEXPECTED_SPACE: 30,\n    CLOSED_CONNECTION: 5,\n    INVALID_METHOD: 6,\n    INVALID_URL: 7,\n    INVALID_CONSTANT: 8,\n    INVALID_VERSION: 9,\n    INVALID_HEADER_TOKEN: 10,\n    INVALID_CONTENT_LENGTH: 11,\n    INVALID_CHUNK_SIZE: 12,\n    INVALID_STATUS: 13,\n    INVALID_EOF_STATE: 14,\n    INVALID_TRANSFER_ENCODING: 15,\n    CB_MESSAGE_BEGIN: 16,\n    CB_HEADERS_COMPLETE: 17,\n    CB_MESSAGE_COMPLETE: 18,\n    CB_CHUNK_HEADER: 19,\n    CB_CHUNK_COMPLETE: 20,\n    PAUSED: 21,\n    PAUSED_UPGRADE: 22,\n    PAUSED_H2_UPGRADE: 23,\n    USER: 24,\n    CB_URL_COMPLETE: 26,\n    CB_STATUS_COMPLETE: 27,\n    CB_METHOD_COMPLETE: 32,\n    CB_VERSION_COMPLETE: 33,\n    CB_HEADER_FIELD_COMPLETE: 28,\n    CB_HEADER_VALUE_COMPLETE: 29,\n    CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,\n    CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,\n    CB_RESET: 31,\n    CB_PROTOCOL_COMPLETE: 38,\n};\nexports.TYPE = {\n    BOTH: 0, // default\n    REQUEST: 1,\n    RESPONSE: 2,\n};\nexports.FLAGS = {\n    CONNECTION_KEEP_ALIVE: 1 << 0,\n    CONNECTION_CLOSE: 1 << 1,\n    CONNECTION_UPGRADE: 1 << 2,\n    CHUNKED: 1 << 3,\n    UPGRADE: 1 << 4,\n    CONTENT_LENGTH: 1 << 5,\n    SKIPBODY: 1 << 6,\n    TRAILING: 1 << 7,\n    // 1 << 8 is unused\n    TRANSFER_ENCODING: 1 << 9,\n};\nexports.LENIENT_FLAGS = {\n    HEADERS: 1 << 0,\n    CHUNKED_LENGTH: 1 << 1,\n    KEEP_ALIVE: 1 << 2,\n    TRANSFER_ENCODING: 1 << 3,\n    VERSION: 1 << 4,\n    DATA_AFTER_CLOSE: 1 << 5,\n    OPTIONAL_LF_AFTER_CR: 1 << 6,\n    OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,\n    OPTIONAL_CR_BEFORE_LF: 1 << 8,\n    SPACES_AFTER_CHUNK_SIZE: 1 << 9,\n};\nexports.METHODS = {\n    'DELETE': 0,\n    'GET': 1,\n    'HEAD': 2,\n    'POST': 3,\n    'PUT': 4,\n    /* pathological */\n    'CONNECT': 5,\n    'OPTIONS': 6,\n    'TRACE': 7,\n    /* WebDAV */\n    'COPY': 8,\n    'LOCK': 9,\n    'MKCOL': 10,\n    'MOVE': 11,\n    'PROPFIND': 12,\n    'PROPPATCH': 13,\n    'SEARCH': 14,\n    'UNLOCK': 15,\n    'BIND': 16,\n    'REBIND': 17,\n    'UNBIND': 18,\n    'ACL': 19,\n    /* subversion */\n    'REPORT': 20,\n    'MKACTIVITY': 21,\n    'CHECKOUT': 22,\n    'MERGE': 23,\n    /* upnp */\n    'M-SEARCH': 24,\n    'NOTIFY': 25,\n    'SUBSCRIBE': 26,\n    'UNSUBSCRIBE': 27,\n    /* RFC-5789 */\n    'PATCH': 28,\n    'PURGE': 29,\n    /* CalDAV */\n    'MKCALENDAR': 30,\n    /* RFC-2068, section 19.6.1.2 */\n    'LINK': 31,\n    'UNLINK': 32,\n    /* icecast */\n    'SOURCE': 33,\n    /* RFC-7540, section 11.6 */\n    'PRI': 34,\n    /* RFC-2326 RTSP */\n    'DESCRIBE': 35,\n    'ANNOUNCE': 36,\n    'SETUP': 37,\n    'PLAY': 38,\n    'PAUSE': 39,\n    'TEARDOWN': 40,\n    'GET_PARAMETER': 41,\n    'SET_PARAMETER': 42,\n    'REDIRECT': 43,\n    'RECORD': 44,\n    /* RAOP */\n    'FLUSH': 45,\n    /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */\n    'QUERY': 46,\n};\nexports.STATUSES = {\n    CONTINUE: 100,\n    SWITCHING_PROTOCOLS: 101,\n    PROCESSING: 102,\n    EARLY_HINTS: 103,\n    RESPONSE_IS_STALE: 110, // Unofficial\n    REVALIDATION_FAILED: 111, // Unofficial\n    DISCONNECTED_OPERATION: 112, // Unofficial\n    HEURISTIC_EXPIRATION: 113, // Unofficial\n    MISCELLANEOUS_WARNING: 199, // Unofficial\n    OK: 200,\n    CREATED: 201,\n    ACCEPTED: 202,\n    NON_AUTHORITATIVE_INFORMATION: 203,\n    NO_CONTENT: 204,\n    RESET_CONTENT: 205,\n    PARTIAL_CONTENT: 206,\n    MULTI_STATUS: 207,\n    ALREADY_REPORTED: 208,\n    TRANSFORMATION_APPLIED: 214, // Unofficial\n    IM_USED: 226,\n    MISCELLANEOUS_PERSISTENT_WARNING: 299, // Unofficial\n    MULTIPLE_CHOICES: 300,\n    MOVED_PERMANENTLY: 301,\n    FOUND: 302,\n    SEE_OTHER: 303,\n    NOT_MODIFIED: 304,\n    USE_PROXY: 305,\n    SWITCH_PROXY: 306, // No longer used\n    TEMPORARY_REDIRECT: 307,\n    PERMANENT_REDIRECT: 308,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_ALLOWED: 405,\n    NOT_ACCEPTABLE: 406,\n    PROXY_AUTHENTICATION_REQUIRED: 407,\n    REQUEST_TIMEOUT: 408,\n    CONFLICT: 409,\n    GONE: 410,\n    LENGTH_REQUIRED: 411,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    URI_TOO_LONG: 414,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    RANGE_NOT_SATISFIABLE: 416,\n    EXPECTATION_FAILED: 417,\n    IM_A_TEAPOT: 418,\n    PAGE_EXPIRED: 419, // Unofficial\n    ENHANCE_YOUR_CALM: 420, // Unofficial\n    MISDIRECTED_REQUEST: 421,\n    UNPROCESSABLE_ENTITY: 422,\n    LOCKED: 423,\n    FAILED_DEPENDENCY: 424,\n    TOO_EARLY: 425,\n    UPGRADE_REQUIRED: 426,\n    PRECONDITION_REQUIRED: 428,\n    TOO_MANY_REQUESTS: 429,\n    REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430, // Unofficial\n    REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n    LOGIN_TIMEOUT: 440, // Unofficial\n    NO_RESPONSE: 444, // Unofficial\n    RETRY_WITH: 449, // Unofficial\n    BLOCKED_BY_PARENTAL_CONTROL: 450, // Unofficial\n    UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n    CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460, // Unofficial\n    INVALID_X_FORWARDED_FOR: 463, // Unofficial\n    REQUEST_HEADER_TOO_LARGE: 494, // Unofficial\n    SSL_CERTIFICATE_ERROR: 495, // Unofficial\n    SSL_CERTIFICATE_REQUIRED: 496, // Unofficial\n    HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497, // Unofficial\n    INVALID_TOKEN: 498, // Unofficial\n    CLIENT_CLOSED_REQUEST: 499, // Unofficial\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504,\n    HTTP_VERSION_NOT_SUPPORTED: 505,\n    VARIANT_ALSO_NEGOTIATES: 506,\n    INSUFFICIENT_STORAGE: 507,\n    LOOP_DETECTED: 508,\n    BANDWIDTH_LIMIT_EXCEEDED: 509,\n    NOT_EXTENDED: 510,\n    NETWORK_AUTHENTICATION_REQUIRED: 511,\n    WEB_SERVER_UNKNOWN_ERROR: 520, // Unofficial\n    WEB_SERVER_IS_DOWN: 521, // Unofficial\n    CONNECTION_TIMEOUT: 522, // Unofficial\n    ORIGIN_IS_UNREACHABLE: 523, // Unofficial\n    TIMEOUT_OCCURED: 524, // Unofficial\n    SSL_HANDSHAKE_FAILED: 525, // Unofficial\n    INVALID_SSL_CERTIFICATE: 526, // Unofficial\n    RAILGUN_ERROR: 527, // Unofficial\n    SITE_IS_OVERLOADED: 529, // Unofficial\n    SITE_IS_FROZEN: 530, // Unofficial\n    IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561, // Unofficial\n    NETWORK_READ_TIMEOUT: 598, // Unofficial\n    NETWORK_CONNECT_TIMEOUT: 599, // Unofficial\n};\nexports.FINISH = {\n    SAFE: 0,\n    SAFE_WITH_CB: 1,\n    UNSAFE: 2,\n};\nexports.HEADER_STATE = {\n    GENERAL: 0,\n    CONNECTION: 1,\n    CONTENT_LENGTH: 2,\n    TRANSFER_ENCODING: 3,\n    UPGRADE: 4,\n    CONNECTION_KEEP_ALIVE: 5,\n    CONNECTION_CLOSE: 6,\n    CONNECTION_UPGRADE: 7,\n    TRANSFER_ENCODING_CHUNKED: 8,\n};\n// C headers\nexports.METHODS_HTTP = [\n    exports.METHODS.DELETE,\n    exports.METHODS.GET,\n    exports.METHODS.HEAD,\n    exports.METHODS.POST,\n    exports.METHODS.PUT,\n    exports.METHODS.CONNECT,\n    exports.METHODS.OPTIONS,\n    exports.METHODS.TRACE,\n    exports.METHODS.COPY,\n    exports.METHODS.LOCK,\n    exports.METHODS.MKCOL,\n    exports.METHODS.MOVE,\n    exports.METHODS.PROPFIND,\n    exports.METHODS.PROPPATCH,\n    exports.METHODS.SEARCH,\n    exports.METHODS.UNLOCK,\n    exports.METHODS.BIND,\n    exports.METHODS.REBIND,\n    exports.METHODS.UNBIND,\n    exports.METHODS.ACL,\n    exports.METHODS.REPORT,\n    exports.METHODS.MKACTIVITY,\n    exports.METHODS.CHECKOUT,\n    exports.METHODS.MERGE,\n    exports.METHODS['M-SEARCH'],\n    exports.METHODS.NOTIFY,\n    exports.METHODS.SUBSCRIBE,\n    exports.METHODS.UNSUBSCRIBE,\n    exports.METHODS.PATCH,\n    exports.METHODS.PURGE,\n    exports.METHODS.MKCALENDAR,\n    exports.METHODS.LINK,\n    exports.METHODS.UNLINK,\n    exports.METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    exports.METHODS.SOURCE,\n    exports.METHODS.QUERY,\n];\nexports.METHODS_ICE = [\n    exports.METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    exports.METHODS.OPTIONS,\n    exports.METHODS.DESCRIBE,\n    exports.METHODS.ANNOUNCE,\n    exports.METHODS.SETUP,\n    exports.METHODS.PLAY,\n    exports.METHODS.PAUSE,\n    exports.METHODS.TEARDOWN,\n    exports.METHODS.GET_PARAMETER,\n    exports.METHODS.SET_PARAMETER,\n    exports.METHODS.REDIRECT,\n    exports.METHODS.RECORD,\n    exports.METHODS.FLUSH,\n    // For AirPlay\n    exports.METHODS.GET,\n    exports.METHODS.POST,\n];\nexports.METHOD_MAP = (0, utils_1.enumToMap)(exports.METHODS);\nexports.H_METHOD_MAP = Object.fromEntries(Object.entries(exports.METHODS).filter(([k]) => k.startsWith('H')));\nexports.STATUSES_HTTP = [\n    exports.STATUSES.CONTINUE,\n    exports.STATUSES.SWITCHING_PROTOCOLS,\n    exports.STATUSES.PROCESSING,\n    exports.STATUSES.EARLY_HINTS,\n    exports.STATUSES.RESPONSE_IS_STALE,\n    exports.STATUSES.REVALIDATION_FAILED,\n    exports.STATUSES.DISCONNECTED_OPERATION,\n    exports.STATUSES.HEURISTIC_EXPIRATION,\n    exports.STATUSES.MISCELLANEOUS_WARNING,\n    exports.STATUSES.OK,\n    exports.STATUSES.CREATED,\n    exports.STATUSES.ACCEPTED,\n    exports.STATUSES.NON_AUTHORITATIVE_INFORMATION,\n    exports.STATUSES.NO_CONTENT,\n    exports.STATUSES.RESET_CONTENT,\n    exports.STATUSES.PARTIAL_CONTENT,\n    exports.STATUSES.MULTI_STATUS,\n    exports.STATUSES.ALREADY_REPORTED,\n    exports.STATUSES.TRANSFORMATION_APPLIED,\n    exports.STATUSES.IM_USED,\n    exports.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,\n    exports.STATUSES.MULTIPLE_CHOICES,\n    exports.STATUSES.MOVED_PERMANENTLY,\n    exports.STATUSES.FOUND,\n    exports.STATUSES.SEE_OTHER,\n    exports.STATUSES.NOT_MODIFIED,\n    exports.STATUSES.USE_PROXY,\n    exports.STATUSES.SWITCH_PROXY,\n    exports.STATUSES.TEMPORARY_REDIRECT,\n    exports.STATUSES.PERMANENT_REDIRECT,\n    exports.STATUSES.BAD_REQUEST,\n    exports.STATUSES.UNAUTHORIZED,\n    exports.STATUSES.PAYMENT_REQUIRED,\n    exports.STATUSES.FORBIDDEN,\n    exports.STATUSES.NOT_FOUND,\n    exports.STATUSES.METHOD_NOT_ALLOWED,\n    exports.STATUSES.NOT_ACCEPTABLE,\n    exports.STATUSES.PROXY_AUTHENTICATION_REQUIRED,\n    exports.STATUSES.REQUEST_TIMEOUT,\n    exports.STATUSES.CONFLICT,\n    exports.STATUSES.GONE,\n    exports.STATUSES.LENGTH_REQUIRED,\n    exports.STATUSES.PRECONDITION_FAILED,\n    exports.STATUSES.PAYLOAD_TOO_LARGE,\n    exports.STATUSES.URI_TOO_LONG,\n    exports.STATUSES.UNSUPPORTED_MEDIA_TYPE,\n    exports.STATUSES.RANGE_NOT_SATISFIABLE,\n    exports.STATUSES.EXPECTATION_FAILED,\n    exports.STATUSES.IM_A_TEAPOT,\n    exports.STATUSES.PAGE_EXPIRED,\n    exports.STATUSES.ENHANCE_YOUR_CALM,\n    exports.STATUSES.MISDIRECTED_REQUEST,\n    exports.STATUSES.UNPROCESSABLE_ENTITY,\n    exports.STATUSES.LOCKED,\n    exports.STATUSES.FAILED_DEPENDENCY,\n    exports.STATUSES.TOO_EARLY,\n    exports.STATUSES.UPGRADE_REQUIRED,\n    exports.STATUSES.PRECONDITION_REQUIRED,\n    exports.STATUSES.TOO_MANY_REQUESTS,\n    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,\n    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,\n    exports.STATUSES.LOGIN_TIMEOUT,\n    exports.STATUSES.NO_RESPONSE,\n    exports.STATUSES.RETRY_WITH,\n    exports.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,\n    exports.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,\n    exports.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,\n    exports.STATUSES.INVALID_X_FORWARDED_FOR,\n    exports.STATUSES.REQUEST_HEADER_TOO_LARGE,\n    exports.STATUSES.SSL_CERTIFICATE_ERROR,\n    exports.STATUSES.SSL_CERTIFICATE_REQUIRED,\n    exports.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,\n    exports.STATUSES.INVALID_TOKEN,\n    exports.STATUSES.CLIENT_CLOSED_REQUEST,\n    exports.STATUSES.INTERNAL_SERVER_ERROR,\n    exports.STATUSES.NOT_IMPLEMENTED,\n    exports.STATUSES.BAD_GATEWAY,\n    exports.STATUSES.SERVICE_UNAVAILABLE,\n    exports.STATUSES.GATEWAY_TIMEOUT,\n    exports.STATUSES.HTTP_VERSION_NOT_SUPPORTED,\n    exports.STATUSES.VARIANT_ALSO_NEGOTIATES,\n    exports.STATUSES.INSUFFICIENT_STORAGE,\n    exports.STATUSES.LOOP_DETECTED,\n    exports.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,\n    exports.STATUSES.NOT_EXTENDED,\n    exports.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,\n    exports.STATUSES.WEB_SERVER_UNKNOWN_ERROR,\n    exports.STATUSES.WEB_SERVER_IS_DOWN,\n    exports.STATUSES.CONNECTION_TIMEOUT,\n    exports.STATUSES.ORIGIN_IS_UNREACHABLE,\n    exports.STATUSES.TIMEOUT_OCCURED,\n    exports.STATUSES.SSL_HANDSHAKE_FAILED,\n    exports.STATUSES.INVALID_SSL_CERTIFICATE,\n    exports.STATUSES.RAILGUN_ERROR,\n    exports.STATUSES.SITE_IS_OVERLOADED,\n    exports.STATUSES.SITE_IS_FROZEN,\n    exports.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,\n    exports.STATUSES.NETWORK_READ_TIMEOUT,\n    exports.STATUSES.NETWORK_CONNECT_TIMEOUT,\n];\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.QUOTED_STRING = ['\\t', ' '];\nfor (let i = 0x21; i <= 0xff; i++) {\n    if (i !== 0x22 && i !== 0x5c) { // All characters in ASCII except \\ and \"\n        exports.QUOTED_STRING.push(i);\n    }\n}\nexports.HTAB_SP_VCHAR_OBS_TEXT = ['\\t', ' '];\n// VCHAR: https://tools.ietf.org/html/rfc5234#appendix-B.1\nfor (let i = 0x21; i <= 0x7E; i++) {\n    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);\n}\n// OBS_TEXT: https://datatracker.ietf.org/doc/html/rfc9110#name-collected-abnf\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);\n}\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nexports.SPECIAL_HEADERS = {\n    'connection': exports.HEADER_STATE.CONNECTION,\n    'content-length': exports.HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': exports.HEADER_STATE.CONNECTION,\n    'transfer-encoding': exports.HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': exports.HEADER_STATE.UPGRADE,\n};\nexports[\"default\"] = {\n    ERROR: exports.ERROR,\n    TYPE: exports.TYPE,\n    FLAGS: exports.FLAGS,\n    LENIENT_FLAGS: exports.LENIENT_FLAGS,\n    METHODS: exports.METHODS,\n    STATUSES: exports.STATUSES,\n    FINISH: exports.FINISH,\n    HEADER_STATE: exports.HEADER_STATE,\n    ALPHA: exports.ALPHA,\n    NUM_MAP: exports.NUM_MAP,\n    HEX_MAP: exports.HEX_MAP,\n    NUM: exports.NUM,\n    ALPHANUM: exports.ALPHANUM,\n    MARK: exports.MARK,\n    USERINFO_CHARS: exports.USERINFO_CHARS,\n    URL_CHAR: exports.URL_CHAR,\n    HEX: exports.HEX,\n    TOKEN: exports.TOKEN,\n    HEADER_CHARS: exports.HEADER_CHARS,\n    CONNECTION_TOKEN_CHARS: exports.CONNECTION_TOKEN_CHARS,\n    QUOTED_STRING: exports.QUOTED_STRING,\n    HTAB_SP_VCHAR_OBS_TEXT: exports.HTAB_SP_VCHAR_OBS_TEXT,\n    MAJOR: exports.MAJOR,\n    MINOR: exports.MINOR,\n    SPECIAL_HEADERS: exports.SPECIAL_HEADERS,\n    METHODS_HTTP: exports.METHODS_HTTP,\n    METHODS_ICE: exports.METHODS_ICE,\n    METHODS_RTSP: exports.METHODS_RTSP,\n    METHOD_MAP: exports.METHOD_MAP,\n    H_METHOD_MAP: exports.H_METHOD_MAP,\n    STATUSES_HTTP: exports.STATUSES_HTTP,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcscUJBQXFCLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQ2xuQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBUztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU0sVUFBVTtBQUNoQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsbUJBQW1CLFdBQVc7QUFDOUIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLkhUQUJfU1BfVkNIQVJfT0JTX1RFWFQgPSBleHBvcnRzLlFVT1RFRF9TVFJJTkcgPSBleHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUyA9IGV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuU1RBVFVTRVNfSFRUUCA9IGV4cG9ydHMuSF9NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBleHBvcnRzLk1FVEhPRFNfSUNFID0gZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5TVEFUVVNFUyA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gRW11bXNcbmV4cG9ydHMuRVJST1IgPSB7XG4gICAgT0s6IDAsXG4gICAgSU5URVJOQUw6IDEsXG4gICAgU1RSSUNUOiAyLFxuICAgIENSX0VYUEVDVEVEOiAyNSxcbiAgICBMRl9FWFBFQ1RFRDogMyxcbiAgICBVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIOiA0LFxuICAgIFVORVhQRUNURURfU1BBQ0U6IDMwLFxuICAgIENMT1NFRF9DT05ORUNUSU9OOiA1LFxuICAgIElOVkFMSURfTUVUSE9EOiA2LFxuICAgIElOVkFMSURfVVJMOiA3LFxuICAgIElOVkFMSURfQ09OU1RBTlQ6IDgsXG4gICAgSU5WQUxJRF9WRVJTSU9OOiA5LFxuICAgIElOVkFMSURfSEVBREVSX1RPS0VOOiAxMCxcbiAgICBJTlZBTElEX0NPTlRFTlRfTEVOR1RIOiAxMSxcbiAgICBJTlZBTElEX0NIVU5LX1NJWkU6IDEyLFxuICAgIElOVkFMSURfU1RBVFVTOiAxMyxcbiAgICBJTlZBTElEX0VPRl9TVEFURTogMTQsXG4gICAgSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORzogMTUsXG4gICAgQ0JfTUVTU0FHRV9CRUdJTjogMTYsXG4gICAgQ0JfSEVBREVSU19DT01QTEVURTogMTcsXG4gICAgQ0JfTUVTU0FHRV9DT01QTEVURTogMTgsXG4gICAgQ0JfQ0hVTktfSEVBREVSOiAxOSxcbiAgICBDQl9DSFVOS19DT01QTEVURTogMjAsXG4gICAgUEFVU0VEOiAyMSxcbiAgICBQQVVTRURfVVBHUkFERTogMjIsXG4gICAgUEFVU0VEX0gyX1VQR1JBREU6IDIzLFxuICAgIFVTRVI6IDI0LFxuICAgIENCX1VSTF9DT01QTEVURTogMjYsXG4gICAgQ0JfU1RBVFVTX0NPTVBMRVRFOiAyNyxcbiAgICBDQl9NRVRIT0RfQ09NUExFVEU6IDMyLFxuICAgIENCX1ZFUlNJT05fQ09NUExFVEU6IDMzLFxuICAgIENCX0hFQURFUl9GSUVMRF9DT01QTEVURTogMjgsXG4gICAgQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFOiAyOSxcbiAgICBDQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURTogMzQsXG4gICAgQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFOiAzNSxcbiAgICBDQl9SRVNFVDogMzEsXG4gICAgQ0JfUFJPVE9DT0xfQ09NUExFVEU6IDM4LFxufTtcbmV4cG9ydHMuVFlQRSA9IHtcbiAgICBCT1RIOiAwLCAvLyBkZWZhdWx0XG4gICAgUkVRVUVTVDogMSxcbiAgICBSRVNQT05TRTogMixcbn07XG5leHBvcnRzLkZMQUdTID0ge1xuICAgIENPTk5FQ1RJT05fS0VFUF9BTElWRTogMSA8PCAwLFxuICAgIENPTk5FQ1RJT05fQ0xPU0U6IDEgPDwgMSxcbiAgICBDT05ORUNUSU9OX1VQR1JBREU6IDEgPDwgMixcbiAgICBDSFVOS0VEOiAxIDw8IDMsXG4gICAgVVBHUkFERTogMSA8PCA0LFxuICAgIENPTlRFTlRfTEVOR1RIOiAxIDw8IDUsXG4gICAgU0tJUEJPRFk6IDEgPDwgNixcbiAgICBUUkFJTElORzogMSA8PCA3LFxuICAgIC8vIDEgPDwgOCBpcyB1bnVzZWRcbiAgICBUUkFOU0ZFUl9FTkNPRElORzogMSA8PCA5LFxufTtcbmV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IHtcbiAgICBIRUFERVJTOiAxIDw8IDAsXG4gICAgQ0hVTktFRF9MRU5HVEg6IDEgPDwgMSxcbiAgICBLRUVQX0FMSVZFOiAxIDw8IDIsXG4gICAgVFJBTlNGRVJfRU5DT0RJTkc6IDEgPDwgMyxcbiAgICBWRVJTSU9OOiAxIDw8IDQsXG4gICAgREFUQV9BRlRFUl9DTE9TRTogMSA8PCA1LFxuICAgIE9QVElPTkFMX0xGX0FGVEVSX0NSOiAxIDw8IDYsXG4gICAgT1BUSU9OQUxfQ1JMRl9BRlRFUl9DSFVOSzogMSA8PCA3LFxuICAgIE9QVElPTkFMX0NSX0JFRk9SRV9MRjogMSA8PCA4LFxuICAgIFNQQUNFU19BRlRFUl9DSFVOS19TSVpFOiAxIDw8IDksXG59O1xuZXhwb3J0cy5NRVRIT0RTID0ge1xuICAgICdERUxFVEUnOiAwLFxuICAgICdHRVQnOiAxLFxuICAgICdIRUFEJzogMixcbiAgICAnUE9TVCc6IDMsXG4gICAgJ1BVVCc6IDQsXG4gICAgLyogcGF0aG9sb2dpY2FsICovXG4gICAgJ0NPTk5FQ1QnOiA1LFxuICAgICdPUFRJT05TJzogNixcbiAgICAnVFJBQ0UnOiA3LFxuICAgIC8qIFdlYkRBViAqL1xuICAgICdDT1BZJzogOCxcbiAgICAnTE9DSyc6IDksXG4gICAgJ01LQ09MJzogMTAsXG4gICAgJ01PVkUnOiAxMSxcbiAgICAnUFJPUEZJTkQnOiAxMixcbiAgICAnUFJPUFBBVENIJzogMTMsXG4gICAgJ1NFQVJDSCc6IDE0LFxuICAgICdVTkxPQ0snOiAxNSxcbiAgICAnQklORCc6IDE2LFxuICAgICdSRUJJTkQnOiAxNyxcbiAgICAnVU5CSU5EJzogMTgsXG4gICAgJ0FDTCc6IDE5LFxuICAgIC8qIHN1YnZlcnNpb24gKi9cbiAgICAnUkVQT1JUJzogMjAsXG4gICAgJ01LQUNUSVZJVFknOiAyMSxcbiAgICAnQ0hFQ0tPVVQnOiAyMixcbiAgICAnTUVSR0UnOiAyMyxcbiAgICAvKiB1cG5wICovXG4gICAgJ00tU0VBUkNIJzogMjQsXG4gICAgJ05PVElGWSc6IDI1LFxuICAgICdTVUJTQ1JJQkUnOiAyNixcbiAgICAnVU5TVUJTQ1JJQkUnOiAyNyxcbiAgICAvKiBSRkMtNTc4OSAqL1xuICAgICdQQVRDSCc6IDI4LFxuICAgICdQVVJHRSc6IDI5LFxuICAgIC8qIENhbERBViAqL1xuICAgICdNS0NBTEVOREFSJzogMzAsXG4gICAgLyogUkZDLTIwNjgsIHNlY3Rpb24gMTkuNi4xLjIgKi9cbiAgICAnTElOSyc6IDMxLFxuICAgICdVTkxJTksnOiAzMixcbiAgICAvKiBpY2VjYXN0ICovXG4gICAgJ1NPVVJDRSc6IDMzLFxuICAgIC8qIFJGQy03NTQwLCBzZWN0aW9uIDExLjYgKi9cbiAgICAnUFJJJzogMzQsXG4gICAgLyogUkZDLTIzMjYgUlRTUCAqL1xuICAgICdERVNDUklCRSc6IDM1LFxuICAgICdBTk5PVU5DRSc6IDM2LFxuICAgICdTRVRVUCc6IDM3LFxuICAgICdQTEFZJzogMzgsXG4gICAgJ1BBVVNFJzogMzksXG4gICAgJ1RFQVJET1dOJzogNDAsXG4gICAgJ0dFVF9QQVJBTUVURVInOiA0MSxcbiAgICAnU0VUX1BBUkFNRVRFUic6IDQyLFxuICAgICdSRURJUkVDVCc6IDQzLFxuICAgICdSRUNPUkQnOiA0NCxcbiAgICAvKiBSQU9QICovXG4gICAgJ0ZMVVNIJzogNDUsXG4gICAgLyogRFJBRlQgaHR0cHM6Ly93d3cuaWV0Zi5vcmcvYXJjaGl2ZS9pZC9kcmFmdC1pZXRmLWh0dHBiaXMtc2FmZS1tZXRob2Qtdy1ib2R5LTAyLmh0bWwgKi9cbiAgICAnUVVFUlknOiA0Nixcbn07XG5leHBvcnRzLlNUQVRVU0VTID0ge1xuICAgIENPTlRJTlVFOiAxMDAsXG4gICAgU1dJVENISU5HX1BST1RPQ09MUzogMTAxLFxuICAgIFBST0NFU1NJTkc6IDEwMixcbiAgICBFQVJMWV9ISU5UUzogMTAzLFxuICAgIFJFU1BPTlNFX0lTX1NUQUxFOiAxMTAsIC8vIFVub2ZmaWNpYWxcbiAgICBSRVZBTElEQVRJT05fRkFJTEVEOiAxMTEsIC8vIFVub2ZmaWNpYWxcbiAgICBESVNDT05ORUNURURfT1BFUkFUSU9OOiAxMTIsIC8vIFVub2ZmaWNpYWxcbiAgICBIRVVSSVNUSUNfRVhQSVJBVElPTjogMTEzLCAvLyBVbm9mZmljaWFsXG4gICAgTUlTQ0VMTEFORU9VU19XQVJOSU5HOiAxOTksIC8vIFVub2ZmaWNpYWxcbiAgICBPSzogMjAwLFxuICAgIENSRUFURUQ6IDIwMSxcbiAgICBBQ0NFUFRFRDogMjAyLFxuICAgIE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OOiAyMDMsXG4gICAgTk9fQ09OVEVOVDogMjA0LFxuICAgIFJFU0VUX0NPTlRFTlQ6IDIwNSxcbiAgICBQQVJUSUFMX0NPTlRFTlQ6IDIwNixcbiAgICBNVUxUSV9TVEFUVVM6IDIwNyxcbiAgICBBTFJFQURZX1JFUE9SVEVEOiAyMDgsXG4gICAgVFJBTlNGT1JNQVRJT05fQVBQTElFRDogMjE0LCAvLyBVbm9mZmljaWFsXG4gICAgSU1fVVNFRDogMjI2LFxuICAgIE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HOiAyOTksIC8vIFVub2ZmaWNpYWxcbiAgICBNVUxUSVBMRV9DSE9JQ0VTOiAzMDAsXG4gICAgTU9WRURfUEVSTUFORU5UTFk6IDMwMSxcbiAgICBGT1VORDogMzAyLFxuICAgIFNFRV9PVEhFUjogMzAzLFxuICAgIE5PVF9NT0RJRklFRDogMzA0LFxuICAgIFVTRV9QUk9YWTogMzA1LFxuICAgIFNXSVRDSF9QUk9YWTogMzA2LCAvLyBObyBsb25nZXIgdXNlZFxuICAgIFRFTVBPUkFSWV9SRURJUkVDVDogMzA3LFxuICAgIFBFUk1BTkVOVF9SRURJUkVDVDogMzA4LFxuICAgIEJBRF9SRVFVRVNUOiA0MDAsXG4gICAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gICAgUEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuICAgIEZPUkJJRERFTjogNDAzLFxuICAgIE5PVF9GT1VORDogNDA0LFxuICAgIE1FVEhPRF9OT1RfQUxMT1dFRDogNDA1LFxuICAgIE5PVF9BQ0NFUFRBQkxFOiA0MDYsXG4gICAgUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDQwNyxcbiAgICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgICBDT05GTElDVDogNDA5LFxuICAgIEdPTkU6IDQxMCxcbiAgICBMRU5HVEhfUkVRVUlSRUQ6IDQxMSxcbiAgICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gICAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgICBVUklfVE9PX0xPTkc6IDQxNCxcbiAgICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG4gICAgUkFOR0VfTk9UX1NBVElTRklBQkxFOiA0MTYsXG4gICAgRVhQRUNUQVRJT05fRkFJTEVEOiA0MTcsXG4gICAgSU1fQV9URUFQT1Q6IDQxOCxcbiAgICBQQUdFX0VYUElSRUQ6IDQxOSwgLy8gVW5vZmZpY2lhbFxuICAgIEVOSEFOQ0VfWU9VUl9DQUxNOiA0MjAsIC8vIFVub2ZmaWNpYWxcbiAgICBNSVNESVJFQ1RFRF9SRVFVRVNUOiA0MjEsXG4gICAgVU5QUk9DRVNTQUJMRV9FTlRJVFk6IDQyMixcbiAgICBMT0NLRUQ6IDQyMyxcbiAgICBGQUlMRURfREVQRU5ERU5DWTogNDI0LFxuICAgIFRPT19FQVJMWTogNDI1LFxuICAgIFVQR1JBREVfUkVRVUlSRUQ6IDQyNixcbiAgICBQUkVDT05ESVRJT05fUkVRVUlSRUQ6IDQyOCxcbiAgICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICAgIFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTDogNDMwLCAvLyBVbm9mZmljaWFsXG4gICAgUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRTogNDMxLFxuICAgIExPR0lOX1RJTUVPVVQ6IDQ0MCwgLy8gVW5vZmZpY2lhbFxuICAgIE5PX1JFU1BPTlNFOiA0NDQsIC8vIFVub2ZmaWNpYWxcbiAgICBSRVRSWV9XSVRIOiA0NDksIC8vIFVub2ZmaWNpYWxcbiAgICBCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0w6IDQ1MCwgLy8gVW5vZmZpY2lhbFxuICAgIFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TOiA0NTEsXG4gICAgQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1Q6IDQ2MCwgLy8gVW5vZmZpY2lhbFxuICAgIElOVkFMSURfWF9GT1JXQVJERURfRk9SOiA0NjMsIC8vIFVub2ZmaWNpYWxcbiAgICBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0U6IDQ5NCwgLy8gVW5vZmZpY2lhbFxuICAgIFNTTF9DRVJUSUZJQ0FURV9FUlJPUjogNDk1LCAvLyBVbm9mZmljaWFsXG4gICAgU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEOiA0OTYsIC8vIFVub2ZmaWNpYWxcbiAgICBIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUOiA0OTcsIC8vIFVub2ZmaWNpYWxcbiAgICBJTlZBTElEX1RPS0VOOiA0OTgsIC8vIFVub2ZmaWNpYWxcbiAgICBDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IDQ5OSwgLy8gVW5vZmZpY2lhbFxuICAgIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICAgIE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuICAgIEJBRF9HQVRFV0FZOiA1MDIsXG4gICAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICAgIEdBVEVXQVlfVElNRU9VVDogNTA0LFxuICAgIEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEOiA1MDUsXG4gICAgVkFSSUFOVF9BTFNPX05FR09USUFURVM6IDUwNixcbiAgICBJTlNVRkZJQ0lFTlRfU1RPUkFHRTogNTA3LFxuICAgIExPT1BfREVURUNURUQ6IDUwOCxcbiAgICBCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQ6IDUwOSxcbiAgICBOT1RfRVhURU5ERUQ6IDUxMCxcbiAgICBORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA1MTEsXG4gICAgV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SOiA1MjAsIC8vIFVub2ZmaWNpYWxcbiAgICBXRUJfU0VSVkVSX0lTX0RPV046IDUyMSwgLy8gVW5vZmZpY2lhbFxuICAgIENPTk5FQ1RJT05fVElNRU9VVDogNTIyLCAvLyBVbm9mZmljaWFsXG4gICAgT1JJR0lOX0lTX1VOUkVBQ0hBQkxFOiA1MjMsIC8vIFVub2ZmaWNpYWxcbiAgICBUSU1FT1VUX09DQ1VSRUQ6IDUyNCwgLy8gVW5vZmZpY2lhbFxuICAgIFNTTF9IQU5EU0hBS0VfRkFJTEVEOiA1MjUsIC8vIFVub2ZmaWNpYWxcbiAgICBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURTogNTI2LCAvLyBVbm9mZmljaWFsXG4gICAgUkFJTEdVTl9FUlJPUjogNTI3LCAvLyBVbm9mZmljaWFsXG4gICAgU0lURV9JU19PVkVSTE9BREVEOiA1MjksIC8vIFVub2ZmaWNpYWxcbiAgICBTSVRFX0lTX0ZST1pFTjogNTMwLCAvLyBVbm9mZmljaWFsXG4gICAgSURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1I6IDU2MSwgLy8gVW5vZmZpY2lhbFxuICAgIE5FVFdPUktfUkVBRF9USU1FT1VUOiA1OTgsIC8vIFVub2ZmaWNpYWxcbiAgICBORVRXT1JLX0NPTk5FQ1RfVElNRU9VVDogNTk5LCAvLyBVbm9mZmljaWFsXG59O1xuZXhwb3J0cy5GSU5JU0ggPSB7XG4gICAgU0FGRTogMCxcbiAgICBTQUZFX1dJVEhfQ0I6IDEsXG4gICAgVU5TQUZFOiAyLFxufTtcbmV4cG9ydHMuSEVBREVSX1NUQVRFID0ge1xuICAgIEdFTkVSQUw6IDAsXG4gICAgQ09OTkVDVElPTjogMSxcbiAgICBDT05URU5UX0xFTkdUSDogMixcbiAgICBUUkFOU0ZFUl9FTkNPRElORzogMyxcbiAgICBVUEdSQURFOiA0LFxuICAgIENPTk5FQ1RJT05fS0VFUF9BTElWRTogNSxcbiAgICBDT05ORUNUSU9OX0NMT1NFOiA2LFxuICAgIENPTk5FQ1RJT05fVVBHUkFERTogNyxcbiAgICBUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEOiA4LFxufTtcbi8vIEMgaGVhZGVyc1xuZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBbXG4gICAgZXhwb3J0cy5NRVRIT0RTLkRFTEVURSxcbiAgICBleHBvcnRzLk1FVEhPRFMuR0VULFxuICAgIGV4cG9ydHMuTUVUSE9EUy5IRUFELFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QT1NULFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QVVQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkNPTk5FQ1QsXG4gICAgZXhwb3J0cy5NRVRIT0RTLk9QVElPTlMsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlRSQUNFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5DT1BZLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5MT0NLLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5NS0NPTCxcbiAgICBleHBvcnRzLk1FVEhPRFMuTU9WRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuUFJPUEZJTkQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBST1BQQVRDSCxcbiAgICBleHBvcnRzLk1FVEhPRFMuU0VBUkNILFxuICAgIGV4cG9ydHMuTUVUSE9EUy5VTkxPQ0ssXG4gICAgZXhwb3J0cy5NRVRIT0RTLkJJTkQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlJFQklORCxcbiAgICBleHBvcnRzLk1FVEhPRFMuVU5CSU5ELFxuICAgIGV4cG9ydHMuTUVUSE9EUy5BQ0wsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlJFUE9SVCxcbiAgICBleHBvcnRzLk1FVEhPRFMuTUtBQ1RJVklUWSxcbiAgICBleHBvcnRzLk1FVEhPRFMuQ0hFQ0tPVVQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLk1FUkdFLFxuICAgIGV4cG9ydHMuTUVUSE9EU1snTS1TRUFSQ0gnXSxcbiAgICBleHBvcnRzLk1FVEhPRFMuTk9USUZZLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5TVUJTQ1JJQkUsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlVOU1VCU0NSSUJFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QQVRDSCxcbiAgICBleHBvcnRzLk1FVEhPRFMuUFVSR0UsXG4gICAgZXhwb3J0cy5NRVRIT0RTLk1LQ0FMRU5EQVIsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkxJTkssXG4gICAgZXhwb3J0cy5NRVRIT0RTLlVOTElOSyxcbiAgICBleHBvcnRzLk1FVEhPRFMuUFJJLFxuICAgIC8vIFRPRE8oaW5kdXRueSk6IHNob3VsZCB3ZSBhbGxvdyBpdCB3aXRoIEhUVFA/XG4gICAgZXhwb3J0cy5NRVRIT0RTLlNPVVJDRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuUVVFUlksXG5dO1xuZXhwb3J0cy5NRVRIT0RTX0lDRSA9IFtcbiAgICBleHBvcnRzLk1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgIGV4cG9ydHMuTUVUSE9EUy5PUFRJT05TLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5ERVNDUklCRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlNFVFVQLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QTEFZLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QQVVTRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuVEVBUkRPV04sXG4gICAgZXhwb3J0cy5NRVRIT0RTLkdFVF9QQVJBTUVURVIsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlJFRElSRUNULFxuICAgIGV4cG9ydHMuTUVUSE9EUy5SRUNPUkQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkZMVVNILFxuICAgIC8vIEZvciBBaXJQbGF5XG4gICAgZXhwb3J0cy5NRVRIT0RTLkdFVCxcbiAgICBleHBvcnRzLk1FVEhPRFMuUE9TVCxcbl07XG5leHBvcnRzLk1FVEhPRF9NQVAgPSAoMCwgdXRpbHNfMS5lbnVtVG9NYXApKGV4cG9ydHMuTUVUSE9EUyk7XG5leHBvcnRzLkhfTUVUSE9EX01BUCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhleHBvcnRzLk1FVEhPRFMpLmZpbHRlcigoW2tdKSA9PiBrLnN0YXJ0c1dpdGgoJ0gnKSkpO1xuZXhwb3J0cy5TVEFUVVNFU19IVFRQID0gW1xuICAgIGV4cG9ydHMuU1RBVFVTRVMuQ09OVElOVUUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TV0lUQ0hJTkdfUFJPVE9DT0xTLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUFJPQ0VTU0lORyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkVBUkxZX0hJTlRTLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkVTUE9OU0VfSVNfU1RBTEUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVZBTElEQVRJT05fRkFJTEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuRElTQ09OTkVDVEVEX09QRVJBVElPTixcbiAgICBleHBvcnRzLlNUQVRVU0VTLkhFVVJJU1RJQ19FWFBJUkFUSU9OLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTUlTQ0VMTEFORU9VU19XQVJOSU5HLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuT0ssXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5DUkVBVEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQUNDRVBURUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5OT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTixcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PX0NPTlRFTlQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVNFVF9DT05URU5ULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUEFSVElBTF9DT05URU5ULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTVVMVElfU1RBVFVTLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQUxSRUFEWV9SRVBPUlRFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlRSQU5TRk9STUFUSU9OX0FQUExJRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTV9VU0VELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5NVUxUSVBMRV9DSE9JQ0VTLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTU9WRURfUEVSTUFORU5UTFksXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5GT1VORCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNFRV9PVEhFUixcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PVF9NT0RJRklFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlVTRV9QUk9YWSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNXSVRDSF9QUk9YWSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlRFTVBPUkFSWV9SRURJUkVDVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlBFUk1BTkVOVF9SRURJUkVDVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkJBRF9SRVFVRVNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVU5BVVRIT1JJWkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUEFZTUVOVF9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkZPUkJJRERFTixcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PVF9GT1VORCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk1FVEhPRF9OT1RfQUxMT1dFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PVF9BQ0NFUFRBQkxFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVFVRVNUX1RJTUVPVVQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5DT05GTElDVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkdPTkUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5MRU5HVEhfUkVRVUlSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QUkVDT05ESVRJT05fRkFJTEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUEFZTE9BRF9UT09fTEFSR0UsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VUklfVE9PX0xPTkcsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VTlNVUFBPUlRFRF9NRURJQV9UWVBFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkFOR0VfTk9UX1NBVElTRklBQkxFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuRVhQRUNUQVRJT05fRkFJTEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSU1fQV9URUFQT1QsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QQUdFX0VYUElSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5FTkhBTkNFX1lPVVJfQ0FMTSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk1JU0RJUkVDVEVEX1JFUVVFU1QsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VTlBST0NFU1NBQkxFX0VOVElUWSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkxPQ0tFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkZBSUxFRF9ERVBFTkRFTkNZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVE9PX0VBUkxZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVVBHUkFERV9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlBSRUNPTkRJVElPTl9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlRPT19NQU5ZX1JFUVVFU1RTLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkxPR0lOX1RJTUVPVVQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5OT19SRVNQT05TRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJFVFJZX1dJVEgsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5CTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkNMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVFVRVNUX0hFQURFUl9UT09fTEFSR0UsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TU0xfQ0VSVElGSUNBVEVfRVJST1IsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5IVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSU5WQUxJRF9UT0tFTixcbiAgICBleHBvcnRzLlNUQVRVU0VTLkNMSUVOVF9DTE9TRURfUkVRVUVTVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLklOVEVSTkFMX1NFUlZFUl9FUlJPUixcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PVF9JTVBMRU1FTlRFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkJBRF9HQVRFV0FZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuU0VSVklDRV9VTkFWQUlMQUJMRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkdBVEVXQVlfVElNRU9VVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVkFSSUFOVF9BTFNPX05FR09USUFURVMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTlNVRkZJQ0lFTlRfU1RPUkFHRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkxPT1BfREVURUNURUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5CQU5EV0lEVEhfTElNSVRfRVhDRUVERUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5OT1RfRVhURU5ERUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5ORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuV0VCX1NFUlZFUl9JU19ET1dOLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQ09OTkVDVElPTl9USU1FT1VULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuT1JJR0lOX0lTX1VOUkVBQ0hBQkxFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVElNRU9VVF9PQ0NVUkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuU1NMX0hBTkRTSEFLRV9GQUlMRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTlZBTElEX1NTTF9DRVJUSUZJQ0FURSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJBSUxHVU5fRVJST1IsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TSVRFX0lTX09WRVJMT0FERUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TSVRFX0lTX0ZST1pFTixcbiAgICBleHBvcnRzLlNUQVRVU0VTLklERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTkVUV09SS19SRUFEX1RJTUVPVVQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5ORVRXT1JLX0NPTk5FQ1RfVElNRU9VVCxcbl07XG5leHBvcnRzLkFMUEhBID0gW107XG5mb3IgKGxldCBpID0gJ0EnLmNoYXJDb2RlQXQoMCk7IGkgPD0gJ1onLmNoYXJDb2RlQXQoMCk7IGkrKykge1xuICAgIC8vIFVwcGVyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG4gICAgLy8gTG93ZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAweDIwKSk7XG59XG5leHBvcnRzLk5VTV9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxufTtcbmV4cG9ydHMuSEVYX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG4gICAgQTogMFhBLCBCOiAwWEIsIEM6IDBYQywgRDogMFhELCBFOiAwWEUsIEY6IDBYRixcbiAgICBhOiAweGEsIGI6IDB4YiwgYzogMHhjLCBkOiAweGQsIGU6IDB4ZSwgZjogMHhmLFxufTtcbmV4cG9ydHMuTlVNID0gW1xuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcbl07XG5leHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5BTFBIQS5jb25jYXQoZXhwb3J0cy5OVU0pO1xuZXhwb3J0cy5NQVJLID0gWyctJywgJ18nLCAnLicsICchJywgJ34nLCAnKicsICdcXCcnLCAnKCcsICcpJ107XG5leHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5BTFBIQU5VTVxuICAgIC5jb25jYXQoZXhwb3J0cy5NQVJLKVxuICAgIC5jb25jYXQoWyclJywgJzsnLCAnOicsICcmJywgJz0nLCAnKycsICckJywgJywnXSk7XG4vLyBUT0RPKGluZHV0bnkpOiB1c2UgUkZDXG5leHBvcnRzLlVSTF9DSEFSID0gW1xuICAgICchJywgJ1wiJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJygnLCAnKScsICcqJywgJysnLCAnLCcsICctJywgJy4nLCAnLycsXG4gICAgJzonLCAnOycsICc8JywgJz0nLCAnPicsXG4gICAgJ0AnLCAnWycsICdcXFxcJywgJ10nLCAnXicsICdfJyxcbiAgICAnYCcsXG4gICAgJ3snLCAnfCcsICd9JywgJ34nLFxuXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG5leHBvcnRzLkhFWCA9IGV4cG9ydHMuTlVNLmNvbmNhdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJ10pO1xuLyogVG9rZW5zIGFzIGRlZmluZWQgYnkgcmZjIDI2MTYuIEFsc28gbG93ZXJjYXNlcyB0aGVtLlxuICogICAgICAgIHRva2VuICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiAqICAgICBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKi9cbmV4cG9ydHMuVE9LRU4gPSBbXG4gICAgJyEnLCAnIycsICckJywgJyUnLCAnJicsICdcXCcnLFxuICAgICcqJywgJysnLCAnLScsICcuJyxcbiAgICAnXicsICdfJywgJ2AnLFxuICAgICd8JywgJ34nLFxuXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG4vKlxuICogVmVyaWZ5IHRoYXQgYSBjaGFyIGlzIGEgdmFsaWQgdmlzaWJsZSAocHJpbnRhYmxlKSBVUy1BU0NJSVxuICogY2hhcmFjdGVyIG9yICV4ODAtRkZcbiAqL1xuZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBbJ1xcdCddO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDEyNykge1xuICAgICAgICBleHBvcnRzLkhFQURFUl9DSEFSUy5wdXNoKGkpO1xuICAgIH1cbn1cbi8vICcsJyA9IFxceDQ0XG5leHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUy5maWx0ZXIoKGMpID0+IGMgIT09IDQ0KTtcbmV4cG9ydHMuUVVPVEVEX1NUUklORyA9IFsnXFx0JywgJyAnXTtcbmZvciAobGV0IGkgPSAweDIxOyBpIDw9IDB4ZmY7IGkrKykge1xuICAgIGlmIChpICE9PSAweDIyICYmIGkgIT09IDB4NWMpIHsgLy8gQWxsIGNoYXJhY3RlcnMgaW4gQVNDSUkgZXhjZXB0IFxcIGFuZCBcIlxuICAgICAgICBleHBvcnRzLlFVT1RFRF9TVFJJTkcucHVzaChpKTtcbiAgICB9XG59XG5leHBvcnRzLkhUQUJfU1BfVkNIQVJfT0JTX1RFWFQgPSBbJ1xcdCcsICcgJ107XG4vLyBWQ0hBUjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUyMzQjYXBwZW5kaXgtQi4xXG5mb3IgKGxldCBpID0gMHgyMTsgaSA8PSAweDdFOyBpKyspIHtcbiAgICBleHBvcnRzLkhUQUJfU1BfVkNIQVJfT0JTX1RFWFQucHVzaChpKTtcbn1cbi8vIE9CU19URVhUOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzkxMTAjbmFtZS1jb2xsZWN0ZWQtYWJuZlxuZm9yIChsZXQgaSA9IDB4ODA7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgZXhwb3J0cy5IVEFCX1NQX1ZDSEFSX09CU19URVhULnB1c2goaSk7XG59XG5leHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IHtcbiAgICAnY29ubmVjdGlvbic6IGV4cG9ydHMuSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJzogZXhwb3J0cy5IRUFERVJfU1RBVEUuQ09OVEVOVF9MRU5HVEgsXG4gICAgJ3Byb3h5LWNvbm5lY3Rpb24nOiBleHBvcnRzLkhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IGV4cG9ydHMuSEVBREVSX1NUQVRFLlRSQU5TRkVSX0VOQ09ESU5HLFxuICAgICd1cGdyYWRlJzogZXhwb3J0cy5IRUFERVJfU1RBVEUuVVBHUkFERSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgRVJST1I6IGV4cG9ydHMuRVJST1IsXG4gICAgVFlQRTogZXhwb3J0cy5UWVBFLFxuICAgIEZMQUdTOiBleHBvcnRzLkZMQUdTLFxuICAgIExFTklFTlRfRkxBR1M6IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyxcbiAgICBNRVRIT0RTOiBleHBvcnRzLk1FVEhPRFMsXG4gICAgU1RBVFVTRVM6IGV4cG9ydHMuU1RBVFVTRVMsXG4gICAgRklOSVNIOiBleHBvcnRzLkZJTklTSCxcbiAgICBIRUFERVJfU1RBVEU6IGV4cG9ydHMuSEVBREVSX1NUQVRFLFxuICAgIEFMUEhBOiBleHBvcnRzLkFMUEhBLFxuICAgIE5VTV9NQVA6IGV4cG9ydHMuTlVNX01BUCxcbiAgICBIRVhfTUFQOiBleHBvcnRzLkhFWF9NQVAsXG4gICAgTlVNOiBleHBvcnRzLk5VTSxcbiAgICBBTFBIQU5VTTogZXhwb3J0cy5BTFBIQU5VTSxcbiAgICBNQVJLOiBleHBvcnRzLk1BUkssXG4gICAgVVNFUklORk9fQ0hBUlM6IGV4cG9ydHMuVVNFUklORk9fQ0hBUlMsXG4gICAgVVJMX0NIQVI6IGV4cG9ydHMuVVJMX0NIQVIsXG4gICAgSEVYOiBleHBvcnRzLkhFWCxcbiAgICBUT0tFTjogZXhwb3J0cy5UT0tFTixcbiAgICBIRUFERVJfQ0hBUlM6IGV4cG9ydHMuSEVBREVSX0NIQVJTLFxuICAgIENPTk5FQ1RJT05fVE9LRU5fQ0hBUlM6IGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyxcbiAgICBRVU9URURfU1RSSU5HOiBleHBvcnRzLlFVT1RFRF9TVFJJTkcsXG4gICAgSFRBQl9TUF9WQ0hBUl9PQlNfVEVYVDogZXhwb3J0cy5IVEFCX1NQX1ZDSEFSX09CU19URVhULFxuICAgIE1BSk9SOiBleHBvcnRzLk1BSk9SLFxuICAgIE1JTk9SOiBleHBvcnRzLk1JTk9SLFxuICAgIFNQRUNJQUxfSEVBREVSUzogZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMsXG4gICAgTUVUSE9EU19IVFRQOiBleHBvcnRzLk1FVEhPRFNfSFRUUCxcbiAgICBNRVRIT0RTX0lDRTogZXhwb3J0cy5NRVRIT0RTX0lDRSxcbiAgICBNRVRIT0RTX1JUU1A6IGV4cG9ydHMuTUVUSE9EU19SVFNQLFxuICAgIE1FVEhPRF9NQVA6IGV4cG9ydHMuTUVUSE9EX01BUCxcbiAgICBIX01FVEhPRF9NQVA6IGV4cG9ydHMuSF9NRVRIT0RfTUFQLFxuICAgIFNUQVRVU0VTX0hUVFA6IGV4cG9ydHMuU1RBVFVTRVNfSFRUUCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst wasmBase64 = 'AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRw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AXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgL5YUCAgd/A34gASACaiEEAkAgACIDKAIMIgANACADKAIEBEAgAyABNgIECyMAQRBrIgkkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQJrDvwBAfkBAgMEBQYHCAkKCwwNDg8QERL4ARP3ARQV9gEWF/UBGBkaGxwdHh8g/QH7ASH0ASIjJCUmJygpKivzASwtLi8wMTLyAfEBMzTwAe8BNTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5P+gFQUVJT7gHtAVTsAVXrAVZXWFla6gFbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHpAegBzwHnAdAB5gHRAdIB0wHUAeUB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMBAPwBC0EADOMBC0EODOIBC0ENDOEBC0EPDOABC0EQDN8BC0ETDN4BC0EUDN0BC0EVDNwBC0EWDNsBC0EXDNoBC0EYDNkBC0EZDNgBC0EaDNcBC0EbDNYBC0EcDNUBC0EdDNQBC0EeDNMBC0EfDNIBC0EgDNEBC0EhDNABC0EIDM8BC0EiDM4BC0EkDM0BC0EjDMwBC0EHDMsBC0ElDMoBC0EmDMkBC0EnDMgBC0EoDMcBC0ESDMYBC0ERDMUBC0EpDMQBC0EqDMMBC0ErDMIBC0EsDMEBC0HeAQzAAQtBLgy/AQtBLwy+AQtBMAy9AQtBMQy8AQtBMgy7AQtBMwy6AQtBNAy5AQtB3wEMuAELQTUMtwELQTkMtgELQQwMtQELQTYMtAELQTcMswELQTgMsgELQT4MsQELQToMsAELQeABDK8BC0ELDK4BC0E/DK0BC0E7DKwBC0EKDKsBC0E8DKoBC0E9DKkBC0HhAQyoAQtBwQAMpwELQcAADKYBC0HCAAylAQtBCQykAQtBLQyjAQtBwwAMogELQcQADKEBC0HFAAygAQtBxgAMnwELQccADJ4BC0HIAAydAQtByQAMnAELQcoADJsBC0HLAAyaAQtBzAAMmQELQc0ADJgBC0HOAAyXAQtBzwAMlgELQdAADJUBC0HRAAyUAQtB0gAMkwELQdMADJIBC0HVAAyRAQtB1AAMkAELQdYADI8BC0HXAAyOAQtB2AAMjQELQdkADIwBC0HaAAyLAQtB2wAMigELQdwADIkBC0HdAAyIAQtB3gAMhwELQd8ADIYBC0HgAAyFAQtB4QAMhAELQeIADIMBC0HjAAyCAQtB5AAMgQELQeUADIABC0HiAQx/C0HmAAx+C0HnAAx9C0EGDHwLQegADHsLQQUMegtB6QAMeQtBBAx4C0HqAAx3C0HrAAx2C0HsAAx1C0HtAAx0C0EDDHMLQe4ADHILQe8ADHELQfAADHALQfIADG8LQfEADG4LQfMADG0LQfQADGwLQfUADGsLQfYADGoLQQIMaQtB9wAMaAtB+AAMZwtB+QAMZgtB+gAMZQtB+wAMZAtB/AAMYwtB/QAMYgtB/gAMYQtB/wAMYAtBgAEMXwtBgQEMXgtBggEMXQtBgwEMXAtBhAEMWwtBhQEMWgtBhgEMWQtBhwEMWAtBiAEMVwtBiQEMVgtBigEMVQtBiwEMVAtBjAEMUwtBjQEMUgtBjgEMUQtBjwEMUAtBkAEMTwtBkQEMTgtBkgEMTQtBkwEMTAtBlAEMSwtBlQEMSgtBlgEMSQtBlwEMSAtBmAEMRwtBmQEMRgtBmgEMRQtBmwEMRAtBnAEMQwtBnQEMQgtBngEMQQtBnwEMQAtBoAEMPwtBoQEMPgtBogEMPQtBowEMPAtBpAEMOwtBpQEMOgtBpgEMOQtBpwEMOAtBqAEMNwtBqQEMNgtBqgEMNQtBqwEMNAtBrAEMMwtBrQEMMgtBrgEMMQtBrwEMMAtBsAEMLwtBsQEMLgtBsgEMLQtBswEMLAtBtAEMKwtBtQEMKgtBtgEMKQtBtwEMKAtBuAEMJwtBuQEMJgtBugEMJQtBuwEMJAtBvAEMIwtBvQEMIgtBvgEMIQtBvwEMIAtBwAEMHwtBwQEMHgtBwgEMHQtBAQwcC0HDAQwbC0HEAQwaC0HFAQwZC0HGAQwYC0HHAQwXC0HIAQwWC0HJAQwVC0HKAQwUC0HLAQwTC0HMAQwSC0HNAQwRC0HOAQwQC0HPAQwPC0HQAQwOC0HRAQwNC0HSAQwMC0HTAQwLC0HUAQwKC0HVAQwJC0HWAQwIC0HjAQwHC0HXAQwGC0HYAQwFC0HZAQwEC0HaAQwDC0HbAQwCC0HdAQwBC0HcAQshAgNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg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ogKiAqICogKiAqICogKiAqICogKiAqICogIAogILIAQgAUEBaiIBRw0AC0HJACECDOwCCyABQQFqIQEgA0Evai0AAEEBcQ2lAiADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMQQAhAgzrAgsgASAERwRAA0AgAS0AAEEgRw0VIAQgAUEBaiIBRw0AC0H4ACECDOsCC0H4ACECDOoCCyADQQI6ACgMOAtBACECIANBADYCHCADQb8LNgIQIANBAjYCDCADIAFBAWo2AhQM6AILQQAhAgzOAgtBDSECDM0CC0ETIQIMzAILQRUhAgzLAgtBFiECDMoCC0EYIQIMyQILQRkhAgzIAgtBGiECDMcCC0EbIQIMxgILQRwhAgzFAgtBHSECDMQCC0EeIQIMwwILQR8hAgzCAgtBICECDMECC0EiIQIMwAILQSMhAgy/AgtBJSECDL4CC0HlACECDL0CCyADQT02AhwgAyABNgIUIAMgADYCDEEAIQIM1QILIANBGzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDNQCCyADQSA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzTAgsgA0ETNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0gILIANBCzYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNECCyADQRA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzQAgsgA0EgNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzwILIANBCzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM4CCyADQQw2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzNAgtBACECIANBADYCHCADIAE2AhQgA0HdDjYCECADQRI2AgwMzAILAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB/QEhAgzMAgsCQAJAIAMtADZBAUcNAEEAIQACQCADKAI4IgJFDQAgAigCYCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUcNASADQfwBNgIcIAMgATYCFCADQdwZNgIQIANBFTYCDEEAIQIMzQILQdwBIQIMswILIANBADYCHCADIAE2AhQgA0H5CzYCECADQR82AgxBACECDMsCCwJAAkAgAy0AKEEBaw4CBAEAC0HbASECDLICC0HUASECDLECCyADQQI6ADFBACEAAkAgAygCOCICRQ0AIAIoAgAiAkUNACADIAIRAAAhAAsgAEUEQEHdASECDLECCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQbQMNgIQIANBEDYCDEEAIQIMygILIANB+wE2AhwgAyABNgIUIANBgRo2AhAgA0EVNgIMQQAhAgzJAgsgASAERgRAQfoBIQIMyQILIAEtAABByABGDQEgA0EBOgAoC0HAASECDK4CC0HaASECDK0CCyABIARHBEAgA0EMNgIIIAMgATYCBEHZASECDK0CC0H5ASECDMUCCyABIARGBEBB+AEhAgzFAgsgAS0AAEHIAEcNBCABQQFqIQFB2AEhAgyrAgsgASAERgRAQfcBIQIMxAILAkACQCABLQAAQcUAaw4QAAUFBQUFBQUFBQUFBQUFAQULIAFBAWohAUHWASECDKsCCyABQQFqIQFB1wEhAgyqAgtB9gEhAiABIARGDcICIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbrVAGotAABHDQMgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMMCCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIARQRAQeMBIQIMqgILIANB9QE2AhwgAyABNgIUIAMgADYCDEEAIQIMwgILQfQBIQIgASAERg3BAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEG41QBqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzCAgsgA0GBBDsBKCADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIADQMMAgsgA0EANgIAC0EAIQIgA0EANgIcIAMgATYCFCADQeUfNgIQIANBCDYCDAy/AgtB1QEhAgylAgsgA0HzATYCHCADIAE2AhQgAyAANgIMQQAhAgy9AgtBACEAAkAgAygCOCICRQ0AIAIoAkAiAkUNACADIAIRAAAhAAsgAEUNbiAAQRVHBEAgA0EANgIcIAMgATYCFCADQYIPNgIQIANBIDYCDEEAIQIMvQILIANBjwE2AhwgAyABNgIUIANB7Bs2AhAgA0EVNgIMQQAhAgy8AgsgASAERwRAIANBDTYCCCADIAE2AgRB0wEhAgyjAgtB8gEhAgy7AgsgASAERgRAQfEBIQIMuwILAkACQAJAIAEtAABByABrDgsAAQgICAgICAgIAggLIAFBAWohAUHQASECDKMCCyABQQFqIQFB0QEhAgyiAgsgAUEBaiEBQdIBIQIMoQILQfABIQIgASAERg25AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBtdUAai0AAEcNBCAAQQJGDQMgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuQILQe8BIQIgASAERg24AiADKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABBs9UAai0AAEcNAyAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuAILQe4BIQIgASAERg23AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMtwILIAMoAgQhACADQgA3AwAgAyAAIAVBAWoiARArIgBFDQIgA0HsATYCHCADIAE2AhQgAyAANgIMQQAhAgy2AgsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNnAIgA0HtATYCHCADIAE2AhQgAyAANgIMQQAhAgy0AgtBzwEhAgyaAgtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDLQCC0HOASECDJoCCyADQesBNgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMsgILIAEgBEYEQEHrASECDLICCyABLQAAQS9GBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GyODYCECADQQg2AgxBACECDLECC0HNASECDJcCCyABIARHBEAgA0EONgIIIAMgATYCBEHMASECDJcCC0HqASECDK8CCyABIARGBEBB6QEhAgyvAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBywEhAgyWAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZcCIANB6AE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAEgBEYEQEHnASECDK4CCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5gE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILQcoBIQIMlAILIAEgBEYEQEHlASECDK0CC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDQIgA0HiATYCHCADIAE2AhQgAyAANgIMQQAhAgyvAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZoCIANB4wE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ2YAiADQeQBNgIcIAMgATYCFCADIAA2AgwMrQILQckBIQIMkwILQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBpA02AhAgA0EhNgIMQQAhAgytAgtByAEhAgyTAgsgA0HhATYCHCADIAE2AhQgA0HQGjYCECADQRU2AgxBACECDKsCCyABIARGBEBB4QEhAgyrAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANBmRE2AhAgA0EJNgIMQQAhAgyrAgtBxwEhAgyRAgsgASAERgRAQeABIQIMqgILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyrAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqgILQcYBIQIMkAILIAEgBEYEQEHfASECDKkCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqgILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKkCC0HFASECDI8CCyABIARGBEBB3gEhAgyoAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKkCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyoAgtBxAEhAgyOAgsgASAERgRAQd0BIQIMpwILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUHDASECDI8CCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKcCCyADQQA2AhwgAyABNgIUIANBjQs2AhAgA0ENNgIMQQAhAgymAgsgASAERwRAIANBDzYCCCADIAE2AgRBASECDI0CC0HcASECDKUCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB2wEhAgymAgsgAygCBCEAIANBADYCBCADIAAgARAtIgBFBEAgAUEBaiEBDAQLIANB2gE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMpQILIAMoAgQhACADQQA2AgQgAyAAIAEQLSIADQEgAUEBagshAUHBASECDIoCCyADQdkBNgIcIAMgADYCDCADIAFBAWo2AhRBACECDKICC0HCASECDIgCCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQeQcNgIQIANBGTYCDEEAIQIMoAILIAEgBEYEQEHZASEC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IAFBAWohAUGeASECDOQBCyABQQFqIQFBnwEhAgzjAQtBtwEhAiABIARGDfsBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQezUAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPwBCyADQQA2AgAgBkEBaiEBQQ0MKAtBtgEhAiABIARGDfoBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPsBCyADQQA2AgAgBkEBaiEBQQwMJwtBtQEhAiABIARGDfkBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQerUAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPoBCyADQQA2AgAgBkEBaiEBQQMMJgtBtAEhAiABIARGDfgBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQejUAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPkBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQbMBIQIM+AELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBmQEhAgzfAQsgAUEBaiEBQZoBIQIM3gELQbIBIQIgASAERg32ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm1ABqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz3AQsgA0EANgIAIAZBAWohAUEnDCMLQbEBIQIgASAERg31ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk1ABqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz2AQsgA0EANgIAIAZBAWohAUEcDCILQbABIQIgASAERg30ASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHe1ABqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz1AQsgA0EANgIAIAZBAWohAUEGDCELQa8BIQIgASAERg3zASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHZ1ABqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz0AQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGuASECDPMBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQY4BIQIM3AELIAFBAWohAUGPASECDNsBCyABQQFqIQFBlAEhAgzaAQsgAUEBaiEBQZUBIQIM2QELQa0BIQIgASAERg3xASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHX1ABqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzyAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGsASECDPEBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGQASECDNgBCyABQQFqIQFBkwEhAgzXAQsgASAERgRAQasBIQIM8AELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQZEBIQIM1wELIAFBAWohAUGSASECDNYBCyABIARGBEBBqgEhAgzvAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GpASECIAEgBEYN7QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB0dQAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7gELIANBADYCACAGQQFqIQFBHgwaC0GoASECIAEgBEYN7AEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBytQAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7QELIANBADYCACAGQQFqIQFBFQwZC0GnASECIAEgBEYN6wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBx9QAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7AELIANBADYCACAGQQFqIQFBFwwYC0GmASECIAEgBEYN6gEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBwdQAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6wELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBpQEhAgzqAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYsBIQIM0QELIAFBAWohAUGMASECDNABC0GkASECIAEgBEYN6AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBptUAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6QELIANBADYCACAGQQFqIQFBCQwVC0GjASECIAEgBEYN5wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBpNUAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6AELIANBADYCACAGQQFqIQFBHwwUC0GiASECIAEgBEYN5gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtQAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5wELIANBADYCACAGQQFqIQFBAgwTC0GhASECIAEgBEYN5QEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQbzUAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOUBCyABIARGBEBBoAEhAgzlAQtBASABLQAAQd8ARw0RGiABQQFqIQFBhwEhAgzLAQsgA0EANgIAIAZBAWohAUGIASECDMoBC0GfASECIAEgBEYN4gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBhNUAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4wELIANBADYCACAGQQFqIQFBKQwPC0GeASECIAEgBEYN4QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBuNQAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4gELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBnQEhAgzhAQsgAS0AAEHFAEcNDiABQQFqIQFBhAEhAgzHAQsgASAERgRAQZwBIQIM4AELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFBggEhAgzHAQsgAUEBaiEBQYMBIQIMxgELQZsBIQIgASAERg3eASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGz1ABqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzfAQsgA0EANgIAIAZBAWohAUEjDAsLQZoBIQIgASAERg3dASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGw1ABqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzeAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGZASECDN0BCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQf0AIQIMxAELIAFBAWohAUGAASECDMMBCyABIARGBEBBmAEhAgzcAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB/gAhAgzDAQsgAUEBaiEBQf8AIQIMwgELIAEgBEYEQEGXASECDNsBCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQZYBIQIgASAERg3ZASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEGs1ABqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzaAQsgA0EANgIAIAZBAWohAUEFDAYLQZUBIQIgASAERg3YASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGm1ABqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzZAQsgA0EANgIAIAZBAWohAUEWDAULQZQBIQIgASAERg3XASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzYAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGTASECDNcBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUH5ACECDL4BCyABQQFqIQFB+gAhAgy9AQtBkgEhAiABIARGDdUBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQaDUAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNYBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGRASECDNQBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC4iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB/h82AhAgA0EGNgIMDNEBC0H4ACECDLcBCyADQZABNgIcIAMgATYCFCADIAA2AgxBACECDM8BC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgzOAQtB9wAhAgy0AQsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDMwBCyABIARGBEBBjwEhAgzMAQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GbHzYCECADQQY2AgxBACECDMwBC0ECIQIMsgELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GOASECDMoBCyABIARGBEBBjQEhAgzKAQsCQCABLQAAQQlrDgRKAABKAAtB9QAhAgywAQsgAy0AKUEFRgRAQfYAIQIMsAELQfQAIQIMrwELIAEgBEYEQEGMASECDMgBCyADQRA2AgggAyABNgIEDAoLIAEgBEYEQEGLASECDMcBCwJAIAEtAABBCWsOBEcAAEcAC0HzACECDK0BCyABIARHBEAgA0EQNgIIIAMgATYCBEHxACECDK0BC0GKASECDMUBCwJAIAEgBEcEQANAIAEtAABBoNAAai0AACIAQQNHBEACQCAAQQFrDgJJAAQLQfAAIQIMrwELIAQgAUEBaiIBRw0AC0GIASEC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BCABQQFqIgFHDQALQfsAIQIMpwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMpgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMpQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMpAELIANBADYCHCADIAE2AhQgA0G8CjYCECADQQc2AgxBACECDKMBC0HPACECDIkBC0HRACECDIgBC0HnACECDIcBCyABIARGBEBB+gAhAgygAQsCQCABLQAAQQlrDgQgAAAgAAsgAUEBaiEBQeYAIQIMhgELIAEgBEYEQEH5ACECDJ8BCwJAIAEtAABBCWsOBB8AAB8AC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQRAQeIBIQIMhgELIABBFUcEQCADQQA2AhwgAyABNgIUIANByQ02AhAgA0EaNgIMQQAhAgyfAQsgA0H4ADYCHCADIAE2AhQgA0HqGjYCECADQRU2AgxBACECDJ4BCyABIARHBEAgA0ENNgIIIAMgATYCBEHkACECDIUBC0H3ACECDJ0BCyABIARGBEBB9gAhAgydAQsCQAJAAkAgAS0AAEHIAGsOCwABCwsLCwsLCwsCCwsgAUEBaiEBQd0AIQIMhQELIAFBAWohAUHgACECDIQBCyABQQFqIQFB4wAhAgyDAQtB9QAhAiABIARGDZsBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbXVAGotAABHDQggAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJwBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIABEAgA0H0ADYCHCADIAE2AhQgAyAANgIMQQAhAgycAQtB4gAhAgyCAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJwBC0HhACECDIIBCyADQfMANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMmgELIAMtACkiAEEja0ELSQ0JAkAgAEEGSw0AQQEgAHRBygBxRQ0ADAoLQQAhAiADQQA2AhwgAyABNgIUIANB7Qk2AhAgA0EINgIMDJkBC0HyACECIAEgBEYNmAEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBs9UAai0AAEcNBSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMmQELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfEANgIcIAMgATYCFCADIAA2AgxBACECDJkBC0HfACECDH8LQQAhAAJAIAMoAjgiAkUNACACKAI0IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANB6g02AhAgA0EmNgIMQQAhAgyZAQtB3gAhAgx/CyADQfAANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMlwELIAMtAClBIUYNBiADQQA2AhwgAyABNgIUIANBkQo2AhAgA0EINgIMQQAhAgyWAQtB7wAhAiABIARGDZUBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDVAGotAABHDQIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJYBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIARQ0CIANB7QA2AhwgAyABNgIUIAMgADYCDEEAIQIMlQELIANBADYCAAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDYABIANB7gA2AhwgAyABNgIUIAMgADYCDEEAIQIMkwELQdwAIQIMeQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJMBC0HbACECDHkLIANB7AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyRAQsgAy0AKSIAQSNJDQAgAEEuRg0AIANBADYCHCADIAE2AhQgA0HJCTYCECADQQg2AgxBACECDJABC0HaACECDHYLIAEgBEYEQEHrACECDI8BCwJAIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMjwELQdkAIQIMdQsgASAERwRAIANBDjYCCCADIAE2AgRB2AAhAgx1C0HqACECDI0BCyABIARGBEBB6QAhAgyNAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1wAhAgx0CyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeiADQegANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyABIARGBEBB5wAhAgyMAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ17IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELQdYAIQIMcgsgASAERgRAQeUAIQIMiwELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDI0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNfSADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeyADQeQANgIcIAMgATYCFCADIAA2AgwMiwELQdQAIQIMcQsgAy0AKUEiRg2GAUHTACECDHALQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFBEBB1QAhAgxwCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQaQNNgIQIANBITYCDEEAIQIMiQELIANB4QA2AhwgAyABNgIUIANB0Bo2AhAgA0EVNgIMQQAhAgyIAQsgASAERgRAQeAAIQIMiAELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HSACECDHALIANBADYCHCADIAE2AhQgA0G2ETYCECADQQk2AgxBACECDIgBCyADQQA2AhwgAyABNgIUIANBthE2AhAgA0EJNgIMQQAhAgyHAQsgASAERgRAQd8AIQIMhwELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBthE2AhAgA0ECNgIMQQAhAgyGAQsgASAERgRAQd0AIQIMhgELIAEtAAAiAkENRgRAIAFBAWohAUHQACECDG0LIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyFAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0HKLTYCECADQQc2AgwMgwELIAEgBEYEQEHbACECDIMBCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc4AIQIMaAsgASAERgRAQdoAIQIMgQELIAEtAABBCWsOBAABAQABC0EAIQIgA0EANgIcIANBmhI2AhAgA0EHNgIMIAMgAUEBajYCFAx/CyADQYASOwEqQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2QA2AhwgAyABNgIUIANB6ho2AhAgA0EVNgIMQQAhAgx+C0HNACECDGQLIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDHwLIAEgBEYEQEHZACECDHwLIAEtAABBIEcNPSABQQFqIQEgAy0ALkEBcQ09IANBADYCHCADIAE2AhQgA0HCHDYCECADQR42AgxBACECDHsLIAEgBEYEQEHYACECDHsLAkACQAJAAkACQCABLQAAIgBBCmsOBAIDAwABCyABQQFqIQFBLCECDGULIABBOkcNASADQQA2AhwgAyABNgIUIANB5xE2AhAgA0EKNgIMQQAhAgx9CyABQQFqIQEgA0Evai0AAEEBcUUNcyADLQAyQYABcUUEQCADQTJqIQIgAxA1QQAhAAJAIAMoAjgiBkUNACAGKAIoIgZFDQAgAyAGEQAAIQALAkACQCAADhZNTEsBAQEBAQEBAQEBAQEBAQEBAQEAAQsgA0EpNgIcIAMgATYCFCADQawZNgIQIANBFTYCDEEAIQIMfgsg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c3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw=='\n\nlet wasmBuffer\n\nObject.defineProperty(module, 'exports', {\n  get: () => {\n    return wasmBuffer\n      ? wasmBuffer\n      : (wasmBuffer = Buffer.from(wasmBase64, 'base64'))\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IjtBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGxsaHR0cC13YXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5jb25zdCB3YXNtQmFzZTY0ID0gJ0FHRnpiUUVBQUFBQkp3ZGdBWDhCZjJBRGYzOS9BWDlnQW45L0FHQUJmd0JnQkg5L2YzOEJmMkFBQUdBRGYzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUVBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBelUwQlFZQUFBTUFBQUFBQUFBREFRTUFBd01EQUFBQ0FBQUFBQUlDQWdJQ0FnSUNBZ0lCQVFFQkFRRUJBUUVCQXdBQUF3QUFBQVFGQVhBQkV4TUZBd0VBQWdZSUFYOEJRY0RaQkFzSHhRY29CbTFsYlc5eWVRSUFDMTlwYm1sMGFXRnNhWHBsQUFnWlgxOXBibVJwY21WamRGOW1kVzVqZEdsdmJsOTBZV0pzWlFFQUMyeHNhSFIwY0Y5cGJtbDBBQWtZYkd4b2RIUndYM05vYjNWc1pGOXJaV1Z3WDJGc2FYWmxBRGNNYkd4b2RIUndYMkZzYkc5akFBc0diV0ZzYkc5akFEa0xiR3hvZEhSd1gyWnlaV1VBREFSbWNtVmxBQXdQYkd4b2RIUndYMmRsZEY5MGVYQmxBQTBWYkd4b2RIUndYMmRsZEY5b2RIUndYMjFoYW05eUFBNFZiR3hvZEhSd1gyZGxkRjlvZEhSd1gyMXBibTl5QUE4UmJHeG9kSFJ3WDJkbGRGOXRaWFJvYjJRQUVCWnNiR2gwZEhCZloyVjBYM04wWVhSMWMxOWpiMlJsQUJFU2JHeG9kSFJ3WDJkbGRGOTFjR2R5WVdSbEFCSU1iR3hvZEhSd1gzSmxjMlYwQUJNT2JHeG9kSFJ3WDJWNFpXTjFkR1VBRkJSc2JHaDBkSEJmYzJWMGRHbHVaM05mYVc1cGRBQVZEV3hzYUhSMGNGOW1hVzVwYzJnQUZneHNiR2gwZEhCZmNHRjFjMlVBRncxc2JHaDBkSEJmY21WemRXMWxBQmdiYkd4b2RIUndYM0psYzNWdFpWOWhablJsY2w5MWNHZHlZV1JsQUJrUWJHeG9kSFJ3WDJkbGRGOWxjbkp1YndBYUYyeHNhSFIwY0Y5blpYUmZaWEp5YjNKZmNtVmhjMjl1QUJzWGJHeG9kSFJ3WDNObGRGOWxjbkp2Y2w5eVpXRnpiMjRBSEJSc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNCdmN3QWRFV3hzYUhSMGNGOWxjbkp1YjE5dVlXMWxBQjRTYkd4b2RIUndYMjFsZEdodlpGOXVZVzFsQUI4U2JHeG9kSFJ3WDNOMFlYUjFjMTl1WVcxbEFDQWFiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMmhsWVdSbGNuTUFJU0ZzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmWTJoMWJtdGxaRjlzWlc1bmRHZ0FJaDFzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmYTJWbGNGOWhiR2wyWlFBakpHeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOTBjbUZ1YzJabGNsOWxibU52WkdsdVp3QWtHbXhzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjkyWlhKemFXOXVBQ1VqYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDJSaGRHRmZZV1owWlhKZlkyeHZjMlVBSmlkc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmIzQjBhVzl1WVd4ZmJHWmZZV1owWlhKZlkzSUFKeXhzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmYjNCMGFXOXVZV3hmWTNKc1psOWhablJsY2w5amFIVnVhd0FvS0d4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5dmNIUnBiMjVoYkY5amNsOWlaV1p2Y21WZmJHWUFLU3BzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmYzNCaFkyVnpYMkZtZEdWeVgyTm9kVzVyWDNOcGVtVUFLaGhzYkdoMGRIQmZiV1Z6YzJGblpWOXVaV1ZrYzE5bGIyWUFOZ2tZQVFCQkFRc1NBUUlEQkFVS0JnY3lORE11S3k4dExEQXhDcS9aQWpRV0FFSEExUUFvQWdBRVFBQUxRY0RWQUVFQk5nSUFDeFFBSUFBUU9DQUFJQUkyQWpnZ0FDQUJPZ0FvQ3hRQUlBQWdBQzhCTkNBQUxRQXdJQUFRTnhBQUN4NEJBWDlCd0FBUU9pSUJFRGdnQVVHQUNEWUNPQ0FCSUFBNkFDZ2dBUXVQREFFSGZ3SkFJQUJGRFFBZ0FFRUlheUlCSUFCQkJHc29BZ0FpQUVGNGNTSUVhaUVGQWtBZ0FFRUJjUTBBSUFCQkEzRkZEUUVnQVNBQktBSUFJZ0JySWdGQjFOVUFLQUlBU1EwQklBQWdCR29oQkFKQUFrQkIyTlVBS0FJQUlBRkhCRUFnQUVIL0FVMEVRQ0FBUVFOMklRTWdBU2dDQ0NJQUlBRW9BZ3dpQWtZRVFFSEUxUUJCeE5VQUtBSUFRWDRnQTNkeE5nSUFEQVVMSUFJZ0FEWUNDQ0FBSUFJMkFnd01CQXNnQVNnQ0dDRUdJQUVnQVNnQ0RDSUFSd1JBSUFBZ0FTZ0NDQ0lDTmdJSUlBSWdBRFlDREF3REN5QUJRUlJxSWdNb0FnQWlBa1VFUUNBQktBSVFJZ0pGRFFJZ0FVRVFhaUVEQ3dOQUlBTWhCeUFDSWdCQkZHb2lBeWdDQUNJQ0RRQWdBRUVRYWlFRElBQW9BaEFpQWcwQUN5QUhRUUEyQWdBTUFnc2dCU2dDQkNJQVFRTnhRUU5IRFFJZ0JTQUFRWDV4TmdJRVFjelZBQ0FFTmdJQUlBVWdCRFlDQUNBQklBUkJBWEkyQWdRTUF3dEJBQ0VBQ3lBR1JRMEFBa0FnQVNnQ0hDSUNRUUowUWZUWEFHb2lBeWdDQUNBQlJnUkFJQU1nQURZQ0FDQUFEUUZCeU5VQVFjalZBQ2dDQUVGK0lBSjNjVFlDQUF3Q0N5QUdRUkJCRkNBR0tBSVFJQUZHRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQVkyQWhnZ0FTZ0NFQ0lDQkVBZ0FDQUNOZ0lRSUFJZ0FEWUNHQXNnQVVFVWFpZ0NBQ0lDUlEwQUlBQkJGR29nQWpZQ0FDQUNJQUEyQWhnTElBRWdCVThOQUNBRktBSUVJZ0JCQVhGRkRRQUNRQUpBQWtBQ1FDQUFRUUp4UlFSQVFkelZBQ2dDQUNBRlJnUkFRZHpWQUNBQk5nSUFRZERWQUVIUTFRQW9BZ0FnQkdvaUFEWUNBQ0FCSUFCQkFYSTJBZ1FnQVVIWTFRQW9BZ0JIRFFaQnpOVUFRUUEyQWdCQjJOVUFRUUEyQWdBTUJndEIyTlVBS0FJQUlBVkdCRUJCMk5VQUlBRTJBZ0JCek5VQVFjelZBQ2dDQUNBRWFpSUFOZ0lBSUFFZ0FFRUJjallDQkNBQUlBRnFJQUEyQWdBTUJnc2dBRUY0Y1NBRWFpRUVJQUJCL3dGTkJFQWdBRUVEZGlFRElBVW9BZ2dpQUNBRktBSU1JZ0pHQkVCQnhOVUFRY1RWQUNnQ0FFRitJQU4zY1RZQ0FBd0ZDeUFDSUFBMkFnZ2dBQ0FDTmdJTURBUUxJQVVvQWhnaEJpQUZJQVVvQWd3aUFFY0VRRUhVMVFBb0FnQWFJQUFnQlNnQ0NDSUNOZ0lJSUFJZ0FEWUNEQXdEQ3lBRlFSUnFJZ01vQWdBaUFrVUVRQ0FGS0FJUUlnSkZEUUlnQlVFUWFpRURDd05BSUFNaEJ5QUNJZ0JCRkdvaUF5Z0NBQ0lDRFFBZ0FFRVFhaUVESUFBb0FoQWlBZzBBQ3lBSFFRQTJBZ0FNQWdzZ0JTQUFRWDV4TmdJRUlBRWdCR29nQkRZQ0FDQUJJQVJCQVhJMkFnUU1Bd3RCQUNFQUN5QUdSUTBBQWtBZ0JTZ0NIQ0lDUVFKMFFmVFhBR29pQXlnQ0FDQUZSZ1JBSUFNZ0FEWUNBQ0FBRFFGQnlOVUFRY2pWQUNnQ0FFRitJQUozY1RZQ0FBd0NDeUFHUVJCQkZDQUdLQUlRSUFWR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFZMkFoZ2dCU2dDRUNJQ0JFQWdBQ0FDTmdJUUlBSWdBRFlDR0FzZ0JVRVVhaWdDQUNJQ1JRMEFJQUJCRkdvZ0FqWUNBQ0FDSUFBMkFoZ0xJQUVnQkdvZ0JEWUNBQ0FCSUFSQkFYSTJBZ1FnQVVIWTFRQW9BZ0JIRFFCQnpOVUFJQVEyQWdBTUFRc2dCRUgvQVUwRVFDQUVRWGh4UWV6VkFHb2hBQUovUWNUVkFDZ0NBQ0lDUVFFZ0JFRURkblFpQTNGRkJFQkJ4TlVBSUFJZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQ0lBRTJBZ3dnQUNBQk5nSUlJQUVnQURZQ0RDQUJJQUkyQWdnTUFRdEJIeUVDSUFSQi8vLy9CMDBFUUNBRVFTWWdCRUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFJTElBRWdBallDSENBQlFnQTNBaEFnQWtFQ2RFSDAxd0JxSVFBQ1FFSEkxUUFvQWdBaUEwRUJJQUowSWdkeFJRUkFJQUFnQVRZQ0FFSEkxUUFnQXlBSGNqWUNBQ0FCSUFBMkFoZ2dBU0FCTmdJSUlBRWdBVFlDREF3QkN5QUVRUmtnQWtFQmRtdEJBQ0FDUVI5SEczUWhBaUFBS0FJQUlRQUNRQU5BSUFBaUF5Z0NCRUY0Y1NBRVJnMEJJQUpCSFhZaEFDQUNRUUYwSVFJZ0F5QUFRUVJ4YWtFUWFpSUhLQUlBSWdBTkFBc2dCeUFCTmdJQUlBRWdBellDR0NBQklBRTJBZ3dnQVNBQk5nSUlEQUVMSUFNb0FnZ2lBQ0FCTmdJTUlBTWdBVFlDQ0NBQlFRQTJBaGdnQVNBRE5nSU1JQUVnQURZQ0NBdEI1TlVBUWVUVkFDZ0NBRUVCYXlJQVFYOGdBQnMyQWdBTEN3Y0FJQUF0QUNnTEJ3QWdBQzBBS2dzSEFDQUFMUUFyQ3djQUlBQXRBQ2tMQndBZ0FDOEJOQXNIQUNBQUxRQXdDMEFCQkg4Z0FDZ0NHQ0VCSUFBdkFTNGhBaUFBTFFBb0lRTWdBQ2dDT0NFRUlBQVFPQ0FBSUFRMkFqZ2dBQ0FET2dBb0lBQWdBanNCTGlBQUlBRTJBaGdMNVlVQ0FnZC9BMzRnQVNBQ2FpRUVBa0FnQUNJREtBSU1JZ0FOQUNBREtBSUVCRUFnQXlBQk5nSUVDeU1BUVJCcklna2tBQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0F5Z0NIQ0lDUVFKckR2d0JBZmtCQWdNRUJRWUhDQWtLQ3d3TkRnOFFFUkw0QVJQM0FSUVY5Z0VXRi9VQkdCa2FHeHdkSGg4Zy9RSDdBU0gwQVNJakpDVW1KeWdwS2l2ekFTd3RMaTh3TVRMeUFmRUJNelR3QWU4Qk5UWTNPRGs2T3p3OVBqOUFRVUpEUkVWR1IwaEpTa3RNVFU1UCtnRlFVVkpUN2dIdEFWVHNBVlhyQVZaWFdGbGE2Z0ZiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0FiZ0J1UUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSEdBY2NCeUFISkFjb0J5d0hNQWMwQnpnSHBBZWdCendIbkFkQUI1Z0hSQWRJQjB3SFVBZVVCMVFIV0FkY0IyQUhaQWRvQjJ3SGNBZDBCM2dIZkFlQUI0UUhpQWVNQkFQd0JDMEVBRE9NQkMwRU9ET0lCQzBFTkRPRUJDMEVQRE9BQkMwRVFETjhCQzBFVERONEJDMEVVRE4wQkMwRVZETndCQzBFV0ROc0JDMEVYRE5vQkMwRVlETmtCQzBFWkROZ0JDMEVhRE5jQkMwRWJETllCQzBFY0ROVUJDMEVkRE5RQkMwRWVETk1CQzBFZkROSUJDMEVnRE5FQkMwRWhETkFCQzBFSURNOEJDMEVpRE00QkMwRWtETTBCQzBFakRNd0JDMEVIRE1zQkMwRWxETW9CQzBFbURNa0JDMEVuRE1nQkMwRW9ETWNCQzBFU0RNWUJDMEVSRE1VQkMwRXBETVFCQzBFcURNTUJDMEVyRE1JQkMwRXNETUVCQzBIZUFRekFBUXRCTGd5L0FRdEJMd3krQVF0Qk1BeTlBUXRCTVF5OEFRdEJNZ3k3QVF0Qk13eTZBUXRCTkF5NUFRdEIzd0VNdUFFTFFUVU10d0VMUVRrTXRnRUxRUXdNdFFFTFFUWU10QUVMUVRjTXN3RUxRVGdNc2dFTFFUNE1zUUVMUVRvTXNBRUxRZUFCREs4QkMwRUxESzRCQzBFL0RLMEJDMEU3REt3QkMwRUtES3NCQzBFOERLb0JDMEU5REtrQkMwSGhBUXlvQVF0QndRQU1wd0VMUWNBQURLWUJDMEhDQUF5bEFRdEJDUXlrQVF0QkxReWpBUXRCd3dBTW9nRUxRY1FBREtFQkMwSEZBQXlnQVF0QnhnQU1ud0VMUWNjQURKNEJDMEhJQUF5ZEFRdEJ5UUFNbkFFTFFjb0FESnNCQzBITEFBeWFBUXRCekFBTW1RRUxRYzBBREpnQkMwSE9BQXlYQVF0Qnp3QU1sZ0VMUWRBQURKVUJDMEhSQUF5VUFRdEIwZ0FNa3dFTFFkTUFESklCQzBIVkFBeVJBUXRCMUFBTWtBRUxRZFlBREk4QkMwSFhBQXlPQVF0QjJBQU1qUUVMUWRrQURJd0JDMEhhQUF5TEFRdEIyd0FNaWdFTFFkd0FESWtCQzBIZEFBeUlBUXRCM2dBTWh3RUxRZDhBRElZQkMwSGdBQXlGQVF0QjRRQU1oQUVMUWVJQURJTUJDMEhqQUF5Q0FRdEI1QUFNZ1FFTFFlVUFESUFCQzBIaUFReC9DMEhtQUF4K0MwSG5BQXg5QzBFR0RId0xRZWdBREhzTFFRVU1lZ3RCNlFBTWVRdEJCQXg0QzBIcUFBeDNDMEhyQUF4MkMwSHNBQXgxQzBIdEFBeDBDMEVEREhNTFFlNEFESElMUWU4QURIRUxRZkFBREhBTFFmSUFERzhMUWZFQURHNExRZk1BREcwTFFmUUFER3dMUWZVQURHc0xRZllBREdvTFFRSU1hUXRCOXdBTWFBdEIrQUFNWnd0QitRQU1aZ3RCK2dBTVpRdEIrd0FNWkF0Qi9BQU1Zd3RCL1FBTVlndEIvZ0FNWVF0Qi93QU1ZQXRCZ0FFTVh3dEJnUUVNWGd0QmdnRU1YUXRCZ3dFTVhBdEJoQUVNV3d0QmhRRU1XZ3RCaGdFTVdRdEJod0VNV0F0QmlBRU1Wd3RCaVFFTVZndEJpZ0VNVlF0Qml3RU1WQXRCakFFTVV3dEJqUUVNVWd0QmpnRU1VUXRCandFTVVBdEJrQUVNVHd0QmtRRU1UZ3RCa2dFTVRRdEJrd0VNVEF0QmxBRU1Td3RCbFFFTVNndEJsZ0VNU1F0Qmx3RU1TQXRCbUFFTVJ3dEJtUUVNUmd0Qm1nRU1SUXRCbXdFTVJBdEJuQUVNUXd0Qm5RRU1RZ3RCbmdFTVFRdEJud0VNUUF0Qm9BRU1Qd3RCb1FFTVBndEJvZ0VNUFF0Qm93RU1QQXRCcEFFTU93dEJwUUVNT2d0QnBnRU1PUXRCcHdFTU9BdEJxQUVNTnd0QnFRRU1OZ3RCcWdFTU5RdEJxd0VNTkF0QnJBRU1Nd3RCclFFTU1ndEJyZ0VNTVF0QnJ3RU1NQXRCc0FFTUx3dEJzUUVNTGd0QnNnRU1MUXRCc3dFTUxBdEJ0QUVNS3d0QnRRRU1LZ3RCdGdFTUtRdEJ0d0VNS0F0QnVBRU1Kd3RCdVFFTUpndEJ1Z0VNSlF0QnV3RU1KQXRCdkFFTUl3dEJ2UUVNSWd0QnZnRU1JUXRCdndFTUlBdEJ3QUVNSHd0QndRRU1IZ3RCd2dFTUhRdEJBUXdjQzBIREFRd2JDMEhFQVF3YUMwSEZBUXdaQzBIR0FRd1lDMEhIQVF3WEMwSElBUXdXQzBISkFRd1ZDMEhLQVF3VUMwSExBUXdUQzBITUFRd1NDMEhOQVF3UkMwSE9BUXdRQzBIUEFRd1BDMEhRQVF3T0MwSFJBUXdOQzBIU0FRd01DMEhUQVF3TEMwSFVBUXdLQzBIVkFRd0pDMEhXQVF3SUMwSGpBUXdIQzBIWEFRd0dDMEhZQVF3RkMwSFpBUXdFQzBIYUFRd0RDMEhiQVF3Q0MwSGRBUXdCQzBIY0FRc2hBZ05BQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQURBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKL0FrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBTUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FnN2pBUUFCQWdNRUJRWUhDQWtLQ3d3TkRnOFFFUklURkJVV0Z4Z1pHaHNjSFI0ZklDRWpKQ1VuS0NtZUE1c0RtZ09SQTRvRGd3T0FBLzBDK3dMNEF2SUM4UUx2QXUwQzZBTG5BdVlDNVFMa0F0d0Myd0xhQXRrQzJBTFhBdFlDMVFMUEFzNEN6QUxMQXNvQ3lRTElBc2NDeGdMRUFzTUN2Z0s4QXJvQ3VRSzRBcmNDdGdLMUFyUUNzd0t5QXJFQ3NBS3VBcTBDcVFLb0FxY0NwZ0tsQXFRQ293S2lBcUVDb0FLZkFwZ0NrQUtNQW9zQ2lnS0JBdjRCL1FIOEFmc0IrZ0g1QWZnQjl3SDFBZk1COEFIckFla0I2QUhuQWVZQjVRSGtBZU1CNGdIaEFlQUIzd0hlQWQwQjNBSGFBZGtCMkFIWEFkWUIxUUhVQWRNQjBnSFJBZEFCendIT0FjMEJ6QUhMQWNvQnlRSElBY2NCeGdIRkFjUUJ3d0hDQWNFQndBRy9BYjRCdlFHOEFic0J1Z0c1QWJnQnR3RzJBYlVCdEFHekFiSUJzUUd3QWE4QnJnR3RBYXdCcXdHcUFha0JxQUduQWFZQnBRR2tBYU1Cb2dHZkFaNEJtUUdZQVpjQmxnR1ZBWlFCa3dHU0FaRUJrQUdQQVkwQmpBR0hBWVlCaFFHRUFZTUJnZ0Y5Zkh0NmVYWjFkRkJSVWxOVVZRc2dBU0FFUncxeVFmMEJJUUlNdmdNTElBRWdCRWNObUFGQjJ3RWhBZ3k5QXdzZ0FTQUVSdzN4QVVHT0FTRUNETHdEQ3lBQklBUkhEZndCUVlRQklRSU11d01MSUFFZ0JFY05pZ0pCL3dBaEFneTZBd3NnQVNBRVJ3MlJBa0g5QUNFQ0RMa0RDeUFCSUFSSERaUUNRZnNBSVFJTXVBTUxJQUVnQkVjTkhrRWVJUUlNdHdNTElBRWdCRWNOR1VFWUlRSU10Z01MSUFFZ0JFY055Z0pCelFBaEFneTFBd3NnQVNBRVJ3M1ZBa0hHQUNFQ0RMUURDeUFCSUFSSERkWUNRY01BSVFJTXN3TUxJQUVnQkVjTjNBSkJPQ0VDRExJREN5QURMUUF3UVFGR0RhMERESWtEQzBFQUlRQUNRQUpBQWtBZ0F5MEFLa1VOQUNBRExRQXJSUTBBSUFNdkFUSWlBa0VDY1VVTkFRd0NDeUFETHdFeUlnSkJBWEZGRFFFTFFRRWhBQ0FETFFBb1FRRkdEUUFnQXk4Qk5DSUdRZVFBYTBIa0FFa05BQ0FHUWN3QlJnMEFJQVpCc0FKR0RRQWdBa0hBQUhFTkFFRUFJUUFnQWtHSUJIRkJnQVJHRFFBZ0FrRW9jVUVBUnlFQUN5QURRUUE3QVRJZ0EwRUFPZ0F4QWtBZ0FFVUVRQ0FEUVFBNkFERWdBeTBBTGtFRWNRMEJETEVEQ3lBRFFnQTNBeUFMSUFOQkFEb0FNU0FEUVFFNkFEWU1TQXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpBaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVTlNDQUFRUlZIRFdJZ0EwRUVOZ0ljSUFNZ0FUWUNGQ0FEUWRJYk5nSVFJQU5CRlRZQ0RFRUFJUUlNcndNTElBRWdCRVlFUUVFR0lRSU1yd01MSUFFdEFBQkJDa2NOR1NBQlFRRnFJUUVNR2dzZ0EwSUFOd01nUVJJaEFneVVBd3NnQVNBRVJ3MktBMEVqSVFJTXJBTUxJQUVnQkVZRVFFRUhJUUlNckFNTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCR0JnQUdBc2dBVUVCYWlFQlFSQWhBZ3lUQXdzZ0FVRUJhaUVCSUFOQkwyb3RBQUJCQVhFTkYwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWmtnTmdJUUlBTkJHVFlDREF5ckF3c2dBeUFES1FNZ0lnd2dCQ0FCYTYwaUNuMGlDMElBSUFzZ0RGZ2JOd01nSUFvZ0RGb05HRUVJSVFJTXFnTUxJQUVnQkVjRVFDQURRUWsyQWdnZ0F5QUJOZ0lFUVJRaEFneVJBd3RCQ1NFQ0RLa0RDeUFES1FNZ1VBMnVBZ3hEQ3lBQklBUkdCRUJCQ3lFQ0RLZ0RDeUFCTFFBQVFRcEhEUllnQVVFQmFpRUJEQmNMSUFOQkwyb3RBQUJCQVhGRkRSa01KZ3RCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWxBaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwWkRFSUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpRSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUFOR2d3a0MwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NVQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFEUnNNTWdzZ0EwRXZhaTBBQUVFQmNVVU5IQXdpQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1ZDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQURSd01RZ3RCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWxRaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwZERDQUxJQUVnQkVZRVFFRVRJUUlNb0FNTEFrQWdBUzBBQUNJQVFRcHJEZ1FmSXlNQUlnc2dBVUVCYWlFQkRCOExRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpVSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUFOSWd4Q0N5QUJJQVJHQkVCQkZpRUNESjREQ3lBQkxRQUFRY0RCQUdvdEFBQkJBVWNOSXd5REF3c0NRQU5BSUFFdEFBQkJzRHRxTFFBQUlnQkJBVWNFUUFKQUlBQkJBbXNPQWdNQUp3c2dBVUVCYWlFQlFTRWhBZ3lHQXdzZ0JDQUJRUUZxSWdGSERRQUxRUmdoQWd5ZEF3c2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFGQkFXb2lBUkEwSWdBTklReEJDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDVkNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBRFNNTUtnc2dBU0FFUmdSQVFSd2hBZ3liQXdzZ0EwRUtOZ0lJSUFNZ0FUWUNCRUVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDVUNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBRFNWQkpDRUNESUVEQ3lBQklBUkhCRUFEUUNBQkxRQUFRYkE5YWkwQUFDSUFRUU5IQkVBZ0FFRUJhdzRGR0JvbWdnTWxKZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSc2hBZ3lhQXd0Qkd5RUNESmtEQ3dOQUlBRXRBQUJCc0Q5cUxRQUFJZ0JCQTBjRVFDQUFRUUZyRGdVUEVTY1RKaWNMSUFRZ0FVRUJhaUlCUncwQUMwRWVJUUlNbUFNTElBRWdCRWNFUUNBRFFRczJBZ2dnQXlBQk5nSUVRUWNoQWd6L0FndEJIeUVDREpjREN5QUJJQVJHQkVCQklDRUNESmNEQ3dKQUlBRXRBQUJCRFdzT0ZDNC9QejgvUHo4L1B6OC9QejgvUHo4L1B6OEFQd3RCQUNFQ0lBTkJBRFlDSENBRFFiOExOZ0lRSUFOQkFqWUNEQ0FESUFGQkFXbzJBaFFNbGdNTElBTkJMMm9oQWdOQUlBRWdCRVlFUUVFaElRSU1sd01MQWtBQ1FBSkFJQUV0QUFBaUFFRUphdzRZQWdBcEtRRXBLU2twS1NrcEtTa3BLU2twS1NrcEtTa0NKd3NnQVVFQmFpRUJJQU5CTDJvdEFBQkJBWEZGRFFvTUdBc2dBVUVCYWlFQkRCY0xJQUZCQVdvaEFTQUNMUUFBUVFKeERRQUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CbnhVMkFoQWdBMEVNTmdJTURKVURDeUFETFFBdVFZQUJjVVVOQVF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Fsd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU41Z0lnQUVFVlJnUkFJQU5CSkRZQ0hDQURJQUUyQWhRZ0EwR2JHellDRUNBRFFSVTJBZ3hCQUNFQ0RKUURDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpBT05nSVFJQU5CRkRZQ0RBeVRBd3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHK0lEWUNFQ0FEUVFJMkFnd01rZ01MSUFNb0FnUWhBRUVBSVFJZ0EwRUFOZ0lFSUFNZ0FDQUJJQXluYWlJQkVESWlBRVVOS3lBRFFRYzJBaHdnQXlBQk5nSVVJQU1nQURZQ0RBeVJBd3NnQXkwQUxrSEFBSEZGRFFFTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSllJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQkZEU3NnQUVFVlJnUkFJQU5CQ2pZQ0hDQURJQUUyQWhRZ0EwSHJHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RKQURDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpNTU5nSVFJQU5CRXpZQ0RBeVBBd3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHQ0ZUWUNFQ0FEUVFJMkFnd01qZ01MUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjNSUTJBaEFnQTBFWk5nSU1ESTBEQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFlWWROZ0lRSUFOQkdUWUNEQXlNQXdzZ0FFRVZSZzA5UVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjBBODJBaEFnQTBFaU5nSU1ESXNEQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkF6SWdCRkRTZ2dBMEVOTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3dNaWdNTElBQkJGVVlOT2tFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkQVBOZ0lRSUFOQklqWUNEQXlKQXdzZ0F5Z0NCQ0VBUVFBaEFpQURRUUEyQWdRZ0F5QUFJQUVRTXlJQVJRUkFJQUZCQVdvaEFRd29DeUFEUVE0MkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZBeUlBd3NnQUVFVlJnMDNRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CMEE4MkFoQWdBMEVpTmdJTURJY0RDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FSQXpJZ0JGQkVBZ0FVRUJhaUVCRENjTElBTkJEellDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVRElZREMwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZUlYTmdJUUlBTkJHVFlDREF5RkF3c2dBRUVWUmcwelFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIxZ3cyQWhBZ0EwRWpOZ0lNRElRREN5QURLQUlFSVFCQkFDRUNJQU5CQURZQ0JDQURJQUFnQVJBMElnQkZEU1VnQTBFUk5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd3TWd3TUxJQUJCRlVZTk1FRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZFlNTmdJUUlBTkJJellDREF5Q0F3c2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFUU5DSUFSUVJBSUFGQkFXb2hBUXdsQ3lBRFFSSTJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGQXlCQXdzZ0EwRXZhaTBBQUVFQmNVVU5BUXRCRnlFQ0RPWUNDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVJWE5nSVFJQU5CR1RZQ0RBeitBZ3NnQUVFN1J3MEFJQUZCQVdvaEFRd01DMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpJWU5nSVFJQU5CQWpZQ0RBejhBZ3NnQUVFVlJnMG9RUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CMWd3MkFoQWdBMEVqTmdJTURQc0NDeUFEUVJRMkFod2dBeUFCTmdJVUlBTWdBRFlDREF6NkFnc2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFUU5DSUFSUVJBSUFGQkFXb2hBUXoxQWdzZ0EwRVZOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFFNK1FJTElBTW9BZ1FoQUVFQUlRSWdBMEVBTmdJRUlBTWdBQ0FCRURRaUFFVUVRQ0FCUVFGcUlRRU04d0lMSUFOQkZ6WUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVEUGdDQ3lBQVFSVkdEU05CQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIV0REWUNFQ0FEUVNNMkFnd005d0lMSUFNb0FnUWhBRUVBSVFJZ0EwRUFOZ0lFSUFNZ0FDQUJFRFFpQUVVRVFDQUJRUUZxSVFFTUhRc2dBMEVaTmdJY0lBTWdBRFlDRENBRElBRkJBV28yQWhRTTlnSUxJQU1vQWdRaEFFRUFJUUlnQTBFQU5nSUVJQU1nQUNBQkVEUWlBRVVFUUNBQlFRRnFJUUVNN3dJTElBTkJHallDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVRFBVQ0N5QUFRUlZHRFI5QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFFEellDRUNBRFFTSTJBZ3dNOUFJTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFNeUlBUlFSQUlBRkJBV29oQVF3YkN5QURRUncyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkVFQUlRSU04d0lMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUU15SUFSUVJBSUFGQkFXb2hBUXpyQWdzZ0EwRWROZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFJCQUNFQ0RQSUNDeUFBUVR0SERRRWdBVUVCYWlFQkMwRW1JUUlNMXdJTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJueFUyQWhBZ0EwRU1OZ0lNRE84Q0N5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERZUUNJQVFnQVVFQmFpSUJSdzBBQzBFc0lRSU03d0lMUVN3aEFnenVBZ3NnQVNBRVJnUkFRVFFoQWd6dUFnc0NRQUpBQTBBQ1FDQUJMUUFBUVFwckRnUUNBQUFEQUFzZ0JDQUJRUUZxSWdGSERRQUxRVFFoQWd6dkFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF4SWdCRkRaOENJQU5CTWpZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFnenVBZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBeElnQkZCRUFnQVVFQmFpRUJESjhDQ3lBRFFUSTJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGRUVBSVFJTTdRSUxJQUVnQkVjRVFBSkFBMEFnQVMwQUFFRXdheUlBUWY4QmNVRUtUd1JBUVRvaEFnelhBZ3NnQXlrRElDSUxRcG16NXN5WnMrYk1HVllOQVNBRElBdENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBTWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCd0FBaEFnenVBZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVVFQmFpSUJFREVpQUEwWERPSUNDMEhBQUNFQ0RPd0NDeUFCSUFSR0JFQkJ5UUFoQWd6c0Fnc0NRQU5BQWtBZ0FTMEFBRUVKYXc0WUFBS2lBcUlDcVFLaUFxSUNvZ0tpQXFJQ29nS2lBcUlDb2dLaUFxSUNvZ0tpQXFJQ29nS2lBcUlDb2dJQW9nSUxJQVFnQVVFQmFpSUJSdzBBQzBISkFDRUNET3dDQ3lBQlFRRnFJUUVnQTBFdmFpMEFBRUVCY1EybEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmx4QTJBaEFnQTBFS05nSU1RUUFoQWd6ckFnc2dBU0FFUndSQUEwQWdBUzBBQUVFZ1J3MFZJQVFnQVVFQmFpSUJSdzBBQzBINEFDRUNET3NDQzBINEFDRUNET29DQ3lBRFFRSTZBQ2dNT0F0QkFDRUNJQU5CQURZQ0hDQURRYjhMTmdJUUlBTkJBallDRENBRElBRkJBV28yQWhRTTZBSUxRUUFoQWd6T0FndEJEU0VDRE0wQ0MwRVRJUUlNekFJTFFSVWhBZ3pMQWd0QkZpRUNETW9DQzBFWUlRSU15UUlMUVJraEFneklBZ3RCR2lFQ0RNY0NDMEViSVFJTXhnSUxRUndoQWd6RkFndEJIU0VDRE1RQ0MwRWVJUUlNd3dJTFFSOGhBZ3pDQWd0QklDRUNETUVDQzBFaUlRSU13QUlMUVNNaEFneS9BZ3RCSlNFQ0RMNENDMEhsQUNFQ0RMMENDeUFEUVQwMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU0xUUlMSUFOQkd6WUNIQ0FESUFFMkFoUWdBMEdrSERZQ0VDQURRUlUyQWd4QkFDRUNETlFDQ3lBRFFTQTJBaHdnQXlBQk5nSVVJQU5CbUJvMkFoQWdBMEVWTmdJTVFRQWhBZ3pUQWdzZ0EwRVROZ0ljSUFNZ0FUWUNGQ0FEUVpnYU5nSVFJQU5CRlRZQ0RFRUFJUUlNMGdJTElBTkJDellDSENBRElBRTJBaFFnQTBHWUdqWUNFQ0FEUVJVMkFneEJBQ0VDRE5FQ0N5QURRUkEyQWh3Z0F5QUJOZ0lVSUFOQm1CbzJBaEFnQTBFVk5nSU1RUUFoQWd6UUFnc2dBMEVnTmdJY0lBTWdBVFlDRkNBRFFhUWNOZ0lRSUFOQkZUWUNERUVBSVFJTXp3SUxJQU5CQ3pZQ0hDQURJQUUyQWhRZ0EwR2tIRFlDRUNBRFFSVTJBZ3hCQUNFQ0RNNENDeUFEUVF3MkFod2dBeUFCTmdJVUlBTkJwQncyQWhBZ0EwRVZOZ0lNUVFBaEFnek5BZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIZERqWUNFQ0FEUVJJMkFnd016QUlMQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCL1FFaEFnek1BZ3NDUUFKQUlBTXRBRFpCQVVjTkFFRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NZQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTBBSUFCQkZVY05BU0FEUWZ3Qk5nSWNJQU1nQVRZQ0ZDQURRZHdaTmdJUUlBTkJGVFlDREVFQUlRSU16UUlMUWR3QklRSU1zd0lMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEg1Q3pZQ0VDQURRUjgyQWd4QkFDRUNETXNDQ3dKQUFrQWdBeTBBS0VFQmF3NENCQUVBQzBIYkFTRUNETElDQzBIVUFTRUNETEVDQ3lBRFFRSTZBREZCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWdBaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVRVFFSGRBU0VDRExFQ0N5QUFRUlZIQkVBZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWJRTU5nSVFJQU5CRURZQ0RFRUFJUUlNeWdJTElBTkIrd0UyQWh3Z0F5QUJOZ0lVSUFOQmdSbzJBaEFnQTBFVk5nSU1RUUFoQWd6SkFnc2dBU0FFUmdSQVFmb0JJUUlNeVFJTElBRXRBQUJCeUFCR0RRRWdBMEVCT2dBb0MwSEFBU0VDREs0Q0MwSGFBU0VDREswQ0N5QUJJQVJIQkVBZ0EwRU1OZ0lJSUFNZ0FUWUNCRUhaQVNFQ0RLMENDMEg1QVNFQ0RNVUNDeUFCSUFSR0JFQkIrQUVoQWd6RkFnc2dBUzBBQUVISUFFY05CQ0FCUVFGcUlRRkIyQUVoQWd5ckFnc2dBU0FFUmdSQVFmY0JJUUlNeEFJTEFrQUNRQ0FCTFFBQVFjVUFhdzRRQUFVRkJRVUZCUVVGQlFVRkJRVUZBUVVMSUFGQkFXb2hBVUhXQVNFQ0RLc0NDeUFCUVFGcUlRRkIxd0VoQWd5cUFndEI5Z0VoQWlBQklBUkdEY0lDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyVkFHb3RBQUJIRFFNZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBRE1NQ0N5QURLQUlFSVFBZ0EwSUFOd01BSUFNZ0FDQUdRUUZxSWdFUUxpSUFSUVJBUWVNQklRSU1xZ0lMSUFOQjlRRTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNd2dJTFFmUUJJUUlnQVNBRVJnM0JBaUFES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUc0MVFCcUxRQUFSdzBDSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpDQWdzZ0EwR0JCRHNCS0NBREtBSUVJUUFnQTBJQU53TUFJQU1nQUNBR1FRRnFJZ0VRTGlJQURRTU1BZ3NnQTBFQU5nSUFDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVVZk5nSVFJQU5CQ0RZQ0RBeS9BZ3RCMVFFaEFneWxBZ3NnQTBIekFUWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3k5QWd0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FrQWlBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5iaUFBUVJWSEJFQWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZSVBOZ0lRSUFOQklEWUNERUVBSVFJTXZRSUxJQU5CandFMkFod2dBeUFCTmdJVUlBTkI3QnMyQWhBZ0EwRVZOZ0lNUVFBaEFneThBZ3NnQVNBRVJ3UkFJQU5CRFRZQ0NDQURJQUUyQWdSQjB3RWhBZ3lqQWd0QjhnRWhBZ3k3QWdzZ0FTQUVSZ1JBUWZFQklRSU11d0lMQWtBQ1FBSkFJQUV0QUFCQnlBQnJEZ3NBQVFnSUNBZ0lDQWdJQWdnTElBRkJBV29oQVVIUUFTRUNES01DQ3lBQlFRRnFJUUZCMFFFaEFneWlBZ3NnQVVFQmFpRUJRZElCSVFJTW9RSUxRZkFCSVFJZ0FTQUVSZzI1QWlBREtBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRSnFJUVVEUUNBQkxRQUFJQUJCdGRVQWFpMEFBRWNOQkNBQVFRSkdEUU1nQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBWTJBZ0FNdVFJTFFlOEJJUUlnQVNBRVJnMjRBaUFES0FJQUlnQWdCQ0FCYTJvaEJpQUJJQUJyUVFGcUlRVURRQ0FCTFFBQUlBQkJzOVVBYWkwQUFFY05BeUFBUVFGR0RRSWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFZMkFnQU11QUlMUWU0QklRSWdBU0FFUmcyM0FpQURLQUlBSWdBZ0JDQUJhMm9oQmlBQklBQnJRUUpxSVFVRFFDQUJMUUFBSUFCQnNOVUFhaTBBQUVjTkFpQUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVkyQWdBTXR3SUxJQU1vQWdRaEFDQURRZ0EzQXdBZ0F5QUFJQVZCQVdvaUFSQXJJZ0JGRFFJZ0EwSHNBVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5MkFnc2dBMEVBTmdJQUN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3NpQUVVTm5BSWdBMEh0QVRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneTBBZ3RCendFaEFneWFBZ3RCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpRaUFrVU5BQ0FESUFJUkFBQWhBQXNDUUNBQUJFQWdBRUVWUmcwQklBTkJBRFlDSENBRElBRTJBaFFnQTBIcURUWUNFQ0FEUVNZMkFneEJBQ0VDRExRQ0MwSE9BU0VDREpvQ0N5QURRZXNCTmdJY0lBTWdBVFlDRkNBRFFZQWJOZ0lRSUFOQkZUWUNERUVBSVFJTXNnSUxJQUVnQkVZRVFFSHJBU0VDRExJQ0N5QUJMUUFBUVM5R0JFQWdBVUVCYWlFQkRBRUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR3lPRFlDRUNBRFFRZzJBZ3hCQUNFQ0RMRUNDMEhOQVNFQ0RKY0NDeUFCSUFSSEJFQWdBMEVPTmdJSUlBTWdBVFlDQkVITUFTRUNESmNDQzBIcUFTRUNESzhDQ3lBQklBUkdCRUJCNlFFaEFneXZBZ3NnQVMwQUFFRXdheUlBUWY4QmNVRUtTUVJBSUFNZ0FEb0FLaUFCUVFGcUlRRkJ5d0VoQWd5V0Fnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF2SWdCRkRaY0NJQU5CNkFFMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1yZ0lMSUFFZ0JFWUVRRUhuQVNFQ0RLNENDd0pBSUFFdEFBQkJMa1lFUUNBQlFRRnFJUUVNQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXZJZ0JGRFpnQ0lBTkI1Z0UyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTXJnSUxRY29CSVFJTWxBSUxJQUVnQkVZRVFFSGxBU0VDREswQ0MwRUFJUUJCQVNFRlFRRWhCMEVBSVFJQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVEJyRGdvS0NRQUJBZ01FQlFZSUN3dEJBZ3dHQzBFRERBVUxRUVFNQkF0QkJRd0RDMEVHREFJTFFRY01BUXRCQ0FzaEFrRUFJUVZCQUNFSERBSUxRUWtoQWtFQklRQkJBQ0VGUVFBaEJ3d0JDMEVBSVFWQkFTRUNDeUFESUFJNkFDc2dBVUVCYWlFQkFrQUNRQ0FETFFBdVFSQnhEUUFDUUFKQUFrQWdBeTBBS2c0REFRQUNCQXNnQjBVTkF3d0NDeUFBRFFFTUFnc2dCVVVOQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXZJZ0JGRFFJZ0EwSGlBVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5dkFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF2SWdCRkRab0NJQU5CNHdFMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1yZ0lMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUx5SUFSUTJZQWlBRFFlUUJOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFnd01yUUlMUWNrQklRSU1rd0lMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKRUlnSkZEUUFnQXlBQ0VRQUFJUUFMQWtBZ0FBUkFJQUJCRlVZTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnBBMDJBaEFnQTBFaE5nSU1RUUFoQWd5dEFndEJ5QUVoQWd5VEFnc2dBMEhoQVRZQ0hDQURJQUUyQWhRZ0EwSFFHallDRUNBRFFSVTJBZ3hCQUNFQ0RLc0NDeUFCSUFSR0JFQkI0UUVoQWd5ckFnc0NRQ0FCTFFBQVFTQkdCRUFnQTBFQU93RTBJQUZCQVdvaEFRd0JDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJtUkUyQWhBZ0EwRUpOZ0lNUVFBaEFneXJBZ3RCeHdFaEFneVJBZ3NnQVNBRVJnUkFRZUFCSVFJTXFnSUxBa0FnQVMwQUFFRXdhMEgvQVhFaUFrRUtTUVJBSUFGQkFXb2hBUUpBSUFNdkFUUWlBRUdaTTBzTkFDQURJQUJCQ213aUFEc0JOQ0FBUWY3L0EzRWdBa0gvL3dOelN3MEFJQU1nQUNBQ2Fqc0JOQXdDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaVWVOZ0lRSUFOQkRUWUNEQXlyQWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpVZU5nSVFJQU5CRFRZQ0RFRUFJUUlNcWdJTFFjWUJJUUlNa0FJTElBRWdCRVlFUUVIZkFTRUNES2tDQ3dKQUlBRXRBQUJCTUd0Qi93RnhJZ0pCQ2trRVFDQUJRUUZxSVFFQ1FDQURMd0UwSWdCQm1UTkxEUUFnQXlBQVFRcHNJZ0E3QVRRZ0FFSCsvd054SUFKQi8vOERjMHNOQUNBRElBQWdBbW83QVRRTUFndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdWSGpZQ0VDQURRUTAyQWd3TXFnSUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR1ZIallDRUNBRFFRMDJBZ3hCQUNFQ0RLa0NDMEhGQVNFQ0RJOENDeUFCSUFSR0JFQkIzZ0VoQWd5b0Fnc0NRQ0FCTFFBQVFUQnJRZjhCY1NJQ1FRcEpCRUFnQVVFQmFpRUJBa0FnQXk4Qk5DSUFRWmt6U3cwQUlBTWdBRUVLYkNJQU93RTBJQUJCL3Y4RGNTQUNRZi8vQTNOTERRQWdBeUFBSUFKcU93RTBEQUlMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmxSNDJBaEFnQTBFTk5nSU1ES2tDQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CbFI0MkFoQWdBMEVOTmdJTVFRQWhBZ3lvQWd0QnhBRWhBZ3lPQWdzZ0FTQUVSZ1JBUWQwQklRSU1wd0lMQWtBQ1FBSkFBa0FnQVMwQUFFRUthdzRYQWdNREFBTURBd01EQXdNREF3TURBd01EQXdNREF3RURDeUFCUVFGcURBVUxJQUZCQVdvaEFVSERBU0VDREk4Q0N5QUJRUUZxSVFFZ0EwRXZhaTBBQUVFQmNRMElJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR05DellDRUNBRFFRMDJBZ3hCQUNFQ0RLY0NDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJqUXMyQWhBZ0EwRU5OZ0lNUVFBaEFneW1BZ3NnQVNBRVJ3UkFJQU5CRHpZQ0NDQURJQUUyQWdSQkFTRUNESTBDQzBIY0FTRUNES1VDQ3dKQUFrQURRQUpBSUFFdEFBQkJDbXNPQkFJQUFBTUFDeUFFSUFGQkFXb2lBVWNOQUF0QjJ3RWhBZ3ltQWdzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXRJZ0JGQkVBZ0FVRUJhaUVCREFRTElBTkIyZ0UyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkVFQUlRSU1wUUlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxTSUFEUUVnQVVFQmFnc2hBVUhCQVNFQ0RJb0NDeUFEUWRrQk5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDREtJQ0MwSENBU0VDRElnQ0N5QURRUzlxTFFBQVFRRnhEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZVFjTmdJUUlBTkJHVFlDREVFQUlRSU1vQUlMSUFFZ0JFWUVRRUhaQVNFQ0RLQUNDd0pBQWtBQ1FDQUJMUUFBUVFwckRnUUJBZ0lBQWdzZ0FVRUJhaUVCREFJTElBRkJBV29oQVF3QkN5QURMUUF1UWNBQWNVVU5BUXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWp3aUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVTm9BRWdBRUVWUmdSQUlBTkIyUUEyQWh3Z0F5QUJOZ0lVSUFOQnR4bzJBaEFnQTBFVk5nSU1RUUFoQWd5ZkFnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFZQU5OZ0lRSUFOQkd6WUNERUVBSVFJTW5nSUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSGNLRFlDRUNBRFFRSTJBZ3hCQUNFQ0RKMENDeUFCSUFSSEJFQWdBMEVNTmdJSUlBTWdBVFlDQkVHL0FTRUNESVFDQzBIWUFTRUNESndDQ3lBQklBUkdCRUJCMXdFaEFneWNBZ3NDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBQVFJRFdnUUZCbHBhV2djSUNRb0xEQTBPRHhCYUN5QUJRUUZxSVFGQit3QWhBZ3lTQWdzZ0FVRUJhaUVCUWZ3QUlRSU1rUUlMSUFGQkFXb2hBVUdCQVNFQ0RKQUNDeUFCUVFGcUlRRkJoUUVoQWd5UEFnc2dBVUVCYWlFQlFZWUJJUUlNamdJTElBRkJBV29oQVVHSkFTRUNESTBDQ3lBQlFRRnFJUUZCaWdFaEFneU1BZ3NnQVVFQmFpRUJRWTBCSVFJTWl3SUxJQUZCQVdvaEFVR1dBU0VDRElvQ0N5QUJRUUZxSVFGQmx3RWhBZ3lKQWdzZ0FVRUJhaUVCUVpnQklRSU1pQUlMSUFGQkFXb2hBVUdsQVNFQ0RJY0NDeUFCUVFGcUlRRkJwZ0VoQWd5R0Fnc2dBVUVCYWlFQlFhd0JJUUlNaFFJTElBRkJBV29oQVVHMEFTRUNESVFDQ3lBQlFRRnFJUUZCdHdFaEFneURBZ3NnQVVFQmFpRUJRYjRCSVFJTWdnSUxJQUVnQkVZRVFFSFdBU0VDREpzQ0N5QUJMUUFBUWM0QVJ3MUlJQUZCQVdvaEFVRzlBU0VDRElFQ0N5QUJJQVJHQkVCQjFRRWhBZ3lhQWdzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdCS1NrcEtTa3BLU2tvQlNrcEtTa3BLQWtvTElBRkJBV29oQVVHNEFTRUNESUlDQ3lBQlFRRnFJUUZCdXdFaEFneUJBZ3NnQVVFQmFpRUJRYndCSVFJTWdBSUxRZFFCSVFJZ0FTQUVSZzJZQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRZHFJUVlDUUFOQUlBRXRBQUFnQUVHbzFRQnFMUUFBUncxRklBQkJCMFlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5WkFnc2dBMEVBTmdJQUlBWkJBV29oQVVFYkRFVUxJQUVnQkVZRVFFSFRBU0VDREpnQ0N3SkFBa0FnQVMwQUFFSEpBR3NPQndCSFIwZEhSd0ZIQ3lBQlFRRnFJUUZCdVFFaEFnei9BUXNnQVVFQmFpRUJRYm9CSVFJTS9nRUxRZElCSVFJZ0FTQUVSZzJXQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHbTFRQnFMUUFBUncxRElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5WEFnc2dBMEVBTmdJQUlBWkJBV29oQVVFUERFTUxRZEVCSVFJZ0FTQUVSZzJWQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHazFRQnFMUUFBUncxQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5V0Fnc2dBMEVBTmdJQUlBWkJBV29oQVVFZ0RFSUxRZEFCSVFJZ0FTQUVSZzJVQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVHaDFRQnFMUUFBUncxQklBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5VkFnc2dBMEVBTmdJQUlBWkJBV29oQVVFU0RFRUxJQUVnQkVZRVFFSFBBU0VDREpRQ0N3SkFBa0FnQVMwQUFFSEZBR3NPRGdCRFEwTkRRME5EUTBORFEwTUJRd3NnQVVFQmFpRUJRYlVCSVFJTSt3RUxJQUZCQVdvaEFVRzJBU0VDRFBvQkMwSE9BU0VDSUFFZ0JFWU5rZ0lnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCbnRVQWFpMEFBRWNOUHlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNa3dJTElBTkJBRFlDQUNBR1FRRnFJUUZCQnd3L0MwSE5BU0VDSUFFZ0JFWU5rUUlnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCbU5VQWFpMEFBRWNOUGlBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNa2dJTElBTkJBRFlDQUNBR1FRRnFJUUZCS0F3K0N5QUJJQVJHQkVCQnpBRWhBZ3lSQWdzQ1FBSkFBa0FnQVMwQUFFSEZBR3NPRVFCQlFVRkJRVUZCUVVFQlFVRkJRVUVDUVFzZ0FVRUJhaUVCUWJFQklRSU0rUUVMSUFGQkFXb2hBVUd5QVNFQ0RQZ0JDeUFCUVFGcUlRRkJzd0VoQWd6M0FRdEJ5d0VoQWlBQklBUkdEWThDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUVpIVkFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBREpBQ0N5QURRUUEyQWdBZ0JrRUJhaUVCUVJvTVBBdEJ5Z0VoQWlBQklBUkdEWTRDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUVkzVkFHb3RBQUJIRFRzZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBREk4Q0N5QURRUUEyQWdBZ0JrRUJhaUVCUVNFTU93c2dBU0FFUmdSQVFja0JJUUlNamdJTEFrQUNRQ0FCTFFBQVFjRUFhdzRVQUQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFFFOUN5QUJRUUZxSVFGQnJRRWhBZ3oxQVFzZ0FVRUJhaUVCUWJBQklRSU05QUVMSUFFZ0JFWUVRRUhJQVNFQ0RJMENDd0pBQWtBZ0FTMEFBRUhWQUdzT0N3QThQRHc4UER3OFBEd0JQQXNnQVVFQmFpRUJRYTRCSVFJTTlBRUxJQUZCQVdvaEFVR3ZBU0VDRFBNQkMwSEhBU0VDSUFFZ0JFWU5pd0lnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSWFpRUdBa0FEUUNBQkxRQUFJQUJCaE5VQWFpMEFBRWNOT0NBQVFRaEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNakFJTElBTkJBRFlDQUNBR1FRRnFJUUZCS2d3NEN5QUJJQVJHQkVCQnhnRWhBZ3lMQWdzZ0FTMEFBRUhRQUVjTk9DQUJRUUZxSVFGQkpRdzNDMEhGQVNFQ0lBRWdCRVlOaVFJZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQmdkVUFhaTBBQUVjTk5pQUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTWlnSUxJQU5CQURZQ0FDQUdRUUZxSVFGQkRndzJDeUFCSUFSR0JFQkJ4QUVoQWd5SkFnc2dBUzBBQUVIRkFFY05OaUFCUVFGcUlRRkJxd0VoQWd6dkFRc2dBU0FFUmdSQVFjTUJJUUlNaUFJTEFrQUNRQUpBQWtBZ0FTMEFBRUhDQUdzT0R3QUJBams1T1RrNU9UazVPVGs1QXprTElBRkJBV29oQVVHbkFTRUNEUEVCQ3lBQlFRRnFJUUZCcUFFaEFnendBUXNnQVVFQmFpRUJRYWtCSVFJTTd3RUxJQUZCQVdvaEFVR3FBU0VDRE80QkMwSENBU0VDSUFFZ0JFWU5oZ0lnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCL3RRQWFpMEFBRWNOTXlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaHdJTElBTkJBRFlDQUNBR1FRRnFJUUZCRkF3ekMwSEJBU0VDSUFFZ0JFWU5oUUlnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRWFpRUdBa0FEUUNBQkxRQUFJQUJCK2RRQWFpMEFBRWNOTWlBQVFRUkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaGdJTElBTkJBRFlDQUNBR1FRRnFJUUZCS3d3eUMwSEFBU0VDSUFFZ0JFWU5oQUlnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCOXRRQWFpMEFBRWNOTVNBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaFFJTElBTkJBRFlDQUNBR1FRRnFJUUZCTEF3eEMwRy9BU0VDSUFFZ0JFWU5nd0lnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCb2RVQWFpMEFBRWNOTUNBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaEFJTElBTkJBRFlDQUNBR1FRRnFJUUZCRVF3d0MwRytBU0VDSUFFZ0JFWU5nZ0lnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCOHRRQWFpMEFBRWNOTHlBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNZ3dJTElBTkJBRFlDQUNBR1FRRnFJUUZCTGd3dkN5QUJJQVJHQkVCQnZRRWhBZ3lDQWdzQ1FBSkFBa0FDUUFKQUlBRXRBQUJCd1FCckRoVUFORFEwTkRRME5EUTBOQUUwTkFJME5BTTBOQVEwQ3lBQlFRRnFJUUZCbXdFaEFnenNBUXNnQVVFQmFpRUJRWndCSVFJTTZ3RUxJQUZCQVdvaEFVR2RBU0VDRE9vQkN5QUJRUUZxSVFGQm9nRWhBZ3pwQVFzZ0FVRUJhaUVCUWFRQklRSU02QUVMSUFFZ0JFWUVRRUc4QVNFQ0RJRUNDd0pBQWtBZ0FTMEFBRUhTQUdzT0F3QXdBVEFMSUFGQkFXb2hBVUdqQVNFQ0RPZ0JDeUFCUVFGcUlRRkJCQXd0QzBHN0FTRUNJQUVnQkVZTi93RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI4TlFBYWkwQUFFY05MQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1nQUlMSUFOQkFEWUNBQ0FHUVFGcUlRRkJIUXdzQ3lBQklBUkdCRUJCdWdFaEFnei9BUXNDUUFKQUlBRXRBQUJCeVFCckRnY0JMaTR1TGk0QUxnc2dBVUVCYWlFQlFhRUJJUUlNNWdFTElBRkJBV29oQVVFaURDc0xJQUVnQkVZRVFFRzVBU0VDRFA0QkN5QUJMUUFBUWRBQVJ3MHJJQUZCQVdvaEFVR2dBU0VDRE9RQkN5QUJJQVJHQkVCQnVBRWhBZ3o5QVFzQ1FBSkFJQUV0QUFCQnhnQnJEZ3NBTEN3c0xDd3NMQ3dzQVN3TElBRkJBV29oQVVHZUFTRUNET1FCQ3lBQlFRRnFJUUZCbndFaEFnempBUXRCdHdFaEFpQUJJQVJHRGZzQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFlelVBR290QUFCSERTZ2dBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQd0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFRME1LQXRCdGdFaEFpQUJJQVJHRGZvQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFhSFZBR290QUFCSERTY2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQc0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFRd01Kd3RCdFFFaEFpQUJJQVJHRGZrQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFlclVBR290QUFCSERTWWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQb0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFRTU1KZ3RCdEFFaEFpQUJJQVJHRGZnQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFlalVBR290QUFCSERTVWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQa0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFTWU1KUXNnQVNBRVJnUkFRYk1CSVFJTStBRUxBa0FDUUNBQkxRQUFRZFFBYXc0Q0FBRW5DeUFCUVFGcUlRRkJtUUVoQWd6ZkFRc2dBVUVCYWlFQlFab0JJUUlNM2dFTFFiSUJJUUlnQVNBRVJnMzJBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUhtMUFCcUxRQUFSdzBqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXozQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVuRENNTFFiRUJJUUlnQVNBRVJnMzFBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUhrMUFCcUxRQUFSdzBpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXoyQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVjRENJTFFiQUJJUUlnQVNBRVJnMzBBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUhlMUFCcUxRQUFSdzBoSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXoxQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVHRENFTFFhOEJJUUlnQVNBRVJnM3pBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhaMUFCcUxRQUFSdzBnSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXowQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVaRENBTElBRWdCRVlFUUVHdUFTRUNEUE1CQ3dKQUFrQUNRQUpBSUFFdEFBQkJMV3NPSXdBa0pDUWtKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQUVrSkNRa0pBSWtKQ1FESkFzZ0FVRUJhaUVCUVk0QklRSU0zQUVMSUFGQkFXb2hBVUdQQVNFQ0ROc0JDeUFCUVFGcUlRRkJsQUVoQWd6YUFRc2dBVUVCYWlFQlFaVUJJUUlNMlFFTFFhMEJJUUlnQVNBRVJnM3hBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUhYMUFCcUxRQUFSdzBlSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXp5QVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVMREI0TElBRWdCRVlFUUVHc0FTRUNEUEVCQ3dKQUFrQWdBUzBBQUVIQkFHc09Bd0FnQVNBTElBRkJBV29oQVVHUUFTRUNETmdCQ3lBQlFRRnFJUUZCa3dFaEFnelhBUXNnQVNBRVJnUkFRYXNCSVFJTThBRUxBa0FDUUNBQkxRQUFRY0VBYXc0UEFCOGZIeDhmSHg4Zkh4OGZIeDhCSHdzZ0FVRUJhaUVCUVpFQklRSU0xd0VMSUFGQkFXb2hBVUdTQVNFQ0ROWUJDeUFCSUFSR0JFQkJxZ0VoQWd6dkFRc2dBUzBBQUVITUFFY05IQ0FCUVFGcUlRRkJDZ3diQzBHcEFTRUNJQUVnQkVZTjdRRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkIwZFFBYWkwQUFFY05HaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU03Z0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJIZ3dhQzBHb0FTRUNJQUVnQkVZTjdBRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVHYWlFR0FrQURRQ0FCTFFBQUlBQkJ5dFFBYWkwQUFFY05HU0FBUVFaR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU03UUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJGUXdaQzBHbkFTRUNJQUVnQkVZTjZ3RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJ4OVFBYWkwQUFFY05HQ0FBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU03QUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJGd3dZQzBHbUFTRUNJQUVnQkVZTjZnRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJ3ZFFBYWkwQUFFY05GeUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU02d0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJHQXdYQ3lBQklBUkdCRUJCcFFFaEFnenFBUXNDUUFKQUlBRXRBQUJCeVFCckRnY0FHUmtaR1JrQkdRc2dBVUVCYWlFQlFZc0JJUUlNMFFFTElBRkJBV29oQVVHTUFTRUNETkFCQzBHa0FTRUNJQUVnQkVZTjZBRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwdFVBYWkwQUFFY05GU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU02UUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJDUXdWQzBHakFTRUNJQUVnQkVZTjV3RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwTlVBYWkwQUFFY05GQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU02QUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJId3dVQzBHaUFTRUNJQUVnQkVZTjVnRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJ2dFFBYWkwQUFFY05FeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU01d0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJBZ3dUQzBHaEFTRUNJQUVnQkVZTjVRRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0EwQWdBUzBBQUNBQVFielVBR290QUFCSERSRWdBRUVCUmcwQ0lBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURPVUJDeUFCSUFSR0JFQkJvQUVoQWd6bEFRdEJBU0FCTFFBQVFkOEFSdzBSR2lBQlFRRnFJUUZCaHdFaEFnekxBUXNnQTBFQU5nSUFJQVpCQVdvaEFVR0lBU0VDRE1vQkMwR2ZBU0VDSUFFZ0JFWU40Z0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSWFpRUdBa0FEUUNBQkxRQUFJQUJCaE5VQWFpMEFBRWNORHlBQVFRaEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNNHdFTElBTkJBRFlDQUNBR1FRRnFJUUZCS1F3UEMwR2VBU0VDSUFFZ0JFWU40UUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCdU5RQWFpMEFBRWNORGlBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNNGdFTElBTkJBRFlDQUNBR1FRRnFJUUZCTFF3T0N5QUJJQVJHQkVCQm5RRWhBZ3poQVFzZ0FTMEFBRUhGQUVjTkRpQUJRUUZxSVFGQmhBRWhBZ3pIQVFzZ0FTQUVSZ1JBUVp3QklRSU00QUVMQWtBQ1FDQUJMUUFBUWN3QWF3NElBQThQRHc4UER3RVBDeUFCUVFGcUlRRkJnZ0VoQWd6SEFRc2dBVUVCYWlFQlFZTUJJUUlNeGdFTFFac0JJUUlnQVNBRVJnM2VBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUd6MUFCcUxRQUFSdzBMSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpmQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVqREFzTFFab0JJUUlnQVNBRVJnM2RBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUd3MUFCcUxRQUFSdzBLSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXplQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVBREFvTElBRWdCRVlFUUVHWkFTRUNETjBCQ3dKQUFrQWdBUzBBQUVISUFHc09DQUFNREF3TURBd0JEQXNnQVVFQmFpRUJRZjBBSVFJTXhBRUxJQUZCQVdvaEFVR0FBU0VDRE1NQkN5QUJJQVJHQkVCQm1BRWhBZ3pjQVFzQ1FBSkFJQUV0QUFCQnpnQnJEZ01BQ3dFTEN5QUJRUUZxSVFGQi9nQWhBZ3pEQVFzZ0FVRUJhaUVCUWY4QUlRSU13Z0VMSUFFZ0JFWUVRRUdYQVNFQ0ROc0JDeUFCTFFBQVFka0FSdzBJSUFGQkFXb2hBVUVJREFjTFFaWUJJUUlnQVNBRVJnM1pBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFOcUlRWUNRQU5BSUFFdEFBQWdBRUdzMUFCcUxRQUFSdzBHSUFCQkEwWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXphQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVGREFZTFFaVUJJUUlnQVNBRVJnM1lBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdtMUFCcUxRQUFSdzBGSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpaQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVXREFVTFFaUUJJUUlnQVNBRVJnM1hBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdoMVFCcUxRQUFSdzBFSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpZQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVRREFRTElBRWdCRVlFUUVHVEFTRUNETmNCQ3dKQUFrQWdBUzBBQUVIREFHc09EQUFHQmdZR0JnWUdCZ1lHQVFZTElBRkJBV29oQVVINUFDRUNETDRCQ3lBQlFRRnFJUUZCK2dBaEFneTlBUXRCa2dFaEFpQUJJQVJHRGRVQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFhRFVBR290QUFCSERRSWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROWUJDeUFEUVFBMkFnQWdCa0VCYWlFQlFTUU1BZ3NnQTBFQU5nSUFEQUlMSUFFZ0JFWUVRRUdSQVNFQ0ROUUJDeUFCTFFBQVFjd0FSdzBCSUFGQkFXb2hBVUVUQ3pvQUtTQURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzRpQUEwQ0RBRUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CL2g4MkFoQWdBMEVHTmdJTURORUJDMEg0QUNFQ0RMY0JDeUFEUVpBQk5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNETThCQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1FDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmdnODJBaEFnQTBFZ05nSU1RUUFoQWd6T0FRdEI5d0FoQWd5MEFRc2dBMEdQQVRZQ0hDQURJQUUyQWhRZ0EwSHNHellDRUNBRFFSVTJBZ3hCQUNFQ0RNd0JDeUFCSUFSR0JFQkJqd0VoQWd6TUFRc0NRQ0FCTFFBQVFTQkdCRUFnQVVFQmFpRUJEQUVMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdiSHpZQ0VDQURRUVkyQWd4QkFDRUNETXdCQzBFQ0lRSU1zZ0VMQTBBZ0FTMEFBRUVnUncwQ0lBUWdBVUVCYWlJQlJ3MEFDMEdPQVNFQ0RNb0JDeUFCSUFSR0JFQkJqUUVoQWd6S0FRc0NRQ0FCTFFBQVFRbHJEZ1JLQUFCS0FBdEI5UUFoQWd5d0FRc2dBeTBBS1VFRlJnUkFRZllBSVFJTXNBRUxRZlFBSVFJTXJ3RUxJQUVnQkVZRVFFR01BU0VDRE1nQkN5QURRUkEyQWdnZ0F5QUJOZ0lFREFvTElBRWdCRVlFUUVHTEFTRUNETWNCQ3dKQUlBRXRBQUJCQ1dzT0JFY0FBRWNBQzBIekFDRUNESzBCQ3lBQklBUkhCRUFnQTBFUU5nSUlJQU1nQVRZQ0JFSHhBQ0VDREswQkMwR0tBU0VDRE1VQkN3SkFJQUVnQkVjRVFBTkFJQUV0QUFCQm9OQUFhaTBBQUNJQVFRTkhCRUFDUUNBQVFRRnJEZ0pKQUFRTFFmQUFJUUlNcndFTElBUWdBVUVCYWlJQlJ3MEFDMEdJQVNFQ0RNWUJDMEdJQVNFQ0RNVUJDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkIyeUEyQWhBZ0EwRUhOZ0lNUVFBaEFnekVBUXNnQVNBRVJnUkFRWWtCSVFJTXhBRUxBa0FDUUFKQUlBRXRBQUJCb05JQWFpMEFBRUVCYXc0RFJnSUFBUXRCOGdBaEFneXNBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYlFTTmdJUUlBTkJCellDREVFQUlRSU14QUVMUWVvQUlRSU1xZ0VMSUFFZ0JFY0VRQ0FCUVFGcUlRRkI3d0FoQWd5cUFRdEJod0VoQWd6Q0FRc2dCQ0FCSWdCR0JFQkJoZ0VoQWd6Q0FRc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZTRBSVFJTXFRRUxJQUZCQ1dzaUFrRVhTdzBCSUFBaEFVRUJJQUowUVp1QWdBUnhEVUVNQVFzZ0JDQUJJZ0JHQkVCQmhRRWhBZ3pCQVFzZ0FDMEFBRUV2UncwQUlBQkJBV29oQVF3REMwRUFJUUlnQTBFQU5nSWNJQU1nQURZQ0ZDQURRZHNnTmdJUUlBTkJCellDREF5L0FRc0NRQUpBQWtBQ1FBSkFBMEFnQVMwQUFFR2d6Z0JxTFFBQUlnQkJCVWNFUUFKQUFrQWdBRUVCYXc0SVJ3VUdCd2dBQkFFSUMwSHJBQ0VDREswQkN5QUJRUUZxSVFGQjdRQWhBZ3lzQVFzZ0JDQUJRUUZxSWdGSERRQUxRWVFCSVFJTXd3RUxJQUZCQVdvTUZBc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFzSWdCRkRSNGdBMEhiQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFnekJBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBc0lnQkZEUjRnQTBIZEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3pBQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXNJZ0JGRFI0Z0EwSDZBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5L0FRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFma1BOZ0lRSUFOQkJ6WUNERUVBSVFJTXZnRUxJQUVnQkVZRVFFR0RBU0VDREw0QkN3SkFJQUV0QUFCQm9NNEFhaTBBQUVFQmF3NElQZ1FGQmdBSUFnTUhDeUFCUVFGcUlRRUxRUU1oQWd5akFRc2dBVUVCYWd3TkMwRUFJUUlnQTBFQU5nSWNJQU5CMFJJMkFoQWdBMEVITmdJTUlBTWdBVUVCYWpZQ0ZBeTZBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBc0lnQkZEUllnQTBIYkFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3k1QVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXNJZ0JGRFJZZ0EwSGRBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5NEFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFzSWdCRkRSWWdBMEg2QURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneTNBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZmtQTmdJUUlBTkJCellDREVFQUlRSU10Z0VMUWV3QUlRSU1uQUVMSUFFZ0JFWUVRRUdDQVNFQ0RMVUJDeUFCUVFGcURBSUxJQUVnQkVZRVFFR0JBU0VDRExRQkN5QUJRUUZxREFFTElBRWdCRVlOQVNBQlFRRnFDeUVCUVFRaEFneVlBUXRCZ0FFaEFneXdBUXNEUUNBQkxRQUFRYURNQUdvdEFBQWlBRUVDUndSQUlBQkJBVWNFUUVIcEFDRUNESmtCQ3d3eEN5QUVJQUZCQVdvaUFVY05BQXRCL3dBaEFneXZBUXNnQVNBRVJnUkFRZjRBSVFJTXJ3RUxBa0FnQVMwQUFFRUphdzQzTHdNR0x3UUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUZCZ1lDQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQUFZTElBRkJBV29MSVFGQkJTRUNESlFCQ3lBQlFRRnFEQVlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxDSUFSUTBJSUFOQjJ3QTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNcXdFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMQ0lBUlEwSUlBTkIzUUEyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTXFnRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTENJQVJRMElJQU5CK2dBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1xUUVMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdORkRZQ0VDQURRUWMyQWd4QkFDRUNES2dCQ3dKQUFrQUNRQUpBQTBBZ0FTMEFBRUdneWdCcUxRQUFJZ0JCQlVjRVFBSkFJQUJCQVdzT0JpNERCQVVHQUFZTFFlZ0FJUUlNbEFFTElBUWdBVUVCYWlJQlJ3MEFDMEg5QUNFQ0RLc0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUN3aUFFVU5CeUFEUWRzQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNES29CQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDd2lBRVVOQnlBRFFkMEFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREtrQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3dpQUVVTkJ5QURRZm9BTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RLZ0JDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkI1QWcyQWhBZ0EwRUhOZ0lNUVFBaEFneW5BUXNnQVNBRVJnMEJJQUZCQVdvTElRRkJCaUVDREl3QkMwSDhBQ0VDREtRQkN3SkFBa0FDUUFKQUEwQWdBUzBBQUVHZ3lBQnFMUUFBSWdCQkJVY0VRQ0FBUVFGckRnUXBBZ01FQlFzZ0JDQUJRUUZxSWdGSERRQUxRZnNBSVFJTXB3RUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTENJQVJRMERJQU5CMndBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1wZ0VMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxDSUFSUTBESUFOQjNRQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNcFFFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMQ0lBUlEwRElBTkIrZ0EyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTXBBRUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRzhDallDRUNBRFFRYzJBZ3hCQUNFQ0RLTUJDMEhQQUNFQ0RJa0JDMEhSQUNFQ0RJZ0JDMEhuQUNFQ0RJY0JDeUFCSUFSR0JFQkIrZ0FoQWd5Z0FRc0NRQ0FCTFFBQVFRbHJEZ1FnQUFBZ0FBc2dBVUVCYWlFQlFlWUFJUUlNaGdFTElBRWdCRVlFUUVINUFDRUNESjhCQ3dKQUlBRXRBQUJCQ1dzT0JCOEFBQjhBQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ09DSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQVJRUkFRZUlCSVFJTWhnRUxJQUJCRlVjRVFDQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnlRMDJBaEFnQTBFYU5nSU1RUUFoQWd5ZkFRc2dBMEg0QURZQ0hDQURJQUUyQWhRZ0EwSHFHallDRUNBRFFSVTJBZ3hCQUNFQ0RKNEJDeUFCSUFSSEJFQWdBMEVOTmdJSUlBTWdBVFlDQkVIa0FDRUNESVVCQzBIM0FDRUNESjBCQ3lBQklBUkdCRUJCOWdBaEFneWRBUXNDUUFKQUFrQWdBUzBBQUVISUFHc09Dd0FCQ3dzTEN3c0xDd3NDQ3dzZ0FVRUJhaUVCUWQwQUlRSU1oUUVMSUFGQkFXb2hBVUhnQUNFQ0RJUUJDeUFCUVFGcUlRRkI0d0FoQWd5REFRdEI5UUFoQWlBQklBUkdEWnNCSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJYVkFHb3RBQUJIRFFnZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBREp3QkN5QURLQUlFSVFBZ0EwSUFOd01BSUFNZ0FDQUdRUUZxSWdFUUt5SUFCRUFnQTBIMEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3ljQVF0QjRnQWhBZ3lDQVF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FqUWlBa1VOQUNBRElBSVJBQUFoQUFzQ1FDQUFCRUFnQUVFVlJnMEJJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSHFEVFlDRUNBRFFTWTJBZ3hCQUNFQ0RKd0JDMEhoQUNFQ0RJSUJDeUFEUWZNQU5nSWNJQU1nQVRZQ0ZDQURRWUFiTmdJUUlBTkJGVFlDREVFQUlRSU1tZ0VMSUFNdEFDa2lBRUVqYTBFTFNRMEpBa0FnQUVFR1N3MEFRUUVnQUhSQnlnQnhSUTBBREFvTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI3UWsyQWhBZ0EwRUlOZ0lNREprQkMwSHlBQ0VDSUFFZ0JFWU5tQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCczlVQWFpMEFBRWNOQlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNbVFFTElBTW9BZ1FoQUNBRFFnQTNBd0FnQXlBQUlBWkJBV29pQVJBcklnQUVRQ0FEUWZFQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESmtCQzBIZkFDRUNESDhMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FJMElnSkZEUUFnQXlBQ0VRQUFJUUFMQWtBZ0FBUkFJQUJCRlVZTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjZnMDJBaEFnQTBFbU5nSU1RUUFoQWd5WkFRdEIzZ0FoQWd4L0N5QURRZkFBTmdJY0lBTWdBVFlDRkNBRFFZQWJOZ0lRSUFOQkZUWUNERUVBSVFJTWx3RUxJQU10QUNsQklVWU5CaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJrUW8yQWhBZ0EwRUlOZ0lNUVFBaEFneVdBUXRCN3dBaEFpQUJJQVJHRFpVQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFiRFZBR290QUFCSERRSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURKWUJDeUFES0FJRUlRQWdBMElBTndNQUlBTWdBQ0FHUVFGcUlnRVFLeUlBUlEwQ0lBTkI3UUEyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTWxRRUxJQU5CQURZQ0FBc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRZQUJJQU5CN2dBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1rd0VMUWR3QUlRSU1lUXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpRaUFrVU5BQ0FESUFJUkFBQWhBQXNDUUNBQUJFQWdBRUVWUmcwQklBTkJBRFlDSENBRElBRTJBaFFnQTBIcURUWUNFQ0FEUVNZMkFneEJBQ0VDREpNQkMwSGJBQ0VDREhrTElBTkI3QUEyQWh3Z0F5QUJOZ0lVSUFOQmdCczJBaEFnQTBFVk5nSU1RUUFoQWd5UkFRc2dBeTBBS1NJQVFTTkpEUUFnQUVFdVJnMEFJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSEpDVFlDRUNBRFFRZzJBZ3hCQUNFQ0RKQUJDMEhhQUNFQ0RIWUxJQUVnQkVZRVFFSHJBQ0VDREk4QkN3SkFJQUV0QUFCQkwwWUVRQ0FCUVFGcUlRRU1BUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYkk0TmdJUUlBTkJDRFlDREVFQUlRSU1qd0VMUWRrQUlRSU1kUXNnQVNBRVJ3UkFJQU5CRGpZQ0NDQURJQUUyQWdSQjJBQWhBZ3gxQzBIcUFDRUNESTBCQ3lBQklBUkdCRUJCNlFBaEFneU5BUXNnQVMwQUFFRXdheUlBUWY4QmNVRUtTUVJBSUFNZ0FEb0FLaUFCUVFGcUlRRkIxd0FoQWd4MEN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzhpQUVVTmVpQURRZWdBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RJd0JDeUFCSUFSR0JFQkI1d0FoQWd5TUFRc0NRQ0FCTFFBQVFTNUdCRUFnQVVFQmFpRUJEQUVMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUx5SUFSUTE3SUFOQjVnQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNakFFTFFkWUFJUUlNY2dzZ0FTQUVSZ1JBUWVVQUlRSU1pd0VMUVFBaEFFRUJJUVZCQVNFSFFRQWhBZ0pBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09DZ29KQUFFQ0F3UUZCZ2dMQzBFQ0RBWUxRUU1NQlF0QkJBd0VDMEVGREFNTFFRWU1BZ3RCQnd3QkMwRUlDeUVDUVFBaEJVRUFJUWNNQWd0QkNTRUNRUUVoQUVFQUlRVkJBQ0VIREFFTFFRQWhCVUVCSVFJTElBTWdBam9BS3lBQlFRRnFJUUVDUUFKQUlBTXRBQzVCRUhFTkFBSkFBa0FDUUNBRExRQXFEZ01CQUFJRUN5QUhSUTBEREFJTElBQU5BUXdDQ3lBRlJRMEJDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM4aUFFVU5BaUFEUWVJQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESTBCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDOGlBRVVOZlNBRFFlTUFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREl3QkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzhpQUVVTmV5QURRZVFBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3dNaXdFTFFkUUFJUUlNY1FzZ0F5MEFLVUVpUmcyR0FVSFRBQ0VDREhBTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSkVJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQkZCRUJCMVFBaEFneHdDeUFBUVJWSEJFQWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFhUU5OZ0lRSUFOQklUWUNERUVBSVFJTWlRRUxJQU5CNFFBMkFod2dBeUFCTmdJVUlBTkIwQm8yQWhBZ0EwRVZOZ0lNUVFBaEFneUlBUXNnQVNBRVJnUkFRZUFBSVFJTWlBRUxBa0FDUUFKQUFrQUNRQ0FCTFFBQVFRcHJEZ1FCQkFRQUJBc2dBVUVCYWlFQkRBRUxJQUZCQVdvaEFTQURRUzlxTFFBQVFRRnhSUTBCQzBIU0FDRUNESEFMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEcyRVRZQ0VDQURRUWsyQWd4QkFDRUNESWdCQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CdGhFMkFoQWdBMEVKTmdJTVFRQWhBZ3lIQVFzZ0FTQUVSZ1JBUWQ4QUlRSU1od0VMSUFFdEFBQkJDa1lFUUNBQlFRRnFJUUVNQ1FzZ0F5MEFMa0hBQUhFTkNDQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnRoRTJBaEFnQTBFQ05nSU1RUUFoQWd5R0FRc2dBU0FFUmdSQVFkMEFJUUlNaGdFTElBRXRBQUFpQWtFTlJnUkFJQUZCQVdvaEFVSFFBQ0VDREcwTElBRWhBQ0FDUVFsckRnUUZBUUVGQVFzZ0JDQUJJZ0JHQkVCQjNBQWhBZ3lGQVFzZ0FDMEFBRUVLUncwQUlBQkJBV29NQWd0QkFDRUNJQU5CQURZQ0hDQURJQUEyQWhRZ0EwSEtMVFlDRUNBRFFRYzJBZ3dNZ3dFTElBRWdCRVlFUUVIYkFDRUNESU1CQ3dKQUlBRXRBQUJCQ1dzT0JBTUFBQU1BQ3lBQlFRRnFDeUVCUWM0QUlRSU1hQXNnQVNBRVJnUkFRZG9BSVFJTWdRRUxJQUV0QUFCQkNXc09CQUFCQVFBQkMwRUFJUUlnQTBFQU5nSWNJQU5CbWhJMkFoQWdBMEVITmdJTUlBTWdBVUVCYWpZQ0ZBeC9DeUFEUVlBU093RXFRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUk0SWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGRFFBZ0FFRVZSdzBCSUFOQjJRQTJBaHdnQXlBQk5nSVVJQU5CNmhvMkFoQWdBMEVWTmdJTVFRQWhBZ3grQzBITkFDRUNER1FMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhKRFRZQ0VDQURRUm8yQWd4QkFDRUNESHdMSUFFZ0JFWUVRRUhaQUNFQ0RId0xJQUV0QUFCQklFY05QU0FCUVFGcUlRRWdBeTBBTGtFQmNRMDlJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSENIRFlDRUNBRFFSNDJBZ3hCQUNFQ0RIc0xJQUVnQkVZRVFFSFlBQ0VDREhzTEFrQUNRQUpBQWtBQ1FDQUJMUUFBSWdCQkNtc09CQUlEQXdBQkN5QUJRUUZxSVFGQkxDRUNER1VMSUFCQk9rY05BU0FEUVFBMkFod2dBeUFCTmdJVUlBTkI1eEUyQWhBZ0EwRUtOZ0lNUVFBaEFneDlDeUFCUVFGcUlRRWdBMEV2YWkwQUFFRUJjVVVOY3lBRExRQXlRWUFCY1VVRVFDQURRVEpxSVFJZ0F4QTFRUUFoQUFKQUlBTW9BamdpQmtVTkFDQUdLQUlvSWdaRkRRQWdBeUFHRVFBQUlRQUxBa0FDUUNBQURoWk5URXNCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFzZ0EwRXBOZ0ljSUFNZ0FUWUNGQ0FEUWF3Wk5nSVFJQU5CRlRZQ0RFRUFJUUlNZmdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVVTE5nSVFJQU5CRVRZQ0RFRUFJUUlNZlF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Fsd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5XU0FBUVJWSERRRWdBMEVGTmdJY0lBTWdBVFlDRkNBRFFac2JOZ0lRSUFOQkZUWUNERUVBSVFJTWZBdEJ5d0FoQWd4aUMwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWkFPTmdJUUlBTkJGRFlDREF4NkN5QURJQU12QVRKQmdBRnlPd0V5RERzTElBRWdCRWNFUUNBRFFSRTJBZ2dnQXlBQk5nSUVRY29BSVFJTVlBdEIxd0FoQWd4NEN5QUJJQVJHQkVCQjFnQWhBZ3g0Q3dKQUFrQUNRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlTUFhdzRUQUVCQVFFQkFRRUJBUUVCQVFBRkFRRUFDQTBBTElBRkJBV29oQVVIR0FDRUNER0VMSUFGQkFXb2hBVUhIQUNFQ0RHQUxJQUZCQVdvaEFVSElBQ0VDREY4TElBRkJBV29oQVVISkFDRUNERjRMUWRVQUlRSWdCQ0FCSWdCR0RYWWdCQ0FCYXlBREtBSUFJZ0ZxSVFZZ0FDQUJhMEVGYWlFSEEwQWdBVUdReUFCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwSVFRUWdBVUVGUmcwS0dpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQU1nQmpZQ0FBeDJDMEhVQUNFQ0lBUWdBU0lBUmcxMUlBUWdBV3NnQXlnQ0FDSUJhaUVHSUFBZ0FXdEJEMm9oQndOQUlBRkJnTWdBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOQjBFRElBRkJEMFlOQ1JvZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QURJQVkyQWdBTWRRdEIwd0FoQWlBRUlBRWlBRVlOZENBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRNXFJUWNEUUNBQlFlTEhBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUVlnQVVFT1JnMEhJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBR05nSUFESFFMUWRJQUlRSWdCQ0FCSWdCR0RYTWdCQ0FCYXlBREtBSUFJZ0ZxSVFVZ0FDQUJhMEVCYWlFR0EwQWdBVUhneHdCcUxRQUFJQUF0QUFBaUIwRWdjaUFISUFkQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwRklBRkJBVVlOQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBTWdCVFlDQUF4ekN5QUJJQVJHQkVCQjBRQWhBZ3h6Q3dKQUFrQWdBUzBBQUNJQVFTQnlJQUFnQUVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZCN2dCckRnY0FPVGs1T1RrQk9Rc2dBVUVCYWlFQlFjTUFJUUlNV2dzZ0FVRUJhaUVCUWNRQUlRSU1XUXNnQTBFQU5nSUFJQVpCQVdvaEFVSEZBQ0VDREZnTFFkQUFJUUlnQkNBQklnQkdEWEFnQkNBQmF5QURLQUlBSWdGcUlRWWdBQ0FCYTBFSmFpRUhBMEFnQVVIV3h3QnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MENRUUlnQVVFSlJnMEVHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXh3QzBIUEFDRUNJQVFnQVNJQVJnMXZJQVFnQVdzZ0F5Z0NBQ0lCYWlFR0lBQWdBV3RCQldvaEJ3TkFJQUZCME1jQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTkFTQUJRUVZHRFFJZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QURJQVkyQWdBTWJ3c2dBQ0VCSUFOQkFEWUNBQXd6QzBFQkN6b0FMQ0FEUVFBMkFnQWdCMEVCYWlFQkMwRXRJUUlNVWdzQ1FBTkFJQUV0QUFCQjBNVUFhaTBBQUVFQlJ3MEJJQVFnQVVFQmFpSUJSdzBBQzBITkFDRUNER3NMUWNJQUlRSU1VUXNnQVNBRVJnUkFRY3dBSVFJTWFnc2dBUzBBQUVFNlJnUkFJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTUNJQVJRMHpJQU5CeXdBMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNYWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVjUk5nSVFJQU5CQ2pZQ0RFRUFJUUlNYVFzQ1FBSkFJQU10QUN4QkFtc09BZ0FCSndzZ0EwRXphaTBBQUVFQ2NVVU5KaUFETFFBdVFRSnhEU1lnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYVlVTmdJUUlBTkJDellDREVFQUlRSU1hUXNnQXkwQU1rRWdjVVVOSlNBRExRQXVRUUp4RFNVZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWIwVE5nSVFJQU5CRHpZQ0RFRUFJUUlNYUF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FrZ2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVUVRRUhCQUNFQ0RFOExJQUJCRlVjRVFDQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnBnODJBaEFnQTBFY05nSU1RUUFoQWd4b0N5QURRY29BTmdJY0lBTWdBVFlDRkNBRFFZVWNOZ0lRSUFOQkZUWUNERUVBSVFJTVp3c2dBU0FFUndSQUEwQWdBUzBBQUVIQXdRQnFMUUFBUVFGSERSY2dCQ0FCUVFGcUlnRkhEUUFMUWNRQUlRSU1ad3RCeEFBaEFneG1DeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUUySVFJTVVnc2dBVUVCYWlFQlFUY2hBZ3hSQ3lBQlFRRnFJUUZCT0NFQ0RGQUxEQlVMSUFRZ0FVRUJhaUlCUncwQUMwRThJUUlNWmd0QlBDRUNER1VMSUFFZ0JFWUVRRUhJQUNFQ0RHVUxJQU5CRWpZQ0NDQURJQUUyQWdRQ1FBSkFBa0FDUUFKQUlBTXRBQ3hCQVdzT0JCUUFBUUlKQ3lBRExRQXlRU0J4RFFOQjRBRWhBZ3hQQ3dKQUlBTXZBVElpQUVFSWNVVU5BQ0FETFFBb1FRRkhEUUFnQXkwQUxrRUljVVVOQWdzZ0F5QUFRZmY3QTNGQmdBUnlPd0V5REFzTElBTWdBeThCTWtFUWNqc0JNZ3dFQ3lBRFFRQTJBZ1FnQXlBQklBRVFNU0lBQkVBZ0EwSEJBRFlDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVUVFBaEFneG1DeUFCUVFGcUlRRU1XQXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZlFUTmdJUUlBTkJCRFlDREVFQUlRSU1aQXRCeHdBaEFpQUJJQVJHRFdNZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUdhaUVHQWtBRFFDQUFRY0RGQUdvdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0RVb2dBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1aQXNnQTBFQU5nSUFEQVVMQWtBZ0FTQUVSd1JBQTBBZ0FTMEFBRUhBd3dCcUxRQUFJZ0JCQVVjRVFDQUFRUUpIRFFNZ0FVRUJhaUVCREFVTElBUWdBVUVCYWlJQlJ3MEFDMEhGQUNFQ0RHUUxRY1VBSVFJTVl3c0xJQU5CQURvQUxBd0JDMEVMSVFJTVJ3dEJQeUVDREVZTEFrQUNRQU5BSUFFdEFBQWlBRUVnUndSQUFrQWdBRUVLYXc0RUF3VUZBd0FMSUFCQkxFWU5Bd3dFQ3lBRUlBRkJBV29pQVVjTkFBdEJ4Z0FoQWd4Z0N5QURRUWc2QUN3TURnc2dBeTBBS0VFQlJ3MENJQU10QUM1QkNIRU5BaUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRURFaUFBUkFJQU5Cd2dBMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNWHdzZ0FVRUJhaUVCREZBTFFUc2hBZ3hFQ3dKQUEwQWdBUzBBQUNJQVFTQkhJQUJCQ1VkeERRRWdCQ0FCUVFGcUlnRkhEUUFMUWNNQUlRSU1YUXNMUVR3aEFneENDd0pBQWtBZ0FTQUVSd1JBQTBBZ0FTMEFBQ0lBUVNCSEJFQWdBRUVLYXc0RUF3UUVBd1FMSUFRZ0FVRUJhaUlCUncwQUMwRS9JUUlNWFF0QlB5RUNERndMSUFNZ0F5OEJNa0VnY2pzQk1nd0tDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRURFaUFFVU5UaUFEUVQ0MkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1XZ3NDUUNBQklBUkhCRUFEUUNBQkxRQUFRY0REQUdvdEFBQWlBRUVCUndSQUlBQkJBa1lOQXd3TUN5QUVJQUZCQVdvaUFVY05BQXRCTnlFQ0RGc0xRVGNoQWd4YUN5QUJRUUZxSVFFTUJBdEJPeUVDSUFRZ0FTSUFSZzFZSUFRZ0FXc2dBeWdDQUNJQmFpRUdJQUFnQVd0QkJXb2hCd0pBQTBBZ0FVR1F5QUJxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkJVWUVRRUVISVFFTVB3c2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFESUFZMkFnQU1XUXNnQTBFQU5nSUFJQUFoQVF3RkMwRTZJUUlnQkNBQklnQkdEVmNnQkNBQmF5QURLQUlBSWdGcUlRWWdBQ0FCYTBFSWFpRUhBa0FEUUNBQlFiVEJBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUUVnQVVFSVJnUkFRUVVoQVF3K0N5QUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQU1nQmpZQ0FBeFlDeUFEUVFBMkFnQWdBQ0VCREFRTFFUa2hBaUFFSUFFaUFFWU5WaUFFSUFGcklBTW9BZ0FpQVdvaEJpQUFJQUZyUVFOcUlRY0NRQU5BSUFGQnNNRUFhaTBBQUNBQUxRQUFJZ1ZCSUhJZ0JTQUZRY0VBYTBIL0FYRkJHa2tiUWY4QmNVY05BU0FCUVFOR0JFQkJCaUVCREQwTElBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBeUFHTmdJQURGY0xJQU5CQURZQ0FDQUFJUUVNQXdzQ1FBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CQWNFQkFjQ0N5QUVJQUZCQVdvaUFVY05BQXRCT0NFQ0RGWUxJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FETFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQU5CQVRvQUxDQURJQU12QVRJZ0FYSTdBVElnQUNFQkRBRUxJQU1nQXk4Qk1rRUljanNCTWlBQUlRRUxRVDRoQWd3N0N5QURRUUE2QUN3TFFUa2hBZ3c1Q3lBQklBUkdCRUJCTmlFQ0RGSUxBa0FDUUFKQUFrQUNRQ0FCTFFBQVFRcHJEZ1FBQWdJQkFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF4SWdCRkRRSWdBMEV6TmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RGVUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTVNJQVJRUkFJQUZCQVdvaEFRd0dDeUFEUVRJMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNVkFzZ0F5MEFMa0VCY1FSQVFkOEJJUUlNT3dzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXhJZ0FOQVF4SkMwRTBJUUlNT1FzZ0EwRTFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREZFTFFUVWhBZ3czQ3lBRFFTOXFMUUFBUVFGeERRQWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFlc1dOZ0lRSUFOQkdUWUNERUVBSVFJTVR3dEJNeUVDRERVTElBRWdCRVlFUUVFeUlRSU1UZ3NDUUNBQkxRQUFRUXBHQkVBZ0FVRUJhaUVCREFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBHU0Z6WUNFQ0FEUVFNMkFneEJBQ0VDREU0TFFUSWhBZ3cwQ3lBQklBUkdCRUJCTVNFQ0RFMExBa0FnQVMwQUFDSUFRUWxHRFFBZ0FFRWdSZzBBUVFFaEFnSkFJQU10QUN4QkJXc09CQVlFQlFBTkN5QURJQU12QVRKQkNISTdBVElNREFzZ0F5MEFMa0VCY1VVTkFTQURMUUFzUVFoSERRQWdBMEVBT2dBc0MwRTlJUUlNTWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNJV05nSVFJQU5CQ2pZQ0RFRUFJUUlNU2d0QkFpRUNEQUVMUVFRaEFnc2dBMEVCT2dBc0lBTWdBeThCTWlBQ2Nqc0JNZ3dHQ3lBQklBUkdCRUJCTUNFQ0RFY0xJQUV0QUFCQkNrWUVRQ0FCUVFGcUlRRU1BUXNnQXkwQUxrRUJjUTBBSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhjS0RZQ0VDQURRUUkyQWd4QkFDRUNERVlMUVRBaEFnd3NDeUFCUVFGcUlRRkJNU0VDRENzTElBRWdCRVlFUUVFdklRSU1SQXNnQVMwQUFDSUFRUWxISUFCQklFZHhSUVJBSUFGQkFXb2hBU0FETFFBdVFRRnhEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWmNRTmdJUUlBTkJDallDREVFQUlRSU1SQXRCQVNFQ0FrQUNRQUpBQWtBQ1FBSkFJQU10QUN4QkFtc09Cd1VFQkFNQkFnQUVDeUFESUFNdkFUSkJDSEk3QVRJTUF3dEJBaUVDREFFTFFRUWhBZ3NnQTBFQk9nQXNJQU1nQXk4Qk1pQUNjanNCTWd0Qkx5RUNEQ3NMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdFRXpZQ0VDQURRUXMyQWd4QkFDRUNERU1MUWVFQklRSU1LUXNnQVNBRVJnUkFRUzRoQWd4Q0N5QURRUUEyQWdRZ0EwRVNOZ0lJSUFNZ0FTQUJFREVpQUEwQkMwRXVJUUlNSndzZ0EwRXROZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREQ4TFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSk1JZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQU5CMkFBMkFod2dBeUFCTmdJVUlBTkJzeHMyQWhBZ0EwRVZOZ0lNUVFBaEFndytDMEhNQUNFQ0RDUUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR3pEallDRUNBRFFSMDJBZ3hCQUNFQ0REd0xJQUVnQkVZRVFFSE9BQ0VDRER3TElBRXRBQUFpQUVFZ1JnMENJQUJCT2tZTkFRc2dBMEVBT2dBc1FRa2hBZ3doQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVEQWlBQTBCREFJTElBTXRBQzVCQVhFRVFFSGVBU0VDRENBTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFNQ0lBUlEwQ0lBTkJLallDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVUVFBaEFndzRDeUFEUWNzQU5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDRERjTElBRkJBV29oQVVIQUFDRUNEQjBMSUFGQkFXb2hBUXdzQ3lBQklBUkdCRUJCS3lFQ0REVUxBa0FnQVMwQUFFRUtSZ1JBSUFGQkFXb2hBUXdCQ3lBRExRQXVRY0FBY1VVTkJnc2dBeTBBTWtHQUFYRUVRRUVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDWENJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlEwU0lBQkJGVVlFUUNBRFFRVTJBaHdnQXlBQk5nSVVJQU5CbXhzMkFoQWdBMEVWTmdJTVFRQWhBZ3cyQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5Ca0E0MkFoQWdBMEVVTmdJTVFRQWhBZ3cxQ3lBRFFUSnFJUUlnQXhBMVFRQWhBQUpBSUFNb0FqZ2lCa1VOQUNBR0tBSW9JZ1pGRFFBZ0F5QUdFUUFBSVFBTElBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QURRUUU2QURBTElBSWdBaThCQUVIQUFISTdBUUFMUVNzaEFnd1lDeUFEUVNrMkFod2dBeUFCTmdJVUlBTkJyQmsyQWhBZ0EwRVZOZ0lNUVFBaEFnd3dDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkI1UXMyQWhBZ0EwRVJOZ0lNUVFBaEFnd3ZDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJwUXMyQWhBZ0EwRUNOZ0lNUVFBaEFnd3VDMEVCSVFjZ0F5OEJNaUlGUVFoeFJRUkFJQU1wQXlCQ0FGSWhCd3NDUUNBRExRQXdCRUJCQVNFQUlBTXRBQ2xCQlVZTkFTQUZRY0FBY1VVZ0IzRkZEUUVMQWtBZ0F5MEFLQ0lDUVFKR0JFQkJBU0VBSUFNdkFUUWlCa0hsQUVZTkFrRUFJUUFnQlVIQUFIRU5BaUFHUWVRQVJnMENJQVpCNWdCclFRSkpEUUlnQmtITUFVWU5BaUFHUWJBQ1JnMENEQUVMUVFBaEFDQUZRY0FBY1EwQkMwRUNJUUFnQlVFSWNRMEFJQVZCZ0FSeEJFQUNRQ0FDUVFGSERRQWdBeTBBTGtFS2NRMEFRUVVoQUF3Q0MwRUVJUUFNQVFzZ0JVRWdjVVVFUUNBREVEWkJBRWRCQW5RaEFBd0JDMEVBUVFNZ0F5a0RJRkFiSVFBTElBQkJBV3NPQlFJQUJ3RURCQXRCRVNFQ0RCTUxJQU5CQVRvQU1Rd3BDMEVBSVFJQ1FDQURLQUk0SWdCRkRRQWdBQ2dDTUNJQVJRMEFJQU1nQUJFQUFDRUNDeUFDUlEwbUlBSkJGVVlFUUNBRFFRTTJBaHdnQXlBQk5nSVVJQU5CMGhzMkFoQWdBMEVWTmdJTVFRQWhBZ3dyQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkME9OZ0lRSUFOQkVqWUNEQXdxQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CK1NBMkFoQWdBMEVQTmdJTVFRQWhBZ3dwQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ01DSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQURRRUxRUTRoQWd3T0N5QUFRUlZHQkVBZ0EwRUNOZ0ljSUFNZ0FUWUNGQ0FEUWRJYk5nSVFJQU5CRlRZQ0RFRUFJUUlNSndzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWQwT05nSVFJQU5CRWpZQ0RFRUFJUUlNSmd0QktpRUNEQXdMSUFFZ0JFY0VRQ0FEUVFrMkFnZ2dBeUFCTmdJRVFTa2hBZ3dNQzBFbUlRSU1KQXNnQXlBREtRTWdJZ3dnQkNBQmE2MGlDbjBpQzBJQUlBc2dERmdiTndNZ0lBb2dERlFFUUVFbElRSU1KQXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVNBTXAyb2lBUkF5SWdCRkRRQWdBMEVGTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RDTUxRUThoQWd3SkMwSUFJUW9DUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDNGeFlBQVFJREJBVUdCeFFVRkJRVUZCUUlDUW9MREEwVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkE0UEVCRVNFeFFMUWdJaENnd1dDMElESVFvTUZRdENCQ0VLREJRTFFnVWhDZ3dUQzBJR0lRb01FZ3RDQnlFS0RCRUxRZ2doQ2d3UUMwSUpJUW9NRHd0Q0NpRUtEQTRMUWdzaENnd05DMElNSVFvTURBdENEU0VLREFzTFFnNGhDZ3dLQzBJUElRb01DUXRDQ2lFS0RBZ0xRZ3NoQ2d3SEMwSU1JUW9NQmd0Q0RTRUtEQVVMUWc0aENnd0VDMElQSVFvTUF3c2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFaOFZOZ0lRSUFOQkREWUNERUVBSVFJTUlRc2dBU0FFUmdSQVFTSWhBZ3doQzBJQUlRb0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFFdEFBQkJNR3NPTnhVVUFBRUNBd1FGQmdjV0ZoWVdGaFlXQ0FrS0N3d05GaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWU9EeEFSRWhNV0MwSUNJUW9NRkF0Q0F5RUtEQk1MUWdRaENnd1NDMElGSVFvTUVRdENCaUVLREJBTFFnY2hDZ3dQQzBJSUlRb01EZ3RDQ1NFS0RBMExRZ29oQ2d3TUMwSUxJUW9NQ3d0Q0RDRUtEQW9MUWcwaENnd0pDMElPSVFvTUNBdENEeUVLREFjTFFnb2hDZ3dHQzBJTElRb01CUXRDRENFS0RBUUxRZzBoQ2d3REMwSU9JUW9NQWd0Q0R5RUtEQUVMUWdFaENnc2dBVUVCYWlFQklBTXBBeUFpQzBMLy8vLy8vLy8vL3c5WUJFQWdBeUFMUWdTR0lBcUVOd01nREFJTElBTkJBRFlDSENBRElBRTJBaFFnQTBHMUNUWUNFQ0FEUVF3MkFneEJBQ0VDREI0TFFTY2hBZ3dFQzBFb0lRSU1Bd3NnQXlBQk9nQXNJQU5CQURZQ0FDQUhRUUZxSVFGQkRDRUNEQUlMSUFOQkFEWUNBQ0FHUVFGcUlRRkJDaUVDREFFTElBRkJBV29oQVVFSUlRSU1BQXNBQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFiSTROZ0lRSUFOQkNEWUNEQXdYQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZTVJOZ0lRSUFOQkNUWUNEQXdXQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkOEtOZ0lRSUFOQkNUWUNEQXdWQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFlMFFOZ0lRSUFOQkNUWUNEQXdVQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkSVJOZ0lRSUFOQkNUWUNEQXdUQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFiSTROZ0lRSUFOQkNEWUNEQXdTQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZTVJOZ0lRSUFOQkNUWUNEQXdSQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkOEtOZ0lRSUFOQkNUWUNEQXdRQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFlMFFOZ0lRSUFOQkNUWUNEQXdQQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFkSVJOZ0lRSUFOQkNUWUNEQXdPQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFia1hOZ0lRSUFOQkR6WUNEQXdOQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFia1hOZ0lRSUFOQkR6WUNEQXdNQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaa1ROZ0lRSUFOQkN6WUNEQXdMQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaMEpOZ0lRSUFOQkN6WUNEQXdLQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaY1FOZ0lRSUFOQkNqWUNEQXdKQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFiRVFOZ0lRSUFOQkNqWUNEQXdJQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFic2ROZ0lRSUFOQkFqWUNEQXdIQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaWVdOZ0lRSUFOQkFqWUNEQXdHQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFma1lOZ0lRSUFOQkFqWUNEQXdGQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFjUVlOZ0lRSUFOQkFqWUNEQXdFQ3lBRFFRSTJBaHdnQXlBQk5nSVVJQU5CcVI0MkFoQWdBMEVXTmdJTVFRQWhBZ3dEQzBIZUFDRUNJQUVnQkVZTkFpQUpRUWhxSVFjZ0F5Z0NBQ0VGQWtBQ1FDQUJJQVJIQkVBZ0JVR1d5QUJxSVFnZ0JDQUZhaUFCYXlFR0lBVkJmM05CQ21vaUJTQUJhaUVBQTBBZ0FTMEFBQ0FJTFFBQVJ3UkFRUUloQ0F3REN5QUZSUVJBUVFBaENDQUFJUUVNQXdzZ0JVRUJheUVGSUFoQkFXb2hDQ0FFSUFGQkFXb2lBVWNOQUFzZ0JpRUZJQVFoQVFzZ0IwRUJOZ0lBSUFNZ0JUWUNBQXdCQ3lBRFFRQTJBZ0FnQnlBSU5nSUFDeUFISUFFMkFnUWdDU2dDRENFQUFrQUNRQ0FKS0FJSVFRRnJEZ0lFQVFBTElBTkJBRFlDSENBRFFjSWVOZ0lRSUFOQkZ6WUNEQ0FESUFCQkFXbzJBaFJCQUNFQ0RBTUxJQU5CQURZQ0hDQURJQUEyQWhRZ0EwSFhIallDRUNBRFFRazJBZ3hCQUNFQ0RBSUxJQUVnQkVZRVFFRW9JUUlNQWdzZ0EwRUpOZ0lJSUFNZ0FUWUNCRUVuSVFJTUFRc2dBU0FFUmdSQVFRRWhBZ3dCQ3dOQUFrQUNRQUpBSUFFdEFBQkJDbXNPQkFBQkFRQUJDeUFCUVFGcUlRRU1BUXNnQVVFQmFpRUJJQU10QUM1QklIRU5BRUVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWFFaE5nSVFJQU5CQlRZQ0RBd0NDMEVCSVFJZ0FTQUVSdzBBQ3dzZ0NVRVFhaVFBSUFKRkJFQWdBeWdDRENFQURBRUxJQU1nQWpZQ0hFRUFJUUFnQXlnQ0JDSUJSUTBBSUFNZ0FTQUVJQU1vQWdnUkFRQWlBVVVOQUNBRElBUTJBaFFnQXlBQk5nSU1JQUVoQUFzZ0FBdStBZ0VDZnlBQVFRQTZBQUFnQUVIa0FHb2lBVUVCYTBFQU9nQUFJQUJCQURvQUFpQUFRUUE2QUFFZ0FVRURhMEVBT2dBQUlBRkJBbXRCQURvQUFDQUFRUUE2QUFNZ0FVRUVhMEVBT2dBQVFRQWdBR3RCQTNFaUFTQUFhaUlBUVFBMkFnQkI1QUFnQVd0QmZIRWlBaUFBYWlJQlFRUnJRUUEyQWdBQ1FDQUNRUWxKRFFBZ0FFRUFOZ0lJSUFCQkFEWUNCQ0FCUVFoclFRQTJBZ0FnQVVFTWEwRUFOZ0lBSUFKQkdVa05BQ0FBUVFBMkFoZ2dBRUVBTmdJVUlBQkJBRFlDRUNBQVFRQTJBZ3dnQVVFUWEwRUFOZ0lBSUFGQkZHdEJBRFlDQUNBQlFSaHJRUUEyQWdBZ0FVRWNhMEVBTmdJQUlBSWdBRUVFY1VFWWNpSUNheUlCUVNCSkRRQWdBQ0FDYWlFQUEwQWdBRUlBTndNWUlBQkNBRGNERUNBQVFnQTNBd2dnQUVJQU53TUFJQUJCSUdvaEFDQUJRU0JySWdGQkgwc05BQXNMQzFZQkFYOENRQ0FBS0FJTURRQUNRQUpBQWtBQ1FDQUFMUUF4RGdNQkFBTUNDeUFBS0FJNElnRkZEUUFnQVNnQ01DSUJSUTBBSUFBZ0FSRUFBQ0lCRFFNTFFRQVBDd0FMSUFCQnloazJBaEJCRGlFQkN5QUJDeG9BSUFBb0FneEZCRUFnQUVIZUh6WUNFQ0FBUVJVMkFnd0xDeFFBSUFBb0FneEJGVVlFUUNBQVFRQTJBZ3dMQ3hRQUlBQW9BZ3hCRmtZRVFDQUFRUUEyQWd3TEN3Y0FJQUFvQWd3TEJ3QWdBQ2dDRUFzSkFDQUFJQUUyQWhBTEJ3QWdBQ2dDRkFzckFBSkFJQUJCSjA4TkFFTC8vLy8vL3drZ0FLMklRZ0dEVUEwQUlBQkJBblJCMERocUtBSUFEd3NBQ3hjQUlBQkJMMDhFUUFBTElBQkJBblJCN0RscUtBSUFDNzhKQVFGL1FmUXRJUUVDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQVFlUUFhdzcwQTJOaUFBRmhZV0ZoWVdFQ0F3UUZZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVFZSENBa0tDd3dORGc5aFlXRmhZUkJoWVdGaFlXRmhZV0ZoWVJGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdFU0V4UVZGaGNZR1JvYllXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSd2RIaDhnSVNJakpDVW1KeWdwS2lzc0xTNHZNREV5TXpRMU5tRTNPRGs2WVdGaFlXRmhZV0U3WVdGaFBHRmhZV0U5UGo5aFlXRmhZV0ZoWVVCaFlVRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5oWVdGaFlXRmhZVlJWVmxkWVdWcGJZVnhkWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFhtRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlWOWdZUXRCNml3UEMwR1lKZzhMUWUweER3dEJvRGNQQzBISktROExRYlFwRHd0QmxpMFBDMEhyS3c4TFFhSTFEd3RCMnpRUEMwSGdLUThMUWVNa0R3dEIxU1FQQzBIdUpBOExRZVlsRHd0QnlqUVBDMEhRTnc4TFFhbzFEd3RCOVN3UEMwSDJKZzhMUVlJaUR3dEI4ak1QQzBHK0tBOExRZWMzRHd0QnpTRVBDMEhBSVE4TFFiZ2xEd3RCeXlVUEMwR1dKQThMUVk4MER3dEJ6VFVQQzBIZEtnOExRZTR6RHd0Qm5EUVBDMEdlTVE4TFFmUTFEd3RCNVNJUEMwR3ZKUThMUVpreER3dEJzallQQzBINU5nOExRY1F5RHd0QjNTd1BDMEdDTVE4TFFjRXhEd3RCalRjUEMwSEpKQThMUWV3MkR3dEI1eW9QQzBISUl3OExRZUloRHd0QnlUY1BDMEdsSWc4TFFaUWlEd3RCMnpZUEMwSGVOUThMUVlZbUR3dEJ2Q3NQQzBHTE1nOExRYUFqRHd0QjlqQVBDMEdBTEE4TFFZa3JEd3RCcENZUEMwSHlJdzhMUVlFb0R3dEJxeklQQzBIckp3OExRY0kyRHd0Qm9pUVBDMEhQS2c4TFFkd2pEd3RCaHljUEMwSGtOQThMUWJjaUR3dEJyVEVQQzBIVklnOExRYTgwRHd0QjNpWVBDMEhXTWc4TFFmUTBEd3RCZ1RnUEMwSDBOdzhMUVpJMkR3dEJuU2NQQzBHQ0tROExRWTBqRHd0QjF6RVBDMEc5TlE4TFFiUTNEd3RCMkRBUEMwRzJKdzhMUVpvNER3dEJweW9QQzBIRUp3OExRYTRqRHd0QjlTSVBDd0FMUWNvbUlRRUxJQUVMRndBZ0FDQUFMd0V1UWY3L0EzRWdBVUVBUjNJN0FTNExHZ0FnQUNBQUx3RXVRZjMvQTNFZ0FVRUFSMEVCZEhJN0FTNExHZ0FnQUNBQUx3RXVRZnYvQTNFZ0FVRUFSMEVDZEhJN0FTNExHZ0FnQUNBQUx3RXVRZmYvQTNFZ0FVRUFSMEVEZEhJN0FTNExHZ0FnQUNBQUx3RXVRZS8vQTNFZ0FVRUFSMEVFZEhJN0FTNExHZ0FnQUNBQUx3RXVRZC8vQTNFZ0FVRUFSMEVGZEhJN0FTNExHZ0FnQUNBQUx3RXVRYi8vQTNFZ0FVRUFSMEVHZEhJN0FTNExHZ0FnQUNBQUx3RXVRZi8rQTNFZ0FVRUFSMEVIZEhJN0FTNExHZ0FnQUNBQUx3RXVRZi85QTNFZ0FVRUFSMEVJZEhJN0FTNExHZ0FnQUNBQUx3RXVRZi83QTNFZ0FVRUFSMEVKZEhJN0FTNExQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlFSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVIaEVqWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlJSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVIOEVUWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlNSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVIc0NqWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlRSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVINkhqWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlVSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVITEVEWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlZSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVHM0h6WUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUljSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVHL0ZUWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlzSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVIK0NEWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlnSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVHTUhUWUNFRUVZSVFRTElBUUxQZ0VDZndKQUlBQW9BamdpQTBVTkFDQURLQUlrSWdORkRRQWdBQ0FCSUFJZ0FXc2dBeEVCQUNJRVFYOUhEUUFnQUVIbUZUWUNFRUVZSVFRTElBUUxPQUFnQUFKL0lBQXZBVEpCRkhGQkZFWUVRRUVCSUFBdEFDaEJBVVlOQVJvZ0FDOEJORUhsQUVZTUFRc2dBQzBBS1VFRlJnczZBREFMV1FFQ2Z3SkFJQUF0QUNoQkFVWU5BQ0FBTHdFMElnRkI1QUJyUWVRQVNRMEFJQUZCekFGR0RRQWdBVUd3QWtZTkFDQUFMd0V5SWdCQndBQnhEUUJCQVNFQ0lBQkJpQVJ4UVlBRVJnMEFJQUJCS0hGRklRSUxJQUlMakFFQkFuOENRQUpBQWtBZ0FDMEFLa1VOQUNBQUxRQXJSUTBBSUFBdkFUSWlBVUVDY1VVTkFRd0NDeUFBTHdFeUlnRkJBWEZGRFFFTFFRRWhBaUFBTFFBb1FRRkdEUUFnQUM4Qk5DSUFRZVFBYTBIa0FFa05BQ0FBUWN3QlJnMEFJQUJCc0FKR0RRQWdBVUhBQUhFTkFFRUFJUUlnQVVHSUJIRkJnQVJHRFFBZ0FVRW9jVUVBUnlFQ0N5QUNDMWNBSUFCQkdHcENBRGNEQUNBQVFnQTNBd0FnQUVFNGFrSUFOd01BSUFCQk1HcENBRGNEQUNBQVFTaHFRZ0EzQXdBZ0FFRWdha0lBTndNQUlBQkJFR3BDQURjREFDQUFRUWhxUWdBM0F3QWdBRUg5QVRZQ0hBc0dBQ0FBRURvTG1pMEJDMzhqQUVFUWF5SUtKQUJCM05VQUtBSUFJZ2xGQkVCQm5Oa0FLQUlBSWdWRkJFQkJxTmtBUW44M0FnQkJvTmtBUW9DQWhJQ0FnTUFBTndJQVFaelpBQ0FLUVFocVFYQnhRZGlxMWFvRmN5SUZOZ0lBUWJEWkFFRUFOZ0lBUVlEWkFFRUFOZ0lBQzBHRTJRQkJ3TmtFTmdJQVFkVFZBRUhBMlFRMkFnQkI2TlVBSUFVMkFnQkI1TlVBUVg4MkFnQkJpTmtBUWNDbUF6WUNBQU5BSUFGQmdOWUFhaUFCUWZUVkFHb2lBallDQUNBQ0lBRkI3TlVBYWlJRE5nSUFJQUZCK05VQWFpQUROZ0lBSUFGQmlOWUFhaUFCUWZ6VkFHb2lBellDQUNBRElBSTJBZ0FnQVVHUTFnQnFJQUZCaE5ZQWFpSUNOZ0lBSUFJZ0F6WUNBQ0FCUVl6V0FHb2dBallDQUNBQlFTQnFJZ0ZCZ0FKSERRQUxRY3paQkVHQnBnTTJBZ0JCNE5VQVFhelpBQ2dDQURZQ0FFSFExUUJCZ0tZRE5nSUFRZHpWQUVISTJRUTJBZ0JCelA4SFFUZzJBZ0JCeU5rRUlRa0xBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSHNBVTBFUUVIRTFRQW9BZ0FpQmtFUUlBQkJFMnBCY0hFZ0FFRUxTUnNpQkVFRGRpSUFkaUlCUVFOeEJFQUNRQ0FCUVFGeElBQnlRUUZ6SWdKQkEzUWlBRUhzMVFCcUlnRWdBRUgwMVFCcUtBSUFJZ0FvQWdnaUEwWUVRRUhFMVFBZ0JrRitJQUozY1RZQ0FBd0JDeUFCSUFNMkFnZ2dBeUFCTmdJTUN5QUFRUWhxSVFFZ0FDQUNRUU4wSWdKQkEzSTJBZ1FnQUNBQ2FpSUFJQUFvQWdSQkFYSTJBZ1FNRVF0QnpOVUFLQUlBSWdnZ0JFOE5BU0FCQkVBQ1FFRUNJQUIwSWdKQkFDQUNhM0lnQVNBQWRIRm9JZ0JCQTNRaUFrSHMxUUJxSWdFZ0FrSDAxUUJxS0FJQUlnSW9BZ2dpQTBZRVFFSEUxUUFnQmtGK0lBQjNjU0lHTmdJQURBRUxJQUVnQXpZQ0NDQURJQUUyQWd3TElBSWdCRUVEY2pZQ0JDQUFRUU4wSWdBZ0JHc2hCU0FBSUFKcUlBVTJBZ0FnQWlBRWFpSUVJQVZCQVhJMkFnUWdDQVJBSUFoQmVIRkI3TlVBYWlFQVFkalZBQ2dDQUNFREFuOUJBU0FJUVFOMmRDSUJJQVp4UlFSQVFjVFZBQ0FCSUFaeU5nSUFJQUFNQVFzZ0FDZ0NDQXNpQVNBRE5nSU1JQUFnQXpZQ0NDQURJQUEyQWd3Z0F5QUJOZ0lJQ3lBQ1FRaHFJUUZCMk5VQUlBUTJBZ0JCek5VQUlBVTJBZ0FNRVF0QnlOVUFLQUlBSWd0RkRRRWdDMmhCQW5SQjlOY0FhaWdDQUNJQUtBSUVRWGh4SUFScklRVWdBQ0VDQTBBQ1FDQUNLQUlRSWdGRkJFQWdBa0VVYWlnQ0FDSUJSUTBCQ3lBQktBSUVRWGh4SUFScklnTWdCVWtoQWlBRElBVWdBaHNoQlNBQklBQWdBaHNoQUNBQklRSU1BUXNMSUFBb0FoZ2hDU0FBS0FJTUlnTWdBRWNFUUVIVTFRQW9BZ0FhSUFNZ0FDZ0NDQ0lCTmdJSUlBRWdBellDREF3UUN5QUFRUlJxSWdJb0FnQWlBVVVFUUNBQUtBSVFJZ0ZGRFFNZ0FFRVFhaUVDQ3dOQUlBSWhCeUFCSWdOQkZHb2lBaWdDQUNJQkRRQWdBMEVRYWlFQ0lBTW9BaEFpQVEwQUN5QUhRUUEyQWdBTUR3dEJmeUVFSUFCQnYzOUxEUUFnQUVFVGFpSUJRWEJ4SVFSQnlOVUFLQUlBSWdoRkRRQkJBQ0FFYXlFRkFrQUNRQUpBQW45QkFDQUVRWUFDU1EwQUdrRWZJQVJCLy8vL0Iwc05BQm9nQkVFbUlBRkJDSFpuSWdCcmRrRUJjU0FBUVFGMGEwRSthZ3NpQmtFQ2RFSDAxd0JxS0FJQUlnSkZCRUJCQUNFQlFRQWhBd3dCQzBFQUlRRWdCRUVaSUFaQkFYWnJRUUFnQmtFZlJ4dDBJUUJCQUNFREEwQUNRQ0FDS0FJRVFYaHhJQVJySWdjZ0JVOE5BQ0FDSVFNZ0J5SUZEUUJCQUNFRklBSWhBUXdEQ3lBQklBSkJGR29vQWdBaUJ5QUhJQUlnQUVFZGRrRUVjV3BCRUdvb0FnQWlBa1liSUFFZ0J4c2hBU0FBUVFGMElRQWdBZzBBQ3dzZ0FTQURja1VFUUVFQUlRTkJBaUFHZENJQVFRQWdBR3R5SUFoeElnQkZEUU1nQUdoQkFuUkI5TmNBYWlnQ0FDRUJDeUFCUlEwQkN3TkFJQUVvQWdSQmVIRWdCR3NpQWlBRlNTRUFJQUlnQlNBQUd5RUZJQUVnQXlBQUd5RURJQUVvQWhBaUFBUi9JQUFGSUFGQkZHb29BZ0FMSWdFTkFBc0xJQU5GRFFBZ0JVSE0xUUFvQWdBZ0JHdFBEUUFnQXlnQ0dDRUhJQU1nQXlnQ0RDSUFSd1JBUWRUVkFDZ0NBQm9nQUNBREtBSUlJZ0UyQWdnZ0FTQUFOZ0lNREE0TElBTkJGR29pQWlnQ0FDSUJSUVJBSUFNb0FoQWlBVVVOQXlBRFFSQnFJUUlMQTBBZ0FpRUdJQUVpQUVFVWFpSUNLQUlBSWdFTkFDQUFRUkJxSVFJZ0FDZ0NFQ0lCRFFBTElBWkJBRFlDQUF3TkMwSE0xUUFvQWdBaUF5QUVUd1JBUWRqVkFDZ0NBQ0VCQWtBZ0F5QUVheUlDUVJCUEJFQWdBU0FFYWlJQUlBSkJBWEkyQWdRZ0FTQURhaUFDTmdJQUlBRWdCRUVEY2pZQ0JBd0JDeUFCSUFOQkEzSTJBZ1FnQVNBRGFpSUFJQUFvQWdSQkFYSTJBZ1JCQUNFQVFRQWhBZ3RCek5VQUlBSTJBZ0JCMk5VQUlBQTJBZ0FnQVVFSWFpRUJEQThMUWREVkFDZ0NBQ0lESUFSTEJFQWdCQ0FKYWlJQUlBTWdCR3NpQVVFQmNqWUNCRUhjMVFBZ0FEWUNBRUhRMVFBZ0FUWUNBQ0FKSUFSQkEzSTJBZ1FnQ1VFSWFpRUJEQThMUVFBaEFTQUVBbjlCbk5rQUtBSUFCRUJCcE5rQUtBSUFEQUVMUWFqWkFFSi9Od0lBUWFEWkFFS0FnSVNBZ0lEQUFEY0NBRUdjMlFBZ0NrRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQnNOa0FRUUEyQWdCQmdOa0FRUUEyQWdCQmdJQUVDeUlBSUFSQnh3QnFJZ1ZxSWdaQkFDQUFheUlIY1NJQ1R3UkFRYlRaQUVFd05nSUFEQThMQWtCQi9OZ0FLQUlBSWdGRkRRQkI5TmdBS0FJQUlnZ2dBbW9oQUNBQUlBRk5JQUFnQ0V0eERRQkJBQ0VCUWJUWkFFRXdOZ0lBREE4TFFZRFpBQzBBQUVFRWNRMEVBa0FDUUNBSkJFQkJoTmtBSVFFRFFDQUJLQUlBSWdBZ0NVMEVRQ0FBSUFFb0FnUnFJQWxMRFFNTElBRW9BZ2dpQVEwQUN3dEJBQkE3SWdCQmYwWU5CU0FDSVFaQm9Oa0FLQUlBSWdGQkFXc2lBeUFBY1FSQUlBSWdBR3NnQUNBRGFrRUFJQUZyY1dvaEJnc2dCQ0FHVHcwRklBWkIvdi8vL3dkTERRVkIvTmdBS0FJQUlnTUVRRUgwMkFBb0FnQWlCeUFHYWlFQklBRWdCMDBOQmlBQklBTkxEUVlMSUFZUU95SUJJQUJIRFFFTUJ3c2dCaUFEYXlBSGNTSUdRZjcvLy84SFN3MEVJQVlRT3lFQUlBQWdBU2dDQUNBQktBSUVha1lOQXlBQUlRRUxBa0FnQmlBRVFjZ0FhazhOQUNBQlFYOUdEUUJCcE5rQUtBSUFJZ0FnQlNBR2EycEJBQ0FBYTNFaUFFSCsvLy8vQjBzRVFDQUJJUUFNQndzZ0FCQTdRWDlIQkVBZ0FDQUdhaUVHSUFFaEFBd0hDMEVBSUFackVEc2FEQVFMSUFFaUFFRi9SdzBGREFNTFFRQWhBd3dNQzBFQUlRQU1DZ3NnQUVGL1J3MENDMEdBMlFCQmdOa0FLQUlBUVFSeU5nSUFDeUFDUWY3Ly8vOEhTdzBCSUFJUU95RUFRUUFRT3lFQklBQkJmMFlOQVNBQlFYOUdEUUVnQUNBQlR3MEJJQUVnQUdzaUJpQUVRVGhxVFEwQkMwSDAyQUJCOU5nQUtBSUFJQVpxSWdFMkFnQkIrTmdBS0FJQUlBRkpCRUJCK05nQUlBRTJBZ0FMQWtBQ1FBSkFRZHpWQUNnQ0FDSUNCRUJCaE5rQUlRRURRQ0FBSUFFb0FnQWlBeUFCS0FJRUlnVnFSZzBDSUFFb0FnZ2lBUTBBQ3d3Q0MwSFUxUUFvQWdBaUFVRUFSeUFBSUFGUGNVVUVRRUhVMVFBZ0FEWUNBQXRCQUNFQlFZalpBQ0FHTmdJQVFZVFpBQ0FBTmdJQVFlVFZBRUYvTmdJQVFlalZBRUdjMlFBb0FnQTJBZ0JCa05rQVFRQTJBZ0FEUUNBQlFZRFdBR29nQVVIMDFRQnFJZ0kyQWdBZ0FpQUJRZXpWQUdvaUF6WUNBQ0FCUWZqVkFHb2dBellDQUNBQlFZaldBR29nQVVIODFRQnFJZ00yQWdBZ0F5QUNOZ0lBSUFGQmtOWUFhaUFCUVlUV0FHb2lBallDQUNBQ0lBTTJBZ0FnQVVHTTFnQnFJQUkyQWdBZ0FVRWdhaUlCUVlBQ1J3MEFDMEY0SUFCclFROXhJZ0VnQUdvaUFpQUdRVGhySWdNZ0FXc2lBVUVCY2pZQ0JFSGcxUUJCck5rQUtBSUFOZ0lBUWREVkFDQUJOZ0lBUWR6VkFDQUNOZ0lBSUFBZ0EycEJPRFlDQkF3Q0N5QUFJQUpORFFBZ0FpQURTUTBBSUFFb0FneEJDSEVOQUVGNElBSnJRUTl4SWdBZ0Ftb2lBMEhRMVFBb0FnQWdCbW9pQnlBQWF5SUFRUUZ5TmdJRUlBRWdCU0FHYWpZQ0JFSGcxUUJCck5rQUtBSUFOZ0lBUWREVkFDQUFOZ0lBUWR6VkFDQUROZ0lBSUFJZ0IycEJPRFlDQkF3QkN5QUFRZFRWQUNnQ0FFa0VRRUhVMVFBZ0FEWUNBQXNnQUNBR2FpRURRWVRaQUNFQkFrQUNRQUpBQTBBZ0F5QUJLQUlBUndSQUlBRW9BZ2dpQVEwQkRBSUxDeUFCTFFBTVFRaHhSUTBCQzBHRTJRQWhBUU5BSUFFb0FnQWlBeUFDVFFSQUlBTWdBU2dDQkdvaUJTQUNTdzBEQ3lBQktBSUlJUUVNQUFzQUN5QUJJQUEyQWdBZ0FTQUJLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjV29pQ1NBRVFRTnlOZ0lFSUFOQmVDQURhMEVQY1dvaUJpQUVJQWxxSWdScklRRWdBaUFHUmdSQVFkelZBQ0FFTmdJQVFkRFZBRUhRMVFBb0FnQWdBV29pQURZQ0FDQUVJQUJCQVhJMkFnUU1DQXRCMk5VQUtBSUFJQVpHQkVCQjJOVUFJQVEyQWdCQnpOVUFRY3pWQUNnQ0FDQUJhaUlBTmdJQUlBUWdBRUVCY2pZQ0JDQUFJQVJxSUFBMkFnQU1DQXNnQmlnQ0JDSUZRUU54UVFGSERRWWdCVUY0Y1NFSUlBVkIvd0ZOQkVBZ0JVRURkaUVESUFZb0FnZ2lBQ0FHS0FJTUlnSkdCRUJCeE5VQVFjVFZBQ2dDQUVGK0lBTjNjVFlDQUF3SEN5QUNJQUEyQWdnZ0FDQUNOZ0lNREFZTElBWW9BaGdoQnlBR0lBWW9BZ3dpQUVjRVFDQUFJQVlvQWdnaUFqWUNDQ0FDSUFBMkFnd01CUXNnQmtFVWFpSUNLQUlBSWdWRkJFQWdCaWdDRUNJRlJRMEVJQVpCRUdvaEFnc0RRQ0FDSVFNZ0JTSUFRUlJxSWdJb0FnQWlCUTBBSUFCQkVHb2hBaUFBS0FJUUlnVU5BQXNnQTBFQU5nSUFEQVFMUVhnZ0FHdEJEM0VpQVNBQWFpSUhJQVpCT0dzaUF5QUJheUlCUVFGeU5nSUVJQUFnQTJwQk9EWUNCQ0FDSUFWQk55QUZhMEVQY1dwQlAyc2lBeUFESUFKQkVHcEpHeUlEUVNNMkFnUkI0TlVBUWF6WkFDZ0NBRFlDQUVIUTFRQWdBVFlDQUVIYzFRQWdCellDQUNBRFFSQnFRWXpaQUNrQ0FEY0NBQ0FEUVlUWkFDa0NBRGNDQ0VHTTJRQWdBMEVJYWpZQ0FFR0kyUUFnQmpZQ0FFR0UyUUFnQURZQ0FFR1EyUUJCQURZQ0FDQURRU1JxSVFFRFFDQUJRUWMyQWdBZ0JTQUJRUVJxSWdGTERRQUxJQUlnQTBZTkFDQURJQU1vQWdSQmZuRTJBZ1FnQXlBRElBSnJJZ1UyQWdBZ0FpQUZRUUZ5TmdJRUlBVkIvd0ZOQkVBZ0JVRjRjVUhzMVFCcUlRQUNmMEhFMVFBb0FnQWlBVUVCSUFWQkEzWjBJZ054UlFSQVFjVFZBQ0FCSUFOeU5nSUFJQUFNQVFzZ0FDZ0NDQXNpQVNBQ05nSU1JQUFnQWpZQ0NDQUNJQUEyQWd3Z0FpQUJOZ0lJREFFTFFSOGhBU0FGUWYvLy93ZE5CRUFnQlVFbUlBVkJDSFpuSWdCcmRrRUJjU0FBUVFGMGEwRSthaUVCQ3lBQ0lBRTJBaHdnQWtJQU53SVFJQUZCQW5SQjlOY0FhaUVBUWNqVkFDZ0NBQ0lEUVFFZ0FYUWlCbkZGQkVBZ0FDQUNOZ0lBUWNqVkFDQURJQVp5TmdJQUlBSWdBRFlDR0NBQ0lBSTJBZ2dnQWlBQ05nSU1EQUVMSUFWQkdTQUJRUUYyYTBFQUlBRkJIMGNiZENFQklBQW9BZ0FoQXdKQUEwQWdBeUlBS0FJRVFYaHhJQVZHRFFFZ0FVRWRkaUVESUFGQkFYUWhBU0FBSUFOQkJIRnFRUkJxSWdZb0FnQWlBdzBBQ3lBR0lBSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFRc2dBQ2dDQ0NJQklBSTJBZ3dnQUNBQ05nSUlJQUpCQURZQ0dDQUNJQUEyQWd3Z0FpQUJOZ0lJQzBIUTFRQW9BZ0FpQVNBRVRRMEFRZHpWQUNnQ0FDSUFJQVJxSWdJZ0FTQUVheUlCUVFGeU5nSUVRZERWQUNBQk5nSUFRZHpWQUNBQ05nSUFJQUFnQkVFRGNqWUNCQ0FBUVFocUlRRU1DQXRCQUNFQlFiVFpBRUV3TmdJQURBY0xRUUFoQUFzZ0IwVU5BQUpBSUFZb0Fod2lBa0VDZEVIMDF3QnFJZ01vQWdBZ0JrWUVRQ0FESUFBMkFnQWdBQTBCUWNqVkFFSEkxUUFvQWdCQmZpQUNkM0UyQWdBTUFnc2dCMEVRUVJRZ0J5Z0NFQ0FHUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FITmdJWUlBWW9BaEFpQWdSQUlBQWdBallDRUNBQ0lBQTJBaGdMSUFaQkZHb29BZ0FpQWtVTkFDQUFRUlJxSUFJMkFnQWdBaUFBTmdJWUN5QUJJQWhxSVFFZ0JpQUlhaUlHS0FJRUlRVUxJQVlnQlVGK2NUWUNCQ0FCSUFScUlBRTJBZ0FnQkNBQlFRRnlOZ0lFSUFGQi93Rk5CRUFnQVVGNGNVSHMxUUJxSVFBQ2YwSEUxUUFvQWdBaUFrRUJJQUZCQTNaMElnRnhSUVJBUWNUVkFDQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2lBU0FFTmdJTUlBQWdCRFlDQ0NBRUlBQTJBZ3dnQkNBQk5nSUlEQUVMUVI4aEJTQUJRZi8vL3dkTkJFQWdBVUVtSUFGQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUZDeUFFSUFVMkFod2dCRUlBTndJUUlBVkJBblJCOU5jQWFpRUFRY2pWQUNnQ0FDSUNRUUVnQlhRaUEzRkZCRUFnQUNBRU5nSUFRY2pWQUNBQ0lBTnlOZ0lBSUFRZ0FEWUNHQ0FFSUFRMkFnZ2dCQ0FFTmdJTURBRUxJQUZCR1NBRlFRRjJhMEVBSUFWQkgwY2JkQ0VGSUFBb0FnQWhBQUpBQTBBZ0FDSUNLQUlFUVhoeElBRkdEUUVnQlVFZGRpRUFJQVZCQVhRaEJTQUNJQUJCQkhGcVFSQnFJZ01vQWdBaUFBMEFDeUFESUFRMkFnQWdCQ0FDTmdJWUlBUWdCRFlDRENBRUlBUTJBZ2dNQVFzZ0FpZ0NDQ0lBSUFRMkFnd2dBaUFFTmdJSUlBUkJBRFlDR0NBRUlBSTJBZ3dnQkNBQU5nSUlDeUFKUVFocUlRRU1BZ3NDUUNBSFJRMEFBa0FnQXlnQ0hDSUJRUUowUWZUWEFHb2lBaWdDQUNBRFJnUkFJQUlnQURZQ0FDQUFEUUZCeU5VQUlBaEJmaUFCZDNFaUNEWUNBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBYzJBaGdnQXlnQ0VDSUJCRUFnQUNBQk5nSVFJQUVnQURZQ0dBc2dBMEVVYWlnQ0FDSUJSUTBBSUFCQkZHb2dBVFlDQUNBQklBQTJBaGdMQWtBZ0JVRVBUUVJBSUFNZ0JDQUZhaUlBUVFOeU5nSUVJQUFnQTJvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFNZ0JHb2lBaUFGUVFGeU5nSUVJQU1nQkVFRGNqWUNCQ0FDSUFWcUlBVTJBZ0FnQlVIL0FVMEVRQ0FGUVhoeFFlelZBR29oQUFKL1FjVFZBQ2dDQUNJQlFRRWdCVUVEZG5RaUJYRkZCRUJCeE5VQUlBRWdCWEkyQWdBZ0FBd0JDeUFBS0FJSUN5SUJJQUkyQWd3Z0FDQUNOZ0lJSUFJZ0FEWUNEQ0FDSUFFMkFnZ01BUXRCSHlFQklBVkIvLy8vQjAwRVFDQUZRU1lnQlVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRRUxJQUlnQVRZQ0hDQUNRZ0EzQWhBZ0FVRUNkRUgwMXdCcUlRQkJBU0FCZENJRUlBaHhSUVJBSUFBZ0FqWUNBRUhJMVFBZ0JDQUljallDQUNBQ0lBQTJBaGdnQWlBQ05nSUlJQUlnQWpZQ0RBd0JDeUFGUVJrZ0FVRUJkbXRCQUNBQlFSOUhHM1FoQVNBQUtBSUFJUVFDUUFOQUlBUWlBQ2dDQkVGNGNTQUZSZzBCSUFGQkhYWWhCQ0FCUVFGMElRRWdBQ0FFUVFSeGFrRVFhaUlHS0FJQUlnUU5BQXNnQmlBQ05nSUFJQUlnQURZQ0dDQUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBQW9BZ2dpQVNBQ05nSU1JQUFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXNnQTBFSWFpRUJEQUVMQWtBZ0NVVU5BQUpBSUFBb0Fod2lBVUVDZEVIMDF3QnFJZ0lvQWdBZ0FFWUVRQ0FDSUFNMkFnQWdBdzBCUWNqVkFDQUxRWDRnQVhkeE5nSUFEQUlMSUFsQkVFRVVJQWtvQWhBZ0FFWWJhaUFETmdJQUlBTkZEUUVMSUFNZ0NUWUNHQ0FBS0FJUUlnRUVRQ0FESUFFMkFoQWdBU0FETmdJWUN5QUFRUlJxS0FJQUlnRkZEUUFnQTBFVWFpQUJOZ0lBSUFFZ0F6WUNHQXNDUUNBRlFROU5CRUFnQUNBRUlBVnFJZ0ZCQTNJMkFnUWdBQ0FCYWlJQklBRW9BZ1JCQVhJMkFnUU1BUXNnQUNBRWFpSUhJQVZCQVhJMkFnUWdBQ0FFUVFOeU5nSUVJQVVnQjJvZ0JUWUNBQ0FJQkVBZ0NFRjRjVUhzMVFCcUlRRkIyTlVBS0FJQUlRTUNmMEVCSUFoQkEzWjBJZ0lnQm5GRkJFQkJ4TlVBSUFJZ0JuSTJBZ0FnQVF3QkN5QUJLQUlJQ3lJQ0lBTTJBZ3dnQVNBRE5nSUlJQU1nQVRZQ0RDQURJQUkyQWdnTFFkalZBQ0FITmdJQVFjelZBQ0FGTmdJQUN5QUFRUWhxSVFFTElBcEJFR29rQUNBQkMwTUFJQUJGQkVBL0FFRVFkQThMQWtBZ0FFSC8vd054RFFBZ0FFRUFTQTBBSUFCQkVIWkFBQ0lBUVg5R0JFQkJ0TmtBUVRBMkFnQkJmdzhMSUFCQkVIUVBDd0FMQzVsQ0lnQkJnQWdMRFFFQUFBQUFBQUFBQWdBQUFBTUFRWmdJQ3dVRUFBQUFCUUJCcUFnTENRWUFBQUFIQUFBQUNBQkI1QWdMd2pKSmJuWmhiR2xrSUdOb1lYSWdhVzRnZFhKc0lIRjFaWEo1QUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmWW05a2VRQkRiMjUwWlc1MExVeGxibWQwYUNCdmRtVnlabXh2ZHdCRGFIVnVheUJ6YVhwbElHOTJaWEptYkc5M0FFbHVkbUZzYVdRZ2JXVjBhRzlrSUdadmNpQklWRlJRTDNndWVDQnlaWEYxWlhOMEFFbHVkbUZzYVdRZ2JXVjBhRzlrSUdadmNpQlNWRk5RTDNndWVDQnlaWEYxWlhOMEFFVjRjR1ZqZEdWa0lGTlBWVkpEUlNCdFpYUm9iMlFnWm05eUlFbERSUzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUdOb1lYSWdhVzRnZFhKc0lHWnlZV2R0Wlc1MElITjBZWEowQUVWNGNHVmpkR1ZrSUdSdmRBQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzTjBZWFIxY3dCSmJuWmhiR2xrSUhKbGMzQnZibk5sSUhOMFlYUjFjd0JGZUhCbFkzUmxaQ0JNUmlCaFpuUmxjaUJvWldGa1pYSnpBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1BVlhObGNpQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZjbVZ6WlhSZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5b1pXRmtaWEpnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJKbFoybHVZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZjM1JoZEhWelgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkbVZ5YzJsdmJsOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM1Z5YkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzQnliM1J2WTI5c1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVjBhRzlrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUZWdVpYaHdaV04wWldRZ1kyaGhjaUJwYmlCMWNtd2djMlZ5ZG1WeUFFbHVkbUZzYVdRZ2FHVmhaR1Z5SUhaaGJIVmxJR05vWVhJQVNXNTJZV3hwWkNCb1pXRmtaWElnWm1sbGJHUWdZMmhoY2dCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNabGNuTnBiMjRBU1c1MllXeHBaQ0J0YVc1dmNpQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXRnFiM0lnZG1WeWMybHZiZ0JGZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCMlpYSnphVzl1QUVWNGNHVmpkR1ZrSUVOU1RFWWdZV1owWlhJZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUVoVVZGQWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lHaGxZV1JsY2lCMGIydGxiZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1Z5YkFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY25NZ2FXNGdkWEpzQUZWdVpYaHdaV04wWldRZ2MzUmhjblFnWTJoaGNpQnBiaUIxY213QVJHOTFZbXhsSUVBZ2FXNGdkWEpzQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmY0hKdmRHOWpiMndBUlcxd2RIa2dRMjl1ZEdWdWRDMU1aVzVuZEdnQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdRMjl1ZEdWdWRDMU1aVzVuZEdnQVZISmhibk5tWlhJdFJXNWpiMlJwYm1jZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRU52Ym5SbGJuUXRUR1Z1WjNSb0FFUjFjR3hwWTJGMFpTQkRiMjUwWlc1MExVeGxibWQwYUFCSmJuWmhiR2xrSUdOb1lYSWdhVzRnZFhKc0lIQmhkR2dBUTI5dWRHVnVkQzFNWlc1bmRHZ2dZMkZ1SjNRZ1ltVWdjSEpsYzJWdWRDQjNhWFJvSUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnWTJoMWJtc2djMmw2WlFCRmVIQmxZM1JsWkNCTVJpQmhablJsY2lCamFIVnVheUJ6YVhwbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQlZibVY0Y0dWamRHVmtJSGRvYVhSbGMzQmhZMlVnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnYUdWaFpHVnlJSFpoYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1RFWWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQ0JvWldGa1pYSWdkbUZzZFdVQVRXbHpjMmx1WnlCbGVIQmxZM1JsWkNCRFVpQmhablJsY2lCamFIVnVheUJsZUhSbGJuTnBiMjRnZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ4ZFc5MFpTQjJZV3gxWlFCSmJuWmhiR2xrSUhGMWIzUmxaQzF3WVdseUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdWa0lIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1ZrSUhaaGJIVmxBRkJoZFhObFpDQmllU0J2Ymw5b1pXRmtaWEp6WDJOdmJYQnNaWFJsQUVsdWRtRnNhV1FnUlU5R0lITjBZWFJsQUc5dVgzSmxjMlYwSUhCaGRYTmxBRzl1WDJOb2RXNXJYMmhsWVdSbGNpQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgySmxaMmx1SUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpTQndZWFZ6WlFCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MWNteGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZjSEp2ZEc5amIyeGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDNaaGJIVmxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WlNCd1lYVnpaUUJWYm1WNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlITjBZWEowSUd4cGJtVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQnlaWE53YjI1elpTQnNhVzVsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnVZVzFsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnWTJoMWJtc2daWGgwWlc1emFXOXVJRzVoYldVQVNXNTJZV3hwWkNCemRHRjBkWE1nWTI5a1pRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCTmFYTnphVzVuSUdWNGNHVmpkR1ZrSUVOU0lHRm1kR1Z5SUdOb2RXNXJJR1JoZEdFQVJYaHdaV04wWldRZ1RFWWdZV1owWlhJZ1kyaDFibXNnWkdGMFlRQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVJHRjBZU0JoWm5SbGNpQmdRMjl1Ym1WamRHbHZiam9nWTJ4dmMyVmdBRk5YU1ZSRFNGOVFVazlZV1FCVlUwVmZVRkpQV0ZrQVRVdEJRMVJKVmtsVVdRQlZUbEJTVDBORlUxTkJRa3hGWDBWT1ZFbFVXUUJSVlVWU1dRQkRUMUJaQUUxUFZrVkVYMUJGVWsxQlRrVk9WRXhaQUZSUFQxOUZRVkpNV1FCT1QxUkpSbGtBUmtGSlRFVkVYMFJGVUVWT1JFVk9RMWtBUWtGRVgwZEJWRVZYUVZrQVVFeEJXUUJRVlZRQVEwaEZRMHRQVlZRQVIwRlVSVmRCV1Y5VVNVMUZUMVZVQUZKRlVWVkZVMVJmVkVsTlJVOVZWQUJPUlZSWFQxSkxYME5QVGs1RlExUmZWRWxOUlU5VlZBQkRUMDVPUlVOVVNVOU9YMVJKVFVWUFZWUUFURTlIU1U1ZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDFKRlFVUmZWRWxOUlU5VlZBQlFUMU5VQUUxSlUwUkpVa1ZEVkVWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlRFOUJSRjlDUVV4QlRrTkZSRjlTUlZGVlJWTlVBRUpCUkY5U1JWRlZSVk5VQUVoVVZGQmZVa1ZSVlVWVFZGOVRSVTVVWDFSUFgwaFVWRkJUWDFCUFVsUUFVa1ZRVDFKVUFFbE5YMEZmVkVWQlVFOVVBRkpGVTBWVVgwTlBUbFJGVGxRQVRrOWZRMDlPVkVWT1ZBQlFRVkpVU1VGTVgwTlBUbFJGVGxRQVNGQkZYMGxPVmtGTVNVUmZRMDlPVTFSQlRsUUFTRkJGWDBOQ1gxSkZVMFZVQUVkRlZBQklVRVZmVTFSU1NVTlVBRU5QVGtaTVNVTlVBRlJGVFZCUFVrRlNXVjlTUlVSSlVrVkRWQUJRUlZKTlFVNUZUbFJmVWtWRVNWSkZRMVFBUTA5T1RrVkRWQUJOVlV4VVNWOVRWRUZVVlZNQVNGQkZYMGxPVmtGTVNVUmZVMVJCVkZWVEFGUlBUMTlOUVU1WlgxSkZVVlZGVTFSVEFFVkJVa3haWDBoSlRsUlRBRlZPUVZaQlNVeEJRa3hGWDBaUFVsOU1SVWRCVEY5U1JVRlRUMDVUQUU5UVZFbFBUbE1BVTFkSlZFTklTVTVIWDFCU1QxUlBRMDlNVXdCV1FWSkpRVTVVWDBGTVUwOWZUa1ZIVDFSSlFWUkZVd0JOVlV4VVNWQk1SVjlEU0U5SlEwVlRBRWxPVkVWU1RrRk1YMU5GVWxaRlVsOUZVbEpQVWdCWFJVSmZVMFZTVmtWU1gxVk9TMDVQVjA1ZlJWSlNUMUlBVWtGSlRFZFZUbDlGVWxKUFVnQkpSRVZPVkVsVVdWOVFVazlXU1VSRlVsOUJWVlJJUlU1VVNVTkJWRWxQVGw5RlVsSlBVZ0JUVTB4ZlEwVlNWRWxHU1VOQlZFVmZSVkpTVDFJQVNVNVdRVXhKUkY5WVgwWlBVbGRCVWtSRlJGOUdUMUlBVTBWVVgxQkJVa0ZOUlZSRlVnQkhSVlJmVUVGU1FVMUZWRVZTQUVoUVJWOVZVMFZTQUZORlJWOVBWRWhGVWdCSVVFVmZRMEpmUTBoVlRrdGZTRVZCUkVWU0FFVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlFTlNBRTFMUTBGTVJVNUVRVklBVTBWVVZWQUFWMFZDWDFORlVsWkZVbDlKVTE5RVQxZE9BRlJGUVZKRVQxZE9BRWhRUlY5RFRFOVRSVVJmUTA5T1RrVkRWRWxQVGdCSVJWVlNTVk5VU1VOZlJWaFFTVkpCVkVsUFRnQkVTVk5EVDA1T1JVTlVSVVJmVDFCRlVrRlVTVTlPQUU1UFRsOUJWVlJJVDFKSlZFRlVTVlpGWDBsT1JrOVNUVUZVU1U5T0FFaFFSVjlKVGxaQlRFbEVYMVpGVWxOSlQwNEFTRkJGWDBOQ1gwMUZVMU5CUjBWZlFrVkhTVTRBVTBsVVJWOUpVMTlHVWs5YVJVNEFTRkJGWDBsT1ZrRk1TVVJmU0VWQlJFVlNYMVJQUzBWT0FFbE9Wa0ZNU1VSZlZFOUxSVTRBUms5U1FrbEVSRVZPQUVWT1NFRk9RMFZmV1U5VlVsOURRVXhOQUVoUVJWOUpUbFpCVEVsRVgxVlNUQUJDVEU5RFMwVkVYMEpaWDFCQlVrVk9WRUZNWDBOUFRsUlNUMHdBVFV0RFQwd0FRVU5NQUVoUVJWOUpUbFJGVWs1QlRBQlNSVkZWUlZOVVgwaEZRVVJGVWw5R1NVVk1SRk5mVkU5UFgweEJVa2RGWDFWT1QwWkdTVU5KUVV3QVNGQkZYMDlMQUZWT1RFbE9Td0JWVGt4UFEwc0FVRkpKQUZKRlZGSlpYMWRKVkVnQVNGQkZYMGxPVmtGTVNVUmZRMDlPVkVWT1ZGOU1SVTVIVkVnQVNGQkZYMVZPUlZoUVJVTlVSVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FSa3hWVTBnQVVGSlBVRkJCVkVOSUFFMHRVMFZCVWtOSUFGVlNTVjlVVDA5ZlRFOU9Sd0JRVWs5RFJWTlRTVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZVRVZTVTBsVFZFVk9WRjlYUVZKT1NVNUhBRTFKVTBORlRFeEJUa1ZQVlZOZlYwRlNUa2xPUndCSVVFVmZTVTVXUVV4SlJGOVVVa0ZPVTBaRlVsOUZUa05QUkVsT1J3QkZlSEJsWTNSbFpDQkRVa3hHQUVoUVJWOUpUbFpCVEVsRVgwTklWVTVMWDFOSldrVUFUVTlXUlFCRFQwNVVTVTVWUlFCSVVFVmZRMEpmVTFSQlZGVlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKVFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5V1JWSlRTVTlPWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlWVWt4ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFCU1QxUlBRMDlNWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlEU0ZWT1MxOURUMDFRVEVWVVJRQklVRVZmUTBKZlNFVkJSRVZTWDFaQlRGVkZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RldGUkZUbE5KVDA1ZlZrRk1WVVZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwVllWRVZPVTBsUFRsOU9RVTFGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlOUlZOVFFVZEZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOU5SVlJJVDBSZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbDlHU1VWTVJGOURUMDFRVEVWVVJRQkVSVXhGVkVVQVNGQkZYMGxPVmtGTVNVUmZSVTlHWDFOVVFWUkZBRWxPVmtGTVNVUmZVMU5NWDBORlVsUkpSa2xEUVZSRkFGQkJWVk5GQUU1UFgxSkZVMUJQVGxORkFGVk9VMVZRVUU5U1ZFVkVYMDFGUkVsQlgxUlpVRVVBUjA5T1JRQk9UMVJmUVVORFJWQlVRVUpNUlFCVFJWSldTVU5GWDFWT1FWWkJTVXhCUWt4RkFGSkJUa2RGWDA1UFZGOVRRVlJKVTBaSlFVSk1SUUJQVWtsSFNVNWZTVk5mVlU1U1JVRkRTRUZDVEVVQVVrVlRVRTlPVTBWZlNWTmZVMVJCVEVVQVVGVlNSMFVBVFVWU1IwVUFVa1ZSVlVWVFZGOUlSVUZFUlZKZlJrbEZURVJUWDFSUFQxOU1RVkpIUlFCU1JWRlZSVk5VWDBoRlFVUkZVbDlVVDA5ZlRFRlNSMFVBVUVGWlRFOUJSRjlVVDA5ZlRFRlNSMFVBU1U1VFZVWkdTVU5KUlU1VVgxTlVUMUpCUjBVQVNGQkZYMUJCVlZORlJGOVZVRWRTUVVSRkFFaFFSVjlRUVZWVFJVUmZTREpmVlZCSFVrRkVSUUJUVDFWU1EwVUFRVTVPVDFWT1EwVUFWRkpCUTBVQVNGQkZYMVZPUlZoUVJVTlVSVVJmVTFCQlEwVUFSRVZUUTFKSlFrVUFWVTVUVlVKVFExSkpRa1VBVWtWRFQxSkVBRWhRUlY5SlRsWkJURWxFWDAxRlZFaFBSQUJPVDFSZlJrOVZUa1FBVUZKUFVFWkpUa1FBVlU1Q1NVNUVBRkpGUWtsT1JBQlZUa0ZWVkVoUFVrbGFSVVFBVFVWVVNFOUVYMDVQVkY5QlRFeFBWMFZFQUVoVVZGQmZWa1ZTVTBsUFRsOU9UMVJmVTFWUVVFOVNWRVZFQUVGTVVrVkJSRmxmVWtWUVQxSlVSVVFBUVVORFJWQlVSVVFBVGs5VVgwbE5VRXhGVFVWT1ZFVkVBRXhQVDFCZlJFVlVSVU5VUlVRQVNGQkZYME5TWDBWWVVFVkRWRVZFQUVoUVJWOU1SbDlGV0ZCRlExUkZSQUJEVWtWQlZFVkVBRWxOWDFWVFJVUUFTRkJGWDFCQlZWTkZSQUJVU1UxRlQxVlVYMDlEUTFWU1JVUUFVRUZaVFVWT1ZGOVNSVkZWU1ZKRlJBQlFVa1ZEVDA1RVNWUkpUMDVmVWtWUlZVbFNSVVFBVUZKUFdGbGZRVlZVU0VWT1ZFbERRVlJKVDA1ZlVrVlJWVWxTUlVRQVRrVlVWMDlTUzE5QlZWUklSVTVVU1VOQlZFbFBUbDlTUlZGVlNWSkZSQUJNUlU1SFZFaGZVa1ZSVlVsU1JVUUFVMU5NWDBORlVsUkpSa2xEUVZSRlgxSkZVVlZKVWtWRUFGVlFSMUpCUkVWZlVrVlJWVWxTUlVRQVVFRkhSVjlGV0ZCSlVrVkVBRkJTUlVOUFRrUkpWRWxQVGw5R1FVbE1SVVFBUlZoUVJVTlVRVlJKVDA1ZlJrRkpURVZFQUZKRlZrRk1TVVJCVkVsUFRsOUdRVWxNUlVRQVUxTk1YMGhCVGtSVFNFRkxSVjlHUVVsTVJVUUFURTlEUzBWRUFGUlNRVTVUUms5U1RVRlVTVTlPWDBGUVVFeEpSVVFBVGs5VVgwMVBSRWxHU1VWRUFFNVBWRjlGV0ZSRlRrUkZSQUJDUVU1RVYwbEVWRWhmVEVsTlNWUmZSVmhEUlVWRVJVUUFVMGxVUlY5SlUxOVBWa1ZTVEU5QlJFVkVBRWhGUVVRQVJYaHdaV04wWldRZ1NGUlVVQzhzSUZKVVUxQXZJRzl5SUVsRFJTOEE1eFVBQUs4VkFBQ2tFZ0FBa2hvQUFDWVdBQUNlRkFBQTJ4a0FBSGtWQUFCK0VnQUEvaFFBQURZVkFBQUxGZ0FBMkJZQUFQTVNBQUJDR0FBQXJCWUFBQklWQUFBVUZ3QUE3eGNBQUVnVUFBQnhGd0FBc2hvQUFHc1pBQUIrR1FBQU5SUUFBSUlhQUFCRUZ3QUEvUllBQUI0WUFBQ0hGd0FBcWhrQUFKTVNBQUFIR0FBQUxCY0FBTW9YQUFDa0Z3QUE1eFVBQU9jVkFBQllGd0FBT3hnQUFLQVNBQUF0SEFBQXd4RUFBRWdSQUFEZUVnQUFRaE1BQUtRWkFBRDlFQUFBOXhVQUFLVVZBQUR2RmdBQStCa0FBRW9XQUFCV0ZnQUE5UlVBQUFvYUFBQUlHZ0FBQVJvQUFLc1ZBQUJDRWdBQTF4QUFBRXdSQUFBRkdRQUFWQllBQUI0UkFBREtHUUFBeUJrQUFFNFdBQUQvR0FBQWNSUUFBUEFWQUFEdUZRQUFsQmtBQVB3VkFBQy9HUUFBbXhrQUFId1VBQUJERVFBQWNCZ0FBSlVVQUFBbkZBQUFHUlFBQU5VU0FBRFVHUUFBUkJZQUFQY1FBRUc1T3dzQkFRQkIwRHNMNEFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVEQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFCQnVqMExCQUVBQUFJQVFkRTlDMTREQkFNREF3TURBQUFEQXdBREF3QURBd01EQXdNREF3TURBQVVBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQXdBREFFRzZQd3NFQVFBQUFnQkIwVDhMWGdNQUF3TURBd01BQUFNREFBTURBQU1EQXdNREF3TURBd01BQkFBRkFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBREFBTUFRYkRCQUFzTmJHOXpaV1ZsY0MxaGJHbDJaUUJCeWNFQUN3RUJBRUhnd1FBTDRBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkJ5Y01BQ3dFQkFFSGd3d0FMNXdFQkFRRUJBUUVCQVFFQkFRRUNBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVdOb2RXNXJaV1FBUWZIRkFBdGVBUUFCQVFFQkFRQUFBUUVBQVFFQUFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFCQjBNY0FDeUZsWTNScGIyNWxiblF0YkdWdVozUm9iMjV5YjNoNUxXTnZibTVsWTNScGIyNEFRWURJQUFzZ2NtRnVjMlpsY2kxbGJtTnZaR2x1WjNCbmNtRmtaUTBLRFFwVFRRMEtEUW9BUWFuSUFBc0ZBUUlBQVFNQVFjRElBQXRmQkFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUFRYW5LQUFzRkFRSUFBUU1BUWNES0FBdGZCQVVGQmdVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVQVFhbk1BQXNFQVFBQUFRQkJ3Y3dBQzE0Q0FnQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBRUdwemdBTEJRRUNBQUVEQUVIQXpnQUxYd1FGQUFBRkJRVUZCUVVGQlFVRkJRWUZCUVVGQlFVRkJRVUZCUVVBQlFBSENBVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRQUZBQVVBQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVBQUFBRkFFR3AwQUFMQlFFQkFBRUJBRUhBMEFBTEFRRUFRZHJRQUF0QkFnQUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFRYW5TQUFzRkFRRUFBUUVBUWNEU0FBc0JBUUJCeXRJQUN3WUNBQUFBQUFJQVFlSFNBQXM2QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QkJvTlFBQzUwQlRrOVZUa05GUlVOTFQxVlVUa1ZEVkVWVVJVTlNTVUpGVEZWVFNFVlVSVUZFVTBWQlVrTklVa2RGUTFSSlZrbFVXVXhGVGtSQlVsWkZUMVJKUmxsUVZFbFBUbE5EU0ZORlFWbFRWRUZVUTBoSFJWVkZVbGxQVWtSSlVrVkRWRTlTVkZKRFNGQkJVa0ZOUlZSRlVsVlNRMFZDVTBOU1NVSkZRVkpFVDFkT1FVTkZTVTVFVGt0RFMxVkNVME5TU1VKRlZGUlFRMFZVVTFCQlJGUlFMdz09J1xuXG5sZXQgd2FzbUJ1ZmZlclxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcbiAgZ2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuIHdhc21CdWZmZXJcbiAgICAgID8gd2FzbUJ1ZmZlclxuICAgICAgOiAod2FzbUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHdhc21CYXNlNjQsICdiYXNlNjQnKSlcbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst wasmBase64 = 'AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRwX3NldF9sZW5pZW50X2hlYWRlcnMAISFsbGh0dHBfc2V0X2xlbmllbnRfY2h1bmtlZF9sZW5ndGgAIh1sbGh0dHBfc2V0X2xlbmllbnRfa2VlcF9hbGl2ZQAjJGxsaHR0cF9zZXRfbGVuaWVudF90cmFuc2Zlcl9lbmNvZGluZwAkGmxsaHR0cF9zZXRfbGVuaWVudF92ZXJzaW9uACUjbGxodHRwX3NldF9sZW5pZW50X2RhdGFfYWZ0ZXJfY2xvc2UAJidsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfbGZfYWZ0ZXJfY3IAJyxsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfY3JsZl9hZnRlcl9jaHVuawAoKGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcl9iZWZvcmVfbGYAKSpsbGh0dHBfc2V0X2xlbmllbnRfc3BhY2VzX2FmdGVyX2NodW5rX3NpemUAKhhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YANgkYAQBBAQsSAQIDBAUKBgcyNDMuKy8tLDAxCuzaAjQWAEHA1QAoAgAEQAALQcDVAEEBNgIACxQAIAAQOCAAIAI2AjggACABOgAoCxQAIAAgAC8BNCAALQAwIAAQNxAACx4BAX9BwAAQOiIBEDggAUGACDYCOCABIAA6ACggAQuPDAEHfwJAIABFDQAgAEEIayIBIABBBGsoAgAiAEF4cSIEaiEFAkAgAEEBcQ0AIABBA3FFDQEgASABKAIAIgBrIgFB1NUAKAIASQ0BIAAgBGohBAJAAkBB2NUAKAIAIAFHBEAgAEH/AU0EQCAAQQN2IQMgASgCCCIAIAEoAgwiAkYEQEHE1QBBxNUAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgASgCGCEGIAEgASgCDCIARwRAIAAgASgCCCICNgIIIAIgADYCDAwDCyABQRRqIgMoAgAiAkUEQCABKAIQIgJFDQIgAUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSgCBCIAQQNxQQNHDQIgBSAAQX5xNgIEQczVACAENgIAIAUgBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgASgCHCICQQJ0QfTXAGoiAygCACABRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAFGG2ogADYCACAARQ0BCyAAIAY2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgAUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBU8NACAFKAIEIgBBAXFFDQACQAJAAkACQCAAQQJxRQRAQdzVACgCACAFRgRAQdzVACABNgIAQdDVAEHQ1QAoAgAgBGoiADYCACABIABBAXI2AgQgAUHY1QAoAgBHDQZBzNUAQQA2AgBB2NUAQQA2AgAMBgtB2NUAKAIAIAVGBEBB2NUAIAE2AgBBzNUAQczVACgCACAEaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMBgsgAEF4cSAEaiEEIABB/wFNBEAgAEEDdiEDIAUoAggiACAFKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAUoAhghBiAFIAUoAgwiAEcEQEHU1QAoAgAaIAAgBSgCCCICNgIIIAIgADYCDAwDCyAFQRRqIgMoAgAiAkUEQCAFKAIQIgJFDQIgBUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSAAQX5xNgIEIAEgBGogBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgBSgCHCICQQJ0QfTXAGoiAygCACAFRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogADYCACAARQ0BCyAAIAY2AhggBSgCECICBEAgACACNgIQIAIgADYCGAsgBUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBGogBDYCACABIARBAXI2AgQgAUHY1QAoAgBHDQBBzNUAIAQ2AgAMAQsgBEH/AU0EQCAEQXhxQezVAGohAAJ/QcTVACgCACICQQEgBEEDdnQiA3FFBEBBxNUAIAIgA3I2AgAgAAwBCyAAKAIICyICIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggMAQtBHyECIARB////B00EQCAEQSYgBEEIdmciAGt2QQFxIABBAXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgLhocCAwd/A34BeyABIAJqIQQCQCAAIgMoAgwiAA0AIAMoAgQEQCADIAE2AgQLIwBBEGsiCSQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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DAgLQeMBDAcLQdcBDAYLQdgBDAULQdkBDAQLQdoBDAMLQdsBDAILQd0BDAELQdwBCyECA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAn8CQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAwJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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A0EXNgIcIAMgADYCDCADIAFBAWo2AhQM+AILIABBFUYNI0EAIQIgA0EANgIcIAMgATYCFCADQdYMNgIQIANBIzYCDAz3AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQwdCyADQRk2AhwgAyAANgIMIAMgAUEBajYCFAz2AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQzvAgsgA0EaNgIcIAMgADYCDCADIAFBAWo2AhQM9QILIABBFUYNH0EAIQIgA0EANgIcIAMgATYCFCADQdAPNgIQIANBIjYCDAz0AgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgzzAgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDOsCCyADQR02AhwgAyAANgIMIAMgAUEBajYCFEEAIQIM8gILIABBO0cNASABQQFqIQELQSYhAgzXAgtBACECIANBADYCHCADIAE2AhQgA0GfFTYCECADQQw2AgwM7wILIAEgBEcEQANAIAEtAABBIEcNhAIgBCABQQFqIgFHDQALQSwhAgzvAgtBLCECDO4CCyABIARGBEBBNCECDO4CCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtBNCECDO8CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNnwIgA0EyNgIcIAMgATYCFCADIAA2AgxBACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUEQCABQQFqIQEMnwILIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgztAgsgASAERwRAAkADQCABLQAAQTBrIgBB/wFxQQpPBEBBOiECDNcCCyADKQMgIgtCmbPmzJmz5swZVg0BIAMgC0IKfiIKNwMgIAogAK1C/wGDIgtCf4VWDQEgAyAKIAt8NwMgIAQgAUEBaiIBRw0AC0HAACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABQQFqIgEQMSIADRcM4gILQcAAIQIM7AILIAEgBEYEQEHJACECDOwCCwJAA0ACQCABLQAAQQlrDhgAAqICogKpAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAgCiAgsgBCABQQFqIgFHDQALQckAIQIM7AILIAFBAWohASADQS9qLQAAQQFxDaUCIANBADYCHCADIAE2AhQgA0GXEDYCECADQQo2AgxBACECDOsCCyABIARHBEADQCABLQAAQSBHDRUgBCABQQFqIgFHDQALQfgAIQIM6wILQfgAIQIM6gILIANBAjoAKAw4C0EAIQIgA0EANgIcIANBvws2AhAgA0ECNgIMIAMgAUEBajYCFAzoAgtBACECDM4CC0ENIQIMzQILQRMhAgzMAgtBFSECDMsCC0EWIQIMygILQRghAgzJAgtBGSECDMgCC0EaIQIMxwILQRshAgzGAgtBHCECDMUCC0EdIQIMxAILQR4hAgzDAgtBHyECDMICC0EgIQIMwQILQSIhAgzAAgtBIyECDL8CC0ElIQIMvgILQeUAIQIMvQILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgzVAgsgA0EbNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIM1AILIANBIDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNMCCyADQRM2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzSAgsgA0ELNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0QILIANBEDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNACCyADQSA2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzPAgsgA0ELNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzgILIANBDDYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM0CC0EAIQIgA0EANgIcIAMgATYCFCADQd0ONgIQIANBEjYCDAzMAgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0H9ASECDMwCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJgIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB/AE2AhwgAyABNgIUIANB3Bk2AhAgA0EVNgIMQQAhAgzNAgtB3AEhAgyzAgsgA0EANgIcIAMgATYCFCADQfkLNgIQIANBHzYCDEEAIQIMywILAkACQCADLQAoQQFrDgIEAQALQdsBIQIMsgILQdQBIQIMsQILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQd0BIQIMsQILIABBFUcEQCADQQA2AhwgAyABNgIUIANBtAw2AhAgA0EQNgIMQQAhAgzKAgsgA0H7ATYCHCADIAE2AhQgA0GBGjYCECADQRU2AgxBACECDMkCCyABIARGBEBB+gEhAgzJAgsgAS0AAEHIAEYNASADQQE6ACgLQcABIQIMrgILQdoBIQIMrQILIAEgBEcEQCADQQw2AgggAyABNgIEQdkBIQIMrQILQfkBIQIMxQILIAEgBEYEQEH4ASECDMUCCyABLQAAQcgARw0EIAFBAWohAUHYASECDKsCCyABIARGBEBB9wEhAgzEAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQdYBIQIMqwILIAFBAWohAUHXASECDKoCC0H2ASECIAEgBEYNwgIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABButUAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMwwILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgBFBEBB4wEhAgyqAgsgA0H1ATYCHCADIAE2AhQgAyAANgIMQQAhAgzCAgtB9AEhAiABIARGDcECIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjVAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMICCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB5R82AhAgA0EINgIMDL8CC0HVASECDKUCCyADQfMBNgIcIAMgATYCFCADIAA2AgxBACECDL0CC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ1uIABBFUcEQCADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgy9AgsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDLwCCyABIARHBEAgA0ENNgIIIAMgATYCBEHTASECDKMCC0HyASECDLsCCyABIARGBEBB8QEhAgy7AgsCQAJAAkAgAS0AAEHIAGsOCwABCAgICAgICAgCCAsgAUEBaiEBQdABIQIMowILIAFBAWohAUHRASECDKICCyABQQFqIQFB0gEhAgyhAgtB8AEhAiABIARGDbkCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEG11QBqLQAARw0EIABBAkYNAyAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy5AgtB7wEhAiABIARGDbgCIAMoAgAiACAEIAFraiEGIAEgAGtBAWohBQNAIAEtAAAgAEGz1QBqLQAARw0DIABBAUYNAiAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy4AgtB7gEhAiABIARGDbcCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEGw1QBqLQAARw0CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy3AgsgAygCBCEAIANCADcDACADIAAgBUEBaiIBECsiAEUNAiADQewBNgIcIAMgATYCFCADIAA2AgxBACECDLYCCyADQQA2AgALIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ2cAiADQe0BNgIcIAMgATYCFCADIAA2AgxBACECDLQCC0HPASECDJoCC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMtAILQc4BIQIMmgILIANB6wE2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyyAgsgASAERgRAQesBIQIMsgILIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMsQILQc0BIQIMlwILIAEgBEcEQCADQQ42AgggAyABNgIEQcwBIQIMlwILQeoBIQIMrwILIAEgBEYEQEHpASECDK8CCyABLQAAQTBrIgBB/wFxQQpJBEAgAyAAOgAqIAFBAWohAUHLASECDJYCCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNlwIgA0HoATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgASAERgRAQecBIQIMrgILAkAgAS0AAEEuRgRAIAFBAWohAQwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmAIgA0HmATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgtBygEhAgyUAgsgASAERgRAQeUBIQIMrQILQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDK8CCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmgIgA0HjATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5AE2AhwgAyABNgIUIAMgADYCDAytAgtByQEhAgyTAgtBACEAAkAgAygCOCICRQ0AIAIoAkQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GkDTYCECADQSE2AgxBACECDK0CC0HIASECDJMCCyADQeEBNgIcIAMgATYCFCADQdAaNgIQIANBFTYCDEEAIQIMqwILIAEgBEYEQEHhASECDKsCCwJAIAEtAABBIEYEQCADQQA7ATQgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GZETYCECADQQk2AgxBACECDKsCC0HHASECDJECCyABIARGBEBB4AEhAgyqAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKsCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyqAgtBxgEhAgyQAgsgASAERgRAQd8BIQIMqQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyqAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqQILQcUBIQIMjwILIAEgBEYEQEHeASECDKgCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqQILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKgCC0HEASECDI4CCyABIARGBEBB3QEhAgynAgsCQAJAAkACQCABLQAAQQprDhcCAwMAAwMDAwMDAwMDAwMDAwMDAwMDAQMLIAFBAWoMBQsgAUEBaiEBQcMBIQIMjwILIAFBAWohASADQS9qLQAAQQFxDQggA0EANgIcIAMgATYCFCADQY0LNgIQIANBDTYCDEEAIQIMpwILIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKYCCyABIARHBEAgA0EPNgIIIAMgATYCBEEBIQIMjQILQdwBIQIMpQILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0HbASECDKYCCyADKAIEIQAgA0EANgIEIAMgACABEC0iAEUEQCABQQFqIQEMBAsgA0HaATYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgylAgsgAygCBCEAIANBADYCBCADIAAgARAtIgANASABQQFqCyEBQcEBIQIMigILIANB2QE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMogILQcIBIQIMiAILIANBL2otAABBAXENASADQQA2AhwgAyABNgIUIANB5Bw2AhAgA0EZNgIMQQAhAgygAgsgASAERgRAQdkB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CyADIAU2AgAMkAILIANBADYCACAGQQFqIQFBGgw8C0HKASECIAEgBEYNjgIgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBjdUAai0AAEcNOyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMjwILIANBADYCACAGQQFqIQFBIQw7CyABIARGBEBByQEhAgyOAgsCQAJAIAEtAABBwQBrDhQAPT09PT09PT09PT09PT09PT09AT0LIAFBAWohAUGtASECDPUBCyABQQFqIQFBsAEhAgz0AQsgASAERgRAQcgBIQIMjQILAkACQCABLQAAQdUAaw4LADw8PDw8PDw8PAE8CyABQQFqIQFBrgEhAgz0AQsgAUEBaiEBQa8BIQIM8wELQccBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw04IABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEqDDgLIAEgBEYEQEHGASECDIsCCyABLQAAQdAARw04IAFBAWohAUElDDcLQcUBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGB1QBqLQAARw02IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEODDYLIAEgBEYEQEHEASECDIkCCyABLQAAQcUARw02IAFBAWohAUGrASECDO8BCyABIARGBEBBwwEhAgyIAgsCQAJAAkACQCABLQAAQcIAaw4PAAECOTk5OTk5OTk5OTkDOQsgAUEBaiEBQacBIQIM8QELIAFBAWohAUGoASECDPABCyABQQFqIQFBqQEhAgzvAQsgAUEBaiEBQaoBIQIM7gELQcIBIQIgASAERg2GAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEH+1ABqLQAARw0zIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyHAgsgA0EANgIAIAZBAWohAUEUDDMLQcEBIQIgASAERg2FAiADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANA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BTYCAAzsAQsgA0EANgIAIAZBAWohAUEXDBgLQaYBIQIgASAERg3qASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHB1ABqLQAARw0XIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzrAQsgA0EANgIAIAZBAWohAUEYDBcLIAEgBEYEQEGlASECDOoBCwJAAkAgAS0AAEHJAGsOBwAZGRkZGQEZCyABQQFqIQFBiwEhAgzRAQsgAUEBaiEBQYwBIQIM0AELQaQBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm1QBqLQAARw0VIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEJDBULQaMBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk1QBqLQAARw0UIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEfDBQLQaIBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEG+1ABqLQAARw0TIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUECDBMLQaEBIQIgASAERg3lASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYDQCABLQAAIABBvNQAai0AAEcNESAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5QELIAEgBEYEQEGgASECDOUBC0EBIAEtAABB3wBHDREaIAFBAWohAUGHASECDMsBCyADQQA2AgAgBkEBaiEBQYgBIQIMygELQZ8BIQIgASAERg3iASADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw0PIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzjAQsgA0EANgIAIAZBAWohAUEpDA8LQZ4BIQIgASAERg3hASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEG41ABqLQAARw0OIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAziAQsgA0EANgIAIAZBAWohAUEtDA4LIAEgBEYEQEGdASECDOEBCyABLQAAQcUARw0OIAFBAWohAUGEASECDMcBCyABIARGBEBBnAEhAgzgAQsCQAJAIAEtAABBzABrDggADw8PDw8PAQ8LIAFBAWohAUGCASECDMcBCyABQQFqIQFBgwEhAgzGAQtBmwEhAiABIARGDd4BIAMoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQbPUAGotAABHDQsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN8BCyADQQA2AgAgBkEBaiEBQSMMCwtBmgEhAiABIARGDd0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDUAGotAABHDQogAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN4BCyADQQA2AgAgBkEBaiEBQQAMCgsgASAERgRAQZkBIQIM3QELAkACQCABLQAAQcgAaw4IAAwMDAwMDAEMCyABQQFqIQFB/QAhAgzEAQsgAUEBaiEBQYABIQIMwwELIAEgBEYEQEGYASECDNwBCwJAAkAgAS0AAEHOAGsOAwALAQsLIAFBAWohAUH+ACECDMMBCyABQQFqIQFB/wAhAgzCAQsgASAERgRAQZcBIQIM2wELIAEtAABB2QBHDQggAUEBaiEBQQgMBwtBlgEhAiABIARGDdkBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazUAGotAABHDQYgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNoBCyADQQA2AgAgBkEBaiEBQQUMBgtBlQEhAiABIARGDdgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQabUAGotAABHDQUgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNkBCyADQQA2AgAgBkEBaiEBQRYMBQtBlAEhAiABIARGDdcBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDQQgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyADQQA2AgAgBkEBaiEBQRAMBAsgASAERgRAQZMBIQIM1wELAkACQCABLQAAQcMAaw4MAAYGBgYGBgYGBgYBBgsgAUEBaiEBQfkAIQIMvgELIAFBAWohAUH6ACECDL0BC0GSASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBoNQAai0AAEcNAiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBJAwCCyADQQA2AgAMAgsgASAERgRAQZEBIQIM1AELIAEtAABBzABHDQEgAUEBaiEBQRMLOgApIAMoAgQhACADQQA2AgQgAyAAIAEQLiIADQIMAQtBACECIANBADYCHCADIAE2AhQgA0H+HzYCECADQQY2AgwM0QELQfgAIQIMtwELIANBkAE2AhwgAyABNgIUIAMgADYCDEEAIQIMzwELQQAhAAJAIAMoAjgiAkUNACACKAJAIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GCDzYCECADQSA2AgxBACECDM4BC0H3ACECDLQBCyADQY8BNgIcIAMgATYCFCADQewbNgIQIANBFTYCDEEAIQIMzAELIAEgBEYEQEGPASECDMwBCwJAIAEtAABBIEYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZsfNgIQIANBBjYCDEEAIQIMzAELQQIhAgyyAQsDQCABLQAAQSBHDQIgBCABQQFqIgFHDQALQY4BIQIMygELIAEgBEYEQEGNASECDMoBCwJAIAEtAABBCWsOBEoAAEoAC0H1ACECDLABCyADLQApQQVGBEBB9gAhAgywAQtB9AAhAgyvAQsgASAERgRAQYwBIQIMyAELIANBEDYCCCADIAE2AgQMCgsgASAERgRAQYsBIQIMxwELAkAgAS0AAEEJaw4ERwAARwALQfMAIQIMrQELIAEgBEcEQCADQRA2AgggAyABNgIEQfEAIQIMrQELQYoBIQIMxQELAkAgASAERwRAA0AgAS0AAEGg0ABqLQAAIgBBA0cEQAJAIABBAWsOAkkABAtB8AAhAgyvAQsgBCABQQFqIgFHDQALQYgBIQIMxgELQYgBIQIMxQELIANBADYCHCADIAE2AhQgA0HbIDYCECADQQc2AgxBACECDMQBCyABIARGBEBBiQEhAgzEAQsCQAJAAkAgAS0AAEGg0gBqLQAAQQFrDgNGAgABC0HyACECDKwBCyADQQA2AhwgAyABNgIUIANBtBI2AhAgA0EHNgIMQQAhAgzEAQtB6gAhAgyqAQsgASAERwRAIAFBAWohAUHvACECDKoBC0GHASECDMIBCyAEIAEiAEYEQEGGASECDMIBCyAALQAAIgFBL0YEQCAAQQFqIQFB7gAhAgypAQsgAUEJayICQRdLDQEgACEBQQEgAnRBm4CABHENQQwBCyAEIAEiAEYEQEGFASECDMEBCyAALQAAQS9HDQAgAEEBaiEBDAMLQQAhAiADQQA2AhwgAyAANgIUIANB2yA2AhAgA0EHNgIMDL8BCwJAAkACQAJAAkADQCABLQAAQaDOAGotAAAiAEEFRwRAAkACQCAAQQFrDghHBQYHCAAEAQgLQesAIQIMrQELIAFBAWohAUHtACECDKwBCyAEIAFBAWoiAUcNAAtBhAEhAgzDAQsgAUEBagwUCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDMEBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDMABCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDL8BCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy+AQsgASAERgRAQYMBIQIMvgELAkAgAS0AAEGgzgBqLQAAQQFrDgg+BAUGAAgCAwcLIAFBAWohAQtBAyECDKMBCyABQQFqDA0LQQAhAiADQQA2AhwgA0HREjYCECADQQc2AgwgAyABQQFqNgIUDLoBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDLkBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDLgBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDLcBCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy2AQtB7AAhAgycAQsgASAERgRAQYIBIQIMtQELIAFBAWoMAgsgASAERgRAQYEBIQIMtAELIAFBAWoMAQsgASAERg0BIAFBAWoLIQFBBCECDJgBC0GAASECDLABCwNAIAEtAABBoMwAai0AACIAQQJHBEAgAEEBRwRAQekAIQIMmQELDDELIAQgAUEBaiIBRw0AC0H/ACECDK8BCyABIARGBEBB/gAhAgyvAQsCQCABLQAAQQlrDjcvAwYvBAYGBgYGBgYGBgYGBgYGBgYGBgUGBgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYABgsgAUEBagshAUEFIQIMlAELIAFBAWoMBgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgypAQsgA0EANgIcIAMgATYCFCADQY0UNgIQIANBBzYCDEEAIQIMqAELAkACQAJAAkADQCABLQAAQaDKAGotAAAiAEEFRwRAAkAgAEEBaw4GLgMEBQYABgtB6AAhAgyUAQsgBCABQQFqIgFHDQALQf0AIQIMqwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMqgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMqQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMqAELIANBADYCHCADIAE2AhQgA0HkCDYCECADQQc2AgxBACECDKcBCyABIARGDQEgAUEBagshAUEGIQIMjAELQfwAIQIMpAELAkACQAJAAkADQCABLQAAQaDIAGotAAAiAEEFRwRAIABBAWsOBCkCAwQFCyAEIAFBAWoiAUcNAAtB+wAhAgynAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgymAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgylAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgykAQsgA0EANgIcIAMgATYCFCADQbwKNgIQIANBBzYCDEEAIQIMowELQc8AIQIMiQELQdEAIQIMiAELQecAIQIMhwELIAEgBEYEQEH6ACECDKABCwJAIAEtAABBCWsOBCAAACAACyABQQFqIQFB5gAhAgyGAQsgASAERgRAQfkAIQIMnwELAkAgAS0AAEEJaw4EHwAAHwALQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFBEBB4gEhAgyGAQsgAEEVRwRAIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDJ8BCyADQfgANgIcIAMgATYCFCADQeoaNgIQIANBFTYCDEEAIQIMngELIAEgBEcEQCADQQ02AgggAyABNgIEQeQAIQIMhQELQfcAIQIMnQELIAEgBEYEQEH2ACECDJ0BCwJAAkACQCABLQAAQcgAaw4LAAELCwsLCwsLCwILCyABQQFqIQFB3QAhAgyFAQsgAUEBaiEBQeAAIQIMhAELIAFBAWohAUHjACECDIMBC0H1ACECIAEgBEYNmwEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBtdUAai0AAEcNCCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMnAELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfQANgIcIAMgATYCFCADIAA2AgxBACECDJwBC0HiACECDIIBC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMnAELQeEAIQIMggELIANB8wA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyaAQsgAy0AKSIAQSNrQQtJDQkCQCAAQQZLDQBBASAAdEHKAHFFDQAMCgtBACECIANBADYCHCADIAE2AhQgA0HtCTYCECADQQg2AgwMmQELQfIAIQIgASAERg2YASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGz1QBqLQAARw0FIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyZAQsgAygCBCEAIANCADcDACADIAAgBkEBaiIBECsiAARAIANB8QA2AhwgAyABNgIUIAMgADYCDEEAIQIMmQELQd8AIQIMfwtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJkBC0HeACECDH8LIANB8AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyXAQsgAy0AKUEhRg0GIANBADYCHCADIAE2AhQgA0GRCjYCECADQQg2AgxBACECDJYBC0HvACECIAEgBEYNlQEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMlgELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgBFDQIgA0HtADYCHCADIAE2AhQgAyAANgIMQQAhAgyVAQsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNgAEgA0HuADYCHCADIAE2AhQgAyAANgIMQQAhAgyTAQtB3AAhAgx5C0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMkwELQdsAIQIMeQsgA0HsADYCHCADIAE2AhQgA0GAGzYCECADQRU2AgxBACECDJEBCyADLQApIgBBI0kNACAAQS5GDQAgA0EANgIcIAMgATYCFCADQckJNgIQIANBCDYCDEEAIQIMkAELQdoAIQIMdgsgASAERgRAQesAIQIMjwELAkAgAS0AAEEvRgRAIAFBAWohAQwBCyAD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ciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw=='\n\nlet wasmBuffer\n\nObject.defineProperty(module, 'exports', {\n  get: () => {\n    return wasmBuffer\n      ? wasmBuffer\n      : (wasmBuffer = Buffer.from(wasmBase64, 'base64'))\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGxsaHR0cFxcbGxodHRwX3NpbWQtd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuY29uc3Qgd2FzbUJhc2U2NCA9ICdBR0Z6YlFFQUFBQUJKd2RnQVg4QmYyQURmMzkvQVg5Z0FuOS9BR0FCZndCZ0JIOS9mMzhCZjJBQUFHQURmMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFFQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXpVMEJRWUFBQU1BQUFBQUFBQURBUU1BQXdNREFBQUNBQUFBQUFJQ0FnSUNBZ0lDQWdJQkFRRUJBUUVCQVFFQkF3QUFBd0FBQUFRRkFYQUJFeE1GQXdFQUFnWUlBWDhCUWNEWkJBc0h4UWNvQm0xbGJXOXllUUlBQzE5cGJtbDBhV0ZzYVhwbEFBZ1pYMTlwYm1ScGNtVmpkRjltZFc1amRHbHZibDkwWVdKc1pRRUFDMnhzYUhSMGNGOXBibWwwQUFrWWJHeG9kSFJ3WDNOb2IzVnNaRjlyWldWd1gyRnNhWFpsQURjTWJHeG9kSFJ3WDJGc2JHOWpBQXNHYldGc2JHOWpBRGtMYkd4b2RIUndYMlp5WldVQURBUm1jbVZsQUF3UGJHeG9kSFJ3WDJkbGRGOTBlWEJsQUEwVmJHeG9kSFJ3WDJkbGRGOW9kSFJ3WDIxaGFtOXlBQTRWYkd4b2RIUndYMmRsZEY5b2RIUndYMjFwYm05eUFBOFJiR3hvZEhSd1gyZGxkRjl0WlhSb2IyUUFFQlpzYkdoMGRIQmZaMlYwWDNOMFlYUjFjMTlqYjJSbEFCRVNiR3hvZEhSd1gyZGxkRjkxY0dkeVlXUmxBQklNYkd4b2RIUndYM0psYzJWMEFCTU9iR3hvZEhSd1gyVjRaV04xZEdVQUZCUnNiR2gwZEhCZmMyVjBkR2x1WjNOZmFXNXBkQUFWRFd4c2FIUjBjRjltYVc1cGMyZ0FGZ3hzYkdoMGRIQmZjR0YxYzJVQUZ3MXNiR2gwZEhCZmNtVnpkVzFsQUJnYmJHeG9kSFJ3WDNKbGMzVnRaVjloWm5SbGNsOTFjR2R5WVdSbEFCa1FiR3hvZEhSd1gyZGxkRjlsY25KdWJ3QWFGMnhzYUhSMGNGOW5aWFJmWlhKeWIzSmZjbVZoYzI5dUFCc1hiR3hvZEhSd1gzTmxkRjlsY25KdmNsOXlaV0Z6YjI0QUhCUnNiR2gwZEhCZloyVjBYMlZ5Y205eVgzQnZjd0FkRVd4c2FIUjBjRjlsY25KdWIxOXVZVzFsQUI0U2JHeG9kSFJ3WDIxbGRHaHZaRjl1WVcxbEFCOFNiR3hvZEhSd1gzTjBZWFIxYzE5dVlXMWxBQ0FhYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDJobFlXUmxjbk1BSVNGc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZlkyaDFibXRsWkY5c1pXNW5kR2dBSWgxc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmEyVmxjRjloYkdsMlpRQWpKR3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjkwY21GdWMyWmxjbDlsYm1OdlpHbHVad0FrR214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5MlpYSnphVzl1QUNVamJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyUmhkR0ZmWVdaMFpYSmZZMnh2YzJVQUppZHNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZiM0IwYVc5dVlXeGZiR1pmWVdaMFpYSmZZM0lBSnl4c2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmIzQjBhVzl1WVd4ZlkzSnNabDloWm5SbGNsOWphSFZ1YXdBb0tHeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXZjSFJwYjI1aGJGOWpjbDlpWldadmNtVmZiR1lBS1Nwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmMzQmhZMlZ6WDJGbWRHVnlYMk5vZFc1clgzTnBlbVVBS2hoc2JHaDBkSEJmYldWemMyRm5aVjl1WldWa2MxOWxiMllBTmdrWUFRQkJBUXNTQVFJREJBVUtCZ2N5TkRNdUt5OHRMREF4Q3V6YUFqUVdBRUhBMVFBb0FnQUVRQUFMUWNEVkFFRUJOZ0lBQ3hRQUlBQVFPQ0FBSUFJMkFqZ2dBQ0FCT2dBb0N4UUFJQUFnQUM4Qk5DQUFMUUF3SUFBUU54QUFDeDRCQVg5QndBQVFPaUlCRURnZ0FVR0FDRFlDT0NBQklBQTZBQ2dnQVF1UERBRUhmd0pBSUFCRkRRQWdBRUVJYXlJQklBQkJCR3NvQWdBaUFFRjRjU0lFYWlFRkFrQWdBRUVCY1EwQUlBQkJBM0ZGRFFFZ0FTQUJLQUlBSWdCcklnRkIxTlVBS0FJQVNRMEJJQUFnQkdvaEJBSkFBa0JCMk5VQUtBSUFJQUZIQkVBZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQVNnQ0NDSUFJQUVvQWd3aUFrWUVRRUhFMVFCQnhOVUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0FTZ0NHQ0VHSUFFZ0FTZ0NEQ0lBUndSQUlBQWdBU2dDQ0NJQ05nSUlJQUlnQURZQ0RBd0RDeUFCUVJScUlnTW9BZ0FpQWtVRVFDQUJLQUlRSWdKRkRRSWdBVUVRYWlFREN3TkFJQU1oQnlBQ0lnQkJGR29pQXlnQ0FDSUNEUUFnQUVFUWFpRURJQUFvQWhBaUFnMEFDeUFIUVFBMkFnQU1BZ3NnQlNnQ0JDSUFRUU54UVFOSERRSWdCU0FBUVg1eE5nSUVRY3pWQUNBRU5nSUFJQVVnQkRZQ0FDQUJJQVJCQVhJMkFnUU1Bd3RCQUNFQUN5QUdSUTBBQWtBZ0FTZ0NIQ0lDUVFKMFFmVFhBR29pQXlnQ0FDQUJSZ1JBSUFNZ0FEWUNBQ0FBRFFGQnlOVUFRY2pWQUNnQ0FFRitJQUozY1RZQ0FBd0NDeUFHUVJCQkZDQUdLQUlRSUFGR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFZMkFoZ2dBU2dDRUNJQ0JFQWdBQ0FDTmdJUUlBSWdBRFlDR0FzZ0FVRVVhaWdDQUNJQ1JRMEFJQUJCRkdvZ0FqWUNBQ0FDSUFBMkFoZ0xJQUVnQlU4TkFDQUZLQUlFSWdCQkFYRkZEUUFDUUFKQUFrQUNRQ0FBUVFKeFJRUkFRZHpWQUNnQ0FDQUZSZ1JBUWR6VkFDQUJOZ0lBUWREVkFFSFExUUFvQWdBZ0JHb2lBRFlDQUNBQklBQkJBWEkyQWdRZ0FVSFkxUUFvQWdCSERRWkJ6TlVBUVFBMkFnQkIyTlVBUVFBMkFnQU1CZ3RCMk5VQUtBSUFJQVZHQkVCQjJOVUFJQUUyQWdCQnpOVUFRY3pWQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUFJQUZxSUFBMkFnQU1CZ3NnQUVGNGNTQUVhaUVFSUFCQi93Rk5CRUFnQUVFRGRpRURJQVVvQWdnaUFDQUZLQUlNSWdKR0JFQkJ4TlVBUWNUVkFDZ0NBRUYrSUFOM2NUWUNBQXdGQ3lBQ0lBQTJBZ2dnQUNBQ05nSU1EQVFMSUFVb0FoZ2hCaUFGSUFVb0Fnd2lBRWNFUUVIVTFRQW9BZ0FhSUFBZ0JTZ0NDQ0lDTmdJSUlBSWdBRFlDREF3REN5QUZRUlJxSWdNb0FnQWlBa1VFUUNBRktBSVFJZ0pGRFFJZ0JVRVFhaUVEQ3dOQUlBTWhCeUFDSWdCQkZHb2lBeWdDQUNJQ0RRQWdBRUVRYWlFRElBQW9BaEFpQWcwQUN5QUhRUUEyQWdBTUFnc2dCU0FBUVg1eE5nSUVJQUVnQkdvZ0JEWUNBQ0FCSUFSQkFYSTJBZ1FNQXd0QkFDRUFDeUFHUlEwQUFrQWdCU2dDSENJQ1FRSjBRZlRYQUdvaUF5Z0NBQ0FGUmdSQUlBTWdBRFlDQUNBQURRRkJ5TlVBUWNqVkFDZ0NBRUYrSUFKM2NUWUNBQXdDQ3lBR1FSQkJGQ0FHS0FJUUlBVkdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBWTJBaGdnQlNnQ0VDSUNCRUFnQUNBQ05nSVFJQUlnQURZQ0dBc2dCVUVVYWlnQ0FDSUNSUTBBSUFCQkZHb2dBallDQUNBQ0lBQTJBaGdMSUFFZ0JHb2dCRFlDQUNBQklBUkJBWEkyQWdRZ0FVSFkxUUFvQWdCSERRQkJ6TlVBSUFRMkFnQU1BUXNnQkVIL0FVMEVRQ0FFUVhoeFFlelZBR29oQUFKL1FjVFZBQ2dDQUNJQ1FRRWdCRUVEZG5RaUEzRkZCRUJCeE5VQUlBSWdBM0kyQWdBZ0FBd0JDeUFBS0FJSUN5SUNJQUUyQWd3Z0FDQUJOZ0lJSUFFZ0FEWUNEQ0FCSUFJMkFnZ01BUXRCSHlFQ0lBUkIvLy8vQjAwRVFDQUVRU1lnQkVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRSUxJQUVnQWpZQ0hDQUJRZ0EzQWhBZ0FrRUNkRUgwMXdCcUlRQUNRRUhJMVFBb0FnQWlBMEVCSUFKMElnZHhSUVJBSUFBZ0FUWUNBRUhJMVFBZ0F5QUhjallDQUNBQklBQTJBaGdnQVNBQk5nSUlJQUVnQVRZQ0RBd0JDeUFFUVJrZ0FrRUJkbXRCQUNBQ1FSOUhHM1FoQWlBQUtBSUFJUUFDUUFOQUlBQWlBeWdDQkVGNGNTQUVSZzBCSUFKQkhYWWhBQ0FDUVFGMElRSWdBeUFBUVFSeGFrRVFhaUlIS0FJQUlnQU5BQXNnQnlBQk5nSUFJQUVnQXpZQ0dDQUJJQUUyQWd3Z0FTQUJOZ0lJREFFTElBTW9BZ2dpQUNBQk5nSU1JQU1nQVRZQ0NDQUJRUUEyQWhnZ0FTQUROZ0lNSUFFZ0FEWUNDQXRCNU5VQVFlVFZBQ2dDQUVFQmF5SUFRWDhnQUJzMkFnQUxDd2NBSUFBdEFDZ0xCd0FnQUMwQUtnc0hBQ0FBTFFBckN3Y0FJQUF0QUNrTEJ3QWdBQzhCTkFzSEFDQUFMUUF3QzBBQkJIOGdBQ2dDR0NFQklBQXZBUzRoQWlBQUxRQW9JUU1nQUNnQ09DRUVJQUFRT0NBQUlBUTJBamdnQUNBRE9nQW9JQUFnQWpzQkxpQUFJQUUyQWhnTGhvY0NBd2QvQTM0QmV5QUJJQUpxSVFRQ1FDQUFJZ01vQWd3aUFBMEFJQU1vQWdRRVFDQURJQUUyQWdRTEl3QkJFR3NpQ1NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FES0FJY0lnSkJBbXNPL0FFQitRRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkV2Z0JFL2NCRkJYMkFSWVg5UUVZR1JvYkhCMGVIeUQ5QWZzQklmUUJJaU1rSlNZbktDa3FLL01CTEMwdUx6QXhNdklCOFFFek5QQUI3d0UxTmpjNE9UbzdQRDArUDBCQlFrTkVSVVpIU0VsS1MweE5Uay82QVZCUlVsUHVBZTBCVk93QlZlc0JWbGRZV1ZycUFWdGNYVjVmWUdGaVkyUmxabWRvYVdwcmJHMXViM0J4Y25OMGRYWjNlSGw2ZTN4OWZuK0FBWUVCZ2dHREFZUUJoUUdHQVljQmlBR0pBWW9CaXdHTUFZMEJqZ0dQQVpBQmtRR1NBWk1CbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWVrQjZBSFBBZWNCMEFIbUFkRUIwZ0hUQWRRQjVRSFZBZFlCMXdIWUFka0IyZ0hiQWR3QjNRSGVBZDhCNEFIaEFlSUI0d0VBL0FFTFFRQU00d0VMUVE0TTRnRUxRUTBNNFFFTFFROE00QUVMUVJBTTN3RUxRUk1NM2dFTFFSUU0zUUVMUVJVTTNBRUxRUllNMndFTFFSY00yZ0VMUVJnTTJRRUxRUmtNMkFFTFFSb00xd0VMUVJzTTFnRUxRUndNMVFFTFFSME0xQUVMUVI0TTB3RUxRUjhNMGdFTFFTQU0wUUVMUVNFTTBBRUxRUWdNendFTFFTSU16Z0VMUVNRTXpRRUxRU01NekFFTFFRY015d0VMUVNVTXlnRUxRU1lNeVFFTFFTY015QUVMUVNnTXh3RUxRUklNeGdFTFFSRU14UUVMUVNrTXhBRUxRU29Nd3dFTFFTc013Z0VMUVN3TXdRRUxRZDRCRE1BQkMwRXVETDhCQzBFdkRMNEJDMEV3REwwQkMwRXhETHdCQzBFeURMc0JDMEV6RExvQkMwRTBETGtCQzBIZkFReTRBUXRCTlF5M0FRdEJPUXkyQVF0QkRBeTFBUXRCTmd5MEFRdEJOd3l6QVF0Qk9BeXlBUXRCUGd5eEFRdEJPZ3l3QVF0QjRBRU1yd0VMUVFzTXJnRUxRVDhNclFFTFFUc01yQUVMUVFvTXF3RUxRVHdNcWdFTFFUME1xUUVMUWVFQkRLZ0JDMEhCQUF5bkFRdEJ3QUFNcGdFTFFjSUFES1VCQzBFSkRLUUJDMEV0REtNQkMwSERBQXlpQVF0QnhBQU1vUUVMUWNVQURLQUJDMEhHQUF5ZkFRdEJ4d0FNbmdFTFFjZ0FESjBCQzBISkFBeWNBUXRCeWdBTW13RUxRY3NBREpvQkMwSE1BQXlaQVF0QnpRQU1tQUVMUWM0QURKY0JDMEhQQUF5V0FRdEIwQUFNbFFFTFFkRUFESlFCQzBIU0FBeVRBUXRCMHdBTWtnRUxRZFVBREpFQkMwSFVBQXlRQVF0QjFnQU1qd0VMUWRjQURJNEJDMEhZQUF5TkFRdEIyUUFNakFFTFFkb0FESXNCQzBIYkFBeUtBUXRCM0FBTWlRRUxRZDBBRElnQkMwSGVBQXlIQVF0QjN3QU1oZ0VMUWVBQURJVUJDMEhoQUF5RUFRdEI0Z0FNZ3dFTFFlTUFESUlCQzBIa0FBeUJBUXRCNVFBTWdBRUxRZUlCREg4TFFlWUFESDRMUWVjQURIMExRUVlNZkF0QjZBQU1ld3RCQlF4NkMwSHBBQXg1QzBFRURIZ0xRZW9BREhjTFFlc0FESFlMUWV3QURIVUxRZTBBREhRTFFRTU1jd3RCN2dBTWNndEI3d0FNY1F0QjhBQU1jQXRCOGdBTWJ3dEI4UUFNYmd0Qjh3QU1iUXRCOUFBTWJBdEI5UUFNYXd0QjlnQU1hZ3RCQWd4cEMwSDNBQXhvQzBINEFBeG5DMEg1QUF4bUMwSDZBQXhsQzBIN0FBeGtDMEg4QUF4akMwSDlBQXhpQzBIK0FBeGhDMEgvQUF4Z0MwR0FBUXhmQzBHQkFReGVDMEdDQVF4ZEMwR0RBUXhjQzBHRUFReGJDMEdGQVF4YUMwR0dBUXhaQzBHSEFReFlDMEdJQVF4WEMwR0pBUXhXQzBHS0FReFZDMEdMQVF4VUMwR01BUXhUQzBHTkFReFNDMEdPQVF4UkMwR1BBUXhRQzBHUUFReFBDMEdSQVF4T0MwR1NBUXhOQzBHVEFReE1DMEdVQVF4TEMwR1ZBUXhLQzBHV0FReEpDMEdYQVF4SUMwR1lBUXhIQzBHWkFReEdDMEdhQVF4RkMwR2JBUXhFQzBHY0FReERDMEdkQVF4Q0MwR2VBUXhCQzBHZkFReEFDMEdnQVF3L0MwR2hBUXcrQzBHaUFRdzlDMEdqQVF3OEMwR2tBUXc3QzBHbEFRdzZDMEdtQVF3NUMwR25BUXc0QzBHb0FRdzNDMEdwQVF3MkMwR3FBUXcxQzBHckFRdzBDMEdzQVF3ekMwR3RBUXd5QzBHdUFRd3hDMEd2QVF3d0MwR3dBUXd2QzBHeEFRd3VDMEd5QVF3dEMwR3pBUXdzQzBHMEFRd3JDMEcxQVF3cUMwRzJBUXdwQzBHM0FRd29DMEc0QVF3bkMwRzVBUXdtQzBHNkFRd2xDMEc3QVF3a0MwRzhBUXdqQzBHOUFRd2lDMEcrQVF3aEMwRy9BUXdnQzBIQUFRd2ZDMEhCQVF3ZUMwSENBUXdkQzBFQkRCd0xRY01CREJzTFFjUUJEQm9MUWNVQkRCa0xRY1lCREJnTFFjY0JEQmNMUWNnQkRCWUxRY2tCREJVTFFjb0JEQlFMUWNzQkRCTUxRY3dCREJJTFFjMEJEQkVMUWM0QkRCQUxRYzhCREE4TFFkQUJEQTRMUWRFQkRBMExRZElCREF3TFFkTUJEQXNMUWRRQkRBb0xRZFVCREFrTFFkWUJEQWdMUWVNQkRBY0xRZGNCREFZTFFkZ0JEQVVMUWRrQkRBUUxRZG9CREFNTFFkc0JEQUlMUWQwQkRBRUxRZHdCQ3lFQ0EwQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFNQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBbjhDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQXdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDRHVNQkFBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkVoTVVGUllYR0JrYUd4d2RIaDhnSVNNa0pTY29LWjREbXdPYUE1RURpZ09EQTRBRC9RTDdBdmdDOGdMeEF1OEM3UUxvQXVjQzVnTGxBdVFDM0FMYkF0b0MyUUxZQXRjQzFnTFZBczhDemdMTUFzc0N5Z0xKQXNnQ3h3TEdBc1FDd3dLK0Fyd0N1Z0s1QXJnQ3R3SzJBclVDdEFLekFySUNzUUt3QXE0Q3JRS3BBcWdDcHdLbUFxVUNwQUtqQXFJQ29RS2dBcDhDbUFLUUFvd0Npd0tLQW9FQy9nSDlBZndCK3dINkFma0IrQUgzQWZVQjh3SHdBZXNCNlFIb0FlY0I1Z0hsQWVRQjR3SGlBZUVCNEFIZkFkNEIzUUhjQWRvQjJRSFlBZGNCMWdIVkFkUUIwd0hTQWRFQjBBSFBBYzRCelFITUFjc0J5Z0hKQWNnQnh3SEdBY1VCeEFIREFjSUJ3UUhBQWI4QnZnRzlBYndCdXdHNkFia0J1QUczQWJZQnRRRzBBYk1Cc2dHeEFiQUJyd0d1QWEwQnJBR3JBYW9CcVFHb0FhY0JwZ0dsQWFRQm93R2lBWjhCbmdHWkFaZ0Jsd0dXQVpVQmxBR1RBWklCa1FHUUFZOEJqUUdNQVljQmhnR0ZBWVFCZ3dHQ0FYMThlM3A1ZG5WMFVGRlNVMVJWQ3lBQklBUkhEWEpCL1FFaEFneStBd3NnQVNBRVJ3MllBVUhiQVNFQ0RMMERDeUFCSUFSSERmRUJRWTRCSVFJTXZBTUxJQUVnQkVjTi9BRkJoQUVoQWd5N0F3c2dBU0FFUncyS0FrSC9BQ0VDRExvREN5QUJJQVJIRFpFQ1FmMEFJUUlNdVFNTElBRWdCRWNObEFKQit3QWhBZ3k0QXdzZ0FTQUVSdzBlUVI0aEFneTNBd3NnQVNBRVJ3MFpRUmdoQWd5MkF3c2dBU0FFUnczS0FrSE5BQ0VDRExVREN5QUJJQVJIRGRVQ1FjWUFJUUlNdEFNTElBRWdCRWNOMWdKQnd3QWhBZ3l6QXdzZ0FTQUVSdzNjQWtFNElRSU1zZ01MSUFNdEFEQkJBVVlOclFNTWlRTUxRUUFoQUFKQUFrQUNRQ0FETFFBcVJRMEFJQU10QUN0RkRRQWdBeThCTWlJQ1FRSnhSUTBCREFJTElBTXZBVElpQWtFQmNVVU5BUXRCQVNFQUlBTXRBQ2hCQVVZTkFDQURMd0UwSWdaQjVBQnJRZVFBU1EwQUlBWkJ6QUZHRFFBZ0JrR3dBa1lOQUNBQ1FjQUFjUTBBUVFBaEFDQUNRWWdFY1VHQUJFWU5BQ0FDUVNoeFFRQkhJUUFMSUFOQkFEc0JNaUFEUVFBNkFERUNRQ0FBUlFSQUlBTkJBRG9BTVNBRExRQXVRUVJ4RFFFTXNRTUxJQU5DQURjRElBc2dBMEVBT2dBeElBTkJBVG9BTmd4SUMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NNQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTFJSUFCQkZVY05ZaUFEUVFRMkFod2dBeUFCTmdJVUlBTkIwaHMyQWhBZ0EwRVZOZ0lNUVFBaEFneXZBd3NnQVNBRVJnUkFRUVloQWd5dkF3c2dBUzBBQUVFS1J3MFpJQUZCQVdvaEFRd2FDeUFEUWdBM0F5QkJFaUVDREpRREN5QUJJQVJIRFlvRFFTTWhBZ3lzQXdzZ0FTQUVSZ1JBUVFjaEFneXNBd3NDUUFKQUlBRXRBQUJCQ21zT0JBRVlHQUFZQ3lBQlFRRnFJUUZCRUNFQ0RKTURDeUFCUVFGcUlRRWdBMEV2YWkwQUFFRUJjUTBYUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQm1TQTJBaEFnQTBFWk5nSU1ES3NEQ3lBRElBTXBBeUFpRENBRUlBRnJyU0lLZlNJTFFnQWdDeUFNV0JzM0F5QWdDaUFNV2cwWVFRZ2hBZ3lxQXdzZ0FTQUVSd1JBSUFOQkNUWUNDQ0FESUFFMkFnUkJGQ0VDREpFREMwRUpJUUlNcVFNTElBTXBBeUJRRGE0Q0RFTUxJQUVnQkVZRVFFRUxJUUlNcUFNTElBRXRBQUJCQ2tjTkZpQUJRUUZxSVFFTUZ3c2dBMEV2YWkwQUFFRUJjVVVOR1F3bUMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NVQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFEUmtNUWd0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FsQWlBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMGFEQ1FMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKUUlnSkZEUUFnQXlBQ0VRQUFJUUFMSUFBTkd3d3lDeUFEUVM5cUxRQUFRUUZ4UlEwY0RDSUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpVSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUFOSEF4Q0MwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NWQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFEUjBNSUFzZ0FTQUVSZ1JBUVJNaEFneWdBd3NDUUNBQkxRQUFJZ0JCQ21zT0JCOGpJd0FpQ3lBQlFRRnFJUUVNSHd0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FsUWlBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMGlERUlMSUFFZ0JFWUVRRUVXSVFJTW5nTUxJQUV0QUFCQndNRUFhaTBBQUVFQlJ3MGpESU1EQ3dKQUEwQWdBUzBBQUVHd08yb3RBQUFpQUVFQlJ3UkFBa0FnQUVFQ2F3NENBd0FuQ3lBQlFRRnFJUUZCSVNFQ0RJWURDeUFFSUFGQkFXb2lBVWNOQUF0QkdDRUNESjBEQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBVUVCYWlJQkVEUWlBQTBoREVFTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSlVJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQU5Jd3dxQ3lBQklBUkdCRUJCSENFQ0RKc0RDeUFEUVFvMkFnZ2dBeUFCTmdJRVFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSlFJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQU5KVUVrSVFJTWdRTUxJQUVnQkVjRVFBTkFJQUV0QUFCQnNEMXFMUUFBSWdCQkEwY0VRQ0FBUVFGckRnVVlHaWFDQXlVbUN5QUVJQUZCQVdvaUFVY05BQXRCR3lFQ0RKb0RDMEViSVFJTW1RTUxBMEFnQVMwQUFFR3dQMm90QUFBaUFFRURSd1JBSUFCQkFXc09CUThSSnhNbUp3c2dCQ0FCUVFGcUlnRkhEUUFMUVI0aEFneVlBd3NnQVNBRVJ3UkFJQU5CQ3pZQ0NDQURJQUUyQWdSQkJ5RUNEUDhDQzBFZklRSU1sd01MSUFFZ0JFWUVRRUVnSVFJTWx3TUxBa0FnQVMwQUFFRU5hdzRVTGo4L1B6OC9QejgvUHo4L1B6OC9QejgvUHdBL0MwRUFJUUlnQTBFQU5nSWNJQU5CdndzMkFoQWdBMEVDTmdJTUlBTWdBVUVCYWpZQ0ZBeVdBd3NnQTBFdmFpRUNBMEFnQVNBRVJnUkFRU0VoQWd5WEF3c0NRQUpBQWtBZ0FTMEFBQ0lBUVFsckRoZ0NBQ2twQVNrcEtTa3BLU2twS1NrcEtTa3BLU2twS1FJbkN5QUJRUUZxSVFFZ0EwRXZhaTBBQUVFQmNVVU5DZ3dZQ3lBQlFRRnFJUUVNRndzZ0FVRUJhaUVCSUFJdEFBQkJBbkVOQUF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR2ZGVFlDRUNBRFFRdzJBZ3dNbFFNTElBTXRBQzVCZ0FGeFJRMEJDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDWENJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlEzbUFpQUFRUlZHQkVBZ0EwRWtOZ0ljSUFNZ0FUWUNGQ0FEUVpzYk5nSVFJQU5CRlRZQ0RFRUFJUUlNbEFNTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJrQTQyQWhBZ0EwRVVOZ0lNREpNREMwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYjRnTmdJUUlBTkJBallDREF5U0F3c2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFZ0RLZHFJZ0VRTWlJQVJRMHJJQU5CQnpZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNREpFREN5QURMUUF1UWNBQWNVVU5BUXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWxnaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVTkt5QUFRUlZHQkVBZ0EwRUtOZ0ljSUFNZ0FUWUNGQ0FEUWVzWk5nSVFJQU5CRlRZQ0RFRUFJUUlNa0FNTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJrd3cyQWhBZ0EwRVROZ0lNREk4REMwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWUlWTmdJUUlBTkJBallDREF5T0F3dEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhkRkRZQ0VDQURRUmsyQWd3TWpRTUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CNWgwMkFoQWdBMEVaTmdJTURJd0RDeUFBUVJWR0RUMUJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhRRHpZQ0VDQURRU0kyQWd3TWl3TUxJQU1vQWdRaEFFRUFJUUlnQTBFQU5nSUVJQU1nQUNBQkVETWlBRVVOS0NBRFFRMDJBaHdnQXlBQk5nSVVJQU1nQURZQ0RBeUtBd3NnQUVFVlJnMDZRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CMEE4MkFoQWdBMEVpTmdJTURJa0RDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FSQXpJZ0JGQkVBZ0FVRUJhaUVCRENnTElBTkJEallDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVRElnREN5QUFRUlZHRFRkQkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFFEellDRUNBRFFTSTJBZ3dNaHdNTElBTW9BZ1FoQUVFQUlRSWdBMEVBTmdJRUlBTWdBQ0FCRURNaUFFVUVRQ0FCUVFGcUlRRU1Kd3NnQTBFUE5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUU1oZ01MUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjRoYzJBaEFnQTBFWk5nSU1ESVVEQ3lBQVFSVkdEVE5CQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIV0REWUNFQ0FEUVNNMkFnd01oQU1MSUFNb0FnUWhBRUVBSVFJZ0EwRUFOZ0lFSUFNZ0FDQUJFRFFpQUVVTkpTQURRUkUyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNEQXlEQXdzZ0FFRVZSZzB3UVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjFndzJBaEFnQTBFak5nSU1ESUlEQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkEwSWdCRkJFQWdBVUVCYWlFQkRDVUxJQU5CRWpZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVURJRURDeUFEUVM5cUxRQUFRUUZ4UlEwQkMwRVhJUUlNNWdJTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI0aGMyQWhBZ0EwRVpOZ0lNRFA0Q0N5QUFRVHRIRFFBZ0FVRUJhaUVCREF3TFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJraGcyQWhBZ0EwRUNOZ0lNRFB3Q0N5QUFRUlZHRFNoQkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFdERFlDRUNBRFFTTTJBZ3dNK3dJTElBTkJGRFlDSENBRElBRTJBaFFnQXlBQU5nSU1EUG9DQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkEwSWdCRkJFQWdBVUVCYWlFQkRQVUNDeUFEUVJVMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZBejVBZ3NnQXlnQ0JDRUFRUUFoQWlBRFFRQTJBZ1FnQXlBQUlBRVFOQ0lBUlFSQUlBRkJBV29oQVF6ekFnc2dBMEVYTmdJY0lBTWdBRFlDRENBRElBRkJBV28yQWhRTStBSUxJQUJCRlVZTkkwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZFlNTmdJUUlBTkJJellDREF6M0Fnc2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFUU5DSUFSUVJBSUFGQkFXb2hBUXdkQ3lBRFFSazJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGQXoyQWdzZ0F5Z0NCQ0VBUVFBaEFpQURRUUEyQWdRZ0F5QUFJQUVRTkNJQVJRUkFJQUZCQVdvaEFRenZBZ3NnQTBFYU5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUU05UUlMSUFCQkZVWU5IMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWRBUE5nSVFJQU5CSWpZQ0RBejBBZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBeklnQkZCRUFnQVVFQmFpRUJEQnNMSUFOQkhEWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd6ekFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF6SWdCRkJFQWdBVUVCYWlFQkRPc0NDeUFEUVIwMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNOGdJTElBQkJPMGNOQVNBQlFRRnFJUUVMUVNZaEFnelhBZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHZkZUWUNFQ0FEUVF3MkFnd003d0lMSUFFZ0JFY0VRQU5BSUFFdEFBQkJJRWNOaEFJZ0JDQUJRUUZxSWdGSERRQUxRU3doQWd6dkFndEJMQ0VDRE80Q0N5QUJJQVJHQkVCQk5DRUNETzRDQ3dKQUFrQURRQUpBSUFFdEFBQkJDbXNPQkFJQUFBTUFDeUFFSUFGQkFXb2lBVWNOQUF0Qk5DRUNETzhDQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVERWlBRVVObndJZ0EwRXlOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRE80Q0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFREVpQUVVRVFDQUJRUUZxSVFFTW53SUxJQU5CTWpZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVVFRQWhBZ3p0QWdzZ0FTQUVSd1JBQWtBRFFDQUJMUUFBUVRCcklnQkIvd0Z4UVFwUEJFQkJPaUVDRE5jQ0N5QURLUU1nSWd0Q21iUG16Sm16NXN3WlZnMEJJQU1nQzBJS2ZpSUtOd01nSUFvZ0FLMUMvd0dESWd0Q2Y0VldEUUVnQXlBS0lBdDhOd01nSUFRZ0FVRUJhaUlCUncwQUMwSEFBQ0VDRE80Q0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJRUUZxSWdFUU1TSUFEUmNNNGdJTFFjQUFJUUlNN0FJTElBRWdCRVlFUUVISkFDRUNET3dDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXFJQ29nS3BBcUlDb2dLaUFxSUNvZ0tpQXFJQ29nS2lBcUlDb2dLaUFxSUNvZ0tpQXFJQ29nS2lBZ0NpQWdzZ0JDQUJRUUZxSWdGSERRQUxRY2tBSVFJTTdBSUxJQUZCQVdvaEFTQURRUzlxTFFBQVFRRnhEYVVDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdYRURZQ0VDQURRUW8yQWd4QkFDRUNET3NDQ3lBQklBUkhCRUFEUUNBQkxRQUFRU0JIRFJVZ0JDQUJRUUZxSWdGSERRQUxRZmdBSVFJTTZ3SUxRZmdBSVFJTTZnSUxJQU5CQWpvQUtBdzRDMEVBSVFJZ0EwRUFOZ0ljSUFOQnZ3czJBaEFnQTBFQ05nSU1JQU1nQVVFQmFqWUNGQXpvQWd0QkFDRUNETTRDQzBFTklRSU16UUlMUVJNaEFnek1BZ3RCRlNFQ0RNc0NDMEVXSVFJTXlnSUxRUmdoQWd6SkFndEJHU0VDRE1nQ0MwRWFJUUlNeHdJTFFSc2hBZ3pHQWd0QkhDRUNETVVDQzBFZElRSU14QUlMUVI0aEFnekRBZ3RCSHlFQ0RNSUNDMEVnSVFJTXdRSUxRU0loQWd6QUFndEJJeUVDREw4Q0MwRWxJUUlNdmdJTFFlVUFJUUlNdlFJTElBTkJQVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd6VkFnc2dBMEViTmdJY0lBTWdBVFlDRkNBRFFhUWNOZ0lRSUFOQkZUWUNERUVBSVFJTTFBSUxJQU5CSURZQ0hDQURJQUUyQWhRZ0EwR1lHallDRUNBRFFSVTJBZ3hCQUNFQ0ROTUNDeUFEUVJNMkFod2dBeUFCTmdJVUlBTkJtQm8yQWhBZ0EwRVZOZ0lNUVFBaEFnelNBZ3NnQTBFTE5nSWNJQU1nQVRZQ0ZDQURRWmdhTmdJUUlBTkJGVFlDREVFQUlRSU0wUUlMSUFOQkVEWUNIQ0FESUFFMkFoUWdBMEdZR2pZQ0VDQURRUlUyQWd4QkFDRUNETkFDQ3lBRFFTQTJBaHdnQXlBQk5nSVVJQU5CcEJ3MkFoQWdBMEVWTmdJTVFRQWhBZ3pQQWdzZ0EwRUxOZ0ljSUFNZ0FUWUNGQ0FEUWFRY05nSVFJQU5CRlRZQ0RFRUFJUUlNemdJTElBTkJERFlDSENBRElBRTJBaFFnQTBHa0hEWUNFQ0FEUVJVMkFneEJBQ0VDRE0wQ0MwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZDBPTmdJUUlBTkJFallDREF6TUFnc0NRQU5BQWtBZ0FTMEFBRUVLYXc0RUFBSUNBQUlMSUFRZ0FVRUJhaUlCUncwQUMwSDlBU0VDRE13Q0N3SkFBa0FnQXkwQU5rRUJSdzBBUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKZ0lnSkZEUUFnQXlBQ0VRQUFJUUFMSUFCRkRRQWdBRUVWUncwQklBTkIvQUUyQWh3Z0F5QUJOZ0lVSUFOQjNCazJBaEFnQTBFVk5nSU1RUUFoQWd6TkFndEIzQUVoQWd5ekFnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFma0xOZ0lRSUFOQkh6WUNERUVBSVFJTXl3SUxBa0FDUUNBRExRQW9RUUZyRGdJRUFRQUxRZHNCSVFJTXNnSUxRZFFCSVFJTXNRSUxJQU5CQWpvQU1VRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NBQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUVJBUWQwQklRSU1zUUlMSUFCQkZVY0VRQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkJ0QXcyQWhBZ0EwRVFOZ0lNUVFBaEFnektBZ3NnQTBIN0FUWUNIQ0FESUFFMkFoUWdBMEdCR2pZQ0VDQURRUlUyQWd4QkFDRUNETWtDQ3lBQklBUkdCRUJCK2dFaEFnekpBZ3NnQVMwQUFFSElBRVlOQVNBRFFRRTZBQ2dMUWNBQklRSU1yZ0lMUWRvQklRSU1yUUlMSUFFZ0JFY0VRQ0FEUVF3MkFnZ2dBeUFCTmdJRVFka0JJUUlNclFJTFFma0JJUUlNeFFJTElBRWdCRVlFUUVINEFTRUNETVVDQ3lBQkxRQUFRY2dBUncwRUlBRkJBV29oQVVIWUFTRUNES3NDQ3lBQklBUkdCRUJCOXdFaEFnekVBZ3NDUUFKQUlBRXRBQUJCeFFCckRoQUFCUVVGQlFVRkJRVUZCUVVGQlFVQkJRc2dBVUVCYWlFQlFkWUJJUUlNcXdJTElBRkJBV29oQVVIWEFTRUNES29DQzBIMkFTRUNJQUVnQkVZTndnSWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJ1dFVBYWkwQUFFY05BeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU13d0lMSUFNb0FnUWhBQ0FEUWdBM0F3QWdBeUFBSUFaQkFXb2lBUkF1SWdCRkJFQkI0d0VoQWd5cUFnc2dBMEgxQVRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFnekNBZ3RCOUFFaEFpQUJJQVJHRGNFQ0lBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFialZBR290QUFCSERRSWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURNSUNDeUFEUVlFRU93RW9JQU1vQWdRaEFDQURRZ0EzQXdBZ0F5QUFJQVpCQVdvaUFSQXVJZ0FOQXd3Q0N5QURRUUEyQWdBTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI1UjgyQWhBZ0EwRUlOZ0lNREw4Q0MwSFZBU0VDREtVQ0N5QURRZk1CTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RMMENDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDUUNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlExdUlBQkJGVWNFUUNBRFFRQTJBaHdnQXlBQk5nSVVJQU5CZ2c4MkFoQWdBMEVnTmdJTVFRQWhBZ3k5QWdzZ0EwR1BBVFlDSENBRElBRTJBaFFnQTBIc0d6WUNFQ0FEUVJVMkFneEJBQ0VDREx3Q0N5QUJJQVJIQkVBZ0EwRU5OZ0lJSUFNZ0FUWUNCRUhUQVNFQ0RLTUNDMEh5QVNFQ0RMc0NDeUFCSUFSR0JFQkI4UUVoQWd5N0Fnc0NRQUpBQWtBZ0FTMEFBRUhJQUdzT0N3QUJDQWdJQ0FnSUNBZ0NDQXNnQVVFQmFpRUJRZEFCSVFJTW93SUxJQUZCQVdvaEFVSFJBU0VDREtJQ0N5QUJRUUZxSVFGQjBnRWhBZ3loQWd0QjhBRWhBaUFCSUFSR0Ria0NJQU1vQWdBaUFDQUVJQUZyYWlFR0lBRWdBR3RCQW1vaEJRTkFJQUV0QUFBZ0FFRzExUUJxTFFBQVJ3MEVJQUJCQWtZTkF5QUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQmpZQ0FBeTVBZ3RCN3dFaEFpQUJJQVJHRGJnQ0lBTW9BZ0FpQUNBRUlBRnJhaUVHSUFFZ0FHdEJBV29oQlFOQUlBRXRBQUFnQUVHejFRQnFMUUFBUncwRElBQkJBVVlOQWlBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCallDQUF5NEFndEI3Z0VoQWlBQklBUkdEYmNDSUFNb0FnQWlBQ0FFSUFGcmFpRUdJQUVnQUd0QkFtb2hCUU5BSUFFdEFBQWdBRUd3MVFCcUxRQUFSdzBDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JqWUNBQXkzQWdzZ0F5Z0NCQ0VBSUFOQ0FEY0RBQ0FESUFBZ0JVRUJhaUlCRUNzaUFFVU5BaUFEUWV3Qk5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNETFlDQ3lBRFFRQTJBZ0FMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUt5SUFSUTJjQWlBRFFlMEJOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRExRQ0MwSFBBU0VDREpvQ0MwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NOQ0lDUlEwQUlBTWdBaEVBQUNFQUN3SkFJQUFFUUNBQVFSVkdEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZW9OTmdJUUlBTkJKallDREVFQUlRSU10QUlMUWM0QklRSU1tZ0lMSUFOQjZ3RTJBaHdnQXlBQk5nSVVJQU5CZ0JzMkFoQWdBMEVWTmdJTVFRQWhBZ3l5QWdzZ0FTQUVSZ1JBUWVzQklRSU1zZ0lMSUFFdEFBQkJMMFlFUUNBQlFRRnFJUUVNQVFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWJJNE5nSVFJQU5CQ0RZQ0RFRUFJUUlNc1FJTFFjMEJJUUlNbHdJTElBRWdCRWNFUUNBRFFRNDJBZ2dnQXlBQk5nSUVRY3dCSVFJTWx3SUxRZW9CSVFJTXJ3SUxJQUVnQkVZRVFFSHBBU0VDREs4Q0N5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBeUFBT2dBcUlBRkJBV29oQVVITEFTRUNESllDQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDOGlBRVVObHdJZ0EwSG9BVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5dUFnc2dBU0FFUmdSQVFlY0JJUUlNcmdJTEFrQWdBUzBBQUVFdVJnUkFJQUZCQVdvaEFRd0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM4aUFFVU5tQUlnQTBIbUFUWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3l1QWd0QnlnRWhBZ3lVQWdzZ0FTQUVSZ1JBUWVVQklRSU1yUUlMUVFBaEFFRUJJUVZCQVNFSFFRQWhBZ0pBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09DZ29KQUFFQ0F3UUZCZ2dMQzBFQ0RBWUxRUU1NQlF0QkJBd0VDMEVGREFNTFFRWU1BZ3RCQnd3QkMwRUlDeUVDUVFBaEJVRUFJUWNNQWd0QkNTRUNRUUVoQUVFQUlRVkJBQ0VIREFFTFFRQWhCVUVCSVFJTElBTWdBam9BS3lBQlFRRnFJUUVDUUFKQUlBTXRBQzVCRUhFTkFBSkFBa0FDUUNBRExRQXFEZ01CQUFJRUN5QUhSUTBEREFJTElBQU5BUXdDQ3lBRlJRMEJDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM4aUFFVU5BaUFEUWVJQk5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESzhDQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDOGlBRVVObWdJZ0EwSGpBVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5dUFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF2SWdCRkRaZ0NJQU5CNUFFMkFod2dBeUFCTmdJVUlBTWdBRFlDREF5dEFndEJ5UUVoQWd5VEFndEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9Ba1FpQWtVTkFDQURJQUlSQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdrRFRZQ0VDQURRU0UyQWd4QkFDRUNESzBDQzBISUFTRUNESk1DQ3lBRFFlRUJOZ0ljSUFNZ0FUWUNGQ0FEUWRBYU5nSVFJQU5CRlRZQ0RFRUFJUUlNcXdJTElBRWdCRVlFUUVIaEFTRUNES3NDQ3dKQUlBRXRBQUJCSUVZRVFDQURRUUE3QVRRZ0FVRUJhaUVCREFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBHWkVUWUNFQ0FEUVFrMkFneEJBQ0VDREtzQ0MwSEhBU0VDREpFQ0N5QUJJQVJHQkVCQjRBRWhBZ3lxQWdzQ1FDQUJMUUFBUVRCclFmOEJjU0lDUVFwSkJFQWdBVUVCYWlFQkFrQWdBeThCTkNJQVFaa3pTdzBBSUFNZ0FFRUtiQ0lBT3dFMElBQkIvdjhEY1NBQ1FmLy9BM05MRFFBZ0F5QUFJQUpxT3dFMERBSUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CbFI0MkFoQWdBMEVOTmdJTURLc0NDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJsUjQyQWhBZ0EwRU5OZ0lNUVFBaEFneXFBZ3RCeGdFaEFneVFBZ3NnQVNBRVJnUkFRZDhCSVFJTXFRSUxBa0FnQVMwQUFFRXdhMEgvQVhFaUFrRUtTUVJBSUFGQkFXb2hBUUpBSUFNdkFUUWlBRUdaTTBzTkFDQURJQUJCQ213aUFEc0JOQ0FBUWY3L0EzRWdBa0gvL3dOelN3MEFJQU1nQUNBQ2Fqc0JOQXdDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFaVWVOZ0lRSUFOQkRUWUNEQXlxQWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpVZU5nSVFJQU5CRFRZQ0RFRUFJUUlNcVFJTFFjVUJJUUlNandJTElBRWdCRVlFUUVIZUFTRUNES2dDQ3dKQUlBRXRBQUJCTUd0Qi93RnhJZ0pCQ2trRVFDQUJRUUZxSVFFQ1FDQURMd0UwSWdCQm1UTkxEUUFnQXlBQVFRcHNJZ0E3QVRRZ0FFSCsvd054SUFKQi8vOERjMHNOQUNBRElBQWdBbW83QVRRTUFndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdWSGpZQ0VDQURRUTAyQWd3TXFRSUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR1ZIallDRUNBRFFRMDJBZ3hCQUNFQ0RLZ0NDMEhFQVNFQ0RJNENDeUFCSUFSR0JFQkIzUUVoQWd5bkFnc0NRQUpBQWtBQ1FDQUJMUUFBUVFwckRoY0NBd01BQXdNREF3TURBd01EQXdNREF3TURBd01EQVFNTElBRkJBV29NQlFzZ0FVRUJhaUVCUWNNQklRSU1qd0lMSUFGQkFXb2hBU0FEUVM5cUxRQUFRUUZ4RFFnZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVkwTE5nSVFJQU5CRFRZQ0RFRUFJUUlNcHdJTElBTkJBRFlDSENBRElBRTJBaFFnQTBHTkN6WUNFQ0FEUVEwMkFneEJBQ0VDREtZQ0N5QUJJQVJIQkVBZ0EwRVBOZ0lJSUFNZ0FUWUNCRUVCSVFJTWpRSUxRZHdCSVFJTXBRSUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEhiQVNFQ0RLWUNDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUMwaUFFVUVRQ0FCUVFGcUlRRU1CQXNnQTBIYUFUWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd5bEFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF0SWdBTkFTQUJRUUZxQ3lFQlFjRUJJUUlNaWdJTElBTkIyUUUyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkVFQUlRSU1vZ0lMUWNJQklRSU1pQUlMSUFOQkwyb3RBQUJCQVhFTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjVCdzJBaEFnQTBFWk5nSU1RUUFoQWd5Z0Fnc2dBU0FFUmdSQVFka0JJUUlNb0FJTEFrQUNRQUpBSUFFdEFBQkJDbXNPQkFFQ0FnQUNDeUFCUVFGcUlRRU1BZ3NnQVVFQmFpRUJEQUVMSUFNdEFDNUJ3QUJ4UlEwQkMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NQQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTJnQVNBQVFSVkdCRUFnQTBIWkFEWUNIQ0FESUFFMkFoUWdBMEczR2pZQ0VDQURRUlUyQWd4QkFDRUNESjhDQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CZ0EwMkFoQWdBMEViTmdJTVFRQWhBZ3llQWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWR3b05nSVFJQU5CQWpZQ0RFRUFJUUlNblFJTElBRWdCRWNFUUNBRFFRdzJBZ2dnQXlBQk5nSUVRYjhCSVFJTWhBSUxRZGdCSVFJTW5BSUxJQUVnQkVZRVFFSFhBU0VDREp3Q0N3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUhCQUdzT0ZRQUJBZ05hQkFVR1dscGFCd2dKQ2dzTURRNFBFRm9MSUFGQkFXb2hBVUg3QUNFQ0RKSUNDeUFCUVFGcUlRRkIvQUFoQWd5UkFnc2dBVUVCYWlFQlFZRUJJUUlNa0FJTElBRkJBV29oQVVHRkFTRUNESThDQ3lBQlFRRnFJUUZCaGdFaEFneU9BZ3NnQVVFQmFpRUJRWWtCSVFJTWpRSUxJQUZCQVdvaEFVR0tBU0VDREl3Q0N5QUJRUUZxSVFGQmpRRWhBZ3lMQWdzZ0FVRUJhaUVCUVpZQklRSU1pZ0lMSUFGQkFXb2hBVUdYQVNFQ0RJa0NDeUFCUVFGcUlRRkJtQUVoQWd5SUFnc2dBVUVCYWlFQlFhVUJJUUlNaHdJTElBRkJBV29oQVVHbUFTRUNESVlDQ3lBQlFRRnFJUUZCckFFaEFneUZBZ3NnQVVFQmFpRUJRYlFCSVFJTWhBSUxJQUZCQVdvaEFVRzNBU0VDRElNQ0N5QUJRUUZxSVFGQnZnRWhBZ3lDQWdzZ0FTQUVSZ1JBUWRZQklRSU1td0lMSUFFdEFBQkJ6Z0JIRFVnZ0FVRUJhaUVCUWIwQklRSU1nUUlMSUFFZ0JFWUVRRUhWQVNFQ0RKb0NDd0pBQWtBQ1FDQUJMUUFBUWNJQWF3NFNBRXBLU2twS1NrcEtTZ0ZLU2twS1Nrb0NTZ3NnQVVFQmFpRUJRYmdCSVFJTWdnSUxJQUZCQVdvaEFVRzdBU0VDRElFQ0N5QUJRUUZxSVFGQnZBRWhBZ3lBQWd0QjFBRWhBaUFCSUFSR0RaZ0NJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQjJvaEJnSkFBMEFnQVMwQUFDQUFRYWpWQUdvdEFBQkhEVVVnQUVFSFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFESmtDQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUnNNUlFzZ0FTQUVSZ1JBUWRNQklRSU1tQUlMQWtBQ1FDQUJMUUFBUWNrQWF3NEhBRWRIUjBkSEFVY0xJQUZCQVdvaEFVRzVBU0VDRFA4QkN5QUJRUUZxSVFGQnVnRWhBZ3orQVF0QjBnRWhBaUFCSUFSR0RaWUNJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYWJWQUdvdEFBQkhEVU1nQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFESmNDQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUThNUXd0QjBRRWhBaUFCSUFSR0RaVUNJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYVRWQUdvdEFBQkhEVUlnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFESllDQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRU0FNUWd0QjBBRWhBaUFCSUFSR0RaUUNJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRYUhWQUdvdEFBQkhEVUVnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFESlVDQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUklNUVFzZ0FTQUVSZ1JBUWM4QklRSU1sQUlMQWtBQ1FDQUJMUUFBUWNVQWF3NE9BRU5EUTBORFEwTkRRME5EUXdGREN5QUJRUUZxSVFGQnRRRWhBZ3o3QVFzZ0FVRUJhaUVCUWJZQklRSU0rZ0VMUWM0QklRSWdBU0FFUmcyU0FpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR2UxUUJxTFFBQVJ3MC9JQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeVRBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRUhERDhMUWMwQklRSWdBU0FFUmcyUkFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFR1kxUUJxTFFBQVJ3MCtJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeVNBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRW9ERDRMSUFFZ0JFWUVRRUhNQVNFQ0RKRUNDd0pBQWtBQ1FDQUJMUUFBUWNVQWF3NFJBRUZCUVVGQlFVRkJRUUZCUVVGQlFRSkJDeUFCUVFGcUlRRkJzUUVoQWd6NUFRc2dBVUVCYWlFQlFiSUJJUUlNK0FFTElBRkJBV29oQVVHekFTRUNEUGNCQzBITEFTRUNJQUVnQkVZTmp3SWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVHYWlFR0FrQURRQ0FCTFFBQUlBQkJrZFVBYWkwQUFFY05QQ0FBUVFaR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1rQUlMSUFOQkFEWUNBQ0FHUVFGcUlRRkJHZ3c4QzBIS0FTRUNJQUVnQkVZTmpnSWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJqZFVBYWkwQUFFY05PeUFBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1qd0lMSUFOQkFEWUNBQ0FHUVFGcUlRRkJJUXc3Q3lBQklBUkdCRUJCeVFFaEFneU9BZ3NDUUFKQUlBRXRBQUJCd1FCckRoUUFQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlBVDBMSUFGQkFXb2hBVUd0QVNFQ0RQVUJDeUFCUVFGcUlRRkJzQUVoQWd6MEFRc2dBU0FFUmdSQVFjZ0JJUUlNalFJTEFrQUNRQ0FCTFFBQVFkVUFhdzRMQUR3OFBEdzhQRHc4UEFFOEN5QUJRUUZxSVFGQnJnRWhBZ3owQVFzZ0FVRUJhaUVCUWE4QklRSU04d0VMUWNjQklRSWdBU0FFUmcyTEFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUWhxSVFZQ1FBTkFJQUV0QUFBZ0FFR0UxUUJxTFFBQVJ3MDRJQUJCQ0VZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeU1BZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRXFERGdMSUFFZ0JFWUVRRUhHQVNFQ0RJc0NDeUFCTFFBQVFkQUFSdzA0SUFGQkFXb2hBVUVsRERjTFFjVUJJUUlnQVNBRVJnMkpBaUFES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdCMVFCcUxRQUFSdzAySUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXlLQWdzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVPRERZTElBRWdCRVlFUUVIRUFTRUNESWtDQ3lBQkxRQUFRY1VBUncwMklBRkJBV29oQVVHckFTRUNETzhCQ3lBQklBUkdCRUJCd3dFaEFneUlBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFjSUFhdzRQQUFFQ09UazVPVGs1T1RrNU9Ua0RPUXNnQVVFQmFpRUJRYWNCSVFJTThRRUxJQUZCQVdvaEFVR29BU0VDRFBBQkN5QUJRUUZxSVFGQnFRRWhBZ3p2QVFzZ0FVRUJhaUVCUWFvQklRSU03Z0VMUWNJQklRSWdBU0FFUmcyR0FpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSCsxQUJxTFFBQVJ3MHpJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUhBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRVVERE1MUWNFQklRSWdBU0FFUmcyRkFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVJxSVFZQ1FBTkFJQUV0QUFBZ0FFSDUxQUJxTFFBQVJ3MHlJQUJCQkVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUdBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRXJERElMUWNBQklRSWdBU0FFUmcyRUFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSDIxQUJxTFFBQVJ3MHhJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUZBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRXNEREVMUWI4QklRSWdBU0FFUmcyREFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR2gxUUJxTFFBQVJ3MHdJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUVBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRVJEREFMUWI0QklRSWdBU0FFUmcyQ0FpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUU5xSVFZQ1FBTkFJQUV0QUFBZ0FFSHkxQUJxTFFBQVJ3MHZJQUJCQTBZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeURBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRXVEQzhMSUFFZ0JFWUVRRUc5QVNFQ0RJSUNDd0pBQWtBQ1FBSkFBa0FnQVMwQUFFSEJBR3NPRlFBME5EUTBORFEwTkRRMEFUUTBBalEwQXpRMEJEUUxJQUZCQVdvaEFVR2JBU0VDRE93QkN5QUJRUUZxSVFGQm5BRWhBZ3pyQVFzZ0FVRUJhaUVCUVowQklRSU02Z0VMSUFGQkFXb2hBVUdpQVNFQ0RPa0JDeUFCUVFGcUlRRkJwQUVoQWd6b0FRc2dBU0FFUmdSQVFid0JJUUlNZ1FJTEFrQUNRQ0FCTFFBQVFkSUFhdzREQURBQk1Bc2dBVUVCYWlFQlFhTUJJUUlNNkFFTElBRkJBV29oQVVFRURDMExRYnNCSVFJZ0FTQUVSZzMvQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIdzFBQnFMUUFBUncwc0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5QUFnc2dBMEVBTmdJQUlBWkJBV29oQVVFZERDd0xJQUVnQkVZRVFFRzZBU0VDRFA4QkN3SkFBa0FnQVMwQUFFSEpBR3NPQndFdUxpNHVMZ0F1Q3lBQlFRRnFJUUZCb1FFaEFnem1BUXNnQVVFQmFpRUJRU0lNS3dzZ0FTQUVSZ1JBUWJrQklRSU0vZ0VMSUFFdEFBQkIwQUJIRFNzZ0FVRUJhaUVCUWFBQklRSU01QUVMSUFFZ0JFWUVRRUc0QVNFQ0RQMEJDd0pBQWtBZ0FTMEFBRUhHQUdzT0N3QXNMQ3dzTEN3c0xDd0JMQXNnQVVFQmFpRUJRWjRCSVFJTTVBRUxJQUZCQVdvaEFVR2ZBU0VDRE9NQkMwRzNBU0VDSUFFZ0JFWU4rd0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCN05RQWFpMEFBRWNOS0NBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNL0FFTElBTkJBRFlDQUNBR1FRRnFJUUZCRFF3b0MwRzJBU0VDSUFFZ0JFWU4rZ0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCb2RVQWFpMEFBRWNOSnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK3dFTElBTkJBRFlDQUNBR1FRRnFJUUZCREF3bkMwRzFBU0VDSUFFZ0JFWU4rUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCNnRRQWFpMEFBRWNOSmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK2dFTElBTkJBRFlDQUNBR1FRRnFJUUZCQXd3bUMwRzBBU0VDSUFFZ0JFWU4rQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCNk5RQWFpMEFBRWNOSlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK1FFTElBTkJBRFlDQUNBR1FRRnFJUUZCSmd3bEN5QUJJQVJHQkVCQnN3RWhBZ3o0QVFzQ1FBSkFJQUV0QUFCQjFBQnJEZ0lBQVNjTElBRkJBV29oQVVHWkFTRUNETjhCQ3lBQlFRRnFJUUZCbWdFaEFnemVBUXRCc2dFaEFpQUJJQVJHRGZZQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFlYlVBR290QUFCSERTTWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQY0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFTY01Jd3RCc1FFaEFpQUJJQVJHRGZVQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFlVFVBR290QUFCSERTSWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQWUJDeUFEUVFBMkFnQWdCa0VCYWlFQlFSd01JZ3RCc0FFaEFpQUJJQVJHRGZRQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFkN1VBR290QUFCSERTRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQVUJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRWU1JUXRCcndFaEFpQUJJQVJHRGZNQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFkblVBR290QUFCSERTQWdBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQUUJDeUFEUVFBMkFnQWdCa0VCYWlFQlFSa01JQXNnQVNBRVJnUkFRYTRCSVFJTTh3RUxBa0FDUUFKQUFrQWdBUzBBQUVFdGF3NGpBQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQ1FrSkNRa0FTUWtKQ1FrQWlRa0pBTWtDeUFCUVFGcUlRRkJqZ0VoQWd6Y0FRc2dBVUVCYWlFQlFZOEJJUUlNMndFTElBRkJBV29oQVVHVUFTRUNETm9CQ3lBQlFRRnFJUUZCbFFFaEFnelpBUXRCclFFaEFpQUJJQVJHRGZFQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFkZlVBR290QUFCSERSNGdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURQSUJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRc01IZ3NnQVNBRVJnUkFRYXdCSVFJTThRRUxBa0FDUUNBQkxRQUFRY0VBYXc0REFDQUJJQXNnQVVFQmFpRUJRWkFCSVFJTTJBRUxJQUZCQVdvaEFVR1RBU0VDRE5jQkN5QUJJQVJHQkVCQnF3RWhBZ3p3QVFzQ1FBSkFJQUV0QUFCQndRQnJEZzhBSHg4Zkh4OGZIeDhmSHg4Zkh3RWZDeUFCUVFGcUlRRkJrUUVoQWd6WEFRc2dBVUVCYWlFQlFaSUJJUUlNMWdFTElBRWdCRVlFUUVHcUFTRUNETzhCQ3lBQkxRQUFRY3dBUncwY0lBRkJBV29oQVVFS0RCc0xRYWtCSVFJZ0FTQUVSZzN0QVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIUjFBQnFMUUFBUncwYUlBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6dUFRc2dBMEVBTmdJQUlBWkJBV29oQVVFZURCb0xRYWdCSVFJZ0FTQUVSZzNzQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRWnFJUVlDUUFOQUlBRXRBQUFnQUVISzFBQnFMUUFBUncwWklBQkJCa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6dEFRc2dBMEVBTmdJQUlBWkJBV29oQVVFVkRCa0xRYWNCSVFJZ0FTQUVSZzNyQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVISDFBQnFMUUFBUncwWUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6c0FRc2dBMEVBTmdJQUlBWkJBV29oQVVFWERCZ0xRYVlCSVFJZ0FTQUVSZzNxQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIQjFBQnFMUUFBUncwWElBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6ckFRc2dBMEVBTmdJQUlBWkJBV29oQVVFWURCY0xJQUVnQkVZRVFFR2xBU0VDRE9vQkN3SkFBa0FnQVMwQUFFSEpBR3NPQndBWkdSa1pHUUVaQ3lBQlFRRnFJUUZCaXdFaEFnelJBUXNnQVVFQmFpRUJRWXdCSVFJTTBBRUxRYVFCSVFJZ0FTQUVSZzNvQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHbTFRQnFMUUFBUncwVklBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6cEFRc2dBMEVBTmdJQUlBWkJBV29oQVVFSkRCVUxRYU1CSVFJZ0FTQUVSZzNuQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHazFRQnFMUUFBUncwVUlBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6b0FRc2dBMEVBTmdJQUlBWkJBV29oQVVFZkRCUUxRYUlCSVFJZ0FTQUVSZzNtQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVHKzFBQnFMUUFBUncwVElBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6bkFRc2dBMEVBTmdJQUlBWkJBV29oQVVFQ0RCTUxRYUVCSVFJZ0FTQUVSZzNsQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlEUUNBQkxRQUFJQUJCdk5RQWFpMEFBRWNORVNBQVFRRkdEUUlnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNNVFFTElBRWdCRVlFUUVHZ0FTRUNET1VCQzBFQklBRXRBQUJCM3dCSERSRWFJQUZCQVdvaEFVR0hBU0VDRE1zQkN5QURRUUEyQWdBZ0JrRUJhaUVCUVlnQklRSU15Z0VMUVo4QklRSWdBU0FFUmczaUFTQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUWhxSVFZQ1FBTkFJQUV0QUFBZ0FFR0UxUUJxTFFBQVJ3MFBJQUJCQ0VZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBempBUXNnQTBFQU5nSUFJQVpCQVdvaEFVRXBEQThMUVo0QklRSWdBU0FFUmczaEFTQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUU5xSVFZQ1FBTkFJQUV0QUFBZ0FFRzQxQUJxTFFBQVJ3ME9JQUJCQTBZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBemlBUXNnQTBFQU5nSUFJQVpCQVdvaEFVRXREQTRMSUFFZ0JFWUVRRUdkQVNFQ0RPRUJDeUFCTFFBQVFjVUFSdzBPSUFGQkFXb2hBVUdFQVNFQ0RNY0JDeUFCSUFSR0JFQkJuQUVoQWd6Z0FRc0NRQUpBSUFFdEFBQkJ6QUJyRGdnQUR3OFBEdzhQQVE4TElBRkJBV29oQVVHQ0FTRUNETWNCQ3lBQlFRRnFJUUZCZ3dFaEFnekdBUXRCbXdFaEFpQUJJQVJHRGQ0QklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFiUFVBR290QUFCSERRc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROOEJDeUFEUVFBMkFnQWdCa0VCYWlFQlFTTU1Dd3RCbWdFaEFpQUJJQVJHRGQwQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFiRFVBR290QUFCSERRb2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURONEJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRQU1DZ3NnQVNBRVJnUkFRWmtCSVFJTTNRRUxBa0FDUUNBQkxRQUFRY2dBYXc0SUFBd01EQXdNREFFTUN5QUJRUUZxSVFGQi9RQWhBZ3pFQVFzZ0FVRUJhaUVCUVlBQklRSU13d0VMSUFFZ0JFWUVRRUdZQVNFQ0ROd0JDd0pBQWtBZ0FTMEFBRUhPQUdzT0F3QUxBUXNMSUFGQkFXb2hBVUgrQUNFQ0RNTUJDeUFCUVFGcUlRRkIvd0FoQWd6Q0FRc2dBU0FFUmdSQVFaY0JJUUlNMndFTElBRXRBQUJCMlFCSERRZ2dBVUVCYWlFQlFRZ01Cd3RCbGdFaEFpQUJJQVJHRGRrQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFhelVBR290QUFCSERRWWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROb0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFRVU1CZ3RCbFFFaEFpQUJJQVJHRGRnQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFhYlVBR290QUFCSERRVWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROa0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFSWU1CUXRCbEFFaEFpQUJJQVJHRGRjQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFhSFZBR290QUFCSERRUWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROZ0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFSQU1CQXNnQVNBRVJnUkFRWk1CSVFJTTF3RUxBa0FDUUNBQkxRQUFRY01BYXc0TUFBWUdCZ1lHQmdZR0JnWUJCZ3NnQVVFQmFpRUJRZmtBSVFJTXZnRUxJQUZCQVdvaEFVSDZBQ0VDREwwQkMwR1NBU0VDSUFFZ0JFWU4xUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCb05RQWFpMEFBRWNOQWlBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNMWdFTElBTkJBRFlDQUNBR1FRRnFJUUZCSkF3Q0N5QURRUUEyQWdBTUFnc2dBU0FFUmdSQVFaRUJJUUlNMUFFTElBRXRBQUJCekFCSERRRWdBVUVCYWlFQlFSTUxPZ0FwSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxpSUFEUUlNQVF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSCtIellDRUNBRFFRWTJBZ3dNMFFFTFFmZ0FJUUlNdHdFTElBTkJrQUUyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTXp3RUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpBSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGRFFBZ0FFRVZSZzBCSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdDRHpZQ0VDQURRU0EyQWd4QkFDRUNETTRCQzBIM0FDRUNETFFCQ3lBRFFZOEJOZ0ljSUFNZ0FUWUNGQ0FEUWV3Yk5nSVFJQU5CRlRZQ0RFRUFJUUlNekFFTElBRWdCRVlFUUVHUEFTRUNETXdCQ3dKQUlBRXRBQUJCSUVZRVFDQUJRUUZxSVFFTUFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFac2ZOZ0lRSUFOQkJqWUNERUVBSVFJTXpBRUxRUUloQWd5eUFRc0RRQ0FCTFFBQVFTQkhEUUlnQkNBQlFRRnFJZ0ZIRFFBTFFZNEJJUUlNeWdFTElBRWdCRVlFUUVHTkFTRUNETW9CQ3dKQUlBRXRBQUJCQ1dzT0JFb0FBRW9BQzBIMUFDRUNETEFCQ3lBRExRQXBRUVZHQkVCQjlnQWhBZ3l3QVF0QjlBQWhBZ3l2QVFzZ0FTQUVSZ1JBUVl3QklRSU15QUVMSUFOQkVEWUNDQ0FESUFFMkFnUU1DZ3NnQVNBRVJnUkFRWXNCSVFJTXh3RUxBa0FnQVMwQUFFRUphdzRFUndBQVJ3QUxRZk1BSVFJTXJRRUxJQUVnQkVjRVFDQURRUkEyQWdnZ0F5QUJOZ0lFUWZFQUlRSU1yUUVMUVlvQklRSU14UUVMQWtBZ0FTQUVSd1JBQTBBZ0FTMEFBRUdnMEFCcUxRQUFJZ0JCQTBjRVFBSkFJQUJCQVdzT0Fra0FCQXRCOEFBaEFneXZBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFZZ0JJUUlNeGdFTFFZZ0JJUUlNeFFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBIYklEWUNFQ0FEUVFjMkFneEJBQ0VDRE1RQkN5QUJJQVJHQkVCQmlRRWhBZ3pFQVFzQ1FBSkFBa0FnQVMwQUFFR2cwZ0JxTFFBQVFRRnJEZ05HQWdBQkMwSHlBQ0VDREt3QkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnRCSTJBaEFnQTBFSE5nSU1RUUFoQWd6RUFRdEI2Z0FoQWd5cUFRc2dBU0FFUndSQUlBRkJBV29oQVVIdkFDRUNES29CQzBHSEFTRUNETUlCQ3lBRUlBRWlBRVlFUUVHR0FTRUNETUlCQ3lBQUxRQUFJZ0ZCTDBZRVFDQUFRUUZxSVFGQjdnQWhBZ3lwQVFzZ0FVRUpheUlDUVJkTERRRWdBQ0VCUVFFZ0FuUkJtNENBQkhFTlFRd0JDeUFFSUFFaUFFWUVRRUdGQVNFQ0RNRUJDeUFBTFFBQVFTOUhEUUFnQUVFQmFpRUJEQU1MUVFBaEFpQURRUUEyQWh3Z0F5QUFOZ0lVSUFOQjJ5QTJBaEFnQTBFSE5nSU1ETDhCQ3dKQUFrQUNRQUpBQWtBRFFDQUJMUUFBUWFET0FHb3RBQUFpQUVFRlJ3UkFBa0FDUUNBQVFRRnJEZ2hIQlFZSENBQUVBUWdMUWVzQUlRSU1yUUVMSUFGQkFXb2hBVUh0QUNFQ0RLd0JDeUFFSUFGQkFXb2lBVWNOQUF0QmhBRWhBZ3pEQVFzZ0FVRUJhZ3dVQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDd2lBRVVOSGlBRFFkc0FOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRE1FQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3dpQUVVTkhpQURRZDBBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RNQUJDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUN3aUFFVU5IaUFEUWZvQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNETDhCQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CK1E4MkFoQWdBMEVITmdJTVFRQWhBZ3krQVFzZ0FTQUVSZ1JBUVlNQklRSU12Z0VMQWtBZ0FTMEFBRUdnemdCcUxRQUFRUUZyRGdnK0JBVUdBQWdDQXdjTElBRkJBV29oQVF0QkF5RUNES01CQ3lBQlFRRnFEQTBMUVFBaEFpQURRUUEyQWh3Z0EwSFJFallDRUNBRFFRYzJBZ3dnQXlBQlFRRnFOZ0lVRExvQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3dpQUVVTkZpQURRZHNBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RMa0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUN3aUFFVU5GaUFEUWQwQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNETGdCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDd2lBRVVORmlBRFFmb0FOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRExjQkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQitRODJBaEFnQTBFSE5nSU1RUUFoQWd5MkFRdEI3QUFoQWd5Y0FRc2dBU0FFUmdSQVFZSUJJUUlNdFFFTElBRkJBV29NQWdzZ0FTQUVSZ1JBUVlFQklRSU10QUVMSUFGQkFXb01BUXNnQVNBRVJnMEJJQUZCQVdvTElRRkJCQ0VDREpnQkMwR0FBU0VDRExBQkN3TkFJQUV0QUFCQm9Nd0FhaTBBQUNJQVFRSkhCRUFnQUVFQlJ3UkFRZWtBSVFJTW1RRUxEREVMSUFRZ0FVRUJhaUlCUncwQUMwSC9BQ0VDREs4QkN5QUJJQVJHQkVCQi9nQWhBZ3l2QVFzQ1FDQUJMUUFBUVFsckRqY3ZBd1l2QkFZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdVR0JnSUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUFCZ3NnQVVFQmFnc2hBVUVGSVFJTWxBRUxJQUZCQVdvTUJnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFzSWdCRkRRZ2dBMEhiQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneXJBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBc0lnQkZEUWdnQTBIZEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lxQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXNJZ0JGRFFnZ0EwSDZBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5cEFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFZMFVOZ0lRSUFOQkJ6WUNERUVBSVFJTXFBRUxBa0FDUUFKQUFrQURRQ0FCTFFBQVFhREtBR290QUFBaUFFRUZSd1JBQWtBZ0FFRUJhdzRHTGdNRUJRWUFCZ3RCNkFBaEFneVVBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFmMEFJUUlNcXdFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMQ0lBUlEwSElBTkIyd0EyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTXFnRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTENJQVJRMEhJQU5CM1FBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1xUUVMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxDSUFSUTBISUFOQitnQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNcUFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBIa0NEWUNFQ0FEUVFjMkFneEJBQ0VDREtjQkN5QUJJQVJHRFFFZ0FVRUJhZ3NoQVVFR0lRSU1qQUVMUWZ3QUlRSU1wQUVMQWtBQ1FBSkFBa0FEUUNBQkxRQUFRYURJQUdvdEFBQWlBRUVGUndSQUlBQkJBV3NPQkNrQ0F3UUZDeUFFSUFGQkFXb2lBVWNOQUF0Qit3QWhBZ3luQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXNJZ0JGRFFNZ0EwSGJBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5bUFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFzSWdCRkRRTWdBMEhkQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneWxBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBc0lnQkZEUU1nQTBINkFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lrQVFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWJ3S05nSVFJQU5CQnpZQ0RFRUFJUUlNb3dFTFFjOEFJUUlNaVFFTFFkRUFJUUlNaUFFTFFlY0FJUUlNaHdFTElBRWdCRVlFUUVINkFDRUNES0FCQ3dKQUlBRXRBQUJCQ1dzT0JDQUFBQ0FBQ3lBQlFRRnFJUUZCNWdBaEFneUdBUXNnQVNBRVJnUkFRZmtBSVFJTW53RUxBa0FnQVMwQUFFRUphdzRFSHdBQUh3QUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUk0SWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGQkVCQjRnRWhBZ3lHQVFzZ0FFRVZSd1JBSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhKRFRZQ0VDQURRUm8yQWd4QkFDRUNESjhCQ3lBRFFmZ0FOZ0ljSUFNZ0FUWUNGQ0FEUWVvYU5nSVFJQU5CRlRZQ0RFRUFJUUlNbmdFTElBRWdCRWNFUUNBRFFRMDJBZ2dnQXlBQk5nSUVRZVFBSVFJTWhRRUxRZmNBSVFJTW5RRUxJQUVnQkVZRVFFSDJBQ0VDREowQkN3SkFBa0FDUUNBQkxRQUFRY2dBYXc0TEFBRUxDd3NMQ3dzTEN3SUxDeUFCUVFGcUlRRkIzUUFoQWd5RkFRc2dBVUVCYWlFQlFlQUFJUUlNaEFFTElBRkJBV29oQVVIakFDRUNESU1CQzBIMUFDRUNJQUVnQkVZTm13RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJ0ZFVBYWkwQUFFY05DQ0FBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1uQUVMSUFNb0FnUWhBQ0FEUWdBM0F3QWdBeUFBSUFaQkFXb2lBUkFySWdBRVFDQURRZlFBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RKd0JDMEhpQUNFQ0RJSUJDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDTkNJQ1JRMEFJQU1nQWhFQUFDRUFDd0pBSUFBRVFDQUFRUlZHRFFFZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVvTk5nSVFJQU5CSmpZQ0RFRUFJUUlNbkFFTFFlRUFJUUlNZ2dFTElBTkI4d0EyQWh3Z0F5QUJOZ0lVSUFOQmdCczJBaEFnQTBFVk5nSU1RUUFoQWd5YUFRc2dBeTBBS1NJQVFTTnJRUXRKRFFrQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1DZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIdENUWUNFQ0FEUVFnMkFnd01tUUVMUWZJQUlRSWdBU0FFUmcyWUFTQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFR3oxUUJxTFFBQVJ3MEZJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeVpBUXNnQXlnQ0JDRUFJQU5DQURjREFDQURJQUFnQmtFQmFpSUJFQ3NpQUFSQUlBTkI4UUEyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTW1RRUxRZDhBSVFJTWZ3dEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9BalFpQWtVTkFDQURJQUlSQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhxRFRZQ0VDQURRU1kyQWd4QkFDRUNESmtCQzBIZUFDRUNESDhMSUFOQjhBQTJBaHdnQXlBQk5nSVVJQU5CZ0JzMkFoQWdBMEVWTmdJTVFRQWhBZ3lYQVFzZ0F5MEFLVUVoUmcwR0lBTkJBRFlDSENBRElBRTJBaFFnQTBHUkNqWUNFQ0FEUVFnMkFneEJBQ0VDREpZQkMwSHZBQ0VDSUFFZ0JFWU5sUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCc05VQWFpMEFBRWNOQWlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNbGdFTElBTW9BZ1FoQUNBRFFnQTNBd0FnQXlBQUlBWkJBV29pQVJBcklnQkZEUUlnQTBIdEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lWQVFzZ0EwRUFOZ0lBQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDc2lBRVVOZ0FFZ0EwSHVBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5VEFRdEIzQUFoQWd4NUMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NOQ0lDUlEwQUlBTWdBaEVBQUNFQUN3SkFJQUFFUUNBQVFSVkdEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZW9OTmdJUUlBTkJKallDREVFQUlRSU1rd0VMUWRzQUlRSU1lUXNnQTBIc0FEWUNIQ0FESUFFMkFoUWdBMEdBR3pZQ0VDQURRUlUyQWd4QkFDRUNESkVCQ3lBRExRQXBJZ0JCSTBrTkFDQUFRUzVHRFFBZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNrSk5nSVFJQU5CQ0RZQ0RFRUFJUUlNa0FFTFFkb0FJUUlNZGdzZ0FTQUVSZ1JBUWVzQUlRSU1qd0VMQWtBZ0FTMEFBRUV2UmdSQUlBRkJBV29oQVF3QkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnNqZzJBaEFnQTBFSU5nSU1RUUFoQWd5UEFRdEIyUUFoQWd4MUN5QUJJQVJIQkVBZ0EwRU9OZ0lJSUFNZ0FUWUNCRUhZQUNFQ0RIVUxRZW9BSVFJTWpRRUxJQUVnQkVZRVFFSHBBQ0VDREkwQkN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBeUFBT2dBcUlBRkJBV29oQVVIWEFDRUNESFFMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUx5SUFSUTE2SUFOQjZBQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNakFFTElBRWdCRVlFUUVIbkFDRUNESXdCQ3dKQUlBRXRBQUJCTGtZRVFDQUJRUUZxSVFFTUFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF2SWdCRkRYc2dBMEhtQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneU1BUXRCMWdBaEFneHlDeUFCSUFSR0JFQkI1UUFoQWd5TEFRdEJBQ0VBUVFFaEJVRUJJUWRCQUNFQ0FrQUNRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUV3YXc0S0Nna0FBUUlEQkFVR0NBc0xRUUlNQmd0QkF3d0ZDMEVFREFRTFFRVU1Bd3RCQmd3Q0MwRUhEQUVMUVFnTElRSkJBQ0VGUVFBaEJ3d0NDMEVKSVFKQkFTRUFRUUFoQlVFQUlRY01BUXRCQUNFRlFRRWhBZ3NnQXlBQ09nQXJJQUZCQVdvaEFRSkFBa0FnQXkwQUxrRVFjUTBBQWtBQ1FBSkFJQU10QUNvT0F3RUFBZ1FMSUFkRkRRTU1BZ3NnQUEwQkRBSUxJQVZGRFFFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMeUlBUlEwQ0lBTkI0Z0EyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTWpRRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTHlJQVJRMTlJQU5CNHdBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1qQUVMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUx5SUFSUTE3SUFOQjVBQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RBeUxBUXRCMUFBaEFneHhDeUFETFFBcFFTSkdEWVlCUWRNQUlRSU1jQXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWtRaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVRVFFSFZBQ0VDREhBTElBQkJGVWNFUUNBRFFRQTJBaHdnQXlBQk5nSVVJQU5CcEEwMkFoQWdBMEVoTmdJTVFRQWhBZ3lKQVFzZ0EwSGhBRFlDSENBRElBRTJBaFFnQTBIUUdqWUNFQ0FEUVJVMkFneEJBQ0VDRElnQkN5QUJJQVJHQkVCQjRBQWhBZ3lJQVFzQ1FBSkFBa0FDUUFKQUlBRXRBQUJCQ21zT0JBRUVCQUFFQ3lBQlFRRnFJUUVNQVFzZ0FVRUJhaUVCSUFOQkwyb3RBQUJCQVhGRkRRRUxRZElBSVFJTWNBc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFiWVJOZ0lRSUFOQkNUWUNERUVBSVFJTWlBRUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRzJFVFlDRUNBRFFRazJBZ3hCQUNFQ0RJY0JDeUFCSUFSR0JFQkIzd0FoQWd5SEFRc2dBUzBBQUVFS1JnUkFJQUZCQVdvaEFRd0pDeUFETFFBdVFjQUFjUTBJSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEcyRVRZQ0VDQURRUUkyQWd4QkFDRUNESVlCQ3lBQklBUkdCRUJCM1FBaEFneUdBUXNnQVMwQUFDSUNRUTFHQkVBZ0FVRUJhaUVCUWRBQUlRSU1iUXNnQVNFQUlBSkJDV3NPQkFVQkFRVUJDeUFFSUFFaUFFWUVRRUhjQUNFQ0RJVUJDeUFBTFFBQVFRcEhEUUFnQUVFQmFnd0NDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FEWUNGQ0FEUWNvdE5nSVFJQU5CQnpZQ0RBeURBUXNnQVNBRVJnUkFRZHNBSVFJTWd3RUxBa0FnQVMwQUFFRUphdzRFQXdBQUF3QUxJQUZCQVdvTElRRkJ6Z0FoQWd4b0N5QUJJQVJHQkVCQjJnQWhBZ3lCQVFzZ0FTMEFBRUVKYXc0RUFBRUJBQUVMUVFBaEFpQURRUUEyQWh3Z0EwR2FFallDRUNBRFFRYzJBZ3dnQXlBQlFRRnFOZ0lVREg4TElBTkJnQkk3QVNwQkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FqZ2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5BQ0FBUVJWSERRRWdBMEhaQURZQ0hDQURJQUUyQWhRZ0EwSHFHallDRUNBRFFSVTJBZ3hCQUNFQ0RINExRYzBBSVFJTVpBc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFja05OZ0lRSUFOQkdqWUNERUVBSVFJTWZBc2dBU0FFUmdSQVFka0FJUUlNZkFzZ0FTMEFBRUVnUncwOUlBRkJBV29oQVNBRExRQXVRUUZ4RFQwZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNJY05nSVFJQU5CSGpZQ0RFRUFJUUlNZXdzZ0FTQUVSZ1JBUWRnQUlRSU1ld3NDUUFKQUFrQUNRQUpBSUFFdEFBQWlBRUVLYXc0RUFnTURBQUVMSUFGQkFXb2hBVUVzSVFJTVpRc2dBRUU2UncwQklBTkJBRFlDSENBRElBRTJBaFFnQTBIbkVUWUNFQ0FEUVFvMkFneEJBQ0VDREgwTElBRkJBV29oQVNBRFFTOXFMUUFBUVFGeFJRMXpJQU10QURKQmdBRnhSUVJBSUFOQk1tb2hBaUFERURWQkFDRUFBa0FnQXlnQ09DSUdSUTBBSUFZb0FpZ2lCa1VOQUNBRElBWVJBQUFoQUFzQ1FBSkFJQUFPRmsxTVN3RUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJDeUFEUVNrMkFod2dBeUFCTmdJVUlBTkJyQmsyQWhBZ0EwRVZOZ0lNUVFBaEFneCtDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkI1UXMyQWhBZ0EwRVJOZ0lNUVFBaEFneDlDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDWENJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlExWklBQkJGVWNOQVNBRFFRVTJBaHdnQXlBQk5nSVVJQU5CbXhzMkFoQWdBMEVWTmdJTVFRQWhBZ3g4QzBITEFDRUNER0lMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmtBNDJBaEFnQTBFVU5nSU1ESG9MSUFNZ0F5OEJNa0dBQVhJN0FUSU1Pd3NnQVNBRVJ3UkFJQU5CRVRZQ0NDQURJQUUyQWdSQnlnQWhBZ3hnQzBIWEFDRUNESGdMSUFFZ0JFWUVRRUhXQUNFQ0RIZ0xBa0FDUUFKQUFrQWdBUzBBQUNJQVFTQnlJQUFnQUVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZCNHdCckRoTUFRRUJBUUVCQVFFQkFRRUJBQVVCQVFBSURRQXNnQVVFQmFpRUJRY1lBSVFJTVlRc2dBVUVCYWlFQlFjY0FJUUlNWUFzZ0FVRUJhaUVCUWNnQUlRSU1Yd3NnQVVFQmFpRUJRY2tBSVFJTVhndEIxUUFoQWlBRUlBRWlBRVlOZGlBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRVnFJUWNEUUNBQlFaRElBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUWhCQkNBQlFRVkdEUW9hSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0F5QUdOZ0lBREhZTFFkUUFJUUlnQkNBQklnQkdEWFVnQkNBQmF5QURLQUlBSWdGcUlRWWdBQ0FCYTBFUGFpRUhBMEFnQVVHQXlBQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEhRUU1nQVVFUFJnMEpHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXgxQzBIVEFDRUNJQVFnQVNJQVJnMTBJQVFnQVdzZ0F5Z0NBQ0lCYWlFR0lBQWdBV3RCRG1vaEJ3TkFJQUZCNHNjQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTkJpQUJRUTVHRFFjZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QURJQVkyQWdBTWRBdEIwZ0FoQWlBRUlBRWlBRVlOY3lBRUlBRnJJQU1vQWdBaUFXb2hCU0FBSUFGclFRRnFJUVlEUUNBQlFlREhBR290QUFBZ0FDMEFBQ0lIUVNCeUlBY2dCMEhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUVVnQVVFQlJnMENJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBRk5nSUFESE1MSUFFZ0JFWUVRRUhSQUNFQ0RITUxBa0FDUUNBQkxRQUFJZ0JCSUhJZ0FDQUFRY0VBYTBIL0FYRkJHa2tiUWY4QmNVSHVBR3NPQndBNU9UazVPUUU1Q3lBQlFRRnFJUUZCd3dBaEFneGFDeUFCUVFGcUlRRkJ4QUFoQWd4WkN5QURRUUEyQWdBZ0JrRUJhaUVCUWNVQUlRSU1XQXRCMEFBaEFpQUVJQUVpQUVZTmNDQUVJQUZySUFNb0FnQWlBV29oQmlBQUlBRnJRUWxxSVFjRFFDQUJRZGJIQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFKQkFpQUJRUWxHRFFRYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBeUFHTmdJQURIQUxRYzhBSVFJZ0JDQUJJZ0JHRFc4Z0JDQUJheUFES0FJQUlnRnFJUVlnQUNBQmEwRUZhaUVIQTBBZ0FVSFF4d0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkJVWU5BaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXh2Q3lBQUlRRWdBMEVBTmdJQURETUxRUUVMT2dBc0lBTkJBRFlDQUNBSFFRRnFJUUVMUVMwaEFneFNDd0pBQTBBZ0FTMEFBRUhReFFCcUxRQUFRUUZIRFFFZ0JDQUJRUUZxSWdGSERRQUxRYzBBSVFJTWF3dEJ3Z0FoQWd4UkN5QUJJQVJHQkVCQnpBQWhBZ3hxQ3lBQkxRQUFRVHBHQkVBZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXdJZ0JGRFRNZ0EwSExBRFlDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVUVFBaEFneHFDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkI1eEUyQWhBZ0EwRUtOZ0lNUVFBaEFneHBDd0pBQWtBZ0F5MEFMRUVDYXc0Q0FBRW5DeUFEUVROcUxRQUFRUUp4UlEwbUlBTXRBQzVCQW5FTkppQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnBoUTJBaEFnQTBFTE5nSU1RUUFoQWd4cEN5QURMUUF5UVNCeFJRMGxJQU10QUM1QkFuRU5KU0FEUVFBMkFod2dBeUFCTmdJVUlBTkJ2Uk0yQWhBZ0EwRVBOZ0lNUVFBaEFneG9DMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDU0NJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlFSQVFjRUFJUUlNVHdzZ0FFRVZSd1JBSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdtRHpZQ0VDQURRUncyQWd4QkFDRUNER2dMSUFOQnlnQTJBaHdnQXlBQk5nSVVJQU5CaFJ3MkFoQWdBMEVWTmdJTVFRQWhBZ3huQ3lBQklBUkhCRUFnQVNFQ0EwQWdCQ0FDSWdGclFSQk9CRUFnQVVFUWFpRUMvUXovLy8vLy8vLy8vLy8vLy8vLy8vLy9JQUg5QUFBQUlnMUJCLzFzSUEzOURPRGc0T0RnNE9EZzRPRGc0T0RnNE9EOWJ2ME1YMTlmWDE5ZlgxOWZYMTlmWDE5ZlgvMG1JQTM5REFrSkNRa0pDUWtKQ1FrSkNRa0pDUW45SS8xUS9WTDlaRUYvYzJnaUFFRVFSZzBCSUFBZ0FXb2hBUXdZQ3lBQklBUkdCRUJCeEFBaEFneHBDeUFCTFFBQVFjREJBR290QUFCQkFVY05GeUFFSUFGQkFXb2lBa2NOQUF0QnhBQWhBZ3huQzBIRUFDRUNER1lMSUFFZ0JFY0VRQU5BQWtBZ0FTMEFBQ0lBUVNCeUlBQWdBRUhCQUd0Qi93RnhRUnBKRzBIL0FYRWlBRUVKUmcwQUlBQkJJRVlOQUFKQUFrQUNRQUpBSUFCQjR3QnJEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVRZaEFneFNDeUFCUVFGcUlRRkJOeUVDREZFTElBRkJBV29oQVVFNElRSU1VQXNNRlFzZ0JDQUJRUUZxSWdGSERRQUxRVHdoQWd4bUMwRThJUUlNWlFzZ0FTQUVSZ1JBUWNnQUlRSU1aUXNnQTBFU05nSUlJQU1nQVRZQ0JBSkFBa0FDUUFKQUFrQWdBeTBBTEVFQmF3NEVGQUFCQWdrTElBTXRBREpCSUhFTkEwSGdBU0VDREU4TEFrQWdBeThCTWlJQVFRaHhSUTBBSUFNdEFDaEJBVWNOQUNBRExRQXVRUWh4UlEwQ0N5QURJQUJCOS9zRGNVR0FCSEk3QVRJTUN3c2dBeUFETHdFeVFSQnlPd0V5REFRTElBTkJBRFlDQkNBRElBRWdBUkF4SWdBRVFDQURRY0VBTmdJY0lBTWdBRFlDRENBRElBRkJBV28yQWhSQkFDRUNER1lMSUFGQkFXb2hBUXhZQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5COUJNMkFoQWdBMEVFTmdJTVFRQWhBZ3hrQzBISEFDRUNJQUVnQkVZTll5QURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVpxSVFZQ1FBTkFJQUJCd01VQWFpMEFBQ0FCTFFBQVFTQnlSdzBCSUFCQkJrWU5TaUFBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXhrQ3lBRFFRQTJBZ0FNQlFzQ1FDQUJJQVJIQkVBRFFDQUJMUUFBUWNEREFHb3RBQUFpQUVFQlJ3UkFJQUJCQWtjTkF5QUJRUUZxSVFFTUJRc2dCQ0FCUVFGcUlnRkhEUUFMUWNVQUlRSU1aQXRCeFFBaEFneGpDd3NnQTBFQU9nQXNEQUVMUVFzaEFneEhDMEUvSVFJTVJnc0NRQUpBQTBBZ0FTMEFBQ0lBUVNCSEJFQUNRQ0FBUVFwckRnUURCUVVEQUFzZ0FFRXNSZzBEREFRTElBUWdBVUVCYWlJQlJ3MEFDMEhHQUNFQ0RHQUxJQU5CQ0RvQUxBd09DeUFETFFBb1FRRkhEUUlnQXkwQUxrRUljUTBDSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUU1TSUFCRUFnQTBIQ0FEWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd4ZkN5QUJRUUZxSVFFTVVBdEJPeUVDREVRTEFrQURRQ0FCTFFBQUlnQkJJRWNnQUVFSlIzRU5BU0FFSUFGQkFXb2lBVWNOQUF0Qnd3QWhBZ3hkQ3d0QlBDRUNERUlMQWtBQ1FDQUJJQVJIQkVBRFFDQUJMUUFBSWdCQklFY0VRQ0FBUVFwckRnUURCQVFEQkFzZ0JDQUJRUUZxSWdGSERRQUxRVDhoQWd4ZEMwRS9JUUlNWEFzZ0F5QURMd0V5UVNCeU93RXlEQW9MSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUU1TSUFSUTFPSUFOQlBqWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3hhQ3dKQUlBRWdCRWNFUUFOQUlBRXRBQUJCd01NQWFpMEFBQ0lBUVFGSEJFQWdBRUVDUmcwRERBd0xJQVFnQVVFQmFpSUJSdzBBQzBFM0lRSU1Xd3RCTnlFQ0RGb0xJQUZCQVdvaEFRd0VDMEU3SVFJZ0JDQUJJZ0JHRFZnZ0JDQUJheUFES0FJQUlnRnFJUVlnQUNBQmEwRUZhaUVIQWtBRFFDQUJRWkRJQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FVRUZSZ1JBUVFjaEFRdy9DeUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXhaQ3lBRFFRQTJBZ0FnQUNFQkRBVUxRVG9oQWlBRUlBRWlBRVlOVnlBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRaHFJUWNDUUFOQUlBRkJ0TUVBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOQVNBQlFRaEdCRUJCQlNFQkRENExJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBR05nSUFERmdMSUFOQkFEWUNBQ0FBSVFFTUJBdEJPU0VDSUFRZ0FTSUFSZzFXSUFRZ0FXc2dBeWdDQUNJQmFpRUdJQUFnQVd0QkEyb2hCd0pBQTBBZ0FVR3d3UUJxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkEwWUVRRUVHSVFFTVBRc2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFESUFZMkFnQU1Wd3NnQTBFQU5nSUFJQUFoQVF3REN3SkFBMEFnQVMwQUFDSUFRU0JIQkVBZ0FFRUthdzRFQndRRUJ3SUxJQVFnQVVFQmFpSUJSdzBBQzBFNElRSU1WZ3NnQUVFc1J3MEJJQUZCQVdvaEFFRUJJUUVDUUFKQUFrQUNRQUpBSUFNdEFDeEJCV3NPQkFNQkFnUUFDeUFBSVFFTUJBdEJBaUVCREFFTFFRUWhBUXNnQTBFQk9nQXNJQU1nQXk4Qk1pQUJjanNCTWlBQUlRRU1BUXNnQXlBREx3RXlRUWh5T3dFeUlBQWhBUXRCUGlFQ0REc0xJQU5CQURvQUxBdEJPU0VDRERrTElBRWdCRVlFUUVFMklRSU1VZ3NDUUFKQUFrQUNRQUpBSUFFdEFBQkJDbXNPQkFBQ0FnRUNDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRURFaUFFVU5BaUFEUVRNMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1WUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBeElnQkZCRUFnQVVFQmFpRUJEQVlMSUFOQk1qWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd4VUN5QURMUUF1UVFGeEJFQkIzd0VoQWd3N0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFREVpQUEwQkRFa0xRVFFoQWd3NUN5QURRVFUyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTVVRdEJOU0VDRERjTElBTkJMMm90QUFCQkFYRU5BQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkI2eFkyQWhBZ0EwRVpOZ0lNUVFBaEFneFBDMEV6SVFJTU5Rc2dBU0FFUmdSQVFUSWhBZ3hPQ3dKQUlBRXRBQUJCQ2tZRVFDQUJRUUZxSVFFTUFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFaSVhOZ0lRSUFOQkF6WUNERUVBSVFJTVRndEJNaUVDRERRTElBRWdCRVlFUUVFeElRSU1UUXNDUUNBQkxRQUFJZ0JCQ1VZTkFDQUFRU0JHRFFCQkFTRUNBa0FnQXkwQUxFRUZhdzRFQmdRRkFBMExJQU1nQXk4Qk1rRUljanNCTWd3TUN5QURMUUF1UVFGeFJRMEJJQU10QUN4QkNFY05BQ0FEUVFBNkFDd0xRVDBoQWd3eUN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQndoWTJBaEFnQTBFS05nSU1RUUFoQWd4S0MwRUNJUUlNQVF0QkJDRUNDeUFEUVFFNkFDd2dBeUFETHdFeUlBSnlPd0V5REFZTElBRWdCRVlFUUVFd0lRSU1Sd3NnQVMwQUFFRUtSZ1JBSUFGQkFXb2hBUXdCQ3lBRExRQXVRUUZ4RFFBZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWR3b05nSVFJQU5CQWpZQ0RFRUFJUUlNUmd0Qk1DRUNEQ3dMSUFGQkFXb2hBVUV4SVFJTUt3c2dBU0FFUmdSQVFTOGhBZ3hFQ3lBQkxRQUFJZ0JCQ1VjZ0FFRWdSM0ZGQkVBZ0FVRUJhaUVCSUFNdEFDNUJBWEVOQVNBRFFRQTJBaHdnQXlBQk5nSVVJQU5CbHhBMkFoQWdBMEVLTmdJTVFRQWhBZ3hFQzBFQklRSUNRQUpBQWtBQ1FBSkFBa0FnQXkwQUxFRUNhdzRIQlFRRUF3RUNBQVFMSUFNZ0F5OEJNa0VJY2pzQk1nd0RDMEVDSVFJTUFRdEJCQ0VDQ3lBRFFRRTZBQ3dnQXlBREx3RXlJQUp5T3dFeUMwRXZJUUlNS3dzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVlRVE5nSVFJQU5CQ3pZQ0RFRUFJUUlNUXd0QjRRRWhBZ3dwQ3lBQklBUkdCRUJCTGlFQ0RFSUxJQU5CQURZQ0JDQURRUkkyQWdnZ0F5QUJJQUVRTVNJQURRRUxRUzRoQWd3bkN5QURRUzAyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTVB3dEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9Ba3dpQWtVTkFDQURJQUlSQUFBaEFBc2dBRVVOQUNBQVFSVkhEUUVnQTBIWUFEWUNIQ0FESUFFMkFoUWdBMEd6R3pZQ0VDQURRUlUyQWd4QkFDRUNERDRMUWN3QUlRSU1KQXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYk1PTmdJUUlBTkJIVFlDREVFQUlRSU1QQXNnQVNBRVJnUkFRYzRBSVFJTVBBc2dBUzBBQUNJQVFTQkdEUUlnQUVFNlJnMEJDeUFEUVFBNkFDeEJDU0VDRENFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFNQ0lBRFFFTUFnc2dBeTBBTGtFQmNRUkFRZDRCSVFJTUlBc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF3SWdCRkRRSWdBMEVxTmdJY0lBTWdBRFlDRENBRElBRkJBV28yQWhSQkFDRUNERGdMSUFOQnl3QTJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGRUVBSVFJTU53c2dBVUVCYWlFQlFjQUFJUUlNSFFzZ0FVRUJhaUVCREN3TElBRWdCRVlFUUVFcklRSU1OUXNDUUNBQkxRQUFRUXBHQkVBZ0FVRUJhaUVCREFFTElBTXRBQzVCd0FCeFJRMEdDeUFETFFBeVFZQUJjUVJBUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKY0lnSkZEUUFnQXlBQ0VRQUFJUUFMSUFCRkRSSWdBRUVWUmdSQUlBTkJCVFlDSENBRElBRTJBaFFnQTBHYkd6WUNFQ0FEUVJVMkFneEJBQ0VDRERZTElBTkJBRFlDSENBRElBRTJBaFFnQTBHUURqWUNFQ0FEUVJRMkFneEJBQ0VDRERVTElBTkJNbW9oQWlBREVEVkJBQ0VBQWtBZ0F5Z0NPQ0lHUlEwQUlBWW9BaWdpQmtVTkFDQURJQVlSQUFBaEFBc2dBQTRXQWdFQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUF3UUxJQU5CQVRvQU1Bc2dBaUFDTHdFQVFjQUFjanNCQUF0Qkt5RUNEQmdMSUFOQktUWUNIQ0FESUFFMkFoUWdBMEdzR1RZQ0VDQURRUlUyQWd4QkFDRUNEREFMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhsQ3pZQ0VDQURRUkUyQWd4QkFDRUNEQzhMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdsQ3pZQ0VDQURRUUkyQWd4QkFDRUNEQzRMUVFFaEJ5QURMd0V5SWdWQkNIRkZCRUFnQXlrRElFSUFVaUVIQ3dKQUlBTXRBREFFUUVFQklRQWdBeTBBS1VFRlJnMEJJQVZCd0FCeFJTQUhjVVVOQVFzQ1FDQURMUUFvSWdKQkFrWUVRRUVCSVFBZ0F5OEJOQ0lHUWVVQVJnMENRUUFoQUNBRlFjQUFjUTBDSUFaQjVBQkdEUUlnQmtIbUFHdEJBa2tOQWlBR1Fjd0JSZzBDSUFaQnNBSkdEUUlNQVF0QkFDRUFJQVZCd0FCeERRRUxRUUloQUNBRlFRaHhEUUFnQlVHQUJIRUVRQUpBSUFKQkFVY05BQ0FETFFBdVFRcHhEUUJCQlNFQURBSUxRUVFoQUF3QkN5QUZRU0J4UlFSQUlBTVFOa0VBUjBFQ2RDRUFEQUVMUVFCQkF5QURLUU1nVUJzaEFBc2dBRUVCYXc0RkFnQUhBUU1FQzBFUklRSU1Fd3NnQTBFQk9nQXhEQ2tMUVFBaEFnSkFJQU1vQWpnaUFFVU5BQ0FBS0FJd0lnQkZEUUFnQXlBQUVRQUFJUUlMSUFKRkRTWWdBa0VWUmdSQUlBTkJBellDSENBRElBRTJBaFFnQTBIU0d6WUNFQ0FEUVJVMkFneEJBQ0VDRENzTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIzUTQyQWhBZ0EwRVNOZ0lNRENvTElBTkJBRFlDSENBRElBRTJBaFFnQTBINUlEWUNFQ0FEUVE4MkFneEJBQ0VDRENrTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSXdJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQU5BUXRCRGlFQ0RBNExJQUJCRlVZRVFDQURRUUkyQWh3Z0F5QUJOZ0lVSUFOQjBoczJBaEFnQTBFVk5nSU1RUUFoQWd3bkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjNRNDJBaEFnQTBFU05nSU1RUUFoQWd3bUMwRXFJUUlNREFzZ0FTQUVSd1JBSUFOQkNUWUNDQ0FESUFFMkFnUkJLU0VDREF3TFFTWWhBZ3drQ3lBRElBTXBBeUFpRENBRUlBRnJyU0lLZlNJTFFnQWdDeUFNV0JzM0F5QWdDaUFNVkFSQVFTVWhBZ3drQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQklBeW5haUlCRURJaUFFVU5BQ0FEUVFVMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1Jd3RCRHlFQ0RBa0xRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCTFFBQVFUQnJEamNYRmdBQkFnTUVCUVlIRkJRVUZCUVVGQWdKQ2dzTURSUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVURnOFFFUklURkF0Q0FpRUtEQllMUWdNaENnd1ZDMElFSVFvTUZBdENCU0VLREJNTFFnWWhDZ3dTQzBJSElRb01FUXRDQ0NFS0RCQUxRZ2toQ2d3UEMwSUtJUW9NRGd0Q0N5RUtEQTBMUWd3aENnd01DMElOSVFvTUN3dENEaUVLREFvTFFnOGhDZ3dKQzBJS0lRb01DQXRDQ3lFS0RBY0xRZ3doQ2d3R0MwSU5JUW9NQlF0Q0RpRUtEQVFMUWc4aENnd0RDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJueFUyQWhBZ0EwRU1OZ0lNUVFBaEFnd2hDeUFCSUFSR0JFQkJJaUVDRENFTFFnQWhDZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUV3YXc0M0ZSUUFBUUlEQkFVR0J4WVdGaFlXRmhZSUNRb0xEQTBXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZzRQRUJFU0V4WUxRZ0loQ2d3VUMwSURJUW9NRXd0Q0JDRUtEQklMUWdVaENnd1JDMElHSVFvTUVBdENCeUVLREE4TFFnZ2hDZ3dPQzBJSklRb01EUXRDQ2lFS0RBd0xRZ3NoQ2d3TEMwSU1JUW9NQ2d0Q0RTRUtEQWtMUWc0aENnd0lDMElQSVFvTUJ3dENDaUVLREFZTFFnc2hDZ3dGQzBJTUlRb01CQXRDRFNFS0RBTUxRZzRoQ2d3Q0MwSVBJUW9NQVF0Q0FTRUtDeUFCUVFGcUlRRWdBeWtESUNJTFF2Ly8vLy8vLy8vL0QxZ0VRQ0FESUF0Q0JJWWdDb1EzQXlBTUFnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFiVUpOZ0lRSUFOQkREWUNERUVBSVFJTUhndEJKeUVDREFRTFFTZ2hBZ3dEQ3lBRElBRTZBQ3dnQTBFQU5nSUFJQWRCQVdvaEFVRU1JUUlNQWdzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVLSVFJTUFRc2dBVUVCYWlFQlFRZ2hBZ3dBQ3dBTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJzamcyQWhBZ0EwRUlOZ0lNREJjTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJneEUyQWhBZ0EwRUpOZ0lNREJZTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIzd28yQWhBZ0EwRUpOZ0lNREJVTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI3UkEyQWhBZ0EwRUpOZ0lNREJRTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIwaEUyQWhBZ0EwRUpOZ0lNREJNTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJzamcyQWhBZ0EwRUlOZ0lNREJJTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJneEUyQWhBZ0EwRUpOZ0lNREJFTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIzd28yQWhBZ0EwRUpOZ0lNREJBTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI3UkEyQWhBZ0EwRUpOZ0lNREE4TFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIwaEUyQWhBZ0EwRUpOZ0lNREE0TFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ1UmMyQWhBZ0EwRVBOZ0lNREEwTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ1UmMyQWhBZ0EwRVBOZ0lNREF3TFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJtUk0yQWhBZ0EwRUxOZ0lNREFzTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJuUWsyQWhBZ0EwRUxOZ0lNREFvTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJseEEyQWhBZ0EwRUtOZ0lNREFrTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJzUkEyQWhBZ0EwRUtOZ0lNREFnTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ1eDAyQWhBZ0EwRUNOZ0lNREFjTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJsaFkyQWhBZ0EwRUNOZ0lNREFZTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIrUmcyQWhBZ0EwRUNOZ0lNREFVTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ4QmcyQWhBZ0EwRUNOZ0lNREFRTElBTkJBallDSENBRElBRTJBaFFnQTBHcEhqWUNFQ0FEUVJZMkFneEJBQ0VDREFNTFFkNEFJUUlnQVNBRVJnMENJQWxCQ0dvaEJ5QURLQUlBSVFVQ1FBSkFJQUVnQkVjRVFDQUZRWmJJQUdvaENDQUVJQVZxSUFGcklRWWdCVUYvYzBFS2FpSUZJQUZxSVFBRFFDQUJMUUFBSUFndEFBQkhCRUJCQWlFSURBTUxJQVZGQkVCQkFDRUlJQUFoQVF3REN5QUZRUUZySVFVZ0NFRUJhaUVJSUFRZ0FVRUJhaUlCUncwQUN5QUdJUVVnQkNFQkN5QUhRUUUyQWdBZ0F5QUZOZ0lBREFFTElBTkJBRFlDQUNBSElBZzJBZ0FMSUFjZ0FUWUNCQ0FKS0FJTUlRQUNRQUpBSUFrb0FnaEJBV3NPQWdRQkFBc2dBMEVBTmdJY0lBTkJ3aDQyQWhBZ0EwRVhOZ0lNSUFNZ0FFRUJhallDRkVFQUlRSU1Bd3NnQTBFQU5nSWNJQU1nQURZQ0ZDQURRZGNlTmdJUUlBTkJDVFlDREVFQUlRSU1BZ3NnQVNBRVJnUkFRU2doQWd3Q0N5QURRUWsyQWdnZ0F5QUJOZ0lFUVNjaEFnd0JDeUFCSUFSR0JFQkJBU0VDREFFTEEwQUNRQUpBQWtBZ0FTMEFBRUVLYXc0RUFBRUJBQUVMSUFGQkFXb2hBUXdCQ3lBQlFRRnFJUUVnQXkwQUxrRWdjUTBBUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQm9TRTJBaEFnQTBFRk5nSU1EQUlMUVFFaEFpQUJJQVJIRFFBTEN5QUpRUkJxSkFBZ0FrVUVRQ0FES0FJTUlRQU1BUXNnQXlBQ05nSWNRUUFoQUNBREtBSUVJZ0ZGRFFBZ0F5QUJJQVFnQXlnQ0NCRUJBQ0lCUlEwQUlBTWdCRFlDRkNBRElBRTJBZ3dnQVNFQUN5QUFDNzRDQVFKL0lBQkJBRG9BQUNBQVFlUUFhaUlCUVFGclFRQTZBQUFnQUVFQU9nQUNJQUJCQURvQUFTQUJRUU5yUVFBNkFBQWdBVUVDYTBFQU9nQUFJQUJCQURvQUF5QUJRUVJyUVFBNkFBQkJBQ0FBYTBFRGNTSUJJQUJxSWdCQkFEWUNBRUhrQUNBQmEwRjhjU0lDSUFCcUlnRkJCR3RCQURZQ0FBSkFJQUpCQ1VrTkFDQUFRUUEyQWdnZ0FFRUFOZ0lFSUFGQkNHdEJBRFlDQUNBQlFReHJRUUEyQWdBZ0FrRVpTUTBBSUFCQkFEWUNHQ0FBUVFBMkFoUWdBRUVBTmdJUUlBQkJBRFlDRENBQlFSQnJRUUEyQWdBZ0FVRVVhMEVBTmdJQUlBRkJHR3RCQURZQ0FDQUJRUnhyUVFBMkFnQWdBaUFBUVFSeFFSaHlJZ0pySWdGQklFa05BQ0FBSUFKcUlRQURRQ0FBUWdBM0F4Z2dBRUlBTndNUUlBQkNBRGNEQ0NBQVFnQTNBd0FnQUVFZ2FpRUFJQUZCSUdzaUFVRWZTdzBBQ3dzTFZnRUJmd0pBSUFBb0Fnd05BQUpBQWtBQ1FBSkFJQUF0QURFT0F3RUFBd0lMSUFBb0FqZ2lBVVVOQUNBQktBSXdJZ0ZGRFFBZ0FDQUJFUUFBSWdFTkF3dEJBQThMQUFzZ0FFSEtHVFlDRUVFT0lRRUxJQUVMR2dBZ0FDZ0NERVVFUUNBQVFkNGZOZ0lRSUFCQkZUWUNEQXNMRkFBZ0FDZ0NERUVWUmdSQUlBQkJBRFlDREFzTEZBQWdBQ2dDREVFV1JnUkFJQUJCQURZQ0RBc0xCd0FnQUNnQ0RBc0hBQ0FBS0FJUUN3a0FJQUFnQVRZQ0VBc0hBQ0FBS0FJVUN5c0FBa0FnQUVFblR3MEFRdi8vLy8vL0NTQUFyWWhDQVlOUURRQWdBRUVDZEVIUU9Hb29BZ0FQQ3dBTEZ3QWdBRUV2VHdSQUFBc2dBRUVDZEVIc09Xb29BZ0FMdndrQkFYOUI5QzBoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI1QUJyRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIcUxBOExRWmdtRHd0QjdURVBDMEdnTnc4TFFja3BEd3RCdENrUEMwR1dMUThMUWVzckR3dEJvalVQQzBIYk5BOExRZUFwRHd0QjR5UVBDMEhWSkE4TFFlNGtEd3RCNWlVUEMwSEtOQThMUWRBM0R3dEJxalVQQzBIMUxBOExRZlltRHd0QmdpSVBDMEh5TXc4TFFiNG9Ed3RCNXpjUEMwSE5JUThMUWNBaER3dEJ1Q1VQQzBITEpROExRWllrRHd0Qmp6UVBDMEhOTlE4TFFkMHFEd3RCN2pNUEMwR2NOQThMUVo0eER3dEI5RFVQQzBIbElnOExRYThsRHd0Qm1URVBDMEd5Tmc4TFFmazJEd3RCeERJUEMwSGRMQThMUVlJeER3dEJ3VEVQQzBHTk53OExRY2trRHd0QjdEWVBDMEhuS2c4TFFjZ2pEd3RCNGlFUEMwSEpOdzhMUWFVaUR3dEJsQ0lQQzBIYk5nOExRZDQxRHd0QmhpWVBDMEc4S3c4TFFZc3lEd3RCb0NNUEMwSDJNQThMUVlBc0R3dEJpU3NQQzBHa0pnOExRZklqRHd0QmdTZ1BDMEdyTWc4TFFlc25Ed3RCd2pZUEMwR2lKQThMUWM4cUR3dEIzQ01QQzBHSEp3OExRZVEwRHd0QnR5SVBDMEd0TVE4TFFkVWlEd3RCcnpRUEMwSGVKZzhMUWRZeUR3dEI5RFFQQzBHQk9BOExRZlEzRHd0QmtqWVBDMEdkSnc4TFFZSXBEd3RCalNNUEMwSFhNUThMUWIwMUR3dEJ0RGNQQzBIWU1BOExRYlluRHd0Qm1qZ1BDMEduS2c4TFFjUW5Ed3RCcmlNUEMwSDFJZzhMQUF0QnlpWWhBUXNnQVFzWEFDQUFJQUF2QVM1Qi92OERjU0FCUVFCSGNqc0JMZ3NhQUNBQUlBQXZBUzVCL2Y4RGNTQUJRUUJIUVFGMGNqc0JMZ3NhQUNBQUlBQXZBUzVCKy84RGNTQUJRUUJIUVFKMGNqc0JMZ3NhQUNBQUlBQXZBUzVCOS84RGNTQUJRUUJIUVFOMGNqc0JMZ3NhQUNBQUlBQXZBUzVCNy84RGNTQUJRUUJIUVFSMGNqc0JMZ3NhQUNBQUlBQXZBUzVCMy84RGNTQUJRUUJIUVFWMGNqc0JMZ3NhQUNBQUlBQXZBUzVCdi84RGNTQUJRUUJIUVFaMGNqc0JMZ3NhQUNBQUlBQXZBUzVCLy80RGNTQUJRUUJIUVFkMGNqc0JMZ3NhQUNBQUlBQXZBUzVCLy8wRGNTQUJRUUJIUVFoMGNqc0JMZ3NhQUNBQUlBQXZBUzVCLy9zRGNTQUJRUUJIUVFsMGNqc0JMZ3MrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWdRaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFlRVNOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWdnaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFmd1JOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWd3aUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFld0tOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWhBaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFmb2VOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWhRaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFjc1FOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWhnaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFiY2ZOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWh3aUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFiOFZOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFmNElOZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWlBaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFZd2ROZ0lRUVJnaEJBc2dCQXMrQVFKL0FrQWdBQ2dDT0NJRFJRMEFJQU1vQWlRaUEwVU5BQ0FBSUFFZ0FpQUJheUFERVFFQUlnUkJmMGNOQUNBQVFlWVZOZ0lRUVJnaEJBc2dCQXM0QUNBQUFuOGdBQzhCTWtFVWNVRVVSZ1JBUVFFZ0FDMEFLRUVCUmcwQkdpQUFMd0UwUWVVQVJnd0JDeUFBTFFBcFFRVkdDem9BTUF0WkFRSi9Ba0FnQUMwQUtFRUJSZzBBSUFBdkFUUWlBVUhrQUd0QjVBQkpEUUFnQVVITUFVWU5BQ0FCUWJBQ1JnMEFJQUF2QVRJaUFFSEFBSEVOQUVFQklRSWdBRUdJQkhGQmdBUkdEUUFnQUVFb2NVVWhBZ3NnQWd1TUFRRUNmd0pBQWtBQ1FDQUFMUUFxUlEwQUlBQXRBQ3RGRFFBZ0FDOEJNaUlCUVFKeFJRMEJEQUlMSUFBdkFUSWlBVUVCY1VVTkFRdEJBU0VDSUFBdEFDaEJBVVlOQUNBQUx3RTBJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BQ0FCUWNBQWNRMEFRUUFoQWlBQlFZZ0VjVUdBQkVZTkFDQUJRU2h4UVFCSElRSUxJQUlMY3dBZ0FFRVFhdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQXdBZ0FQME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBd0FnQUVFd2F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBd0FnQUVFZ2F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBd0FnQUVIOUFUWUNIQXNHQUNBQUVEb0xtaTBCQzM4akFFRVFheUlLSkFCQjNOVUFLQUlBSWdsRkJFQkJuTmtBS0FJQUlnVkZCRUJCcU5rQVFuODNBZ0JCb05rQVFvQ0FoSUNBZ01BQU53SUFRWnpaQUNBS1FRaHFRWEJ4UWRpcTFhb0ZjeUlGTmdJQVFiRFpBRUVBTmdJQVFZRFpBRUVBTmdJQUMwR0UyUUJCd05rRU5nSUFRZFRWQUVIQTJRUTJBZ0JCNk5VQUlBVTJBZ0JCNU5VQVFYODJBZ0JCaU5rQVFjQ21BellDQUFOQUlBRkJnTllBYWlBQlFmVFZBR29pQWpZQ0FDQUNJQUZCN05VQWFpSUROZ0lBSUFGQitOVUFhaUFETmdJQUlBRkJpTllBYWlBQlFmelZBR29pQXpZQ0FDQURJQUkyQWdBZ0FVR1ExZ0JxSUFGQmhOWUFhaUlDTmdJQUlBSWdBellDQUNBQlFZeldBR29nQWpZQ0FDQUJRU0JxSWdGQmdBSkhEUUFMUWN6WkJFR0JwZ00yQWdCQjROVUFRYXpaQUNnQ0FEWUNBRUhRMVFCQmdLWUROZ0lBUWR6VkFFSEkyUVEyQWdCQnpQOEhRVGcyQWdCQnlOa0VJUWtMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBRUhzQVUwRVFFSEUxUUFvQWdBaUJrRVFJQUJCRTJwQmNIRWdBRUVMU1JzaUJFRURkaUlBZGlJQlFRTnhCRUFDUUNBQlFRRnhJQUJ5UVFGeklnSkJBM1FpQUVIczFRQnFJZ0VnQUVIMDFRQnFLQUlBSWdBb0FnZ2lBMFlFUUVIRTFRQWdCa0YrSUFKM2NUWUNBQXdCQ3lBQklBTTJBZ2dnQXlBQk5nSU1DeUFBUVFocUlRRWdBQ0FDUVFOMElnSkJBM0kyQWdRZ0FDQUNhaUlBSUFBb0FnUkJBWEkyQWdRTUVRdEJ6TlVBS0FJQUlnZ2dCRThOQVNBQkJFQUNRRUVDSUFCMElnSkJBQ0FDYTNJZ0FTQUFkSEZvSWdCQkEzUWlBa0hzMVFCcUlnRWdBa0gwMVFCcUtBSUFJZ0lvQWdnaUEwWUVRRUhFMVFBZ0JrRitJQUIzY1NJR05nSUFEQUVMSUFFZ0F6WUNDQ0FESUFFMkFnd0xJQUlnQkVFRGNqWUNCQ0FBUVFOMElnQWdCR3NoQlNBQUlBSnFJQVUyQWdBZ0FpQUVhaUlFSUFWQkFYSTJBZ1FnQ0FSQUlBaEJlSEZCN05VQWFpRUFRZGpWQUNnQ0FDRURBbjlCQVNBSVFRTjJkQ0lCSUFaeFJRUkFRY1RWQUNBQklBWnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaUFTQUROZ0lNSUFBZ0F6WUNDQ0FESUFBMkFnd2dBeUFCTmdJSUN5QUNRUWhxSVFGQjJOVUFJQVEyQWdCQnpOVUFJQVUyQWdBTUVRdEJ5TlVBS0FJQUlndEZEUUVnQzJoQkFuUkI5TmNBYWlnQ0FDSUFLQUlFUVhoeElBUnJJUVVnQUNFQ0EwQUNRQ0FDS0FJUUlnRkZCRUFnQWtFVWFpZ0NBQ0lCUlEwQkN5QUJLQUlFUVhoeElBUnJJZ01nQlVraEFpQURJQVVnQWhzaEJTQUJJQUFnQWhzaEFDQUJJUUlNQVFzTElBQW9BaGdoQ1NBQUtBSU1JZ01nQUVjRVFFSFUxUUFvQWdBYUlBTWdBQ2dDQ0NJQk5nSUlJQUVnQXpZQ0RBd1FDeUFBUVJScUlnSW9BZ0FpQVVVRVFDQUFLQUlRSWdGRkRRTWdBRUVRYWlFQ0N3TkFJQUloQnlBQklnTkJGR29pQWlnQ0FDSUJEUUFnQTBFUWFpRUNJQU1vQWhBaUFRMEFDeUFIUVFBMkFnQU1Ed3RCZnlFRUlBQkJ2MzlMRFFBZ0FFRVRhaUlCUVhCeElRUkJ5TlVBS0FJQUlnaEZEUUJCQUNBRWF5RUZBa0FDUUFKQUFuOUJBQ0FFUVlBQ1NRMEFHa0VmSUFSQi8vLy9CMHNOQUJvZ0JFRW1JQUZCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWdzaUJrRUNkRUgwMXdCcUtBSUFJZ0pGQkVCQkFDRUJRUUFoQXd3QkMwRUFJUUVnQkVFWklBWkJBWFpyUVFBZ0JrRWZSeHQwSVFCQkFDRURBMEFDUUNBQ0tBSUVRWGh4SUFScklnY2dCVThOQUNBQ0lRTWdCeUlGRFFCQkFDRUZJQUloQVF3REN5QUJJQUpCRkdvb0FnQWlCeUFISUFJZ0FFRWRka0VFY1dwQkVHb29BZ0FpQWtZYklBRWdCeHNoQVNBQVFRRjBJUUFnQWcwQUN3c2dBU0FEY2tVRVFFRUFJUU5CQWlBR2RDSUFRUUFnQUd0eUlBaHhJZ0JGRFFNZ0FHaEJBblJCOU5jQWFpZ0NBQ0VCQ3lBQlJRMEJDd05BSUFFb0FnUkJlSEVnQkdzaUFpQUZTU0VBSUFJZ0JTQUFHeUVGSUFFZ0F5QUFHeUVESUFFb0FoQWlBQVIvSUFBRklBRkJGR29vQWdBTElnRU5BQXNMSUFORkRRQWdCVUhNMVFBb0FnQWdCR3RQRFFBZ0F5Z0NHQ0VISUFNZ0F5Z0NEQ0lBUndSQVFkVFZBQ2dDQUJvZ0FDQURLQUlJSWdFMkFnZ2dBU0FBTmdJTURBNExJQU5CRkdvaUFpZ0NBQ0lCUlFSQUlBTW9BaEFpQVVVTkF5QURRUkJxSVFJTEEwQWdBaUVHSUFFaUFFRVVhaUlDS0FJQUlnRU5BQ0FBUVJCcUlRSWdBQ2dDRUNJQkRRQUxJQVpCQURZQ0FBd05DMEhNMVFBb0FnQWlBeUFFVHdSQVFkalZBQ2dDQUNFQkFrQWdBeUFFYXlJQ1FSQlBCRUFnQVNBRWFpSUFJQUpCQVhJMkFnUWdBU0FEYWlBQ05nSUFJQUVnQkVFRGNqWUNCQXdCQ3lBQklBTkJBM0kyQWdRZ0FTQURhaUlBSUFBb0FnUkJBWEkyQWdSQkFDRUFRUUFoQWd0QnpOVUFJQUkyQWdCQjJOVUFJQUEyQWdBZ0FVRUlhaUVCREE4TFFkRFZBQ2dDQUNJRElBUkxCRUFnQkNBSmFpSUFJQU1nQkdzaUFVRUJjallDQkVIYzFRQWdBRFlDQUVIUTFRQWdBVFlDQUNBSklBUkJBM0kyQWdRZ0NVRUlhaUVCREE4TFFRQWhBU0FFQW45Qm5Oa0FLQUlBQkVCQnBOa0FLQUlBREFFTFFhalpBRUovTndJQVFhRFpBRUtBZ0lTQWdJREFBRGNDQUVHYzJRQWdDa0VNYWtGd2NVSFlxdFdxQlhNMkFnQkJzTmtBUVFBMkFnQkJnTmtBUVFBMkFnQkJnSUFFQ3lJQUlBUkJ4d0JxSWdWcUlnWkJBQ0FBYXlJSGNTSUNUd1JBUWJUWkFFRXdOZ0lBREE4TEFrQkIvTmdBS0FJQUlnRkZEUUJCOU5nQUtBSUFJZ2dnQW1vaEFDQUFJQUZOSUFBZ0NFdHhEUUJCQUNFQlFiVFpBRUV3TmdJQURBOExRWURaQUMwQUFFRUVjUTBFQWtBQ1FDQUpCRUJCaE5rQUlRRURRQ0FCS0FJQUlnQWdDVTBFUUNBQUlBRW9BZ1JxSUFsTERRTUxJQUVvQWdnaUFRMEFDd3RCQUJBN0lnQkJmMFlOQlNBQ0lRWkJvTmtBS0FJQUlnRkJBV3NpQXlBQWNRUkFJQUlnQUdzZ0FDQURha0VBSUFGcmNXb2hCZ3NnQkNBR1R3MEZJQVpCL3YvLy93ZExEUVZCL05nQUtBSUFJZ01FUUVIMDJBQW9BZ0FpQnlBR2FpRUJJQUVnQjAwTkJpQUJJQU5MRFFZTElBWVFPeUlCSUFCSERRRU1Cd3NnQmlBRGF5QUhjU0lHUWY3Ly8vOEhTdzBFSUFZUU95RUFJQUFnQVNnQ0FDQUJLQUlFYWtZTkF5QUFJUUVMQWtBZ0JpQUVRY2dBYWs4TkFDQUJRWDlHRFFCQnBOa0FLQUlBSWdBZ0JTQUdhMnBCQUNBQWEzRWlBRUgrLy8vL0Iwc0VRQ0FCSVFBTUJ3c2dBQkE3UVg5SEJFQWdBQ0FHYWlFR0lBRWhBQXdIQzBFQUlBWnJFRHNhREFRTElBRWlBRUYvUncwRkRBTUxRUUFoQXd3TUMwRUFJUUFNQ2dzZ0FFRi9SdzBDQzBHQTJRQkJnTmtBS0FJQVFRUnlOZ0lBQ3lBQ1FmNy8vLzhIU3cwQklBSVFPeUVBUVFBUU95RUJJQUJCZjBZTkFTQUJRWDlHRFFFZ0FDQUJUdzBCSUFFZ0FHc2lCaUFFUVRocVRRMEJDMEgwMkFCQjlOZ0FLQUlBSUFacUlnRTJBZ0JCK05nQUtBSUFJQUZKQkVCQitOZ0FJQUUyQWdBTEFrQUNRQUpBUWR6VkFDZ0NBQ0lDQkVCQmhOa0FJUUVEUUNBQUlBRW9BZ0FpQXlBQktBSUVJZ1ZxUmcwQ0lBRW9BZ2dpQVEwQUN3d0NDMEhVMVFBb0FnQWlBVUVBUnlBQUlBRlBjVVVFUUVIVTFRQWdBRFlDQUF0QkFDRUJRWWpaQUNBR05nSUFRWVRaQUNBQU5nSUFRZVRWQUVGL05nSUFRZWpWQUVHYzJRQW9BZ0EyQWdCQmtOa0FRUUEyQWdBRFFDQUJRWURXQUdvZ0FVSDAxUUJxSWdJMkFnQWdBaUFCUWV6VkFHb2lBellDQUNBQlFmalZBR29nQXpZQ0FDQUJRWWpXQUdvZ0FVSDgxUUJxSWdNMkFnQWdBeUFDTmdJQUlBRkJrTllBYWlBQlFZVFdBR29pQWpZQ0FDQUNJQU0yQWdBZ0FVR00xZ0JxSUFJMkFnQWdBVUVnYWlJQlFZQUNSdzBBQzBGNElBQnJRUTl4SWdFZ0FHb2lBaUFHUVRocklnTWdBV3NpQVVFQmNqWUNCRUhnMVFCQnJOa0FLQUlBTmdJQVFkRFZBQ0FCTmdJQVFkelZBQ0FDTmdJQUlBQWdBMnBCT0RZQ0JBd0NDeUFBSUFKTkRRQWdBaUFEU1EwQUlBRW9BZ3hCQ0hFTkFFRjRJQUpyUVE5eElnQWdBbW9pQTBIUTFRQW9BZ0FnQm1vaUJ5QUFheUlBUVFGeU5nSUVJQUVnQlNBR2FqWUNCRUhnMVFCQnJOa0FLQUlBTmdJQVFkRFZBQ0FBTmdJQVFkelZBQ0FETmdJQUlBSWdCMnBCT0RZQ0JBd0JDeUFBUWRUVkFDZ0NBRWtFUUVIVTFRQWdBRFlDQUFzZ0FDQUdhaUVEUVlUWkFDRUJBa0FDUUFKQUEwQWdBeUFCS0FJQVJ3UkFJQUVvQWdnaUFRMEJEQUlMQ3lBQkxRQU1RUWh4UlEwQkMwR0UyUUFoQVFOQUlBRW9BZ0FpQXlBQ1RRUkFJQU1nQVNnQ0JHb2lCU0FDU3cwREN5QUJLQUlJSVFFTUFBc0FDeUFCSUFBMkFnQWdBU0FCS0FJRUlBWnFOZ0lFSUFCQmVDQUFhMEVQY1dvaUNTQUVRUU55TmdJRUlBTkJlQ0FEYTBFUGNXb2lCaUFFSUFscUlnUnJJUUVnQWlBR1JnUkFRZHpWQUNBRU5nSUFRZERWQUVIUTFRQW9BZ0FnQVdvaUFEWUNBQ0FFSUFCQkFYSTJBZ1FNQ0F0QjJOVUFLQUlBSUFaR0JFQkIyTlVBSUFRMkFnQkJ6TlVBUWN6VkFDZ0NBQ0FCYWlJQU5nSUFJQVFnQUVFQmNqWUNCQ0FBSUFScUlBQTJBZ0FNQ0FzZ0JpZ0NCQ0lGUVFOeFFRRkhEUVlnQlVGNGNTRUlJQVZCL3dGTkJFQWdCVUVEZGlFRElBWW9BZ2dpQUNBR0tBSU1JZ0pHQkVCQnhOVUFRY1RWQUNnQ0FFRitJQU4zY1RZQ0FBd0hDeUFDSUFBMkFnZ2dBQ0FDTmdJTURBWUxJQVlvQWhnaEJ5QUdJQVlvQWd3aUFFY0VRQ0FBSUFZb0FnZ2lBallDQ0NBQ0lBQTJBZ3dNQlFzZ0JrRVVhaUlDS0FJQUlnVkZCRUFnQmlnQ0VDSUZSUTBFSUFaQkVHb2hBZ3NEUUNBQ0lRTWdCU0lBUVJScUlnSW9BZ0FpQlEwQUlBQkJFR29oQWlBQUtBSVFJZ1VOQUFzZ0EwRUFOZ0lBREFRTFFYZ2dBR3RCRDNFaUFTQUFhaUlISUFaQk9Hc2lBeUFCYXlJQlFRRnlOZ0lFSUFBZ0EycEJPRFlDQkNBQ0lBVkJOeUFGYTBFUGNXcEJQMnNpQXlBRElBSkJFR3BKR3lJRFFTTTJBZ1JCNE5VQVFhelpBQ2dDQURZQ0FFSFExUUFnQVRZQ0FFSGMxUUFnQnpZQ0FDQURRUkJxUVl6WkFDa0NBRGNDQUNBRFFZVFpBQ2tDQURjQ0NFR00yUUFnQTBFSWFqWUNBRUdJMlFBZ0JqWUNBRUdFMlFBZ0FEWUNBRUdRMlFCQkFEWUNBQ0FEUVNScUlRRURRQ0FCUVFjMkFnQWdCU0FCUVFScUlnRkxEUUFMSUFJZ0EwWU5BQ0FESUFNb0FnUkJmbkUyQWdRZ0F5QURJQUpySWdVMkFnQWdBaUFGUVFGeU5nSUVJQVZCL3dGTkJFQWdCVUY0Y1VIczFRQnFJUUFDZjBIRTFRQW9BZ0FpQVVFQklBVkJBM1owSWdOeFJRUkFRY1RWQUNBQklBTnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDSUFBMkFnd2dBaUFCTmdJSURBRUxRUjhoQVNBRlFmLy8vd2ROQkVBZ0JVRW1JQVZCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQkN5QUNJQUUyQWh3Z0FrSUFOd0lRSUFGQkFuUkI5TmNBYWlFQVFjalZBQ2dDQUNJRFFRRWdBWFFpQm5GRkJFQWdBQ0FDTmdJQVFjalZBQ0FESUFaeU5nSUFJQUlnQURZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFFTElBVkJHU0FCUVFGMmEwRUFJQUZCSDBjYmRDRUJJQUFvQWdBaEF3SkFBMEFnQXlJQUtBSUVRWGh4SUFWR0RRRWdBVUVkZGlFRElBRkJBWFFoQVNBQUlBTkJCSEZxUVJCcUlnWW9BZ0FpQXcwQUN5QUdJQUkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQUNnQ0NDSUJJQUkyQWd3Z0FDQUNOZ0lJSUFKQkFEWUNHQ0FDSUFBMkFnd2dBaUFCTmdJSUMwSFExUUFvQWdBaUFTQUVUUTBBUWR6VkFDZ0NBQ0lBSUFScUlnSWdBU0FFYXlJQlFRRnlOZ0lFUWREVkFDQUJOZ0lBUWR6VkFDQUNOZ0lBSUFBZ0JFRURjallDQkNBQVFRaHFJUUVNQ0F0QkFDRUJRYlRaQUVFd05nSUFEQWNMUVFBaEFBc2dCMFVOQUFKQUlBWW9BaHdpQWtFQ2RFSDAxd0JxSWdNb0FnQWdCa1lFUUNBRElBQTJBZ0FnQUEwQlFjalZBRUhJMVFBb0FnQkJmaUFDZDNFMkFnQU1BZ3NnQjBFUVFSUWdCeWdDRUNBR1JodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSE5nSVlJQVlvQWhBaUFnUkFJQUFnQWpZQ0VDQUNJQUEyQWhnTElBWkJGR29vQWdBaUFrVU5BQ0FBUVJScUlBSTJBZ0FnQWlBQU5nSVlDeUFCSUFocUlRRWdCaUFJYWlJR0tBSUVJUVVMSUFZZ0JVRitjVFlDQkNBQklBUnFJQUUyQWdBZ0JDQUJRUUZ5TmdJRUlBRkIvd0ZOQkVBZ0FVRjRjVUhzMVFCcUlRQUNmMEhFMVFBb0FnQWlBa0VCSUFGQkEzWjBJZ0Z4UlFSQVFjVFZBQ0FCSUFKeU5nSUFJQUFNQVFzZ0FDZ0NDQXNpQVNBRU5nSU1JQUFnQkRZQ0NDQUVJQUEyQWd3Z0JDQUJOZ0lJREFFTFFSOGhCU0FCUWYvLy93ZE5CRUFnQVVFbUlBRkJDSFpuSWdCcmRrRUJjU0FBUVFGMGEwRSthaUVGQ3lBRUlBVTJBaHdnQkVJQU53SVFJQVZCQW5SQjlOY0FhaUVBUWNqVkFDZ0NBQ0lDUVFFZ0JYUWlBM0ZGQkVBZ0FDQUVOZ0lBUWNqVkFDQUNJQU55TmdJQUlBUWdBRFlDR0NBRUlBUTJBZ2dnQkNBRU5nSU1EQUVMSUFGQkdTQUZRUUYyYTBFQUlBVkJIMGNiZENFRklBQW9BZ0FoQUFKQUEwQWdBQ0lDS0FJRVFYaHhJQUZHRFFFZ0JVRWRkaUVBSUFWQkFYUWhCU0FDSUFCQkJIRnFRUkJxSWdNb0FnQWlBQTBBQ3lBRElBUTJBZ0FnQkNBQ05nSVlJQVFnQkRZQ0RDQUVJQVEyQWdnTUFRc2dBaWdDQ0NJQUlBUTJBZ3dnQWlBRU5nSUlJQVJCQURZQ0dDQUVJQUkyQWd3Z0JDQUFOZ0lJQ3lBSlFRaHFJUUVNQWdzQ1FDQUhSUTBBQWtBZ0F5Z0NIQ0lCUVFKMFFmVFhBR29pQWlnQ0FDQURSZ1JBSUFJZ0FEWUNBQ0FBRFFGQnlOVUFJQWhCZmlBQmQzRWlDRFlDQUF3Q0N5QUhRUkJCRkNBSEtBSVFJQU5HRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQWMyQWhnZ0F5Z0NFQ0lCQkVBZ0FDQUJOZ0lRSUFFZ0FEWUNHQXNnQTBFVWFpZ0NBQ0lCUlEwQUlBQkJGR29nQVRZQ0FDQUJJQUEyQWhnTEFrQWdCVUVQVFFSQUlBTWdCQ0FGYWlJQVFRTnlOZ0lFSUFBZ0Eyb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBTWdCR29pQWlBRlFRRnlOZ0lFSUFNZ0JFRURjallDQkNBQ0lBVnFJQVUyQWdBZ0JVSC9BVTBFUUNBRlFYaHhRZXpWQUdvaEFBSi9RY1RWQUNnQ0FDSUJRUUVnQlVFRGRuUWlCWEZGQkVCQnhOVUFJQUVnQlhJMkFnQWdBQXdCQ3lBQUtBSUlDeUlCSUFJMkFnd2dBQ0FDTmdJSUlBSWdBRFlDRENBQ0lBRTJBZ2dNQVF0Qkh5RUJJQVZCLy8vL0IwMEVRQ0FGUVNZZ0JVRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUUVMSUFJZ0FUWUNIQ0FDUWdBM0FoQWdBVUVDZEVIMDF3QnFJUUJCQVNBQmRDSUVJQWh4UlFSQUlBQWdBallDQUVISTFRQWdCQ0FJY2pZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lJSUFJZ0FqWUNEQXdCQ3lBRlFSa2dBVUVCZG10QkFDQUJRUjlIRzNRaEFTQUFLQUlBSVFRQ1FBTkFJQVFpQUNnQ0JFRjRjU0FGUmcwQklBRkJIWFloQkNBQlFRRjBJUUVnQUNBRVFRUnhha0VRYWlJR0tBSUFJZ1FOQUFzZ0JpQUNOZ0lBSUFJZ0FEWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUFvQWdnaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFBTmdJTUlBSWdBVFlDQ0FzZ0EwRUlhaUVCREFFTEFrQWdDVVVOQUFKQUlBQW9BaHdpQVVFQ2RFSDAxd0JxSWdJb0FnQWdBRVlFUUNBQ0lBTTJBZ0FnQXcwQlFjalZBQ0FMUVg0Z0FYZHhOZ0lBREFJTElBbEJFRUVVSUFrb0FoQWdBRVliYWlBRE5nSUFJQU5GRFFFTElBTWdDVFlDR0NBQUtBSVFJZ0VFUUNBRElBRTJBaEFnQVNBRE5nSVlDeUFBUVJScUtBSUFJZ0ZGRFFBZ0EwRVVhaUFCTmdJQUlBRWdBellDR0FzQ1FDQUZRUTlOQkVBZ0FDQUVJQVZxSWdGQkEzSTJBZ1FnQUNBQmFpSUJJQUVvQWdSQkFYSTJBZ1FNQVFzZ0FDQUVhaUlISUFWQkFYSTJBZ1FnQUNBRVFRTnlOZ0lFSUFVZ0Iyb2dCVFlDQUNBSUJFQWdDRUY0Y1VIczFRQnFJUUZCMk5VQUtBSUFJUU1DZjBFQklBaEJBM1owSWdJZ0JuRkZCRUJCeE5VQUlBSWdCbkkyQWdBZ0FRd0JDeUFCS0FJSUN5SUNJQU0yQWd3Z0FTQUROZ0lJSUFNZ0FUWUNEQ0FESUFJMkFnZ0xRZGpWQUNBSE5nSUFRY3pWQUNBRk5nSUFDeUFBUVFocUlRRUxJQXBCRUdva0FDQUJDME1BSUFCRkJFQS9BRUVRZEE4TEFrQWdBRUgvL3dOeERRQWdBRUVBU0EwQUlBQkJFSFpBQUNJQVFYOUdCRUJCdE5rQVFUQTJBZ0JCZnc4TElBQkJFSFFQQ3dBTEM1bENJZ0JCZ0FnTERRRUFBQUFBQUFBQUFnQUFBQU1BUVpnSUN3VUVBQUFBQlFCQnFBZ0xDUVlBQUFBSEFBQUFDQUJCNUFnTHdqSkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEYxWlhKNUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlltOWtlUUJEYjI1MFpXNTBMVXhsYm1kMGFDQnZkbVZ5Wm14dmR3QkRhSFZ1YXlCemFYcGxJRzkyWlhKbWJHOTNBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJJVkZSUUwzZ3VlQ0J5WlhGMVpYTjBBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJTVkZOUUwzZ3VlQ0J5WlhGMVpYTjBBRVY0Y0dWamRHVmtJRk5QVlZKRFJTQnRaWFJvYjJRZ1ptOXlJRWxEUlM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJR1p5WVdkdFpXNTBJSE4wWVhKMEFFVjRjR1ZqZEdWa0lHUnZkQUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM04wWVhSMWN3QkpiblpoYkdsa0lISmxjM0J2Ym5ObElITjBZWFIxY3dCRmVIQmxZM1JsWkNCTVJpQmhablJsY2lCb1pXRmtaWEp6QUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NQVZYTmxjaUJqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmY21WelpYUmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOW9aV0ZrWlhKZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgySmxaMmx1WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYzNSaGRIVnpYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmZG1WeWMybHZibDlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNWeWJGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM0J5YjNSdlkyOXNYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJWeWRtVnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIWmhiSFZsSUdOb1lYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ1ptbGxiR1FnWTJoaGNnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzWmxjbk5wYjI0QVNXNTJZV3hwWkNCdGFXNXZjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV0ZxYjNJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lFTlNURVlnWVdaMFpYSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lFaFVWRkFnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmNISnZkRzlqYjJ3QVJXMXdkSGtnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnUTI5dWRHVnVkQzFNWlc1bmRHZ0FWSEpoYm5ObVpYSXRSVzVqYjJScGJtY2dZMkZ1SjNRZ1ltVWdjSEpsYzJWdWRDQjNhWFJvSUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1ExSWdZV1owWlhJZ1kyaDFibXNnYzJsNlpRQkZlSEJsWTNSbFpDQk1SaUJoWm5SbGNpQmphSFZ1YXlCemFYcGxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCMllXeDFaUUJWYm1WNGNHVmpkR1ZrSUhkb2FYUmxjM0JoWTJVZ1lXWjBaWElnYUdWaFpHVnlJSFpoYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1ExSWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdURVlnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUVsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUNCb1pXRmtaWElnZG1Gc2RXVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQmphSFZ1YXlCbGVIUmxibk5wYjI0Z2RtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCeGRXOTBaU0IyWVd4MVpRQkpiblpoYkdsa0lIRjFiM1JsWkMxd1lXbHlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVmtJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdWa0lIWmhiSFZsQUZCaGRYTmxaQ0JpZVNCdmJsOW9aV0ZrWlhKelgyTnZiWEJzWlhSbEFFbHVkbUZzYVdRZ1JVOUdJSE4wWVhSbEFHOXVYM0psYzJWMElIQmhkWE5sQUc5dVgyTm9kVzVyWDJobFlXUmxjaUJ3WVhWelpRQnZibDl0WlhOellXZGxYMkpsWjJsdUlIQmhkWE5sQUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaU0J3WVhWelpRQnZibDl6ZEdGMGRYTmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZkbVZ5YzJsdmJsOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTFjbXhmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmY0hKdmRHOWpiMnhmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgzWmhiSFZsWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDIxbGMzTmhaMlZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMmhsWVdSbGNsOW1hV1ZzWkY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpTQndZWFZ6WlFCVmJtVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJSE4wWVhKMElHeHBibVVBVFdsemMybHVaeUJsZUhCbFkzUmxaQ0JEVWlCaFpuUmxjaUJ5WlhOd2IyNXpaU0JzYVc1bEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ1WVcxbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1ExSWdZV1owWlhJZ1kyaDFibXNnWlhoMFpXNXphVzl1SUc1aGJXVUFTVzUyWVd4cFpDQnpkR0YwZFhNZ1kyOWtaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMjFsZEdodlpBQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFTlNJR0ZtZEdWeUlHTm9kVzVySUdSaGRHRUFSWGh3WldOMFpXUWdURVlnWVdaMFpYSWdZMmgxYm1zZ1pHRjBZUUJWYm1WNGNHVmpkR1ZrSUdOb1lYSWdhVzRnZFhKc0lITmphR1Z0WVFCU1pYRjFaWE4wSUdoaGN5QnBiblpoYkdsa0lHQlVjbUZ1YzJabGNpMUZibU52WkdsdVoyQUFSR0YwWVNCaFpuUmxjaUJnUTI5dWJtVmpkR2x2YmpvZ1kyeHZjMlZnQUZOWFNWUkRTRjlRVWs5WVdRQlZVMFZmVUZKUFdGa0FUVXRCUTFSSlZrbFVXUUJWVGxCU1QwTkZVMU5CUWt4RlgwVk9WRWxVV1FCUlZVVlNXUUJEVDFCWkFFMVBWa1ZFWDFCRlVrMUJUa1ZPVkV4WkFGUlBUMTlGUVZKTVdRQk9UMVJKUmxrQVJrRkpURVZFWDBSRlVFVk9SRVZPUTFrQVFrRkVYMGRCVkVWWFFWa0FVRXhCV1FCUVZWUUFRMGhGUTB0UFZWUUFSMEZVUlZkQldWOVVTVTFGVDFWVUFGSkZVVlZGVTFSZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDBOUFRrNUZRMVJmVkVsTlJVOVZWQUJEVDA1T1JVTlVTVTlPWDFSSlRVVlBWVlFBVEU5SFNVNWZWRWxOUlU5VlZBQk9SVlJYVDFKTFgxSkZRVVJmVkVsTlJVOVZWQUJRVDFOVUFFMUpVMFJKVWtWRFZFVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5U1JWRlZSVk5VQUVOTVNVVk9WRjlEVEU5VFJVUmZURTlCUkY5Q1FVeEJUa05GUkY5U1JWRlZSVk5VQUVKQlJGOVNSVkZWUlZOVUFFaFVWRkJmVWtWUlZVVlRWRjlUUlU1VVgxUlBYMGhVVkZCVFgxQlBVbFFBVWtWUVQxSlVBRWxOWDBGZlZFVkJVRTlVQUZKRlUwVlVYME5QVGxSRlRsUUFUazlmUTA5T1ZFVk9WQUJRUVZKVVNVRk1YME5QVGxSRlRsUUFTRkJGWDBsT1ZrRk1TVVJmUTA5T1UxUkJUbFFBU0ZCRlgwTkNYMUpGVTBWVUFFZEZWQUJJVUVWZlUxUlNTVU5VQUVOUFRrWk1TVU5VQUZSRlRWQlBVa0ZTV1Y5U1JVUkpVa1ZEVkFCUVJWSk5RVTVGVGxSZlVrVkVTVkpGUTFRQVEwOU9Ua1ZEVkFCTlZVeFVTVjlUVkVGVVZWTUFTRkJGWDBsT1ZrRk1TVVJmVTFSQlZGVlRBRlJQVDE5TlFVNVpYMUpGVVZWRlUxUlRBRVZCVWt4WlgwaEpUbFJUQUZWT1FWWkJTVXhCUWt4RlgwWlBVbDlNUlVkQlRGOVNSVUZUVDA1VEFFOVFWRWxQVGxNQVUxZEpWRU5JU1U1SFgxQlNUMVJQUTA5TVV3QldRVkpKUVU1VVgwRk1VMDlmVGtWSFQxUkpRVlJGVXdCTlZVeFVTVkJNUlY5RFNFOUpRMFZUQUVsT1ZFVlNUa0ZNWDFORlVsWkZVbDlGVWxKUFVnQlhSVUpmVTBWU1ZrVlNYMVZPUzA1UFYwNWZSVkpTVDFJQVVrRkpURWRWVGw5RlVsSlBVZ0JKUkVWT1ZFbFVXVjlRVWs5V1NVUkZVbDlCVlZSSVJVNVVTVU5CVkVsUFRsOUZVbEpQVWdCVFUweGZRMFZTVkVsR1NVTkJWRVZmUlZKU1QxSUFTVTVXUVV4SlJGOVlYMFpQVWxkQlVrUkZSRjlHVDFJQVUwVlVYMUJCVWtGTlJWUkZVZ0JIUlZSZlVFRlNRVTFGVkVWU0FFaFFSVjlWVTBWU0FGTkZSVjlQVkVoRlVnQklVRVZmUTBKZlEwaFZUa3RmU0VWQlJFVlNBRVY0Y0dWamRHVmtJRXhHSUdGbWRHVnlJRU5TQUUxTFEwRk1SVTVFUVZJQVUwVlVWVkFBVjBWQ1gxTkZVbFpGVWw5SlUxOUVUMWRPQUZSRlFWSkVUMWRPQUVoUVJWOURURTlUUlVSZlEwOU9Ua1ZEVkVsUFRnQklSVlZTU1ZOVVNVTmZSVmhRU1ZKQlZFbFBUZ0JFU1ZORFQwNU9SVU5VUlVSZlQxQkZVa0ZVU1U5T0FFNVBUbDlCVlZSSVQxSkpWRUZVU1ZaRlgwbE9SazlTVFVGVVNVOU9BRWhRUlY5SlRsWkJURWxFWDFaRlVsTkpUMDRBU0ZCRlgwTkNYMDFGVTFOQlIwVmZRa1ZIU1U0QVUwbFVSVjlKVTE5R1VrOWFSVTRBU0ZCRlgwbE9Wa0ZNU1VSZlNFVkJSRVZTWDFSUFMwVk9BRWxPVmtGTVNVUmZWRTlMUlU0QVJrOVNRa2xFUkVWT0FFVk9TRUZPUTBWZldVOVZVbDlEUVV4TkFFaFFSVjlKVGxaQlRFbEVYMVZTVEFCQ1RFOURTMFZFWDBKWlgxQkJVa1ZPVkVGTVgwTlBUbFJTVDB3QVRVdERUMHdBUVVOTUFFaFFSVjlKVGxSRlVrNUJUQUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRlgxVk9UMFpHU1VOSlFVd0FTRkJGWDA5TEFGVk9URWxPU3dCVlRreFBRMHNBVUZKSkFGSkZWRkpaWDFkSlZFZ0FTRkJGWDBsT1ZrRk1TVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FTRkJGWDFWT1JWaFFSVU5VUlVSZlEwOU9WRVZPVkY5TVJVNUhWRWdBUmt4VlUwZ0FVRkpQVUZCQlZFTklBRTB0VTBWQlVrTklBRlZTU1Y5VVQwOWZURTlPUndCUVVrOURSVk5UU1U1SEFFMUpVME5GVEV4QlRrVlBWVk5mVUVWU1UwbFRWRVZPVkY5WFFWSk9TVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZWMEZTVGtsT1J3QklVRVZmU1U1V1FVeEpSRjlVVWtGT1UwWkZVbDlGVGtOUFJFbE9Sd0JGZUhCbFkzUmxaQ0JEVWt4R0FFaFFSVjlKVGxaQlRFbEVYME5JVlU1TFgxTkpXa1VBVFU5V1JRQkRUMDVVU1U1VlJRQklVRVZmUTBKZlUxUkJWRlZUWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOVdSVkpUU1U5T1gwTlBUVkJNUlZSRkFFaFFSVjlEUWw5VlVreGZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxQlNUMVJQUTA5TVgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1gxWkJURlZGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlEU0ZWT1MxOUZXRlJGVGxOSlQwNWZWa0ZNVlVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYMFZZVkVWT1UwbFBUbDlPUVUxRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWTlRRVWRGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlOUlZSSVQwUmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwaEZRVVJGVWw5R1NVVk1SRjlEVDAxUVRFVlVSUUJFUlV4RlZFVUFTRkJGWDBsT1ZrRk1TVVJmUlU5R1gxTlVRVlJGQUVsT1ZrRk1TVVJmVTFOTVgwTkZVbFJKUmtsRFFWUkZBRkJCVlZORkFFNVBYMUpGVTFCUFRsTkZBRlZPVTFWUVVFOVNWRVZFWDAxRlJFbEJYMVJaVUVVQVIwOU9SUUJPVDFSZlFVTkRSVkJVUVVKTVJRQlRSVkpXU1VORlgxVk9RVlpCU1V4QlFreEZBRkpCVGtkRlgwNVBWRjlUUVZSSlUwWkpRVUpNUlFCUFVrbEhTVTVmU1ZOZlZVNVNSVUZEU0VGQ1RFVUFVa1ZUVUU5T1UwVmZTVk5mVTFSQlRFVUFVRlZTUjBVQVRVVlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJRQlNSVkZWUlZOVVgwaEZRVVJGVWw5VVQwOWZURUZTUjBVQVVFRlpURTlCUkY5VVQwOWZURUZTUjBVQVNVNVRWVVpHU1VOSlJVNVVYMU5VVDFKQlIwVUFTRkJGWDFCQlZWTkZSRjlWVUVkU1FVUkZBRWhRUlY5UVFWVlRSVVJmU0RKZlZWQkhVa0ZFUlFCVFQxVlNRMFVBUVU1T1QxVk9RMFVBVkZKQlEwVUFTRkJGWDFWT1JWaFFSVU5VUlVSZlUxQkJRMFVBUkVWVFExSkpRa1VBVlU1VFZVSlRRMUpKUWtVQVVrVkRUMUpFQUVoUVJWOUpUbFpCVEVsRVgwMUZWRWhQUkFCT1QxUmZSazlWVGtRQVVGSlBVRVpKVGtRQVZVNUNTVTVFQUZKRlFrbE9SQUJWVGtGVlZFaFBVa2xhUlVRQVRVVlVTRTlFWDA1UFZGOUJURXhQVjBWRUFFaFVWRkJmVmtWU1UwbFBUbDlPVDFSZlUxVlFVRTlTVkVWRUFFRk1Va1ZCUkZsZlVrVlFUMUpVUlVRQVFVTkRSVkJVUlVRQVRrOVVYMGxOVUV4RlRVVk9WRVZFQUV4UFQxQmZSRVZVUlVOVVJVUUFTRkJGWDBOU1gwVllVRVZEVkVWRUFFaFFSVjlNUmw5RldGQkZRMVJGUkFCRFVrVkJWRVZFQUVsTlgxVlRSVVFBU0ZCRlgxQkJWVk5GUkFCVVNVMUZUMVZVWDA5RFExVlNSVVFBVUVGWlRVVk9WRjlTUlZGVlNWSkZSQUJRVWtWRFQwNUVTVlJKVDA1ZlVrVlJWVWxTUlVRQVVGSlBXRmxmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFUa1ZVVjA5U1MxOUJWVlJJUlU1VVNVTkJWRWxQVGw5U1JWRlZTVkpGUkFCTVJVNUhWRWhmVWtWUlZVbFNSVVFBVTFOTVgwTkZVbFJKUmtsRFFWUkZYMUpGVVZWSlVrVkVBRlZRUjFKQlJFVmZVa1ZSVlVsU1JVUUFVRUZIUlY5RldGQkpVa1ZFQUZCU1JVTlBUa1JKVkVsUFRsOUdRVWxNUlVRQVJWaFFSVU5VUVZSSlQwNWZSa0ZKVEVWRUFGSkZWa0ZNU1VSQlZFbFBUbDlHUVVsTVJVUUFVMU5NWDBoQlRrUlRTRUZMUlY5R1FVbE1SVVFBVEU5RFMwVkVBRlJTUVU1VFJrOVNUVUZVU1U5T1gwRlFVRXhKUlVRQVRrOVVYMDFQUkVsR1NVVkVBRTVQVkY5RldGUkZUa1JGUkFCQ1FVNUVWMGxFVkVoZlRFbE5TVlJmUlZoRFJVVkVSVVFBVTBsVVJWOUpVMTlQVmtWU1RFOUJSRVZFQUVoRlFVUUFSWGh3WldOMFpXUWdTRlJVVUM4c0lGSlVVMUF2SUc5eUlFbERSUzhBNXhVQUFLOFZBQUNrRWdBQWtob0FBQ1lXQUFDZUZBQUEyeGtBQUhrVkFBQitFZ0FBL2hRQUFEWVZBQUFMRmdBQTJCWUFBUE1TQUFCQ0dBQUFyQllBQUJJVkFBQVVGd0FBN3hjQUFFZ1VBQUJ4RndBQXNob0FBR3NaQUFCK0dRQUFOUlFBQUlJYUFBQkVGd0FBL1JZQUFCNFlBQUNIRndBQXFoa0FBSk1TQUFBSEdBQUFMQmNBQU1vWEFBQ2tGd0FBNXhVQUFPY1ZBQUJZRndBQU94Z0FBS0FTQUFBdEhBQUF3eEVBQUVnUkFBRGVFZ0FBUWhNQUFLUVpBQUQ5RUFBQTl4VUFBS1VWQUFEdkZnQUErQmtBQUVvV0FBQldGZ0FBOVJVQUFBb2FBQUFJR2dBQUFSb0FBS3NWQUFCQ0VnQUExeEFBQUV3UkFBQUZHUUFBVkJZQUFCNFJBQURLR1FBQXlCa0FBRTRXQUFEL0dBQUFjUlFBQVBBVkFBRHVGUUFBbEJrQUFQd1ZBQUMvR1FBQW14a0FBSHdVQUFCREVRQUFjQmdBQUpVVUFBQW5GQUFBR1JRQUFOVVNBQURVR1FBQVJCWUFBUGNRQUVHNU93c0JBUUJCMERzTDRBRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFREFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkJ1ajBMQkFFQUFBSUFRZEU5QzE0REJBTURBd01EQUFBREF3QURBd0FEQXdNREF3TURBd01EQUFVQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUF3QURBRUc2UHdzRUFRQUFBZ0JCMFQ4TFhnTUFBd01EQXdNQUFBTURBQU1EQUFNREF3TURBd01EQXdNQUJBQUZBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QURBQU1BUWJEQkFBc05iRzl6WldWbGNDMWhiR2wyWlFCQnljRUFDd0VCQUVIZ3dRQUw0QUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCeWNNQUN3RUJBRUhnd3dBTDV3RUJBUUVCQVFFQkFRRUJBUUVDQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFXTm9kVzVyWldRQVFmSEZBQXRlQVFBQkFRRUJBUUFBQVFFQUFRRUFBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQkIwTWNBQ3lGbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBUVlESUFBc2djbUZ1YzJabGNpMWxibU52WkdsdVozQm5jbUZrWlEwS0RRcFRUUTBLRFFvQVFhbklBQXNGQVFJQUFRTUFRY0RJQUF0ZkJBVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVBUWFuS0FBc0ZBUUlBQVFNQVFjREtBQXRmQkFVRkJnVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUFRYW5NQUFzRUFRQUFBUUJCd2N3QUMxNENBZ0FDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUVHcHpnQUxCUUVDQUFFREFFSEF6Z0FMWHdRRkFBQUZCUVVGQlFVRkJRVUZCUVlGQlFVRkJRVUZCUVVGQlFVQUJRQUhDQVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUUFGQUFVQUJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVQUFBQUZBRUdwMEFBTEJRRUJBQUVCQUVIQTBBQUxBUUVBUWRyUUFBdEJBZ0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BUWFuU0FBc0ZBUUVBQVFFQVFjRFNBQXNCQVFCQnl0SUFDd1lDQUFBQUFBSUFRZUhTQUFzNkF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0JCb05RQUM1MEJUazlWVGtORlJVTkxUMVZVVGtWRFZFVlVSVU5TU1VKRlRGVlRTRVZVUlVGRVUwVkJVa05JVWtkRlExUkpWa2xVV1V4RlRrUkJVbFpGVDFSSlJsbFFWRWxQVGxORFNGTkZRVmxUVkVGVVEwaEhSVlZGVWxsUFVrUkpVa1ZEVkU5U1ZGSkRTRkJCVWtGTlJWUkZVbFZTUTBWQ1UwTlNTVUpGUVZKRVQxZE9RVU5GU1U1RVRrdERTMVZDVTBOU1NVSkZWRlJRUTBWVVUxQkJSRlJRTHc9PSdcblxubGV0IHdhc21CdWZmZXJcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG4gIGdldDogKCkgPT4ge1xuICAgIHJldHVybiB3YXNtQnVmZmVyXG4gICAgICA/IHdhc21CdWZmZXJcbiAgICAgIDogKHdhc21CdWZmZXIgPSBCdWZmZXIuZnJvbSh3YXNtQmFzZTY0LCAnYmFzZTY0JykpXG4gIH1cbn0pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = enumToMap;\nfunction enumToMap(obj, filter = [], exceptions = []) {\n    const emptyFilter = (filter?.length ?? 0) === 0;\n    const emptyExceptions = (exceptions?.length ?? 0) === 0;\n    return Object.fromEntries(Object.entries(obj).filter(([, value]) => {\n        return (typeof value === 'number' &&\n            (emptyFilter || filter.includes(value)) &&\n            (emptyExceptions || !exceptions.includes(value)));\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbGxodHRwXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bVRvTWFwID0gZW51bVRvTWFwO1xuZnVuY3Rpb24gZW51bVRvTWFwKG9iaiwgZmlsdGVyID0gW10sIGV4Y2VwdGlvbnMgPSBbXSkge1xuICAgIGNvbnN0IGVtcHR5RmlsdGVyID0gKGZpbHRlcj8ubGVuZ3RoID8/IDApID09PSAwO1xuICAgIGNvbnN0IGVtcHR5RXhjZXB0aW9ucyA9IChleGNlcHRpb25zPy5sZW5ndGggPz8gMCkgPT09IDA7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoWywgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgKGVtcHR5RmlsdGVyIHx8IGZpbHRlci5pbmNsdWRlcyh2YWx1ZSkpICYmXG4gICAgICAgICAgICAoZW1wdHlFeGNlcHRpb25zIHx8ICFleGNlcHRpb25zLmluY2x1ZGVzKHZhbHVlKSkpO1xuICAgIH0pKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory,\n  kMockAgentRegisterCallHistory,\n  kMockAgentIsCallHistoryEnabled,\n  kMockAgentAddCallHistoryLog,\n  kMockAgentMockCallHistoryInstance,\n  kMockAgentAcceptsNonStandardSearchParameters,\n  kMockCallHistoryAddLog,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, normalizeSearchParams, buildAndValidateMockOptions, normalizeOrigin } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\")\nconst { MockCallHistory } = __webpack_require__(/*! ./mock-call-history */ \"(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\")\n\nclass MockAgent extends Dispatcher {\n  constructor (opts = {}) {\n    super(opts)\n\n    const mockOptions = buildAndValidateMockOptions(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n    this[kMockAgentIsCallHistoryEnabled] = mockOptions.enableCallHistory ?? false\n    this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions.acceptNonStandardSearchParameters ?? false\n    this[kIgnoreTrailingSlash] = mockOptions.ignoreTrailingSlash ?? false\n\n    // Instantiate Agent and encapsulate\n    if (opts?.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = mockOptions\n\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      this[kMockAgentRegisterCallHistory]()\n    }\n  }\n\n  get (origin) {\n    // Normalize origin to handle URL objects and case-insensitive hostnames\n    const normalizedOrigin = normalizeOrigin(origin)\n    const originKey = this[kIgnoreTrailingSlash] ? normalizedOrigin.replace(/\\/$/, '') : normalizedOrigin\n\n    let dispatcher = this[kMockAgentGet](originKey)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](originKey)\n      this[kMockAgentSet](originKey, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    opts.origin = normalizeOrigin(opts.origin)\n\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n\n    this[kMockAgentAddCallHistoryLog](opts)\n\n    const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters]\n\n    const dispatchOpts = { ...opts }\n\n    if (acceptNonStandardSearchParameters && dispatchOpts.path) {\n      const [path, searchParams] = dispatchOpts.path.split('?')\n      const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters)\n      dispatchOpts.path = `${path}?${normalizedSearchParams}`\n    }\n\n    return this[kAgent].dispatch(dispatchOpts, handler)\n  }\n\n  async close () {\n    this.clearCallHistory()\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  enableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = true\n\n    return this\n  }\n\n  disableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = false\n\n    return this\n  }\n\n  getCallHistory () {\n    return this[kMockAgentMockCallHistoryInstance]\n  }\n\n  clearCallHistory () {\n    if (this[kMockAgentMockCallHistoryInstance] !== undefined) {\n      this[kMockAgentMockCallHistoryInstance].clear()\n    }\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentRegisterCallHistory] () {\n    if (this[kMockAgentMockCallHistoryInstance] === undefined) {\n      this[kMockAgentMockCallHistoryInstance] = new MockCallHistory()\n    }\n  }\n\n  [kMockAgentAddCallHistoryLog] (opts) {\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      // additional setup when enableCallHistory class method is used after mockAgent instantiation\n      this[kMockAgentRegisterCallHistory]()\n\n      // add call history log on every call (intercepted or not)\n      this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts)\n    }\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, { count: 0, dispatcher })\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const result = this[kClients].get(origin)\n    if (result?.dispatcher) {\n      return result.dispatcher\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, result] of Array.from(this[kClients])) {\n      if (result && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = result.dispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, result]) => result.dispatcher[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    throw new UndiciError(\n      pending.length === 1\n        ? `1 interceptor is pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n        : `${pending.length} interceptors are pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n    )\n  }\n}\n\nmodule.exports = MockAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGdGQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3RDLFFBQVEsa0ZBQWtGLEVBQUUsbUJBQU8sQ0FBQyx3RUFBYztBQUNsSCxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3RFLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEwQjtBQUNyRCxxQ0FBcUMsbUJBQU8sQ0FBQyxnSEFBa0M7QUFDL0UsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHNGQUFxQjs7QUFFekQ7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUssR0FBRyx1QkFBdUI7QUFDNUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDs7QUFFQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1RkFBdUYscUJBQXFCO0FBQzVHLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBLGlDQUFpQyxvRUFBb0UsSUFBSTtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkYsYUFBYSxnQkFBZ0IsK0JBQStCLDZDQUE2QztBQUN6RztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLWFnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDbGllbnRzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2FnZW50JylcbmNvbnN0IHtcbiAga0FnZW50LFxuICBrTW9ja0FnZW50U2V0LFxuICBrTW9ja0FnZW50R2V0LFxuICBrRGlzcGF0Y2hlcyxcbiAga0lzTW9ja0FjdGl2ZSxcbiAga05ldENvbm5lY3QsXG4gIGtHZXROZXRDb25uZWN0LFxuICBrT3B0aW9ucyxcbiAga0ZhY3RvcnksXG4gIGtNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5LFxuICBrTW9ja0FnZW50SXNDYWxsSGlzdG9yeUVuYWJsZWQsXG4gIGtNb2NrQWdlbnRBZGRDYWxsSGlzdG9yeUxvZyxcbiAga01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlLFxuICBrTW9ja0FnZW50QWNjZXB0c05vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycyxcbiAga01vY2tDYWxsSGlzdG9yeUFkZExvZyxcbiAga0lnbm9yZVRyYWlsaW5nU2xhc2hcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCBNb2NrQ2xpZW50ID0gcmVxdWlyZSgnLi9tb2NrLWNsaWVudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbW9jay1wb29sJylcbmNvbnN0IHsgbWF0Y2hWYWx1ZSwgbm9ybWFsaXplU2VhcmNoUGFyYW1zLCBidWlsZEFuZFZhbGlkYXRlTW9ja09wdGlvbnMsIG5vcm1hbGl6ZU9yaWdpbiB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyJylcbmNvbnN0IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlcicpXG5jb25zdCB7IE1vY2tDYWxsSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9tb2NrLWNhbGwtaGlzdG9yeScpXG5cbmNsYXNzIE1vY2tBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIGNvbnN0IG1vY2tPcHRpb25zID0gYnVpbGRBbmRWYWxpZGF0ZU1vY2tPcHRpb25zKG9wdHMpXG5cbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuICAgIHRoaXNba01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkXSA9IG1vY2tPcHRpb25zLmVuYWJsZUNhbGxIaXN0b3J5ID8/IGZhbHNlXG4gICAgdGhpc1trTW9ja0FnZW50QWNjZXB0c05vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVyc10gPSBtb2NrT3B0aW9ucy5hY2NlcHROb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnMgPz8gZmFsc2VcbiAgICB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSA9IG1vY2tPcHRpb25zLmlnbm9yZVRyYWlsaW5nU2xhc2ggPz8gZmFsc2VcblxuICAgIC8vIEluc3RhbnRpYXRlIEFnZW50IGFuZCBlbmNhcHN1bGF0ZVxuICAgIGlmIChvcHRzPy5hZ2VudCAmJiB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG4gICAgY29uc3QgYWdlbnQgPSBvcHRzPy5hZ2VudCA/IG9wdHMuYWdlbnQgOiBuZXcgQWdlbnQob3B0cylcbiAgICB0aGlzW2tBZ2VudF0gPSBhZ2VudFxuXG4gICAgdGhpc1trQ2xpZW50c10gPSBhZ2VudFtrQ2xpZW50c11cbiAgICB0aGlzW2tPcHRpb25zXSA9IG1vY2tPcHRpb25zXG5cbiAgICBpZiAodGhpc1trTW9ja0FnZW50SXNDYWxsSGlzdG9yeUVuYWJsZWRdKSB7XG4gICAgICB0aGlzW2tNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5XSgpXG4gICAgfVxuICB9XG5cbiAgZ2V0IChvcmlnaW4pIHtcbiAgICAvLyBOb3JtYWxpemUgb3JpZ2luIHRvIGhhbmRsZSBVUkwgb2JqZWN0cyBhbmQgY2FzZS1pbnNlbnNpdGl2ZSBob3N0bmFtZXNcbiAgICBjb25zdCBub3JtYWxpemVkT3JpZ2luID0gbm9ybWFsaXplT3JpZ2luKG9yaWdpbilcbiAgICBjb25zdCBvcmlnaW5LZXkgPSB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSA/IG5vcm1hbGl6ZWRPcmlnaW4ucmVwbGFjZSgvXFwvJC8sICcnKSA6IG5vcm1hbGl6ZWRPcmlnaW5cblxuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW5LZXkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW5LZXkpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbktleSwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgb3B0cy5vcmlnaW4gPSBub3JtYWxpemVPcmlnaW4ob3B0cy5vcmlnaW4pXG5cbiAgICAvLyBDYWxsIE1vY2tBZ2VudC5nZXQgdG8gcGVyZm9ybSBhZGRpdGlvbmFsIHNldHVwIGJlZm9yZSBkaXNwYXRjaGluZyBhcyBub3JtYWxcbiAgICB0aGlzLmdldChvcHRzLm9yaWdpbilcblxuICAgIHRoaXNba01vY2tBZ2VudEFkZENhbGxIaXN0b3J5TG9nXShvcHRzKVxuXG4gICAgY29uc3QgYWNjZXB0Tm9uU3RhbmRhcmRTZWFyY2hQYXJhbWV0ZXJzID0gdGhpc1trTW9ja0FnZW50QWNjZXB0c05vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVyc11cblxuICAgIGNvbnN0IGRpc3BhdGNoT3B0cyA9IHsgLi4ub3B0cyB9XG5cbiAgICBpZiAoYWNjZXB0Tm9uU3RhbmRhcmRTZWFyY2hQYXJhbWV0ZXJzICYmIGRpc3BhdGNoT3B0cy5wYXRoKSB7XG4gICAgICBjb25zdCBbcGF0aCwgc2VhcmNoUGFyYW1zXSA9IGRpc3BhdGNoT3B0cy5wYXRoLnNwbGl0KCc/JylcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWFyY2hQYXJhbXMgPSBub3JtYWxpemVTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zLCBhY2NlcHROb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnMpXG4gICAgICBkaXNwYXRjaE9wdHMucGF0aCA9IGAke3BhdGh9PyR7bm9ybWFsaXplZFNlYXJjaFBhcmFtc31gXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChkaXNwYXRjaE9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgdGhpcy5jbGVhckNhbGxIaXN0b3J5KClcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcbiAgfVxuXG4gIGRlYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSBmYWxzZVxuICB9XG5cbiAgYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlXG4gIH1cblxuICBlbmFibGVOZXRDb25uZWN0IChtYXRjaGVyKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJyB8fCBtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzW2tOZXRDb25uZWN0XSkpIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0ucHVzaChtYXRjaGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSBbbWF0Y2hlcl1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignVW5zdXBwb3J0ZWQgbWF0Y2hlci4gTXVzdCBiZSBvbmUgb2YgU3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cC4nKVxuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVOZXRDb25uZWN0ICgpIHtcbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IGZhbHNlXG4gIH1cblxuICBlbmFibGVDYWxsSGlzdG9yeSAoKSB7XG4gICAgdGhpc1trTW9ja0FnZW50SXNDYWxsSGlzdG9yeUVuYWJsZWRdID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRpc2FibGVDYWxsSGlzdG9yeSAoKSB7XG4gICAgdGhpc1trTW9ja0FnZW50SXNDYWxsSGlzdG9yeUVuYWJsZWRdID0gZmFsc2VcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRDYWxsSGlzdG9yeSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlXVxuICB9XG5cbiAgY2xlYXJDYWxsSGlzdG9yeSAoKSB7XG4gICAgaWYgKHRoaXNba01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzW2tNb2NrQWdlbnRNb2NrQ2FsbEhpc3RvcnlJbnN0YW5jZV0uY2xlYXIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYnlwYXNzIGlzc3VlcyBjYXVzZWQgYnkgdXNpbmcgZ2xvYmFsIHN5bWJvbHMgLSBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNDQ3XG4gIGdldCBpc01vY2tBY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzW2tJc01vY2tBY3RpdmVdXG4gIH1cblxuICBba01vY2tBZ2VudFJlZ2lzdGVyQ2FsbEhpc3RvcnldICgpIHtcbiAgICBpZiAodGhpc1trTW9ja0FnZW50TW9ja0NhbGxIaXN0b3J5SW5zdGFuY2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXNba01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlXSA9IG5ldyBNb2NrQ2FsbEhpc3RvcnkoKVxuICAgIH1cbiAgfVxuXG4gIFtrTW9ja0FnZW50QWRkQ2FsbEhpc3RvcnlMb2ddIChvcHRzKSB7XG4gICAgaWYgKHRoaXNba01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkXSkge1xuICAgICAgLy8gYWRkaXRpb25hbCBzZXR1cCB3aGVuIGVuYWJsZUNhbGxIaXN0b3J5IGNsYXNzIG1ldGhvZCBpcyB1c2VkIGFmdGVyIG1vY2tBZ2VudCBpbnN0YW50aWF0aW9uXG4gICAgICB0aGlzW2tNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5XSgpXG5cbiAgICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgbG9nIG9uIGV2ZXJ5IGNhbGwgKGludGVyY2VwdGVkIG9yIG5vdClcbiAgICAgIHRoaXNba01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlXVtrTW9ja0NhbGxIaXN0b3J5QWRkTG9nXShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIFtrTW9ja0FnZW50U2V0XSAob3JpZ2luLCBkaXNwYXRjaGVyKSB7XG4gICAgdGhpc1trQ2xpZW50c10uc2V0KG9yaWdpbiwgeyBjb3VudDogMCwgZGlzcGF0Y2hlciB9KVxuICB9XG5cbiAgW2tGYWN0b3J5XSAob3JpZ2luKSB7XG4gICAgY29uc3QgbW9ja09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWdlbnQ6IHRoaXMgfSwgdGhpc1trT3B0aW9uc10pXG4gICAgcmV0dXJuIHRoaXNba09wdGlvbnNdICYmIHRoaXNba09wdGlvbnNdLmNvbm5lY3Rpb25zID09PSAxXG4gICAgICA/IG5ldyBNb2NrQ2xpZW50KG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gICAgICA6IG5ldyBNb2NrUG9vbChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICB9XG5cbiAgW2tNb2NrQWdlbnRHZXRdIChvcmlnaW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgZmluZCBpdFxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNba0NsaWVudHNdLmdldChvcmlnaW4pXG4gICAgaWYgKHJlc3VsdD8uZGlzcGF0Y2hlcikge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9yaWdpbiBpcyBub3QgYSBzdHJpbmcgY3JlYXRlIGEgZHVtbXkgcGFyZW50IHBvb2wgYW5kIHJldHVybiB0byB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0oJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OScpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgbWF0Y2gsIGNyZWF0ZSBhIHBvb2wgYW5kIGFzc2lnbiB0aGUgc2FtZSBkaXNwYXRjaGVzXG4gICAgZm9yIChjb25zdCBba2V5TWF0Y2hlciwgcmVzdWx0XSBvZiBBcnJheS5mcm9tKHRoaXNba0NsaWVudHNdKSkge1xuICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2Yga2V5TWF0Y2hlciAhPT0gJ3N0cmluZycgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IHJlc3VsdC5kaXNwYXRjaGVyW2tEaXNwYXRjaGVzXVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtrR2V0TmV0Q29ubmVjdF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tOZXRDb25uZWN0XVxuICB9XG5cbiAgcGVuZGluZ0ludGVyY2VwdG9ycyAoKSB7XG4gICAgY29uc3QgbW9ja0FnZW50Q2xpZW50cyA9IHRoaXNba0NsaWVudHNdXG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShtb2NrQWdlbnRDbGllbnRzLmVudHJpZXMoKSlcbiAgICAgIC5mbGF0TWFwKChbb3JpZ2luLCByZXN1bHRdKSA9PiByZXN1bHQuZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc10ubWFwKGRpc3BhdGNoID0+ICh7IC4uLmRpc3BhdGNoLCBvcmlnaW4gfSkpKVxuICAgICAgLmZpbHRlcigoeyBwZW5kaW5nIH0pID0+IHBlbmRpbmcpXG4gIH1cblxuICBhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMgKHsgcGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IG5ldyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyKCkgfSA9IHt9KSB7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ0ludGVyY2VwdG9ycygpXG5cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRocm93IG5ldyBVbmRpY2lFcnJvcihcbiAgICAgIHBlbmRpbmcubGVuZ3RoID09PSAxXG4gICAgICAgID8gYDEgaW50ZXJjZXB0b3IgaXMgcGVuZGluZzpcXG5cXG4ke3BlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIuZm9ybWF0KHBlbmRpbmcpfWAudHJpbSgpXG4gICAgICAgIDogYCR7cGVuZGluZy5sZW5ndGh9IGludGVyY2VwdG9ycyBhcmUgcGVuZGluZzpcXG5cXG4ke3BlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIuZm9ybWF0KHBlbmRpbmcpfWAudHJpbSgpXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0FnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-call-history.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-call-history.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kMockCallHistoryAddLog } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nfunction handleFilterCallsWithOptions (criteria, options, handler, store) {\n  switch (options.operator) {\n    case 'OR':\n      store.push(...handler(criteria))\n\n      return store\n    case 'AND':\n      return handler.call({ logs: store }, criteria)\n    default:\n      // guard -- should never happens because buildAndValidateFilterCallsOptions is called before\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n  }\n}\n\nfunction buildAndValidateFilterCallsOptions (options = {}) {\n  const finalOptions = {}\n\n  if ('operator' in options) {\n    if (typeof options.operator !== 'string' || (options.operator.toUpperCase() !== 'OR' && options.operator.toUpperCase() !== 'AND')) {\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n    }\n\n    return {\n      ...finalOptions,\n      operator: options.operator.toUpperCase()\n    }\n  }\n\n  return finalOptions\n}\n\nfunction makeFilterCalls (parameterName) {\n  return (parameterValue) => {\n    if (typeof parameterValue === 'string' || parameterValue == null) {\n      return this.logs.filter((log) => {\n        return log[parameterName] === parameterValue\n      })\n    }\n    if (parameterValue instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return parameterValue.test(log[parameterName])\n      })\n    }\n\n    throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`)\n  }\n}\nfunction computeUrlWithMaybeSearchParameters (requestInit) {\n  // path can contains query url parameters\n  // or query can contains query url parameters\n  try {\n    const url = new URL(requestInit.path, requestInit.origin)\n\n    // requestInit.path contains query url parameters\n    // requestInit.query is then undefined\n    if (url.search.length !== 0) {\n      return url\n    }\n\n    // requestInit.query can be populated here\n    url.search = new URLSearchParams(requestInit.query).toString()\n\n    return url\n  } catch (error) {\n    throw new InvalidArgumentError('An error occurred when computing MockCallHistoryLog.url', { cause: error })\n  }\n}\n\nclass MockCallHistoryLog {\n  constructor (requestInit = {}) {\n    this.body = requestInit.body\n    this.headers = requestInit.headers\n    this.method = requestInit.method\n\n    const url = computeUrlWithMaybeSearchParameters(requestInit)\n\n    this.fullUrl = url.toString()\n    this.origin = url.origin\n    this.path = url.pathname\n    this.searchParams = Object.fromEntries(url.searchParams)\n    this.protocol = url.protocol\n    this.host = url.host\n    this.port = url.port\n    this.hash = url.hash\n  }\n\n  toMap () {\n    return new Map([\n      ['protocol', this.protocol],\n      ['host', this.host],\n      ['port', this.port],\n      ['origin', this.origin],\n      ['path', this.path],\n      ['hash', this.hash],\n      ['searchParams', this.searchParams],\n      ['fullUrl', this.fullUrl],\n      ['method', this.method],\n      ['body', this.body],\n      ['headers', this.headers]]\n    )\n  }\n\n  toString () {\n    const options = { betweenKeyValueSeparator: '->', betweenPairSeparator: '|' }\n    let result = ''\n\n    this.toMap().forEach((value, key) => {\n      if (typeof value === 'string' || value === undefined || value === null) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`\n      }\n      if ((typeof value === 'object' && value !== null) || Array.isArray(value)) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`\n      }\n      // maybe miss something for non Record / Array headers and searchParams here\n    })\n\n    // delete last betweenPairSeparator\n    return result.slice(0, -1)\n  }\n}\n\nclass MockCallHistory {\n  logs = []\n\n  calls () {\n    return this.logs\n  }\n\n  firstCall () {\n    return this.logs.at(0)\n  }\n\n  lastCall () {\n    return this.logs.at(-1)\n  }\n\n  nthCall (number) {\n    if (typeof number !== 'number') {\n      throw new InvalidArgumentError('nthCall must be called with a number')\n    }\n    if (!Number.isInteger(number)) {\n      throw new InvalidArgumentError('nthCall must be called with an integer')\n    }\n    if (Math.sign(number) !== 1) {\n      throw new InvalidArgumentError('nthCall must be called with a positive value. use firstCall or lastCall instead')\n    }\n\n    // non zero based index. this is more human readable\n    return this.logs.at(number - 1)\n  }\n\n  filterCalls (criteria, options) {\n    // perf\n    if (this.logs.length === 0) {\n      return this.logs\n    }\n    if (typeof criteria === 'function') {\n      return this.logs.filter(criteria)\n    }\n    if (criteria instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return criteria.test(log.toString())\n      })\n    }\n    if (typeof criteria === 'object' && criteria !== null) {\n      // no criteria - returning all logs\n      if (Object.keys(criteria).length === 0) {\n        return this.logs\n      }\n\n      const finalOptions = { operator: 'OR', ...buildAndValidateFilterCallsOptions(options) }\n\n      let maybeDuplicatedLogsFiltered = []\n      if ('protocol' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered)\n      }\n      if ('host' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered)\n      }\n      if ('port' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered)\n      }\n      if ('origin' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered)\n      }\n      if ('path' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered)\n      }\n      if ('hash' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered)\n      }\n      if ('fullUrl' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered)\n      }\n      if ('method' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered)\n      }\n\n      const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)]\n\n      return uniqLogsFiltered\n    }\n\n    throw new InvalidArgumentError('criteria parameter should be one of function, regexp, or object')\n  }\n\n  filterCallsByProtocol = makeFilterCalls.call(this, 'protocol')\n\n  filterCallsByHost = makeFilterCalls.call(this, 'host')\n\n  filterCallsByPort = makeFilterCalls.call(this, 'port')\n\n  filterCallsByOrigin = makeFilterCalls.call(this, 'origin')\n\n  filterCallsByPath = makeFilterCalls.call(this, 'path')\n\n  filterCallsByHash = makeFilterCalls.call(this, 'hash')\n\n  filterCallsByFullUrl = makeFilterCalls.call(this, 'fullUrl')\n\n  filterCallsByMethod = makeFilterCalls.call(this, 'method')\n\n  clear () {\n    this.logs = []\n  }\n\n  [kMockCallHistoryAddLog] (requestInit) {\n    const log = new MockCallHistoryLog(requestInit)\n\n    this.logs.push(log)\n\n    return log\n  }\n\n  * [Symbol.iterator] () {\n    for (const log of this.calls()) {\n      yield log\n    }\n  }\n}\n\nmodule.exports.MockCallHistory = MockCallHistory\nmodule.exports.MockCallHistoryLog = MockCallHistoryLog\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2FsbC1oaXN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDM0QsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixnR0FBZ0csY0FBYztBQUM5RztBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLElBQUksRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLEVBQUUsNkJBQTZCO0FBQzNHO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLElBQUksRUFBRSxpQ0FBaUMsRUFBRSxzQkFBc0IsRUFBRSw2QkFBNkI7QUFDM0g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLGlDQUFpQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stY2FsbC1oaXN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtNb2NrQ2FsbEhpc3RvcnlBZGRMb2cgfSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyAoY3JpdGVyaWEsIG9wdGlvbnMsIGhhbmRsZXIsIHN0b3JlKSB7XG4gIHN3aXRjaCAob3B0aW9ucy5vcGVyYXRvcikge1xuICAgIGNhc2UgJ09SJzpcbiAgICAgIHN0b3JlLnB1c2goLi4uaGFuZGxlcihjcml0ZXJpYSkpXG5cbiAgICAgIHJldHVybiBzdG9yZVxuICAgIGNhc2UgJ0FORCc6XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHsgbG9nczogc3RvcmUgfSwgY3JpdGVyaWEpXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGd1YXJkIC0tIHNob3VsZCBuZXZlciBoYXBwZW5zIGJlY2F1c2UgYnVpbGRBbmRWYWxpZGF0ZUZpbHRlckNhbGxzT3B0aW9ucyBpcyBjYWxsZWQgYmVmb3JlXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdGlvbnMub3BlcmF0b3IgbXVzdCB0byBiZSBhIGNhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIGVxdWFsIHRvIFxcJ09SXFwnIG9yIFxcJ0FORFxcJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRBbmRWYWxpZGF0ZUZpbHRlckNhbGxzT3B0aW9ucyAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHt9XG5cbiAgaWYgKCdvcGVyYXRvcicgaW4gb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcGVyYXRvciAhPT0gJ3N0cmluZycgfHwgKG9wdGlvbnMub3BlcmF0b3IudG9VcHBlckNhc2UoKSAhPT0gJ09SJyAmJiBvcHRpb25zLm9wZXJhdG9yLnRvVXBwZXJDYXNlKCkgIT09ICdBTkQnKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRpb25zLm9wZXJhdG9yIG11c3QgdG8gYmUgYSBjYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBlcXVhbCB0byBcXCdPUlxcJyBvciBcXCdBTkRcXCcnKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5maW5hbE9wdGlvbnMsXG4gICAgICBvcGVyYXRvcjogb3B0aW9ucy5vcGVyYXRvci50b1VwcGVyQ2FzZSgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsT3B0aW9uc1xufVxuXG5mdW5jdGlvbiBtYWtlRmlsdGVyQ2FsbHMgKHBhcmFtZXRlck5hbWUpIHtcbiAgcmV0dXJuIChwYXJhbWV0ZXJWYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyVmFsdWUgPT09ICdzdHJpbmcnIHx8IHBhcmFtZXRlclZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ3MuZmlsdGVyKChsb2cpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvZ1twYXJhbWV0ZXJOYW1lXSA9PT0gcGFyYW1ldGVyVmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXJWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoKGxvZykgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVyVmFsdWUudGVzdChsb2dbcGFyYW1ldGVyTmFtZV0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgJHtwYXJhbWV0ZXJOYW1lfSBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9uZSBvZiBzdHJpbmcsIHJlZ2V4cCwgdW5kZWZpbmVkIG9yIG51bGxgKVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlVXJsV2l0aE1heWJlU2VhcmNoUGFyYW1ldGVycyAocmVxdWVzdEluaXQpIHtcbiAgLy8gcGF0aCBjYW4gY29udGFpbnMgcXVlcnkgdXJsIHBhcmFtZXRlcnNcbiAgLy8gb3IgcXVlcnkgY2FuIGNvbnRhaW5zIHF1ZXJ5IHVybCBwYXJhbWV0ZXJzXG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0SW5pdC5wYXRoLCByZXF1ZXN0SW5pdC5vcmlnaW4pXG5cbiAgICAvLyByZXF1ZXN0SW5pdC5wYXRoIGNvbnRhaW5zIHF1ZXJ5IHVybCBwYXJhbWV0ZXJzXG4gICAgLy8gcmVxdWVzdEluaXQucXVlcnkgaXMgdGhlbiB1bmRlZmluZWRcbiAgICBpZiAodXJsLnNlYXJjaC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0SW5pdC5xdWVyeSBjYW4gYmUgcG9wdWxhdGVkIGhlcmVcbiAgICB1cmwuc2VhcmNoID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXF1ZXN0SW5pdC5xdWVyeSkudG9TdHJpbmcoKVxuXG4gICAgcmV0dXJuIHVybFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBjb21wdXRpbmcgTW9ja0NhbGxIaXN0b3J5TG9nLnVybCcsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cbn1cblxuY2xhc3MgTW9ja0NhbGxIaXN0b3J5TG9nIHtcbiAgY29uc3RydWN0b3IgKHJlcXVlc3RJbml0ID0ge30pIHtcbiAgICB0aGlzLmJvZHkgPSByZXF1ZXN0SW5pdC5ib2R5XG4gICAgdGhpcy5oZWFkZXJzID0gcmVxdWVzdEluaXQuaGVhZGVyc1xuICAgIHRoaXMubWV0aG9kID0gcmVxdWVzdEluaXQubWV0aG9kXG5cbiAgICBjb25zdCB1cmwgPSBjb21wdXRlVXJsV2l0aE1heWJlU2VhcmNoUGFyYW1ldGVycyhyZXF1ZXN0SW5pdClcblxuICAgIHRoaXMuZnVsbFVybCA9IHVybC50b1N0cmluZygpXG4gICAgdGhpcy5vcmlnaW4gPSB1cmwub3JpZ2luXG4gICAgdGhpcy5wYXRoID0gdXJsLnBhdGhuYW1lXG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcylcbiAgICB0aGlzLnByb3RvY29sID0gdXJsLnByb3RvY29sXG4gICAgdGhpcy5ob3N0ID0gdXJsLmhvc3RcbiAgICB0aGlzLnBvcnQgPSB1cmwucG9ydFxuICAgIHRoaXMuaGFzaCA9IHVybC5oYXNoXG4gIH1cblxuICB0b01hcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoW1xuICAgICAgWydwcm90b2NvbCcsIHRoaXMucHJvdG9jb2xdLFxuICAgICAgWydob3N0JywgdGhpcy5ob3N0XSxcbiAgICAgIFsncG9ydCcsIHRoaXMucG9ydF0sXG4gICAgICBbJ29yaWdpbicsIHRoaXMub3JpZ2luXSxcbiAgICAgIFsncGF0aCcsIHRoaXMucGF0aF0sXG4gICAgICBbJ2hhc2gnLCB0aGlzLmhhc2hdLFxuICAgICAgWydzZWFyY2hQYXJhbXMnLCB0aGlzLnNlYXJjaFBhcmFtc10sXG4gICAgICBbJ2Z1bGxVcmwnLCB0aGlzLmZ1bGxVcmxdLFxuICAgICAgWydtZXRob2QnLCB0aGlzLm1ldGhvZF0sXG4gICAgICBbJ2JvZHknLCB0aGlzLmJvZHldLFxuICAgICAgWydoZWFkZXJzJywgdGhpcy5oZWFkZXJzXV1cbiAgICApXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgYmV0d2VlbktleVZhbHVlU2VwYXJhdG9yOiAnLT4nLCBiZXR3ZWVuUGFpclNlcGFyYXRvcjogJ3wnIH1cbiAgICBsZXQgcmVzdWx0ID0gJydcblxuICAgIHRoaXMudG9NYXAoKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0ke2tleX0ke29wdGlvbnMuYmV0d2VlbktleVZhbHVlU2VwYXJhdG9yfSR7dmFsdWV9JHtvcHRpb25zLmJldHdlZW5QYWlyU2VwYXJhdG9yfWBcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSR7a2V5fSR7b3B0aW9ucy5iZXR3ZWVuS2V5VmFsdWVTZXBhcmF0b3J9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9JHtvcHRpb25zLmJldHdlZW5QYWlyU2VwYXJhdG9yfWBcbiAgICAgIH1cbiAgICAgIC8vIG1heWJlIG1pc3Mgc29tZXRoaW5nIGZvciBub24gUmVjb3JkIC8gQXJyYXkgaGVhZGVycyBhbmQgc2VhcmNoUGFyYW1zIGhlcmVcbiAgICB9KVxuXG4gICAgLy8gZGVsZXRlIGxhc3QgYmV0d2VlblBhaXJTZXBhcmF0b3JcbiAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIC0xKVxuICB9XG59XG5cbmNsYXNzIE1vY2tDYWxsSGlzdG9yeSB7XG4gIGxvZ3MgPSBbXVxuXG4gIGNhbGxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzXG4gIH1cblxuICBmaXJzdENhbGwgKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ3MuYXQoMClcbiAgfVxuXG4gIGxhc3RDYWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzLmF0KC0xKVxuICB9XG5cbiAgbnRoQ2FsbCAobnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIG51bWJlcicpXG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBpbnRlZ2VyJylcbiAgICB9XG4gICAgaWYgKE1hdGguc2lnbihudW1iZXIpICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLiB1c2UgZmlyc3RDYWxsIG9yIGxhc3RDYWxsIGluc3RlYWQnKVxuICAgIH1cblxuICAgIC8vIG5vbiB6ZXJvIGJhc2VkIGluZGV4LiB0aGlzIGlzIG1vcmUgaHVtYW4gcmVhZGFibGVcbiAgICByZXR1cm4gdGhpcy5sb2dzLmF0KG51bWJlciAtIDEpXG4gIH1cblxuICBmaWx0ZXJDYWxscyAoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICAvLyBwZXJmXG4gICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ3NcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcml0ZXJpYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoY3JpdGVyaWEpXG4gICAgfVxuICAgIGlmIChjcml0ZXJpYSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoKGxvZykgPT4ge1xuICAgICAgICByZXR1cm4gY3JpdGVyaWEudGVzdChsb2cudG9TdHJpbmcoKSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JpdGVyaWEgPT09ICdvYmplY3QnICYmIGNyaXRlcmlhICE9PSBudWxsKSB7XG4gICAgICAvLyBubyBjcml0ZXJpYSAtIHJldHVybmluZyBhbGwgbG9nc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGNyaXRlcmlhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nc1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7IG9wZXJhdG9yOiAnT1InLCAuLi5idWlsZEFuZFZhbGlkYXRlRmlsdGVyQ2FsbHNPcHRpb25zKG9wdGlvbnMpIH1cblxuICAgICAgbGV0IG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IFtdXG4gICAgICBpZiAoJ3Byb3RvY29sJyBpbiBjcml0ZXJpYSkge1xuICAgICAgICBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQgPSBoYW5kbGVGaWx0ZXJDYWxsc1dpdGhPcHRpb25zKGNyaXRlcmlhLnByb3RvY29sLCBmaW5hbE9wdGlvbnMsIHRoaXMuZmlsdGVyQ2FsbHNCeVByb3RvY29sLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2hvc3QnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuaG9zdCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlIb3N0LCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ3BvcnQnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEucG9ydCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlQb3J0LCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ29yaWdpbicgaW4gY3JpdGVyaWEpIHtcbiAgICAgICAgbWF5YmVEdXBsaWNhdGVkTG9nc0ZpbHRlcmVkID0gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyhjcml0ZXJpYS5vcmlnaW4sIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJDYWxsc0J5T3JpZ2luLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ3BhdGgnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEucGF0aCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlQYXRoLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2hhc2gnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuaGFzaCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlIYXNoLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2Z1bGxVcmwnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuZnVsbFVybCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlGdWxsVXJsLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ21ldGhvZCcgaW4gY3JpdGVyaWEpIHtcbiAgICAgICAgbWF5YmVEdXBsaWNhdGVkTG9nc0ZpbHRlcmVkID0gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyhjcml0ZXJpYS5tZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJDYWxsc0J5TWV0aG9kLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXFMb2dzRmlsdGVyZWQgPSBbLi4ubmV3IFNldChtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXVxuXG4gICAgICByZXR1cm4gdW5pcUxvZ3NGaWx0ZXJlZFxuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY3JpdGVyaWEgcGFyYW1ldGVyIHNob3VsZCBiZSBvbmUgb2YgZnVuY3Rpb24sIHJlZ2V4cCwgb3Igb2JqZWN0JylcbiAgfVxuXG4gIGZpbHRlckNhbGxzQnlQcm90b2NvbCA9IG1ha2VGaWx0ZXJDYWxscy5jYWxsKHRoaXMsICdwcm90b2NvbCcpXG5cbiAgZmlsdGVyQ2FsbHNCeUhvc3QgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAnaG9zdCcpXG5cbiAgZmlsdGVyQ2FsbHNCeVBvcnQgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAncG9ydCcpXG5cbiAgZmlsdGVyQ2FsbHNCeU9yaWdpbiA9IG1ha2VGaWx0ZXJDYWxscy5jYWxsKHRoaXMsICdvcmlnaW4nKVxuXG4gIGZpbHRlckNhbGxzQnlQYXRoID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ3BhdGgnKVxuXG4gIGZpbHRlckNhbGxzQnlIYXNoID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ2hhc2gnKVxuXG4gIGZpbHRlckNhbGxzQnlGdWxsVXJsID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ2Z1bGxVcmwnKVxuXG4gIGZpbHRlckNhbGxzQnlNZXRob2QgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAnbWV0aG9kJylcblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5sb2dzID0gW11cbiAgfVxuXG4gIFtrTW9ja0NhbGxIaXN0b3J5QWRkTG9nXSAocmVxdWVzdEluaXQpIHtcbiAgICBjb25zdCBsb2cgPSBuZXcgTW9ja0NhbGxIaXN0b3J5TG9nKHJlcXVlc3RJbml0KVxuXG4gICAgdGhpcy5sb2dzLnB1c2gobG9nKVxuXG4gICAgcmV0dXJuIGxvZ1xuICB9XG5cbiAgKiBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgZm9yIChjb25zdCBsb2cgb2YgdGhpcy5jYWxscygpKSB7XG4gICAgICB5aWVsZCBsb2dcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuTW9ja0NhbGxIaXN0b3J5ID0gTW9ja0NhbGxIaXN0b3J5XG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2FsbEhpc3RvcnlMb2cgPSBNb2NrQ2FsbEhpc3RvcnlMb2dcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtGQUFzQjtBQUM3QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3pDLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUEwRDtBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvY2xpZW50JylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZCxcbiAga0lnbm9yZVRyYWlsaW5nU2xhc2hcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tDbGllbnQgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgQ2xpZW50IHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tDbGllbnQgZXh0ZW5kcyBDbGllbnQge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdID0gb3B0cy5pZ25vcmVUcmFpbGluZ1NsYXNoID8/IGZhbHNlXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKFxuICAgICAgb3B0cyAmJiB7IGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdLCAuLi5vcHRzIH0sXG4gICAgICB0aGlzW2tEaXNwYXRjaGVzXVxuICAgIClcbiAgfVxuXG4gIGNsZWFuTW9ja3MgKCkge1xuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQ2xpZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kMockNotMatchedError = Symbol.for('undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED')\n\n/**\n * The request does not match any registered mock dispatches.\n */\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kMockNotMatchedError] === true\n  }\n\n  get [kMockNotMatchedError] () {\n    return true\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga01vY2tOb3RNYXRjaGVkRXJyb3IgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZXJyb3IuVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnKVxuXG4vKipcbiAqIFRoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja05vdE1hdGNoZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdNb2NrTm90TWF0Y2hlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcydcbiAgICB0aGlzLmNvZGUgPSAnVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW2tNb2NrTm90TWF0Y2hlZEVycm9yXSA9PT0gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtrTW9ja05vdE1hdGNoZWRFcnJvcl0gKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1vY2tOb3RNYXRjaGVkRXJyb3Jcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = serializePathWithQuery(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData ({ statusCode, data, responseOptions }) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (replyParameters) {\n    if (typeof replyParameters.statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyOptionsCallbackOrStatusCode) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyOptionsCallbackOrStatusCode(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object' || resolvedData === null) {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const replyParameters = { data: '', responseOptions: {}, ...resolvedData }\n        this.validateReplyParameters(replyParameters)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(replyParameters)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const replyParameters = {\n      statusCode: replyOptionsCallbackOrStatusCode,\n      data: arguments[1] === undefined ? '' : arguments[1],\n      responseOptions: arguments[2] === undefined ? {} : arguments[2]\n    }\n    this.validateReplyParameters(replyParameters)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(replyParameters)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUIsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN6RCxRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBLG1EQUFtRCx3Q0FBd0M7QUFDM0Ysc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdIQUFnSCxpREFBaUQ7QUFDaks7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtR0FBbUcsaURBQWlEO0FBQ3BKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU8sSUFBSSxpREFBaUQ7QUFDako7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2staW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga0Rpc3BhdGNoS2V5LFxuICBrRGVmYXVsdEhlYWRlcnMsXG4gIGtEZWZhdWx0VHJhaWxlcnMsXG4gIGtDb250ZW50TGVuZ3RoLFxuICBrTW9ja0Rpc3BhdGNoLFxuICBrSWdub3JlVHJhaWxpbmdTbGFzaFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgc2VyaWFsaXplUGF0aFdpdGhRdWVyeSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzY29wZSBBUEkgZm9yIGFuIGludGVyY2VwdG9yIHJlcGx5XG4gKi9cbmNsYXNzIE1vY2tTY29wZSB7XG4gIGNvbnN0cnVjdG9yIChtb2NrRGlzcGF0Y2gpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdID0gbW9ja0Rpc3BhdGNoXG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgYSByZXBseSBieSBhIHNldCBhbW91bnQgaW4gbXMuXG4gICAqL1xuICBkZWxheSAod2FpdEluTXMpIHtcbiAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih3YWl0SW5NcykgfHwgd2FpdEluTXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5Nc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZGVmaW5lZCByZXBseSwgbmV2ZXIgbWFyayBhcyBjb25zdW1lZC5cbiAgICovXG4gIHBlcnNpc3QgKCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG9uZSB0byBkZWZpbmUgYSByZXBseSBmb3IgYSBzZXQgYW1vdW50IG9mIG1hdGNoaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgdGltZXMgKHJlcGVhdFRpbWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmNlcHRvciBmb3IgYSBNb2NrXG4gKi9cbmNsYXNzIE1vY2tJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMjQ1XG4gICAgLy8gQXMgcGVyIFJGQyAzOTg2LCBjbGllbnRzIGFyZSBub3Qgc3VwcG9zZWQgdG8gc2VuZCBVUklcbiAgICAvLyBmcmFnbWVudHMgdG8gc2VydmVycyB3aGVuIHRoZXkgcmV0cmlldmUgYSBkb2N1bWVudCxcbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5KSB7XG4gICAgICAgIG9wdHMucGF0aCA9IHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkob3B0cy5wYXRoLCBvcHRzLnF1ZXJ5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWF0Y2hlcyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iL21haW4vbGliL3dlYi9mZXRjaC9pbmRleC5qcyNMMTgxMVxuICAgICAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG9wdHMucGF0aCwgJ2RhdGE6Ly8nKVxuICAgICAgICBvcHRzLnBhdGggPSBwYXJzZWRVUkwucGF0aG5hbWUgKyBwYXJzZWRVUkwuc2VhcmNoXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICB9XG5cbiAgICB0aGlzW2tEaXNwYXRjaEtleV0gPSBidWlsZEtleShvcHRzKVxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gbW9ja0Rpc3BhdGNoZXNcbiAgICB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSA9IG9wdHMuaWdub3JlVHJhaWxpbmdTbGFzaCA/PyBmYWxzZVxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IHt9XG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHt9XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBmYWxzZVxuICB9XG5cbiAgY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhICh7IHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyAnY29udGVudC1sZW5ndGgnOiByZXNwb25zZURhdGEubGVuZ3RoIH0gOiB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfVxuICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfVxuICB9XG5cbiAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMgKHJlcGx5UGFyYW1ldGVycykge1xuICAgIGlmICh0eXBlb2YgcmVwbHlQYXJhbWV0ZXJzLnN0YXR1c0NvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3N0YXR1c0NvZGUgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zICE9PSAnb2JqZWN0JyB8fCByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Jlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgcmVwbHkuXG4gICAqL1xuICByZXBseSAocmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUpIHtcbiAgICAvLyBWYWx1ZXMgb2YgcmVwbHkgYXJlbid0IGF2YWlsYWJsZSByaWdodCBub3cgYXMgdGhleVxuICAgIC8vIGNhbiBvbmx5IGJlIGF2YWlsYWJsZSB3aGVuIHRoZSByZXBseSBjYWxsYmFjayBpcyBpbnZva2VkLlxuICAgIGlmICh0eXBlb2YgcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdlJ2xsIGZpcnN0IHdyYXAgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGluIGFub3RoZXIgZnVuY3Rpb24sXG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJvcGVybHkgcmVzb2x2ZSB0aGUgZGF0YSBmcm9tIHRoZSBjYWxsYmFja1xuICAgICAgLy8gd2hlbiBpbnZva2VkLlxuICAgICAgY29uc3Qgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2sgPSAob3B0cykgPT4ge1xuICAgICAgICAvLyBPdXIgcmVwbHkgb3B0aW9ucyBjYWxsYmFjayBjb250YWlucyB0aGUgcGFyYW1ldGVyIGZvciBzdGF0dXNDb2RlLCBkYXRhIGFuZCBvcHRpb25zLlxuICAgICAgICBjb25zdCByZXNvbHZlZERhdGEgPSByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZShvcHRzKVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09ICdvYmplY3QnIHx8IHJlc29sdmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0geyBkYXRhOiAnJywgcmVzcG9uc2VPcHRpb25zOiB7fSwgLi4ucmVzb2x2ZWREYXRhIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhyZXBseVBhcmFtZXRlcnMpXG4gICAgICAgIC8vIFNpbmNlIHRoZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGltbWVkaWF0ZWx5IHdlIHJldHVybiB0aGVtXG4gICAgICAgIC8vIGZyb20gdGhpcyBoaWdoZXIgb3JkZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJlc29sdmVkIGxhdGVyLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdXN1YWwgZGlzcGF0Y2ggZGF0YSwgYnV0IHRoaXMgdGltZSBzZXQgdGhlIGRhdGEgcGFyYW1ldGVyIHRvIGZ1bmN0aW9uIHRoYXQgd2lsbCBldmVudHVhbGx5IHByb3ZpZGUgZGF0YS5cbiAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjaywgeyBpZ25vcmVUcmFpbGluZ1NsYXNoOiB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSB9KVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0ge1xuICAgICAgc3RhdHVzQ29kZTogcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUsXG4gICAgICBkYXRhOiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzFdLFxuICAgICAgcmVzcG9uc2VPcHRpb25zOiBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdXG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMocmVwbHlQYXJhbWV0ZXJzKVxuXG4gICAgLy8gU2VuZCBpbi1hbHJlYWR5IHByb3ZpZGVkIGRhdGEgbGlrZSB1c3VhbFxuICAgIGNvbnN0IGRpc3BhdGNoRGF0YSA9IHRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhLCB7IGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdIH0pXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgZXJyb3IuXG4gICAqL1xuICByZXBseVdpdGhFcnJvciAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdlcnJvciBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB7IGVycm9yIH0sIHsgaWdub3JlVHJhaWxpbmdTbGFzaDogdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0gfSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgaGVhZGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5SGVhZGVycyAoaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IHRyYWlsZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlUcmFpbGVycyAodHJhaWxlcnMpIHtcbiAgICBpZiAodHlwZW9mIHRyYWlsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd0cmFpbGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB0cmFpbGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlcGx5IGNvbnRlbnQgbGVuZ3RoIGhlYWRlciBmb3IgcmVwbGllcyBvbiB0aGUgaW50ZXJjZXB0b3JcbiAgICovXG4gIHJlcGx5Q29udGVudExlbmd0aCAoKSB7XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3Jcbm1vZHVsZS5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDekMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFpQjtBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvcG9vbCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWQsXG4gIGtJZ25vcmVUcmFpbGluZ1NsYXNoXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrUG9vbCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBQb29sIHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tQb29sIGV4dGVuZHMgUG9vbCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0gPSBvcHRzLmlnbm9yZVRyYWlsaW5nU2xhc2ggPz8gZmFsc2VcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3IoXG4gICAgICBvcHRzICYmIHsgaWdub3JlVHJhaWxpbmdTbGFzaDogdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0sIC4uLm9wdHMgfSxcbiAgICAgIHRoaXNba0Rpc3BhdGNoZXNdXG4gICAgKVxuICB9XG5cbiAgY2xlYW5Nb2NrcyAoKSB7XG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOriginalDispatch: Symbol('original dispatch'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected'),\n  kIgnoreTrailingSlash: Symbol('ignore trailing slash'),\n  kMockAgentMockCallHistoryInstance: Symbol('mock agent mock call history name'),\n  kMockAgentRegisterCallHistory: Symbol('mock agent register mock call history'),\n  kMockAgentAddCallHistoryLog: Symbol('mock agent add call history log'),\n  kMockAgentIsCallHistoryEnabled: Symbol('mock agent is call history enabled'),\n  kMockAgentAcceptsNonStandardSearchParameters: Symbol('mock agent accepts non standard search parameters'),\n  kMockCallHistoryAddLog: Symbol('mock call history add log')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1zeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW5hbERpc3BhdGNoOiBTeW1ib2woJ29yaWdpbmFsIGRpc3BhdGNoJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtJZ25vcmVUcmFpbGluZ1NsYXNoOiBTeW1ib2woJ2lnbm9yZSB0cmFpbGluZyBzbGFzaCcpLFxuICBrTW9ja0FnZW50TW9ja0NhbGxIaXN0b3J5SW5zdGFuY2U6IFN5bWJvbCgnbW9jayBhZ2VudCBtb2NrIGNhbGwgaGlzdG9yeSBuYW1lJyksXG4gIGtNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5OiBTeW1ib2woJ21vY2sgYWdlbnQgcmVnaXN0ZXIgbW9jayBjYWxsIGhpc3RvcnknKSxcbiAga01vY2tBZ2VudEFkZENhbGxIaXN0b3J5TG9nOiBTeW1ib2woJ21vY2sgYWdlbnQgYWRkIGNhbGwgaGlzdG9yeSBsb2cnKSxcbiAga01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkOiBTeW1ib2woJ21vY2sgYWdlbnQgaXMgY2FsbCBoaXN0b3J5IGVuYWJsZWQnKSxcbiAga01vY2tBZ2VudEFjY2VwdHNOb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnM6IFN5bWJvbCgnbW9jayBhZ2VudCBhY2NlcHRzIG5vbiBzdGFuZGFyZCBzZWFyY2ggcGFyYW1ldGVycycpLFxuICBrTW9ja0NhbGxIaXN0b3J5QWRkTG9nOiBTeW1ib2woJ21vY2sgY2FsbCBoaXN0b3J5IGFkZCBsb2cnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst {\n  types: {\n    isPromise\n  }\n} = __webpack_require__(/*! node:util */ \"node:util\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction normalizeSearchParams (query) {\n  if (typeof query !== 'string') {\n    return query\n  }\n\n  const originalQp = new URLSearchParams(query)\n  const normalizedQp = new URLSearchParams()\n\n  for (let [key, value] of originalQp.entries()) {\n    key = key.replace('[]', '')\n\n    const valueRepresentsString = /^(['\"]).*\\1$/.test(value)\n    if (valueRepresentsString) {\n      normalizedQp.append(key, value)\n      continue\n    }\n\n    if (value.includes(',')) {\n      const values = value.split(',')\n      for (const v of values) {\n        normalizedQp.append(key, v)\n      }\n      continue\n    }\n\n    normalizedQp.append(key, value)\n  }\n\n  return normalizedQp\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n  const pathSegments = path.split('?', 3)\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else if (data) {\n    return data.toString()\n  } else {\n    return ''\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath)\n\n  // Match path\n  let matchedMockDispatches = mockDispatches\n    .filter(({ consumed }) => !consumed)\n    .filter(({ path, ignoreTrailingSlash }) => {\n      return ignoreTrailingSlash\n        ? matchValue(removeTrailingSlash(safeUrl(path)), resolvedPathWithoutTrailingSlash)\n        : matchValue(safeUrl(path), resolvedPath)\n    })\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data, opts) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\n/**\n * @param {string} path Path to remove trailing slash from\n */\nfunction removeTrailingSlash (path) {\n  while (path.endsWith('/')) {\n    path = path.slice(0, -1)\n  }\n\n  if (path.length === 0) {\n    path = '/'\n  }\n\n  return path\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Track whether the request has been aborted\n  let aborted = false\n  let timer = null\n\n  function abort (err) {\n    if (aborted) {\n      return\n    }\n    aborted = true\n\n    // Clear the pending delayed response if any\n    if (timer !== null) {\n      clearTimeout(timer)\n      timer = null\n    }\n\n    // Notify the handler of the abort\n    handler.onError(err)\n  }\n\n  // Call onConnect to allow the handler to register the abort callback\n  handler.onConnect?.(abort, null)\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    timer = setTimeout(() => {\n      timer = null\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // Don't send response if the request was aborted\n    if (aborted) {\n      return\n    }\n\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      return body.then((newData) => handleReply(mockDispatches, newData))\n    }\n\n    // Check again if aborted after async body resolution\n    if (aborted) {\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error.code === 'UND_MOCK_ERR_MOCK_NOT_MATCHED') {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction normalizeOrigin (origin) {\n  if (typeof origin !== 'string' && !(origin instanceof URL)) {\n    return origin\n  }\n\n  if (origin instanceof URL) {\n    return origin.origin\n  }\n\n  return origin.toLowerCase()\n}\n\nfunction buildAndValidateMockOptions (opts) {\n  const { agent, ...mockOptions } = opts\n\n  if ('enableCallHistory' in mockOptions && typeof mockOptions.enableCallHistory !== 'boolean') {\n    throw new InvalidArgumentError('options.enableCallHistory must to be a boolean')\n  }\n\n  if ('acceptNonStandardSearchParameters' in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== 'boolean') {\n    throw new InvalidArgumentError('options.acceptNonStandardSearchParameters must to be a boolean')\n  }\n\n  if ('ignoreTrailingSlash' in mockOptions && typeof mockOptions.ignoreTrailingSlash !== 'boolean') {\n    throw new InvalidArgumentError('options.ignoreTrailingSlash must to be a boolean')\n  }\n\n  return mockOptions\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildAndValidateMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray,\n  normalizeSearchParams,\n  normalizeOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDekQsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3ZCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLFlBQVksVUFBVTtBQUN0QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHdCQUF3Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTW9ja05vdE1hdGNoZWRFcnJvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWVycm9ycycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga09yaWdpbixcbiAga0dldE5ldENvbm5lY3Rcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHtcbiAgdHlwZXM6IHtcbiAgICBpc1Byb21pc2VcbiAgfVxufSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmZ1bmN0aW9uIG1hdGNoVmFsdWUgKG1hdGNoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWVcbiAgfVxuICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gbWF0Y2gudGVzdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoKHZhbHVlKSA9PT0gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFbnRyaWVzIChoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdXG4gICAgfSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9pbmRleCcpLkhlYWRlcnN8c3RyaW5nW118UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUgKGhlYWRlcnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycylba2V5LnRvTG9jYWxlTG93ZXJDYXNlKCldXG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSAoaGVhZGVycykgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICBjb25zdCBjbG9uZSA9IGhlYWRlcnMuc2xpY2UoKVxuICBjb25zdCBlbnRyaWVzID0gW11cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsb25lLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgIGVudHJpZXMucHVzaChbY2xvbmVbaW5kZXhdLCBjbG9uZVtpbmRleCArIDFdXSlcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpXG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVycyAobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKVxuICAgIH1cbiAgICByZXR1cm4gbW9ja0Rpc3BhdGNoLmhlYWRlcnMoaGVhZGVycyA/IGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykgOiB7fSlcbiAgfVxuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSlcblxuICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWFyY2hQYXJhbXMgKHF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgcXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHF1ZXJ5XG4gIH1cblxuICBjb25zdCBvcmlnaW5hbFFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeSlcbiAgY29uc3Qgbm9ybWFsaXplZFFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG9yaWdpbmFsUXAuZW50cmllcygpKSB7XG4gICAga2V5ID0ga2V5LnJlcGxhY2UoJ1tdJywgJycpXG5cbiAgICBjb25zdCB2YWx1ZVJlcHJlc2VudHNTdHJpbmcgPSAvXihbJ1wiXSkuKlxcMSQvLnRlc3QodmFsdWUpXG4gICAgaWYgKHZhbHVlUmVwcmVzZW50c1N0cmluZykge1xuICAgICAgbm9ybWFsaXplZFFwLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoJywnKSkge1xuICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoJywnKVxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xuICAgICAgICBub3JtYWxpemVkUXAuYXBwZW5kKGtleSwgdilcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbm9ybWFsaXplZFFwLmFwcGVuZChrZXksIHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRRcFxufVxuXG5mdW5jdGlvbiBzYWZlVXJsIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG4gIGNvbnN0IHBhdGhTZWdtZW50cyA9IHBhdGguc3BsaXQoJz8nLCAzKVxuICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBxcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aFNlZ21lbnRzLnBvcCgpKVxuICBxcC5zb3J0KClcbiAgcmV0dXJuIFsuLi5wYXRoU2VnbWVudHMsIHFwLnRvU3RyaW5nKCldLmpvaW4oJz8nKVxufVxuXG5mdW5jdGlvbiBtYXRjaEtleSAobW9ja0Rpc3BhdGNoLCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KSB7XG4gIGNvbnN0IHBhdGhNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLnBhdGgsIHBhdGgpXG4gIGNvbnN0IG1ldGhvZE1hdGNoID0gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gubWV0aG9kLCBtZXRob2QpXG4gIGNvbnN0IGJvZHlNYXRjaCA9IHR5cGVvZiBtb2NrRGlzcGF0Y2guYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5ib2R5LCBib2R5KSA6IHRydWVcbiAgY29uc3QgaGVhZGVyc01hdGNoID0gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwgaGVhZGVycylcbiAgcmV0dXJuIHBhdGhNYXRjaCAmJiBtZXRob2RNYXRjaCAmJiBib2R5TWF0Y2ggJiYgaGVhZGVyc01hdGNoXG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YSAoZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBiYXNlUGF0aCA9IGtleS5xdWVyeSA/IHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkoa2V5LnBhdGgsIGtleS5xdWVyeSkgOiBrZXkucGF0aFxuICBjb25zdCByZXNvbHZlZFBhdGggPSB0eXBlb2YgYmFzZVBhdGggPT09ICdzdHJpbmcnID8gc2FmZVVybChiYXNlUGF0aCkgOiBiYXNlUGF0aFxuXG4gIGNvbnN0IHJlc29sdmVkUGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChyZXNvbHZlZFBhdGgpXG5cbiAgLy8gTWF0Y2ggcGF0aFxuICBsZXQgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbW9ja0Rpc3BhdGNoZXNcbiAgICAuZmlsdGVyKCh7IGNvbnN1bWVkIH0pID0+ICFjb25zdW1lZClcbiAgICAuZmlsdGVyKCh7IHBhdGgsIGlnbm9yZVRyYWlsaW5nU2xhc2ggfSkgPT4ge1xuICAgICAgcmV0dXJuIGlnbm9yZVRyYWlsaW5nU2xhc2hcbiAgICAgICAgPyBtYXRjaFZhbHVlKHJlbW92ZVRyYWlsaW5nU2xhc2goc2FmZVVybChwYXRoKSksIHJlc29sdmVkUGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoKVxuICAgICAgICA6IG1hdGNoVmFsdWUoc2FmZVVybChwYXRoKSwgcmVzb2x2ZWRQYXRoKVxuICAgIH0pXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggbWV0aG9kXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggaGVhZGVyc1xuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKChtb2NrRGlzcGF0Y2gpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGtleS5oZWFkZXJzKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzXG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7aGVhZGVyc30nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEsIG9wdHMpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UsIC4uLm9wdHMgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb21cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaCAocGF0aCkge1xuICB3aGlsZSAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpXG4gIH1cblxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBwYXRoID0gJy8nXG4gIH1cblxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcblxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5VmFsdWVzIChkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV1cbiAgICBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oYCR7a2V5fWApXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5hbWUsIEJ1ZmZlci5mcm9tKGAke3ZhbHVlW2pdfWApKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZX1gKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXR1c1RleHQgKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIFNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXSB8fCAndW5rbm93bidcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2UgKGJvZHkpIHtcbiAgY29uc3QgYnVmZmVycyA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBib2R5KSB7XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycykudG9TdHJpbmcoJ3V0ZjgnKVxufVxuXG4vKipcbiAqIE1vY2sgZGlzcGF0Y2ggZnVuY3Rpb24gdXNlZCB0byBzaW11bGF0ZSB1bmRpY2kgZGlzcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBtb2NrRGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgLy8gR2V0IG1vY2sgZGlzcGF0Y2ggZnJvbSBidWlsdCBrZXlcbiAgY29uc3Qga2V5ID0gYnVpbGRLZXkob3B0cylcbiAgY29uc3QgbW9ja0Rpc3BhdGNoID0gZ2V0TW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG5cbiAgbW9ja0Rpc3BhdGNoLnRpbWVzSW52b2tlZCsrXG5cbiAgLy8gSGVyZSdzIHdoZXJlIHdlIHJlc29sdmUgYSBjYWxsYmFjayBpZiBhIGNhbGxiYWNrIGlzIHByZXNlbnQgZm9yIHRoZSBkaXNwYXRjaCBkYXRhLlxuICBpZiAobW9ja0Rpc3BhdGNoLmRhdGEuY2FsbGJhY2spIHtcbiAgICBtb2NrRGlzcGF0Y2guZGF0YSA9IHsgLi4ubW9ja0Rpc3BhdGNoLmRhdGEsIC4uLm1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKG9wdHMpIH1cbiAgfVxuXG4gIC8vIFBhcnNlIG1vY2tEaXNwYXRjaCBkYXRhXG4gIGNvbnN0IHsgZGF0YTogeyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycywgZXJyb3IgfSwgZGVsYXksIHBlcnNpc3QgfSA9IG1vY2tEaXNwYXRjaFxuICBjb25zdCB7IHRpbWVzSW52b2tlZCwgdGltZXMgfSA9IG1vY2tEaXNwYXRjaFxuXG4gIC8vIElmIGl0J3MgdXNlZCB1cCBhbmQgbm90IHBlcnNpc3RlbnQsIG1hcmsgYXMgY29uc3VtZWRcbiAgbW9ja0Rpc3BhdGNoLmNvbnN1bWVkID0gIXBlcnNpc3QgJiYgdGltZXNJbnZva2VkID49IHRpbWVzXG4gIG1vY2tEaXNwYXRjaC5wZW5kaW5nID0gdGltZXNJbnZva2VkIDwgdGltZXNcblxuICAvLyBJZiBzcGVjaWZpZWQsIHRyaWdnZXIgZGlzcGF0Y2ggZXJyb3JcbiAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG4gICAgaGFuZGxlci5vbkVycm9yKGVycm9yKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBUcmFjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcbiAgbGV0IGFib3J0ZWQgPSBmYWxzZVxuICBsZXQgdGltZXIgPSBudWxsXG5cbiAgZnVuY3Rpb24gYWJvcnQgKGVycikge1xuICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYWJvcnRlZCA9IHRydWVcblxuICAgIC8vIENsZWFyIHRoZSBwZW5kaW5nIGRlbGF5ZWQgcmVzcG9uc2UgaWYgYW55XG4gICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICB0aW1lciA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgdGhlIGhhbmRsZXIgb2YgdGhlIGFib3J0XG4gICAgaGFuZGxlci5vbkVycm9yKGVycilcbiAgfVxuXG4gIC8vIENhbGwgb25Db25uZWN0IHRvIGFsbG93IHRoZSBoYW5kbGVyIHRvIHJlZ2lzdGVyIHRoZSBhYm9ydCBjYWxsYmFja1xuICBoYW5kbGVyLm9uQ29ubmVjdD8uKGFib3J0LCBudWxsKVxuXG4gIC8vIEhhbmRsZSB0aGUgcmVxdWVzdCB3aXRoIGEgZGVsYXkgaWYgbmVjZXNzYXJ5XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lciA9IG51bGxcbiAgICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICAgIH0sIGRlbGF5KVxuICB9IGVsc2Uge1xuICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVwbHkgKG1vY2tEaXNwYXRjaGVzLCBfZGF0YSA9IGRhdGEpIHtcbiAgICAvLyBEb24ndCBzZW5kIHJlc3BvbnNlIGlmIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZldGNoJ3MgSGVhZGVyc0xpc3QgaXMgYSAxRCBzdHJpbmcgYXJyYXlcbiAgICBjb25zdCBvcHRzSGVhZGVycyA9IEFycmF5LmlzQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgPyBidWlsZEhlYWRlcnNGcm9tQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgOiBvcHRzLmhlYWRlcnNcbiAgICBjb25zdCBib2R5ID0gdHlwZW9mIF9kYXRhID09PSAnZnVuY3Rpb24nXG4gICAgICA/IF9kYXRhKHsgLi4ub3B0cywgaGVhZGVyczogb3B0c0hlYWRlcnMgfSlcbiAgICAgIDogX2RhdGFcblxuICAgIC8vIHV0aWwudHlwZXMuaXNQcm9taXNlIGlzIGxpa2VseSBuZWVkZWQgZm9yIGplc3QuXG4gICAgaWYgKGlzUHJvbWlzZShib2R5KSkge1xuICAgICAgLy8gSWYgaGFuZGxlUmVwbHkgaXMgYXN5bmNocm9ub3VzLCB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgLy8gaW4gdGhlIGNhbGxiYWNrIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLCByYXRoZXIgdGhhblxuICAgICAgLy8gc3luY2hyb25vdXNseSB0aHJvdyB0aGUgZXJyb3IsIHdoaWNoIGJyZWFrcyBzb21lIHRlc3RzLlxuICAgICAgLy8gUmF0aGVyLCB3ZSB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gcmVzb2x2ZSBpZiBpdCBpcyBhXG4gICAgICAvLyBwcm9taXNlLCBhbmQgdGhlbiByZS1ydW4gaGFuZGxlUmVwbHkgd2l0aCB0aGUgbmV3IGJvZHkuXG4gICAgICByZXR1cm4gYm9keS50aGVuKChuZXdEYXRhKSA9PiBoYW5kbGVSZXBseShtb2NrRGlzcGF0Y2hlcywgbmV3RGF0YSkpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWdhaW4gaWYgYWJvcnRlZCBhZnRlciBhc3luYyBib2R5IHJlc29sdXRpb25cbiAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLm9uSGVhZGVycz8uKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhPy4oQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGU/LihyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRCcpIHtcbiAgICAgICAgICBjb25zdCBuZXRDb25uZWN0ID0gYWdlbnRba0dldE5ldENvbm5lY3RdKClcbiAgICAgICAgICBpZiAobmV0Q29ubmVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7b3JpZ2lufSB3YXMgbm90IGFsbG93ZWQgKG5ldC5jb25uZWN0IGRpc2FibGVkKWApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGVja05ldENvbm5lY3QobmV0Q29ubmVjdCwgb3JpZ2luKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7b3JpZ2lufSB3YXMgbm90IGFsbG93ZWQgKG5ldC5jb25uZWN0IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIG9yaWdpbilgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05ldENvbm5lY3QgKG5ldENvbm5lY3QsIG9yaWdpbikge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKG9yaWdpbilcbiAgaWYgKG5ldENvbm5lY3QgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV0Q29ubmVjdCkgJiYgbmV0Q29ubmVjdC5zb21lKChtYXRjaGVyKSA9PiBtYXRjaFZhbHVlKG1hdGNoZXIsIHVybC5ob3N0KSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcmlnaW4gKG9yaWdpbikge1xuICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycgJiYgIShvcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgcmV0dXJuIG9yaWdpblxuICB9XG5cbiAgaWYgKG9yaWdpbiBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiBvcmlnaW4ub3JpZ2luXG4gIH1cblxuICByZXR1cm4gb3JpZ2luLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gYnVpbGRBbmRWYWxpZGF0ZU1vY2tPcHRpb25zIChvcHRzKSB7XG4gIGNvbnN0IHsgYWdlbnQsIC4uLm1vY2tPcHRpb25zIH0gPSBvcHRzXG5cbiAgaWYgKCdlbmFibGVDYWxsSGlzdG9yeScgaW4gbW9ja09wdGlvbnMgJiYgdHlwZW9mIG1vY2tPcHRpb25zLmVuYWJsZUNhbGxIaXN0b3J5ICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdGlvbnMuZW5hYmxlQ2FsbEhpc3RvcnkgbXVzdCB0byBiZSBhIGJvb2xlYW4nKVxuICB9XG5cbiAgaWYgKCdhY2NlcHROb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnMnIGluIG1vY2tPcHRpb25zICYmIHR5cGVvZiBtb2NrT3B0aW9ucy5hY2NlcHROb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnMgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0aW9ucy5hY2NlcHROb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnMgbXVzdCB0byBiZSBhIGJvb2xlYW4nKVxuICB9XG5cbiAgaWYgKCdpZ25vcmVUcmFpbGluZ1NsYXNoJyBpbiBtb2NrT3B0aW9ucyAmJiB0eXBlb2YgbW9ja09wdGlvbnMuaWdub3JlVHJhaWxpbmdTbGFzaCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRpb25zLmlnbm9yZVRyYWlsaW5nU2xhc2ggbXVzdCB0byBiZSBhIGJvb2xlYW4nKVxuICB9XG5cbiAgcmV0dXJuIG1vY2tPcHRpb25zXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNwb25zZURhdGEsXG4gIGdldE1vY2tEaXNwYXRjaCxcbiAgYWRkTW9ja0Rpc3BhdGNoLFxuICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkS2V5LFxuICBnZW5lcmF0ZUtleVZhbHVlcyxcbiAgbWF0Y2hWYWx1ZSxcbiAgZ2V0UmVzcG9uc2UsXG4gIGdldFN0YXR1c1RleHQsXG4gIG1vY2tEaXNwYXRjaCxcbiAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gIGNoZWNrTmV0Q29ubmVjdCxcbiAgYnVpbGRBbmRWYWxpZGF0ZU1vY2tPcHRpb25zLFxuICBnZXRIZWFkZXJCeU5hbWUsXG4gIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSxcbiAgbm9ybWFsaXplU2VhcmNoUGFyYW1zLFxuICBub3JtYWxpemVPcmlnaW5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\")\n\nconst PERSISTENT = process.versions.icu ? '' : 'Y '\nconst NOT_PERSISTENT = process.versions.icu ? '' : 'N '\n\n/**\n * Gets the output of `console.table()` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0NBQWM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCLFlBQVksd0NBQXdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXHBlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnbm9kZTpjb25zb2xlJylcblxuY29uc3QgUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KchScgOiAnWSAnXG5jb25zdCBOT1RfUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KdjCcgOiAnTiAnXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyBQRVJTSVNURU5UIDogTk9UX1BFUlNJU1RFTlQsXG4gICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgIFJlbWFpbmluZzogcGVyc2lzdCA/IEluZmluaXR5IDogdGltZXMgLSB0aW1lc0ludm9rZWRcbiAgICAgIH0pKVxuXG4gICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/snapshot-agent.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/mock/snapshot-agent.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst MockAgent = __webpack_require__(/*! ./mock-agent */ \"(rsc)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst { SnapshotRecorder } = __webpack_require__(/*! ./snapshot-recorder */ \"(rsc)/./node_modules/undici/lib/mock/snapshot-recorder.js\")\nconst WrapHandler = __webpack_require__(/*! ../handler/wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { validateSnapshotMode } = __webpack_require__(/*! ./snapshot-utils */ \"(rsc)/./node_modules/undici/lib/mock/snapshot-utils.js\")\n\nconst kSnapshotRecorder = Symbol('kSnapshotRecorder')\nconst kSnapshotMode = Symbol('kSnapshotMode')\nconst kSnapshotPath = Symbol('kSnapshotPath')\nconst kSnapshotLoaded = Symbol('kSnapshotLoaded')\nconst kRealAgent = Symbol('kRealAgent')\n\n// Static flag to ensure warning is only emitted once per process\nlet warningEmitted = false\n\nclass SnapshotAgent extends MockAgent {\n  constructor (opts = {}) {\n    // Emit experimental warning only once\n    if (!warningEmitted) {\n      process.emitWarning(\n        'SnapshotAgent is experimental and subject to change',\n        'ExperimentalWarning'\n      )\n      warningEmitted = true\n    }\n\n    const {\n      mode = 'record',\n      snapshotPath = null,\n      ...mockAgentOpts\n    } = opts\n\n    super(mockAgentOpts)\n\n    validateSnapshotMode(mode)\n\n    // Validate snapshotPath is provided when required\n    if ((mode === 'playback' || mode === 'update') && !snapshotPath) {\n      throw new InvalidArgumentError(`snapshotPath is required when mode is '${mode}'`)\n    }\n\n    this[kSnapshotMode] = mode\n    this[kSnapshotPath] = snapshotPath\n\n    this[kSnapshotRecorder] = new SnapshotRecorder({\n      snapshotPath: this[kSnapshotPath],\n      mode: this[kSnapshotMode],\n      maxSnapshots: opts.maxSnapshots,\n      autoFlush: opts.autoFlush,\n      flushInterval: opts.flushInterval,\n      matchHeaders: opts.matchHeaders,\n      ignoreHeaders: opts.ignoreHeaders,\n      excludeHeaders: opts.excludeHeaders,\n      matchBody: opts.matchBody,\n      matchQuery: opts.matchQuery,\n      caseSensitive: opts.caseSensitive,\n      shouldRecord: opts.shouldRecord,\n      shouldPlayback: opts.shouldPlayback,\n      excludeUrls: opts.excludeUrls\n    })\n    this[kSnapshotLoaded] = false\n\n    // For recording/update mode, we need a real agent to make actual requests\n    // For playback mode, we need a real agent if there are excluded URLs\n    if (this[kSnapshotMode] === 'record' || this[kSnapshotMode] === 'update' ||\n        (this[kSnapshotMode] === 'playback' && opts.excludeUrls && opts.excludeUrls.length > 0)) {\n      this[kRealAgent] = new Agent(opts)\n    }\n\n    // Auto-load snapshots in playback/update mode\n    if ((this[kSnapshotMode] === 'playback' || this[kSnapshotMode] === 'update') && this[kSnapshotPath]) {\n      this.loadSnapshots().catch(() => {\n        // Ignore load errors - file might not exist yet\n      })\n    }\n  }\n\n  dispatch (opts, handler) {\n    handler = WrapHandler.wrap(handler)\n    const mode = this[kSnapshotMode]\n\n    // Check if URL should be excluded (pass through without mocking/recording)\n    if (this[kSnapshotRecorder].isUrlExcluded(opts)) {\n      // Real agent is guaranteed by constructor when excludeUrls is configured\n      return this[kRealAgent].dispatch(opts, handler)\n    }\n\n    if (mode === 'playback' || mode === 'update') {\n      // Ensure snapshots are loaded\n      if (!this[kSnapshotLoaded]) {\n        // Need to load asynchronously, delegate to async version\n        return this.#asyncDispatch(opts, handler)\n      }\n\n      // Try to find existing snapshot (synchronous)\n      const snapshot = this[kSnapshotRecorder].findSnapshot(opts)\n\n      if (snapshot) {\n        // Use recorded response (synchronous)\n        return this.#replaySnapshot(snapshot, handler)\n      } else if (mode === 'update') {\n        // Make real request and record it (async required)\n        return this.#recordAndReplay(opts, handler)\n      } else {\n        // Playback mode but no snapshot found\n        const error = new UndiciError(`No snapshot found for ${opts.method || 'GET'} ${opts.path}`)\n        if (handler.onError) {\n          handler.onError(error)\n          return\n        }\n        throw error\n      }\n    } else if (mode === 'record') {\n      // Record mode - make real request and save response (async required)\n      return this.#recordAndReplay(opts, handler)\n    }\n  }\n\n  /**\n   * Async version of dispatch for when we need to load snapshots first\n   */\n  async #asyncDispatch (opts, handler) {\n    await this.loadSnapshots()\n    return this.dispatch(opts, handler)\n  }\n\n  /**\n   * Records a real request and replays the response\n   */\n  #recordAndReplay (opts, handler) {\n    const responseData = {\n      statusCode: null,\n      headers: {},\n      trailers: {},\n      body: []\n    }\n\n    const self = this // Capture 'this' context for use within nested handler callbacks\n\n    const recordingHandler = {\n      onRequestStart (controller, context) {\n        return handler.onRequestStart(controller, { ...context, history: this.history })\n      },\n\n      onRequestUpgrade (controller, statusCode, headers, socket) {\n        return handler.onRequestUpgrade(controller, statusCode, headers, socket)\n      },\n\n      onResponseStart (controller, statusCode, headers, statusMessage) {\n        responseData.statusCode = statusCode\n        responseData.headers = headers\n        return handler.onResponseStart(controller, statusCode, headers, statusMessage)\n      },\n\n      onResponseData (controller, chunk) {\n        responseData.body.push(chunk)\n        return handler.onResponseData(controller, chunk)\n      },\n\n      onResponseEnd (controller, trailers) {\n        responseData.trailers = trailers\n\n        // Record the interaction using captured 'self' context (fire and forget)\n        const responseBody = Buffer.concat(responseData.body)\n        self[kSnapshotRecorder].record(opts, {\n          statusCode: responseData.statusCode,\n          headers: responseData.headers,\n          body: responseBody,\n          trailers: responseData.trailers\n        })\n          .then(() => handler.onResponseEnd(controller, trailers))\n          .catch((error) => handler.onResponseError(controller, error))\n      }\n    }\n\n    // Use composed agent if available (includes interceptors), otherwise use real agent\n    const agent = this[kRealAgent]\n    return agent.dispatch(opts, recordingHandler)\n  }\n\n  /**\n   * Replays a recorded response\n   *\n   * @param {Object} snapshot - The recorded snapshot to replay.\n   * @param {Object} handler - The handler to call with the response data.\n   * @returns {void}\n   */\n  #replaySnapshot (snapshot, handler) {\n    try {\n      const { response } = snapshot\n\n      const controller = {\n        pause () { },\n        resume () { },\n        abort (reason) {\n          this.aborted = true\n          this.reason = reason\n        },\n\n        aborted: false,\n        paused: false\n      }\n\n      handler.onRequestStart(controller)\n\n      handler.onResponseStart(controller, response.statusCode, response.headers)\n\n      // Body is always stored as base64 string\n      const body = Buffer.from(response.body, 'base64')\n      handler.onResponseData(controller, body)\n\n      handler.onResponseEnd(controller, response.trailers)\n    } catch (error) {\n      handler.onError?.(error)\n    }\n  }\n\n  /**\n   * Loads snapshots from file\n   *\n   * @param {string} [filePath] - Optional file path to load snapshots from.\n   * @returns {Promise<void>} - Resolves when snapshots are loaded.\n   */\n  async loadSnapshots (filePath) {\n    await this[kSnapshotRecorder].loadSnapshots(filePath || this[kSnapshotPath])\n    this[kSnapshotLoaded] = true\n\n    // In playback mode, set up MockAgent interceptors for all snapshots\n    if (this[kSnapshotMode] === 'playback') {\n      this.#setupMockInterceptors()\n    }\n  }\n\n  /**\n   * Saves snapshots to file\n   *\n   * @param {string} [filePath] - Optional file path to save snapshots to.\n   * @returns {Promise<void>} - Resolves when snapshots are saved.\n   */\n  async saveSnapshots (filePath) {\n    return this[kSnapshotRecorder].saveSnapshots(filePath || this[kSnapshotPath])\n  }\n\n  /**\n   * Sets up MockAgent interceptors based on recorded snapshots.\n   *\n   * This method creates MockAgent interceptors for each recorded snapshot,\n   * allowing the SnapshotAgent to fall back to MockAgent's standard intercept\n   * mechanism in playback mode. Each interceptor is configured to persist\n   * (remain active for multiple requests) and responds with the recorded\n   * response data.\n   *\n   * Called automatically when loading snapshots in playback mode.\n   *\n   * @returns {void}\n   */\n  #setupMockInterceptors () {\n    for (const snapshot of this[kSnapshotRecorder].getSnapshots()) {\n      const { request, responses, response } = snapshot\n      const url = new URL(request.url)\n\n      const mockPool = this.get(url.origin)\n\n      // Handle both new format (responses array) and legacy format (response object)\n      const responseData = responses ? responses[0] : response\n      if (!responseData) continue\n\n      mockPool.intercept({\n        path: url.pathname + url.search,\n        method: request.method,\n        headers: request.headers,\n        body: request.body\n      }).reply(responseData.statusCode, responseData.body, {\n        headers: responseData.headers,\n        trailers: responseData.trailers\n      }).persist()\n    }\n  }\n\n  /**\n   * Gets the snapshot recorder\n   * @return {SnapshotRecorder} - The snapshot recorder instance\n   */\n  getRecorder () {\n    return this[kSnapshotRecorder]\n  }\n\n  /**\n   * Gets the current mode\n   * @return {import('./snapshot-utils').SnapshotMode} - The current snapshot mode\n   */\n  getMode () {\n    return this[kSnapshotMode]\n  }\n\n  /**\n   * Clears all snapshots\n   * @returns {void}\n   */\n  clearSnapshots () {\n    this[kSnapshotRecorder].clear()\n  }\n\n  /**\n   * Resets call counts for all snapshots (useful for test cleanup)\n   * @returns {void}\n   */\n  resetCallCounts () {\n    this[kSnapshotRecorder].resetCallCounts()\n  }\n\n  /**\n   * Deletes a specific snapshot by request options\n   * @param {import('./snapshot-recorder').SnapshotRequestOptions} requestOpts - Request options to identify the snapshot\n   * @return {Promise<boolean>} - Returns true if the snapshot was deleted, false if not found\n   */\n  deleteSnapshot (requestOpts) {\n    return this[kSnapshotRecorder].deleteSnapshot(requestOpts)\n  }\n\n  /**\n   * Gets information about a specific snapshot\n   * @returns {import('./snapshot-recorder').SnapshotInfo|null} - Snapshot information or null if not found\n   */\n  getSnapshotInfo (requestOpts) {\n    return this[kSnapshotRecorder].getSnapshotInfo(requestOpts)\n  }\n\n  /**\n   * Replaces all snapshots with new data (full replacement)\n   * @param {Array<{hash: string; snapshot: import('./snapshot-recorder').SnapshotEntryshotEntry}>|Record<string, import('./snapshot-recorder').SnapshotEntry>} snapshotData - New snapshot data to replace existing snapshots\n   * @returns {void}\n   */\n  replaceSnapshots (snapshotData) {\n    this[kSnapshotRecorder].replaceSnapshots(snapshotData)\n  }\n\n  /**\n   * Closes the agent, saving snapshots and cleaning up resources.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    await this[kSnapshotRecorder].close()\n    await this[kRealAgent]?.close()\n    await super.close()\n  }\n}\n\nmodule.exports = SnapshotAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3NuYXBzaG90LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxnRkFBcUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsd0VBQWM7QUFDeEMsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNGQUFxQjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBeUI7QUFDckQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0ZBQWtCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0RBQStELHNCQUFzQixFQUFFLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELG1DQUFtQztBQUN2RixPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXOztBQUV6QjtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkUsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaURBQWlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sY0FBYywrREFBK0QsK0RBQStEO0FBQ2hLLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxzbmFwc2hvdC1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2FnZW50JylcbmNvbnN0IE1vY2tBZ2VudCA9IHJlcXVpcmUoJy4vbW9jay1hZ2VudCcpXG5jb25zdCB7IFNuYXBzaG90UmVjb3JkZXIgfSA9IHJlcXVpcmUoJy4vc25hcHNob3QtcmVjb3JkZXInKVxuY29uc3QgV3JhcEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3dyYXAtaGFuZGxlcicpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZVNuYXBzaG90TW9kZSB9ID0gcmVxdWlyZSgnLi9zbmFwc2hvdC11dGlscycpXG5cbmNvbnN0IGtTbmFwc2hvdFJlY29yZGVyID0gU3ltYm9sKCdrU25hcHNob3RSZWNvcmRlcicpXG5jb25zdCBrU25hcHNob3RNb2RlID0gU3ltYm9sKCdrU25hcHNob3RNb2RlJylcbmNvbnN0IGtTbmFwc2hvdFBhdGggPSBTeW1ib2woJ2tTbmFwc2hvdFBhdGgnKVxuY29uc3Qga1NuYXBzaG90TG9hZGVkID0gU3ltYm9sKCdrU25hcHNob3RMb2FkZWQnKVxuY29uc3Qga1JlYWxBZ2VudCA9IFN5bWJvbCgna1JlYWxBZ2VudCcpXG5cbi8vIFN0YXRpYyBmbGFnIHRvIGVuc3VyZSB3YXJuaW5nIGlzIG9ubHkgZW1pdHRlZCBvbmNlIHBlciBwcm9jZXNzXG5sZXQgd2FybmluZ0VtaXR0ZWQgPSBmYWxzZVxuXG5jbGFzcyBTbmFwc2hvdEFnZW50IGV4dGVuZHMgTW9ja0FnZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIC8vIEVtaXQgZXhwZXJpbWVudGFsIHdhcm5pbmcgb25seSBvbmNlXG4gICAgaWYgKCF3YXJuaW5nRW1pdHRlZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICAgJ1NuYXBzaG90QWdlbnQgaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZScsXG4gICAgICAgICdFeHBlcmltZW50YWxXYXJuaW5nJ1xuICAgICAgKVxuICAgICAgd2FybmluZ0VtaXR0ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgbW9kZSA9ICdyZWNvcmQnLFxuICAgICAgc25hcHNob3RQYXRoID0gbnVsbCxcbiAgICAgIC4uLm1vY2tBZ2VudE9wdHNcbiAgICB9ID0gb3B0c1xuXG4gICAgc3VwZXIobW9ja0FnZW50T3B0cylcblxuICAgIHZhbGlkYXRlU25hcHNob3RNb2RlKG1vZGUpXG5cbiAgICAvLyBWYWxpZGF0ZSBzbmFwc2hvdFBhdGggaXMgcHJvdmlkZWQgd2hlbiByZXF1aXJlZFxuICAgIGlmICgobW9kZSA9PT0gJ3BsYXliYWNrJyB8fCBtb2RlID09PSAndXBkYXRlJykgJiYgIXNuYXBzaG90UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBzbmFwc2hvdFBhdGggaXMgcmVxdWlyZWQgd2hlbiBtb2RlIGlzICcke21vZGV9J2ApXG4gICAgfVxuXG4gICAgdGhpc1trU25hcHNob3RNb2RlXSA9IG1vZGVcbiAgICB0aGlzW2tTbmFwc2hvdFBhdGhdID0gc25hcHNob3RQYXRoXG5cbiAgICB0aGlzW2tTbmFwc2hvdFJlY29yZGVyXSA9IG5ldyBTbmFwc2hvdFJlY29yZGVyKHtcbiAgICAgIHNuYXBzaG90UGF0aDogdGhpc1trU25hcHNob3RQYXRoXSxcbiAgICAgIG1vZGU6IHRoaXNba1NuYXBzaG90TW9kZV0sXG4gICAgICBtYXhTbmFwc2hvdHM6IG9wdHMubWF4U25hcHNob3RzLFxuICAgICAgYXV0b0ZsdXNoOiBvcHRzLmF1dG9GbHVzaCxcbiAgICAgIGZsdXNoSW50ZXJ2YWw6IG9wdHMuZmx1c2hJbnRlcnZhbCxcbiAgICAgIG1hdGNoSGVhZGVyczogb3B0cy5tYXRjaEhlYWRlcnMsXG4gICAgICBpZ25vcmVIZWFkZXJzOiBvcHRzLmlnbm9yZUhlYWRlcnMsXG4gICAgICBleGNsdWRlSGVhZGVyczogb3B0cy5leGNsdWRlSGVhZGVycyxcbiAgICAgIG1hdGNoQm9keTogb3B0cy5tYXRjaEJvZHksXG4gICAgICBtYXRjaFF1ZXJ5OiBvcHRzLm1hdGNoUXVlcnksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBvcHRzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBzaG91bGRSZWNvcmQ6IG9wdHMuc2hvdWxkUmVjb3JkLFxuICAgICAgc2hvdWxkUGxheWJhY2s6IG9wdHMuc2hvdWxkUGxheWJhY2ssXG4gICAgICBleGNsdWRlVXJsczogb3B0cy5leGNsdWRlVXJsc1xuICAgIH0pXG4gICAgdGhpc1trU25hcHNob3RMb2FkZWRdID0gZmFsc2VcblxuICAgIC8vIEZvciByZWNvcmRpbmcvdXBkYXRlIG1vZGUsIHdlIG5lZWQgYSByZWFsIGFnZW50IHRvIG1ha2UgYWN0dWFsIHJlcXVlc3RzXG4gICAgLy8gRm9yIHBsYXliYWNrIG1vZGUsIHdlIG5lZWQgYSByZWFsIGFnZW50IGlmIHRoZXJlIGFyZSBleGNsdWRlZCBVUkxzXG4gICAgaWYgKHRoaXNba1NuYXBzaG90TW9kZV0gPT09ICdyZWNvcmQnIHx8IHRoaXNba1NuYXBzaG90TW9kZV0gPT09ICd1cGRhdGUnIHx8XG4gICAgICAgICh0aGlzW2tTbmFwc2hvdE1vZGVdID09PSAncGxheWJhY2snICYmIG9wdHMuZXhjbHVkZVVybHMgJiYgb3B0cy5leGNsdWRlVXJscy5sZW5ndGggPiAwKSkge1xuICAgICAgdGhpc1trUmVhbEFnZW50XSA9IG5ldyBBZ2VudChvcHRzKVxuICAgIH1cblxuICAgIC8vIEF1dG8tbG9hZCBzbmFwc2hvdHMgaW4gcGxheWJhY2svdXBkYXRlIG1vZGVcbiAgICBpZiAoKHRoaXNba1NuYXBzaG90TW9kZV0gPT09ICdwbGF5YmFjaycgfHwgdGhpc1trU25hcHNob3RNb2RlXSA9PT0gJ3VwZGF0ZScpICYmIHRoaXNba1NuYXBzaG90UGF0aF0pIHtcbiAgICAgIHRoaXMubG9hZFNuYXBzaG90cygpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgLy8gSWdub3JlIGxvYWQgZXJyb3JzIC0gZmlsZSBtaWdodCBub3QgZXhpc3QgeWV0XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaGFuZGxlciA9IFdyYXBIYW5kbGVyLndyYXAoaGFuZGxlcilcbiAgICBjb25zdCBtb2RlID0gdGhpc1trU25hcHNob3RNb2RlXVxuXG4gICAgLy8gQ2hlY2sgaWYgVVJMIHNob3VsZCBiZSBleGNsdWRlZCAocGFzcyB0aHJvdWdoIHdpdGhvdXQgbW9ja2luZy9yZWNvcmRpbmcpXG4gICAgaWYgKHRoaXNba1NuYXBzaG90UmVjb3JkZXJdLmlzVXJsRXhjbHVkZWQob3B0cykpIHtcbiAgICAgIC8vIFJlYWwgYWdlbnQgaXMgZ3VhcmFudGVlZCBieSBjb25zdHJ1Y3RvciB3aGVuIGV4Y2x1ZGVVcmxzIGlzIGNvbmZpZ3VyZWRcbiAgICAgIHJldHVybiB0aGlzW2tSZWFsQWdlbnRdLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdwbGF5YmFjaycgfHwgbW9kZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIC8vIEVuc3VyZSBzbmFwc2hvdHMgYXJlIGxvYWRlZFxuICAgICAgaWYgKCF0aGlzW2tTbmFwc2hvdExvYWRlZF0pIHtcbiAgICAgICAgLy8gTmVlZCB0byBsb2FkIGFzeW5jaHJvbm91c2x5LCBkZWxlZ2F0ZSB0byBhc3luYyB2ZXJzaW9uXG4gICAgICAgIHJldHVybiB0aGlzLiNhc3luY0Rpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSB0byBmaW5kIGV4aXN0aW5nIHNuYXBzaG90IChzeW5jaHJvbm91cylcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpc1trU25hcHNob3RSZWNvcmRlcl0uZmluZFNuYXBzaG90KG9wdHMpXG5cbiAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICAvLyBVc2UgcmVjb3JkZWQgcmVzcG9uc2UgKHN5bmNocm9ub3VzKVxuICAgICAgICByZXR1cm4gdGhpcy4jcmVwbGF5U25hcHNob3Qoc25hcHNob3QsIGhhbmRsZXIpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIC8vIE1ha2UgcmVhbCByZXF1ZXN0IGFuZCByZWNvcmQgaXQgKGFzeW5jIHJlcXVpcmVkKVxuICAgICAgICByZXR1cm4gdGhpcy4jcmVjb3JkQW5kUmVwbGF5KG9wdHMsIGhhbmRsZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQbGF5YmFjayBtb2RlIGJ1dCBubyBzbmFwc2hvdCBmb3VuZFxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBVbmRpY2lFcnJvcihgTm8gc25hcHNob3QgZm91bmQgZm9yICR7b3B0cy5tZXRob2QgfHwgJ0dFVCd9ICR7b3B0cy5wYXRofWApXG4gICAgICAgIGlmIChoYW5kbGVyLm9uRXJyb3IpIHtcbiAgICAgICAgICBoYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdyZWNvcmQnKSB7XG4gICAgICAvLyBSZWNvcmQgbW9kZSAtIG1ha2UgcmVhbCByZXF1ZXN0IGFuZCBzYXZlIHJlc3BvbnNlIChhc3luYyByZXF1aXJlZClcbiAgICAgIHJldHVybiB0aGlzLiNyZWNvcmRBbmRSZXBsYXkob3B0cywgaGFuZGxlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBkaXNwYXRjaCBmb3Igd2hlbiB3ZSBuZWVkIHRvIGxvYWQgc25hcHNob3RzIGZpcnN0XG4gICAqL1xuICBhc3luYyAjYXN5bmNEaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGF3YWl0IHRoaXMubG9hZFNuYXBzaG90cygpXG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmRzIGEgcmVhbCByZXF1ZXN0IGFuZCByZXBsYXlzIHRoZSByZXNwb25zZVxuICAgKi9cbiAgI3JlY29yZEFuZFJlcGxheSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgIHN0YXR1c0NvZGU6IG51bGwsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHRyYWlsZXJzOiB7fSxcbiAgICAgIGJvZHk6IFtdXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXMgLy8gQ2FwdHVyZSAndGhpcycgY29udGV4dCBmb3IgdXNlIHdpdGhpbiBuZXN0ZWQgaGFuZGxlciBjYWxsYmFja3NcblxuICAgIGNvbnN0IHJlY29yZGluZ0hhbmRsZXIgPSB7XG4gICAgICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlci5vblJlcXVlc3RTdGFydChjb250cm9sbGVyLCB7IC4uLmNvbnRleHQsIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KVxuICAgICAgfSxcblxuICAgICAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLm9uUmVxdWVzdFVwZ3JhZGUoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgICAgfSxcblxuICAgICAgb25SZXNwb25zZVN0YXJ0IChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgIHJlc3BvbnNlRGF0YS5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgICAgICByZXNwb25zZURhdGEuaGVhZGVycyA9IGhlYWRlcnNcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIub25SZXNwb25zZVN0YXJ0KGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gICAgICB9LFxuXG4gICAgICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgcmVzcG9uc2VEYXRhLmJvZHkucHVzaChjaHVuaylcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIub25SZXNwb25zZURhdGEoY29udHJvbGxlciwgY2h1bmspXG4gICAgICB9LFxuXG4gICAgICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgICAgICByZXNwb25zZURhdGEudHJhaWxlcnMgPSB0cmFpbGVyc1xuXG4gICAgICAgIC8vIFJlY29yZCB0aGUgaW50ZXJhY3Rpb24gdXNpbmcgY2FwdHVyZWQgJ3NlbGYnIGNvbnRleHQgKGZpcmUgYW5kIGZvcmdldClcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gQnVmZmVyLmNvbmNhdChyZXNwb25zZURhdGEuYm9keSlcbiAgICAgICAgc2VsZltrU25hcHNob3RSZWNvcmRlcl0ucmVjb3JkKG9wdHMsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZURhdGEuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZURhdGEuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgdHJhaWxlcnM6IHJlc3BvbnNlRGF0YS50cmFpbGVyc1xuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IGhhbmRsZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB0cmFpbGVycykpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyb3IpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVzZSBjb21wb3NlZCBhZ2VudCBpZiBhdmFpbGFibGUgKGluY2x1ZGVzIGludGVyY2VwdG9ycyksIG90aGVyd2lzZSB1c2UgcmVhbCBhZ2VudFxuICAgIGNvbnN0IGFnZW50ID0gdGhpc1trUmVhbEFnZW50XVxuICAgIHJldHVybiBhZ2VudC5kaXNwYXRjaChvcHRzLCByZWNvcmRpbmdIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxheXMgYSByZWNvcmRlZCByZXNwb25zZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc25hcHNob3QgLSBUaGUgcmVjb3JkZWQgc25hcHNob3QgdG8gcmVwbGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlciAtIFRoZSBoYW5kbGVyIHRvIGNhbGwgd2l0aCB0aGUgcmVzcG9uc2UgZGF0YS5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAjcmVwbGF5U25hcHNob3QgKHNuYXBzaG90LCBoYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHNuYXBzaG90XG5cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB7XG4gICAgICAgIHBhdXNlICgpIHsgfSxcbiAgICAgICAgcmVzdW1lICgpIHsgfSxcbiAgICAgICAgYWJvcnQgKHJlYXNvbikge1xuICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvblxuICAgICAgICB9LFxuXG4gICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXVzZWQ6IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQoY29udHJvbGxlcilcblxuICAgICAgaGFuZGxlci5vblJlc3BvbnNlU3RhcnQoY29udHJvbGxlciwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcblxuICAgICAgLy8gQm9keSBpcyBhbHdheXMgc3RvcmVkIGFzIGJhc2U2NCBzdHJpbmdcbiAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuZnJvbShyZXNwb25zZS5ib2R5LCAnYmFzZTY0JylcbiAgICAgIGhhbmRsZXIub25SZXNwb25zZURhdGEoY29udHJvbGxlciwgYm9keSlcblxuICAgICAgaGFuZGxlci5vblJlc3BvbnNlRW5kKGNvbnRyb2xsZXIsIHJlc3BvbnNlLnRyYWlsZXJzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGVyLm9uRXJyb3I/LihlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgc25hcHNob3RzIGZyb20gZmlsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVQYXRoXSAtIE9wdGlvbmFsIGZpbGUgcGF0aCB0byBsb2FkIHNuYXBzaG90cyBmcm9tLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gLSBSZXNvbHZlcyB3aGVuIHNuYXBzaG90cyBhcmUgbG9hZGVkLlxuICAgKi9cbiAgYXN5bmMgbG9hZFNuYXBzaG90cyAoZmlsZVBhdGgpIHtcbiAgICBhd2FpdCB0aGlzW2tTbmFwc2hvdFJlY29yZGVyXS5sb2FkU25hcHNob3RzKGZpbGVQYXRoIHx8IHRoaXNba1NuYXBzaG90UGF0aF0pXG4gICAgdGhpc1trU25hcHNob3RMb2FkZWRdID0gdHJ1ZVxuXG4gICAgLy8gSW4gcGxheWJhY2sgbW9kZSwgc2V0IHVwIE1vY2tBZ2VudCBpbnRlcmNlcHRvcnMgZm9yIGFsbCBzbmFwc2hvdHNcbiAgICBpZiAodGhpc1trU25hcHNob3RNb2RlXSA9PT0gJ3BsYXliYWNrJykge1xuICAgICAgdGhpcy4jc2V0dXBNb2NrSW50ZXJjZXB0b3JzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgc25hcHNob3RzIHRvIGZpbGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWxlUGF0aF0gLSBPcHRpb25hbCBmaWxlIHBhdGggdG8gc2F2ZSBzbmFwc2hvdHMgdG8uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAtIFJlc29sdmVzIHdoZW4gc25hcHNob3RzIGFyZSBzYXZlZC5cbiAgICovXG4gIGFzeW5jIHNhdmVTbmFwc2hvdHMgKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXNba1NuYXBzaG90UmVjb3JkZXJdLnNhdmVTbmFwc2hvdHMoZmlsZVBhdGggfHwgdGhpc1trU25hcHNob3RQYXRoXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIE1vY2tBZ2VudCBpbnRlcmNlcHRvcnMgYmFzZWQgb24gcmVjb3JkZWQgc25hcHNob3RzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIE1vY2tBZ2VudCBpbnRlcmNlcHRvcnMgZm9yIGVhY2ggcmVjb3JkZWQgc25hcHNob3QsXG4gICAqIGFsbG93aW5nIHRoZSBTbmFwc2hvdEFnZW50IHRvIGZhbGwgYmFjayB0byBNb2NrQWdlbnQncyBzdGFuZGFyZCBpbnRlcmNlcHRcbiAgICogbWVjaGFuaXNtIGluIHBsYXliYWNrIG1vZGUuIEVhY2ggaW50ZXJjZXB0b3IgaXMgY29uZmlndXJlZCB0byBwZXJzaXN0XG4gICAqIChyZW1haW4gYWN0aXZlIGZvciBtdWx0aXBsZSByZXF1ZXN0cykgYW5kIHJlc3BvbmRzIHdpdGggdGhlIHJlY29yZGVkXG4gICAqIHJlc3BvbnNlIGRhdGEuXG4gICAqXG4gICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGluZyBzbmFwc2hvdHMgaW4gcGxheWJhY2sgbW9kZS5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAjc2V0dXBNb2NrSW50ZXJjZXB0b3JzICgpIHtcbiAgICBmb3IgKGNvbnN0IHNuYXBzaG90IG9mIHRoaXNba1NuYXBzaG90UmVjb3JkZXJdLmdldFNuYXBzaG90cygpKSB7XG4gICAgICBjb25zdCB7IHJlcXVlc3QsIHJlc3BvbnNlcywgcmVzcG9uc2UgfSA9IHNuYXBzaG90XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuXG4gICAgICBjb25zdCBtb2NrUG9vbCA9IHRoaXMuZ2V0KHVybC5vcmlnaW4pXG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIG5ldyBmb3JtYXQgKHJlc3BvbnNlcyBhcnJheSkgYW5kIGxlZ2FjeSBmb3JtYXQgKHJlc3BvbnNlIG9iamVjdClcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlcyA/IHJlc3BvbnNlc1swXSA6IHJlc3BvbnNlXG4gICAgICBpZiAoIXJlc3BvbnNlRGF0YSkgY29udGludWVcblxuICAgICAgbW9ja1Bvb2wuaW50ZXJjZXB0KHtcbiAgICAgICAgcGF0aDogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICBib2R5OiByZXF1ZXN0LmJvZHlcbiAgICAgIH0pLnJlcGx5KHJlc3BvbnNlRGF0YS5zdGF0dXNDb2RlLCByZXNwb25zZURhdGEuYm9keSwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZURhdGEuaGVhZGVycyxcbiAgICAgICAgdHJhaWxlcnM6IHJlc3BvbnNlRGF0YS50cmFpbGVyc1xuICAgICAgfSkucGVyc2lzdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNuYXBzaG90IHJlY29yZGVyXG4gICAqIEByZXR1cm4ge1NuYXBzaG90UmVjb3JkZXJ9IC0gVGhlIHNuYXBzaG90IHJlY29yZGVyIGluc3RhbmNlXG4gICAqL1xuICBnZXRSZWNvcmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1NuYXBzaG90UmVjb3JkZXJdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBtb2RlXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLlNuYXBzaG90TW9kZX0gLSBUaGUgY3VycmVudCBzbmFwc2hvdCBtb2RlXG4gICAqL1xuICBnZXRNb2RlICgpIHtcbiAgICByZXR1cm4gdGhpc1trU25hcHNob3RNb2RlXVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgc25hcHNob3RzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXJTbmFwc2hvdHMgKCkge1xuICAgIHRoaXNba1NuYXBzaG90UmVjb3JkZXJdLmNsZWFyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgY2FsbCBjb3VudHMgZm9yIGFsbCBzbmFwc2hvdHMgKHVzZWZ1bCBmb3IgdGVzdCBjbGVhbnVwKVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlc2V0Q2FsbENvdW50cyAoKSB7XG4gICAgdGhpc1trU25hcHNob3RSZWNvcmRlcl0ucmVzZXRDYWxsQ291bnRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc3BlY2lmaWMgc25hcHNob3QgYnkgcmVxdWVzdCBvcHRpb25zXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL3NuYXBzaG90LXJlY29yZGVyJykuU25hcHNob3RSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdHMgLSBSZXF1ZXN0IG9wdGlvbnMgdG8gaWRlbnRpZnkgdGhlIHNuYXBzaG90XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzbmFwc2hvdCB3YXMgZGVsZXRlZCwgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAqL1xuICBkZWxldGVTbmFwc2hvdCAocmVxdWVzdE9wdHMpIHtcbiAgICByZXR1cm4gdGhpc1trU25hcHNob3RSZWNvcmRlcl0uZGVsZXRlU25hcHNob3QocmVxdWVzdE9wdHMpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHNuYXBzaG90XG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vc25hcHNob3QtcmVjb3JkZXInKS5TbmFwc2hvdEluZm98bnVsbH0gLSBTbmFwc2hvdCBpbmZvcm1hdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgZ2V0U25hcHNob3RJbmZvIChyZXF1ZXN0T3B0cykge1xuICAgIHJldHVybiB0aGlzW2tTbmFwc2hvdFJlY29yZGVyXS5nZXRTbmFwc2hvdEluZm8ocmVxdWVzdE9wdHMpXG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIHNuYXBzaG90cyB3aXRoIG5ldyBkYXRhIChmdWxsIHJlcGxhY2VtZW50KVxuICAgKiBAcGFyYW0ge0FycmF5PHtoYXNoOiBzdHJpbmc7IHNuYXBzaG90OiBpbXBvcnQoJy4vc25hcHNob3QtcmVjb3JkZXInKS5TbmFwc2hvdEVudHJ5c2hvdEVudHJ5fT58UmVjb3JkPHN0cmluZywgaW1wb3J0KCcuL3NuYXBzaG90LXJlY29yZGVyJykuU25hcHNob3RFbnRyeT59IHNuYXBzaG90RGF0YSAtIE5ldyBzbmFwc2hvdCBkYXRhIHRvIHJlcGxhY2UgZXhpc3Rpbmcgc25hcHNob3RzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVwbGFjZVNuYXBzaG90cyAoc25hcHNob3REYXRhKSB7XG4gICAgdGhpc1trU25hcHNob3RSZWNvcmRlcl0ucmVwbGFjZVNuYXBzaG90cyhzbmFwc2hvdERhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBhZ2VudCwgc2F2aW5nIHNuYXBzaG90cyBhbmQgY2xlYW5pbmcgdXAgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzW2tTbmFwc2hvdFJlY29yZGVyXS5jbG9zZSgpXG4gICAgYXdhaXQgdGhpc1trUmVhbEFnZW50XT8uY2xvc2UoKVxuICAgIGF3YWl0IHN1cGVyLmNsb3NlKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBzaG90QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/snapshot-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/snapshot-recorder.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/mock/snapshot-recorder.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { writeFile, readFile, mkdir } = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\")\nconst { dirname, resolve } = __webpack_require__(/*! node:path */ \"node:path\")\nconst { setTimeout, clearTimeout } = __webpack_require__(/*! node:timers */ \"node:timers\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { hashId, isUrlExcludedFactory, normalizeHeaders, createHeaderFilters } = __webpack_require__(/*! ./snapshot-utils */ \"(rsc)/./node_modules/undici/lib/mock/snapshot-utils.js\")\n\n/**\n * @typedef {Object} SnapshotRequestOptions\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} path - Request path\n * @property {string} origin - Request origin (base URL)\n * @property {import('./snapshot-utils').Headers|import('./snapshot-utils').UndiciHeaders} headers - Request headers\n * @property {import('./snapshot-utils').NormalizedHeaders} _normalizedHeaders - Request headers as a lowercase object\n * @property {string|Buffer} [body] - Request body (optional)\n */\n\n/**\n * @typedef {Object} SnapshotEntryRequest\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} url - Full URL of the request\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized headers as a lowercase object\n * @property {string|Buffer} [body] - Request body (optional)\n */\n\n/**\n * @typedef {Object} SnapshotEntryResponse\n * @property {number} statusCode - HTTP status code of the response\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized response headers as a lowercase object\n * @property {string} body - Response body as a base64url encoded string\n * @property {Object} [trailers] - Optional response trailers\n */\n\n/**\n * @typedef {Object} SnapshotEntry\n * @property {SnapshotEntryRequest} request - The request object\n * @property {Array<SnapshotEntryResponse>} responses - Array of response objects\n * @property {number} callCount - Number of times this snapshot has been called\n * @property {string} timestamp - ISO timestamp of when the snapshot was created\n */\n\n/**\n * @typedef {Object} SnapshotRecorderMatchOptions\n * @property {Array<string>} [matchHeaders=[]] - Headers to match (empty array means match all headers)\n * @property {Array<string>} [ignoreHeaders=[]] - Headers to ignore for matching\n * @property {Array<string>} [excludeHeaders=[]] - Headers to exclude from matching\n * @property {boolean} [matchBody=true] - Whether to match request body\n * @property {boolean} [matchQuery=true] - Whether to match query properties\n * @property {boolean} [caseSensitive=false] - Whether header matching is case-sensitive\n */\n\n/**\n * @typedef {Object} SnapshotRecorderOptions\n * @property {string} [snapshotPath] - Path to save/load snapshots\n * @property {import('./snapshot-utils').SnapshotMode} [mode='record'] - Mode: 'record' or 'playback'\n * @property {number} [maxSnapshots=Infinity] - Maximum number of snapshots to keep\n * @property {boolean} [autoFlush=false] - Whether to automatically flush snapshots to disk\n * @property {number} [flushInterval=30000] - Auto-flush interval in milliseconds (default: 30 seconds)\n * @property {Array<string|RegExp>} [excludeUrls=[]] - URLs to exclude from recording\n * @property {function} [shouldRecord=null] - Function to filter requests for recording\n * @property {function} [shouldPlayback=null] - Function to filter requests\n */\n\n/**\n * @typedef {Object} SnapshotFormattedRequest\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} url - Full URL of the request (with query parameters if matchQuery is true)\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized headers as a lowercase object\n * @property {string} body - Request body (optional, only if matchBody is true)\n */\n\n/**\n * @typedef {Object} SnapshotInfo\n * @property {string} hash - Hash key for the snapshot\n * @property {SnapshotEntryRequest} request - The request object\n * @property {number} responseCount - Number of responses recorded for this request\n * @property {number} callCount - Number of times this snapshot has been called\n * @property {string} timestamp - ISO timestamp of when the snapshot was created\n */\n\n/**\n * Formats a request for consistent snapshot storage\n * Caches normalized headers to avoid repeated processing\n *\n * @param {SnapshotRequestOptions} opts - Request options\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached header sets for performance\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers and body\n * @returns {SnapshotFormattedRequest} - Formatted request object\n */\nfunction formatRequestKey (opts, headerFilters, matchOptions = {}) {\n  const url = new URL(opts.path, opts.origin)\n\n  // Cache normalized headers if not already done\n  const normalized = opts._normalizedHeaders || normalizeHeaders(opts.headers)\n  if (!opts._normalizedHeaders) {\n    opts._normalizedHeaders = normalized\n  }\n\n  return {\n    method: opts.method || 'GET',\n    url: matchOptions.matchQuery !== false ? url.toString() : `${url.origin}${url.pathname}`,\n    headers: filterHeadersForMatching(normalized, headerFilters, matchOptions),\n    body: matchOptions.matchBody !== false && opts.body ? String(opts.body) : ''\n  }\n}\n\n/**\n * Filters headers based on matching configuration\n *\n * @param {import('./snapshot-utils').Headers} headers - Headers to filter\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached sets for ignore, exclude, and match headers\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers\n */\nfunction filterHeadersForMatching (headers, headerFilters, matchOptions = {}) {\n  if (!headers || typeof headers !== 'object') return {}\n\n  const {\n    caseSensitive = false\n  } = matchOptions\n\n  const filtered = {}\n  const { ignore, exclude, match } = headerFilters\n\n  for (const [key, value] of Object.entries(headers)) {\n    const headerKey = caseSensitive ? key : key.toLowerCase()\n\n    // Skip if in exclude list (for security)\n    if (exclude.has(headerKey)) continue\n\n    // Skip if in ignore list (for matching)\n    if (ignore.has(headerKey)) continue\n\n    // If matchHeaders is specified, only include those headers\n    if (match.size !== 0) {\n      if (!match.has(headerKey)) continue\n    }\n\n    filtered[headerKey] = value\n  }\n\n  return filtered\n}\n\n/**\n * Filters headers for storage (only excludes sensitive headers)\n *\n * @param {import('./snapshot-utils').Headers} headers - Headers to filter\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached sets for ignore, exclude, and match headers\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers\n */\nfunction filterHeadersForStorage (headers, headerFilters, matchOptions = {}) {\n  if (!headers || typeof headers !== 'object') return {}\n\n  const {\n    caseSensitive = false\n  } = matchOptions\n\n  const filtered = {}\n  const { exclude: excludeSet } = headerFilters\n\n  for (const [key, value] of Object.entries(headers)) {\n    const headerKey = caseSensitive ? key : key.toLowerCase()\n\n    // Skip if in exclude list (for security)\n    if (excludeSet.has(headerKey)) continue\n\n    filtered[headerKey] = value\n  }\n\n  return filtered\n}\n\n/**\n * Creates a hash key for request matching\n * Properly orders headers to avoid conflicts and uses crypto hashing when available\n *\n * @param {SnapshotFormattedRequest} formattedRequest - Request object\n * @returns {string} - Base64url encoded hash of the request\n */\nfunction createRequestHash (formattedRequest) {\n  const parts = [\n    formattedRequest.method,\n    formattedRequest.url\n  ]\n\n  // Process headers in a deterministic way to avoid conflicts\n  if (formattedRequest.headers && typeof formattedRequest.headers === 'object') {\n    const headerKeys = Object.keys(formattedRequest.headers).sort()\n    for (const key of headerKeys) {\n      const values = Array.isArray(formattedRequest.headers[key])\n        ? formattedRequest.headers[key]\n        : [formattedRequest.headers[key]]\n\n      // Add header name\n      parts.push(key)\n\n      // Add all values for this header, sorted for consistency\n      for (const value of values.sort()) {\n        parts.push(String(value))\n      }\n    }\n  }\n\n  // Add body\n  parts.push(formattedRequest.body)\n\n  const content = parts.join('|')\n\n  return hashId(content)\n}\n\nclass SnapshotRecorder {\n  /** @type {NodeJS.Timeout | null} */\n  #flushTimeout\n\n  /** @type {import('./snapshot-utils').IsUrlExcluded} */\n  #isUrlExcluded\n\n  /** @type {Map<string, SnapshotEntry>} */\n  #snapshots = new Map()\n\n  /** @type {string|undefined} */\n  #snapshotPath\n\n  /** @type {number} */\n  #maxSnapshots = Infinity\n\n  /** @type {boolean} */\n  #autoFlush = false\n\n  /** @type {import('./snapshot-utils').HeaderFilters} */\n  #headerFilters\n\n  /**\n   * Creates a new SnapshotRecorder instance\n   * @param {SnapshotRecorderOptions&SnapshotRecorderMatchOptions} [options={}] - Configuration options for the recorder\n   */\n  constructor (options = {}) {\n    this.#snapshotPath = options.snapshotPath\n    this.#maxSnapshots = options.maxSnapshots || Infinity\n    this.#autoFlush = options.autoFlush || false\n    this.flushInterval = options.flushInterval || 30000 // 30 seconds default\n    this._flushTimer = null\n\n    // Matching configuration\n    /** @type {Required<SnapshotRecorderMatchOptions>} */\n    this.matchOptions = {\n      matchHeaders: options.matchHeaders || [], // empty means match all headers\n      ignoreHeaders: options.ignoreHeaders || [],\n      excludeHeaders: options.excludeHeaders || [],\n      matchBody: options.matchBody !== false, // default: true\n      matchQuery: options.matchQuery !== false, // default: true\n      caseSensitive: options.caseSensitive || false\n    }\n\n    // Cache processed header sets to avoid recreating them on every request\n    this.#headerFilters = createHeaderFilters(this.matchOptions)\n\n    // Request filtering callbacks\n    this.shouldRecord = options.shouldRecord || (() => true) // function(requestOpts) -> boolean\n    this.shouldPlayback = options.shouldPlayback || (() => true) // function(requestOpts) -> boolean\n\n    // URL pattern filtering\n    this.#isUrlExcluded = isUrlExcludedFactory(options.excludeUrls) // Array of regex patterns or strings\n\n    // Start auto-flush timer if enabled\n    if (this.#autoFlush && this.#snapshotPath) {\n      this.#startAutoFlush()\n    }\n  }\n\n  /**\n   * Records a request-response interaction\n   * @param {SnapshotRequestOptions} requestOpts - Request options\n   * @param {SnapshotEntryResponse} response - Response data to record\n   * @return {Promise<void>} - Resolves when the recording is complete\n   */\n  async record (requestOpts, response) {\n    // Check if recording should be filtered out\n    if (!this.shouldRecord(requestOpts)) {\n      return // Skip recording\n    }\n\n    // Check URL exclusion patterns\n    if (this.isUrlExcluded(requestOpts)) {\n      return // Skip recording\n    }\n\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n\n    // Extract response data - always store body as base64\n    const normalizedHeaders = normalizeHeaders(response.headers)\n\n    /** @type {SnapshotEntryResponse} */\n    const responseData = {\n      statusCode: response.statusCode,\n      headers: filterHeadersForStorage(normalizedHeaders, this.#headerFilters, this.matchOptions),\n      body: Buffer.isBuffer(response.body)\n        ? response.body.toString('base64')\n        : Buffer.from(String(response.body || '')).toString('base64'),\n      trailers: response.trailers\n    }\n\n    // Remove oldest snapshot if we exceed maxSnapshots limit\n    if (this.#snapshots.size >= this.#maxSnapshots && !this.#snapshots.has(hash)) {\n      const oldestKey = this.#snapshots.keys().next().value\n      this.#snapshots.delete(oldestKey)\n    }\n\n    // Support sequential responses - if snapshot exists, add to responses array\n    const existingSnapshot = this.#snapshots.get(hash)\n    if (existingSnapshot && existingSnapshot.responses) {\n      existingSnapshot.responses.push(responseData)\n      existingSnapshot.timestamp = new Date().toISOString()\n    } else {\n      this.#snapshots.set(hash, {\n        request,\n        responses: [responseData], // Always store as array for consistency\n        callCount: 0,\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    // Auto-flush if enabled\n    if (this.#autoFlush && this.#snapshotPath) {\n      this.#scheduleFlush()\n    }\n  }\n\n  /**\n   * Checks if a URL should be excluded from recording/playback\n   * @param {SnapshotRequestOptions} requestOpts - Request options to check\n   * @returns {boolean} - True if URL is excluded\n   */\n  isUrlExcluded (requestOpts) {\n    const url = new URL(requestOpts.path, requestOpts.origin).toString()\n    return this.#isUrlExcluded(url)\n  }\n\n  /**\n   * Finds a matching snapshot for the given request\n   * Returns the appropriate response based on call count for sequential responses\n   *\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {SnapshotEntry&Record<'response', SnapshotEntryResponse>|undefined} - Matching snapshot response or undefined if not found\n   */\n  findSnapshot (requestOpts) {\n    // Check if playback should be filtered out\n    if (!this.shouldPlayback(requestOpts)) {\n      return undefined // Skip playback\n    }\n\n    // Check URL exclusion patterns\n    if (this.isUrlExcluded(requestOpts)) {\n      return undefined // Skip playback\n    }\n\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    const snapshot = this.#snapshots.get(hash)\n\n    if (!snapshot) return undefined\n\n    // Handle sequential responses\n    const currentCallCount = snapshot.callCount || 0\n    const responseIndex = Math.min(currentCallCount, snapshot.responses.length - 1)\n    snapshot.callCount = currentCallCount + 1\n\n    return {\n      ...snapshot,\n      response: snapshot.responses[responseIndex]\n    }\n  }\n\n  /**\n   * Loads snapshots from file\n   * @param {string} [filePath] - Optional file path to load snapshots from\n   * @return {Promise<void>} - Resolves when snapshots are loaded\n   */\n  async loadSnapshots (filePath) {\n    const path = filePath || this.#snapshotPath\n    if (!path) {\n      throw new InvalidArgumentError('Snapshot path is required')\n    }\n\n    try {\n      const data = await readFile(resolve(path), 'utf8')\n      const parsed = JSON.parse(data)\n\n      // Convert array format back to Map\n      if (Array.isArray(parsed)) {\n        this.#snapshots.clear()\n        for (const { hash, snapshot } of parsed) {\n          this.#snapshots.set(hash, snapshot)\n        }\n      } else {\n        // Legacy object format\n        this.#snapshots = new Map(Object.entries(parsed))\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // File doesn't exist yet - that's ok for recording mode\n        this.#snapshots.clear()\n      } else {\n        throw new UndiciError(`Failed to load snapshots from ${path}`, { cause: error })\n      }\n    }\n  }\n\n  /**\n   * Saves snapshots to file\n   *\n   * @param {string} [filePath] - Optional file path to save snapshots\n   * @returns {Promise<void>} - Resolves when snapshots are saved\n   */\n  async saveSnapshots (filePath) {\n    const path = filePath || this.#snapshotPath\n    if (!path) {\n      throw new InvalidArgumentError('Snapshot path is required')\n    }\n\n    const resolvedPath = resolve(path)\n\n    // Ensure directory exists\n    await mkdir(dirname(resolvedPath), { recursive: true })\n\n    // Convert Map to serializable format\n    const data = Array.from(this.#snapshots.entries()).map(([hash, snapshot]) => ({\n      hash,\n      snapshot\n    }))\n\n    await writeFile(resolvedPath, JSON.stringify(data, null, 2), { flush: true })\n  }\n\n  /**\n   * Clears all recorded snapshots\n   * @returns {void}\n   */\n  clear () {\n    this.#snapshots.clear()\n  }\n\n  /**\n   * Gets all recorded snapshots\n   * @return {Array<SnapshotEntry>} - Array of all recorded snapshots\n   */\n  getSnapshots () {\n    return Array.from(this.#snapshots.values())\n  }\n\n  /**\n   * Gets snapshot count\n   * @return {number} - Number of recorded snapshots\n   */\n  size () {\n    return this.#snapshots.size\n  }\n\n  /**\n   * Resets call counts for all snapshots (useful for test cleanup)\n   * @returns {void}\n   */\n  resetCallCounts () {\n    for (const snapshot of this.#snapshots.values()) {\n      snapshot.callCount = 0\n    }\n  }\n\n  /**\n   * Deletes a specific snapshot by request options\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {boolean} - True if snapshot was deleted, false if not found\n   */\n  deleteSnapshot (requestOpts) {\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    return this.#snapshots.delete(hash)\n  }\n\n  /**\n   * Gets information about a specific snapshot\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {SnapshotInfo|null} - Snapshot information or null if not found\n   */\n  getSnapshotInfo (requestOpts) {\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    const snapshot = this.#snapshots.get(hash)\n\n    if (!snapshot) return null\n\n    return {\n      hash,\n      request: snapshot.request,\n      responseCount: snapshot.responses ? snapshot.responses.length : (snapshot.response ? 1 : 0), // .response for legacy snapshots\n      callCount: snapshot.callCount || 0,\n      timestamp: snapshot.timestamp\n    }\n  }\n\n  /**\n   * Replaces all snapshots with new data (full replacement)\n   * @param {Array<{hash: string; snapshot: SnapshotEntry}>|Record<string, SnapshotEntry>} snapshotData - New snapshot data to replace existing ones\n   * @returns {void}\n   */\n  replaceSnapshots (snapshotData) {\n    this.#snapshots.clear()\n\n    if (Array.isArray(snapshotData)) {\n      for (const { hash, snapshot } of snapshotData) {\n        this.#snapshots.set(hash, snapshot)\n      }\n    } else if (snapshotData && typeof snapshotData === 'object') {\n      // Legacy object format\n      this.#snapshots = new Map(Object.entries(snapshotData))\n    }\n  }\n\n  /**\n   * Starts the auto-flush timer\n   * @returns {void}\n   */\n  #startAutoFlush () {\n    return this.#scheduleFlush()\n  }\n\n  /**\n   * Stops the auto-flush timer\n   * @returns {void}\n   */\n  #stopAutoFlush () {\n    if (this.#flushTimeout) {\n      clearTimeout(this.#flushTimeout)\n      // Ensure any pending flush is completed\n      this.saveSnapshots().catch(() => {\n      // Ignore flush errors\n      })\n      this.#flushTimeout = null\n    }\n  }\n\n  /**\n   * Schedules a flush (debounced to avoid excessive writes)\n   */\n  #scheduleFlush () {\n    this.#flushTimeout = setTimeout(() => {\n      this.saveSnapshots().catch(() => {\n        // Ignore flush errors\n      })\n      if (this.#autoFlush) {\n        this.#flushTimeout?.refresh()\n      } else {\n        this.#flushTimeout = null\n      }\n    }, 1000) // 1 second debounce\n  }\n\n  /**\n   * Cleanup method to stop timers\n   * @returns {void}\n   */\n  destroy () {\n    this.#stopAutoFlush()\n    if (this.#flushTimeout) {\n      clearTimeout(this.#flushTimeout)\n      this.#flushTimeout = null\n    }\n  }\n\n  /**\n   * Async close method that saves all recordings and performs cleanup\n   * @returns {Promise<void>}\n   */\n  async close () {\n    // Save any pending recordings if we have a snapshot path\n    if (this.#snapshotPath && this.#snapshots.size !== 0) {\n      await this.saveSnapshots()\n    }\n\n    // Perform cleanup\n    this.destroy()\n  }\n}\n\nmodule.exports = { SnapshotRecorder, formatRequestKey, createRequestHash, filterHeadersForMatching, filterHeadersForStorage, createHeaderFilters }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3NuYXBzaG90LXJlY29yZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNkJBQTZCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDakUsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ2hELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxRCxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3RFLFFBQVEsc0VBQXNFLEVBQUUsbUJBQU8sQ0FBQyxnRkFBa0I7O0FBRTFHO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsNkVBQTZFO0FBQzNGLGNBQWMsOENBQThDO0FBQzVELGNBQWMsZUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsOENBQThDO0FBQzVELGNBQWMsZUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHNCQUFzQjtBQUNwQyxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxlQUFlO0FBQzdCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHlDQUF5QztBQUN2RCxjQUFjLFFB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QTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLGNBQWMsd0JBQXdCLGlDQUFpQztBQUMzRixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxzbmFwc2hvdC1yZWNvcmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3cml0ZUZpbGUsIHJlYWRGaWxlLCBta2RpciB9ID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpXG5jb25zdCB7IGRpcm5hbWUsIHJlc29sdmUgfSA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCB7IHNldFRpbWVvdXQsIGNsZWFyVGltZW91dCB9ID0gcmVxdWlyZSgnbm9kZTp0aW1lcnMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgaGFzaElkLCBpc1VybEV4Y2x1ZGVkRmFjdG9yeSwgbm9ybWFsaXplSGVhZGVycywgY3JlYXRlSGVhZGVyRmlsdGVycyB9ID0gcmVxdWlyZSgnLi9zbmFwc2hvdC11dGlscycpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU25hcHNob3RSZXF1ZXN0T3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kIChlLmcuICdHRVQnLCAnUE9TVCcsIGV0Yy4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aCAtIFJlcXVlc3QgcGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiAtIFJlcXVlc3Qgb3JpZ2luIChiYXNlIFVSTClcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL3NuYXBzaG90LXV0aWxzJykuSGVhZGVyc3xpbXBvcnQoJy4vc25hcHNob3QtdXRpbHMnKS5VbmRpY2lIZWFkZXJzfSBoZWFkZXJzIC0gUmVxdWVzdCBoZWFkZXJzXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLk5vcm1hbGl6ZWRIZWFkZXJzfSBfbm9ybWFsaXplZEhlYWRlcnMgLSBSZXF1ZXN0IGhlYWRlcnMgYXMgYSBsb3dlcmNhc2Ugb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ3xCdWZmZXJ9IFtib2R5XSAtIFJlcXVlc3QgYm9keSAob3B0aW9uYWwpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTbmFwc2hvdEVudHJ5UmVxdWVzdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kIChlLmcuICdHRVQnLCAnUE9TVCcsIGV0Yy4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gRnVsbCBVUkwgb2YgdGhlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL3NuYXBzaG90LXV0aWxzJykuTm9ybWFsaXplZEhlYWRlcnN9IGhlYWRlcnMgLSBOb3JtYWxpemVkIGhlYWRlcnMgYXMgYSBsb3dlcmNhc2Ugb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ3xCdWZmZXJ9IFtib2R5XSAtIFJlcXVlc3QgYm9keSAob3B0aW9uYWwpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTbmFwc2hvdEVudHJ5UmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGF0dXNDb2RlIC0gSFRUUCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL3NuYXBzaG90LXV0aWxzJykuTm9ybWFsaXplZEhlYWRlcnN9IGhlYWRlcnMgLSBOb3JtYWxpemVkIHJlc3BvbnNlIGhlYWRlcnMgYXMgYSBsb3dlcmNhc2Ugb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9keSAtIFJlc3BvbnNlIGJvZHkgYXMgYSBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdHJhaWxlcnNdIC0gT3B0aW9uYWwgcmVzcG9uc2UgdHJhaWxlcnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNuYXBzaG90RW50cnlcbiAqIEBwcm9wZXJ0eSB7U25hcHNob3RFbnRyeVJlcXVlc3R9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8U25hcHNob3RFbnRyeVJlc3BvbnNlPn0gcmVzcG9uc2VzIC0gQXJyYXkgb2YgcmVzcG9uc2Ugb2JqZWN0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbGxDb3VudCAtIE51bWJlciBvZiB0aW1lcyB0aGlzIHNuYXBzaG90IGhhcyBiZWVuIGNhbGxlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVzdGFtcCAtIElTTyB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgc25hcHNob3Qgd2FzIGNyZWF0ZWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNuYXBzaG90UmVjb3JkZXJNYXRjaE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW21hdGNoSGVhZGVycz1bXV0gLSBIZWFkZXJzIHRvIG1hdGNoIChlbXB0eSBhcnJheSBtZWFucyBtYXRjaCBhbGwgaGVhZGVycylcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW2lnbm9yZUhlYWRlcnM9W11dIC0gSGVhZGVycyB0byBpZ25vcmUgZm9yIG1hdGNoaW5nXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtleGNsdWRlSGVhZGVycz1bXV0gLSBIZWFkZXJzIHRvIGV4Y2x1ZGUgZnJvbSBtYXRjaGluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSBbbWF0Y2hCb2R5PXRydWVdIC0gV2hldGhlciB0byBtYXRjaCByZXF1ZXN0IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21hdGNoUXVlcnk9dHJ1ZV0gLSBXaGV0aGVyIHRvIG1hdGNoIHF1ZXJ5IHByb3BlcnRpZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nhc2VTZW5zaXRpdmU9ZmFsc2VdIC0gV2hldGhlciBoZWFkZXIgbWF0Y2hpbmcgaXMgY2FzZS1zZW5zaXRpdmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNuYXBzaG90UmVjb3JkZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NuYXBzaG90UGF0aF0gLSBQYXRoIHRvIHNhdmUvbG9hZCBzbmFwc2hvdHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL3NuYXBzaG90LXV0aWxzJykuU25hcHNob3RNb2RlfSBbbW9kZT0ncmVjb3JkJ10gLSBNb2RlOiAncmVjb3JkJyBvciAncGxheWJhY2snXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFNuYXBzaG90cz1JbmZpbml0eV0gLSBNYXhpbXVtIG51bWJlciBvZiBzbmFwc2hvdHMgdG8ga2VlcFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0ZsdXNoPWZhbHNlXSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBmbHVzaCBzbmFwc2hvdHMgdG8gZGlza1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmbHVzaEludGVydmFsPTMwMDAwXSAtIEF1dG8tZmx1c2ggaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAzMCBzZWNvbmRzKVxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmd8UmVnRXhwPn0gW2V4Y2x1ZGVVcmxzPVtdXSAtIFVSTHMgdG8gZXhjbHVkZSBmcm9tIHJlY29yZGluZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Nob3VsZFJlY29yZD1udWxsXSAtIEZ1bmN0aW9uIHRvIGZpbHRlciByZXF1ZXN0cyBmb3IgcmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbc2hvdWxkUGxheWJhY2s9bnVsbF0gLSBGdW5jdGlvbiB0byBmaWx0ZXIgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNuYXBzaG90Rm9ybWF0dGVkUmVxdWVzdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kIChlLmcuICdHRVQnLCAnUE9TVCcsIGV0Yy4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gRnVsbCBVUkwgb2YgdGhlIHJlcXVlc3QgKHdpdGggcXVlcnkgcGFyYW1ldGVycyBpZiBtYXRjaFF1ZXJ5IGlzIHRydWUpXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLk5vcm1hbGl6ZWRIZWFkZXJzfSBoZWFkZXJzIC0gTm9ybWFsaXplZCBoZWFkZXJzIGFzIGEgbG93ZXJjYXNlIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvZHkgLSBSZXF1ZXN0IGJvZHkgKG9wdGlvbmFsLCBvbmx5IGlmIG1hdGNoQm9keSBpcyB0cnVlKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU25hcHNob3RJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaGFzaCAtIEhhc2gga2V5IGZvciB0aGUgc25hcHNob3RcbiAqIEBwcm9wZXJ0eSB7U25hcHNob3RFbnRyeVJlcXVlc3R9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNwb25zZUNvdW50IC0gTnVtYmVyIG9mIHJlc3BvbnNlcyByZWNvcmRlZCBmb3IgdGhpcyByZXF1ZXN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsbENvdW50IC0gTnVtYmVyIG9mIHRpbWVzIHRoaXMgc25hcHNob3QgaGFzIGJlZW4gY2FsbGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGltZXN0YW1wIC0gSVNPIHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBzbmFwc2hvdCB3YXMgY3JlYXRlZFxuICovXG5cbi8qKlxuICogRm9ybWF0cyBhIHJlcXVlc3QgZm9yIGNvbnNpc3RlbnQgc25hcHNob3Qgc3RvcmFnZVxuICogQ2FjaGVzIG5vcm1hbGl6ZWQgaGVhZGVycyB0byBhdm9pZCByZXBlYXRlZCBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHtTbmFwc2hvdFJlcXVlc3RPcHRpb25zfSBvcHRzIC0gUmVxdWVzdCBvcHRpb25zXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLkhlYWRlckZpbHRlcnN9IGhlYWRlckZpbHRlcnMgLSBDYWNoZWQgaGVhZGVyIHNldHMgZm9yIHBlcmZvcm1hbmNlXG4gKiBAcGFyYW0ge1NuYXBzaG90UmVjb3JkZXJNYXRjaE9wdGlvbnN9IFttYXRjaE9wdGlvbnNdIC0gTWF0Y2hpbmcgb3B0aW9ucyBmb3IgaGVhZGVycyBhbmQgYm9keVxuICogQHJldHVybnMge1NuYXBzaG90Rm9ybWF0dGVkUmVxdWVzdH0gLSBGb3JtYXR0ZWQgcmVxdWVzdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UmVxdWVzdEtleSAob3B0cywgaGVhZGVyRmlsdGVycywgbWF0Y2hPcHRpb25zID0ge30pIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRzLnBhdGgsIG9wdHMub3JpZ2luKVxuXG4gIC8vIENhY2hlIG5vcm1hbGl6ZWQgaGVhZGVycyBpZiBub3QgYWxyZWFkeSBkb25lXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBvcHRzLl9ub3JtYWxpemVkSGVhZGVycyB8fCBub3JtYWxpemVIZWFkZXJzKG9wdHMuaGVhZGVycylcbiAgaWYgKCFvcHRzLl9ub3JtYWxpemVkSGVhZGVycykge1xuICAgIG9wdHMuX25vcm1hbGl6ZWRIZWFkZXJzID0gbm9ybWFsaXplZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgIHVybDogbWF0Y2hPcHRpb25zLm1hdGNoUXVlcnkgIT09IGZhbHNlID8gdXJsLnRvU3RyaW5nKCkgOiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgaGVhZGVyczogZmlsdGVySGVhZGVyc0Zvck1hdGNoaW5nKG5vcm1hbGl6ZWQsIGhlYWRlckZpbHRlcnMsIG1hdGNoT3B0aW9ucyksXG4gICAgYm9keTogbWF0Y2hPcHRpb25zLm1hdGNoQm9keSAhPT0gZmFsc2UgJiYgb3B0cy5ib2R5ID8gU3RyaW5nKG9wdHMuYm9keSkgOiAnJ1xuICB9XG59XG5cbi8qKlxuICogRmlsdGVycyBoZWFkZXJzIGJhc2VkIG9uIG1hdGNoaW5nIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLkhlYWRlcnN9IGhlYWRlcnMgLSBIZWFkZXJzIHRvIGZpbHRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vc25hcHNob3QtdXRpbHMnKS5IZWFkZXJGaWx0ZXJzfSBoZWFkZXJGaWx0ZXJzIC0gQ2FjaGVkIHNldHMgZm9yIGlnbm9yZSwgZXhjbHVkZSwgYW5kIG1hdGNoIGhlYWRlcnNcbiAqIEBwYXJhbSB7U25hcHNob3RSZWNvcmRlck1hdGNoT3B0aW9uc30gW21hdGNoT3B0aW9uc10gLSBNYXRjaGluZyBvcHRpb25zIGZvciBoZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckhlYWRlcnNGb3JNYXRjaGluZyAoaGVhZGVycywgaGVhZGVyRmlsdGVycywgbWF0Y2hPcHRpb25zID0ge30pIHtcbiAgaWYgKCFoZWFkZXJzIHx8IHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JykgcmV0dXJuIHt9XG5cbiAgY29uc3Qge1xuICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZVxuICB9ID0gbWF0Y2hPcHRpb25zXG5cbiAgY29uc3QgZmlsdGVyZWQgPSB7fVxuICBjb25zdCB7IGlnbm9yZSwgZXhjbHVkZSwgbWF0Y2ggfSA9IGhlYWRlckZpbHRlcnNcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlcktleSA9IGNhc2VTZW5zaXRpdmUgPyBrZXkgOiBrZXkudG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gU2tpcCBpZiBpbiBleGNsdWRlIGxpc3QgKGZvciBzZWN1cml0eSlcbiAgICBpZiAoZXhjbHVkZS5oYXMoaGVhZGVyS2V5KSkgY29udGludWVcblxuICAgIC8vIFNraXAgaWYgaW4gaWdub3JlIGxpc3QgKGZvciBtYXRjaGluZylcbiAgICBpZiAoaWdub3JlLmhhcyhoZWFkZXJLZXkpKSBjb250aW51ZVxuXG4gICAgLy8gSWYgbWF0Y2hIZWFkZXJzIGlzIHNwZWNpZmllZCwgb25seSBpbmNsdWRlIHRob3NlIGhlYWRlcnNcbiAgICBpZiAobWF0Y2guc2l6ZSAhPT0gMCkge1xuICAgICAgaWYgKCFtYXRjaC5oYXMoaGVhZGVyS2V5KSkgY29udGludWVcbiAgICB9XG5cbiAgICBmaWx0ZXJlZFtoZWFkZXJLZXldID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZFxufVxuXG4vKipcbiAqIEZpbHRlcnMgaGVhZGVycyBmb3Igc3RvcmFnZSAob25seSBleGNsdWRlcyBzZW5zaXRpdmUgaGVhZGVycylcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLkhlYWRlcnN9IGhlYWRlcnMgLSBIZWFkZXJzIHRvIGZpbHRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vc25hcHNob3QtdXRpbHMnKS5IZWFkZXJGaWx0ZXJzfSBoZWFkZXJGaWx0ZXJzIC0gQ2FjaGVkIHNldHMgZm9yIGlnbm9yZSwgZXhjbHVkZSwgYW5kIG1hdGNoIGhlYWRlcnNcbiAqIEBwYXJhbSB7U25hcHNob3RSZWNvcmRlck1hdGNoT3B0aW9uc30gW21hdGNoT3B0aW9uc10gLSBNYXRjaGluZyBvcHRpb25zIGZvciBoZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckhlYWRlcnNGb3JTdG9yYWdlIChoZWFkZXJzLCBoZWFkZXJGaWx0ZXJzLCBtYXRjaE9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWhlYWRlcnMgfHwgdHlwZW9mIGhlYWRlcnMgIT09ICdvYmplY3QnKSByZXR1cm4ge31cblxuICBjb25zdCB7XG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlXG4gIH0gPSBtYXRjaE9wdGlvbnNcblxuICBjb25zdCBmaWx0ZXJlZCA9IHt9XG4gIGNvbnN0IHsgZXhjbHVkZTogZXhjbHVkZVNldCB9ID0gaGVhZGVyRmlsdGVyc1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgY29uc3QgaGVhZGVyS2V5ID0gY2FzZVNlbnNpdGl2ZSA/IGtleSA6IGtleS50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyBTa2lwIGlmIGluIGV4Y2x1ZGUgbGlzdCAoZm9yIHNlY3VyaXR5KVxuICAgIGlmIChleGNsdWRlU2V0LmhhcyhoZWFkZXJLZXkpKSBjb250aW51ZVxuXG4gICAgZmlsdGVyZWRbaGVhZGVyS2V5XSA9IHZhbHVlXG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBrZXkgZm9yIHJlcXVlc3QgbWF0Y2hpbmdcbiAqIFByb3Blcmx5IG9yZGVycyBoZWFkZXJzIHRvIGF2b2lkIGNvbmZsaWN0cyBhbmQgdXNlcyBjcnlwdG8gaGFzaGluZyB3aGVuIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7U25hcHNob3RGb3JtYXR0ZWRSZXF1ZXN0fSBmb3JtYXR0ZWRSZXF1ZXN0IC0gUmVxdWVzdCBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQmFzZTY0dXJsIGVuY29kZWQgaGFzaCBvZiB0aGUgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SGFzaCAoZm9ybWF0dGVkUmVxdWVzdCkge1xuICBjb25zdCBwYXJ0cyA9IFtcbiAgICBmb3JtYXR0ZWRSZXF1ZXN0Lm1ldGhvZCxcbiAgICBmb3JtYXR0ZWRSZXF1ZXN0LnVybFxuICBdXG5cbiAgLy8gUHJvY2VzcyBoZWFkZXJzIGluIGEgZGV0ZXJtaW5pc3RpYyB3YXkgdG8gYXZvaWQgY29uZmxpY3RzXG4gIGlmIChmb3JtYXR0ZWRSZXF1ZXN0LmhlYWRlcnMgJiYgdHlwZW9mIGZvcm1hdHRlZFJlcXVlc3QuaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXMoZm9ybWF0dGVkUmVxdWVzdC5oZWFkZXJzKS5zb3J0KClcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBoZWFkZXJLZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGZvcm1hdHRlZFJlcXVlc3QuaGVhZGVyc1trZXldKVxuICAgICAgICA/IGZvcm1hdHRlZFJlcXVlc3QuaGVhZGVyc1trZXldXG4gICAgICAgIDogW2Zvcm1hdHRlZFJlcXVlc3QuaGVhZGVyc1trZXldXVxuXG4gICAgICAvLyBBZGQgaGVhZGVyIG5hbWVcbiAgICAgIHBhcnRzLnB1c2goa2V5KVxuXG4gICAgICAvLyBBZGQgYWxsIHZhbHVlcyBmb3IgdGhpcyBoZWFkZXIsIHNvcnRlZCBmb3IgY29uc2lzdGVuY3lcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzLnNvcnQoKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZyh2YWx1ZSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGJvZHlcbiAgcGFydHMucHVzaChmb3JtYXR0ZWRSZXF1ZXN0LmJvZHkpXG5cbiAgY29uc3QgY29udGVudCA9IHBhcnRzLmpvaW4oJ3wnKVxuXG4gIHJldHVybiBoYXNoSWQoY29udGVudClcbn1cblxuY2xhc3MgU25hcHNob3RSZWNvcmRlciB7XG4gIC8qKiBAdHlwZSB7Tm9kZUpTLlRpbWVvdXQgfCBudWxsfSAqL1xuICAjZmx1c2hUaW1lb3V0XG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vc25hcHNob3QtdXRpbHMnKS5Jc1VybEV4Y2x1ZGVkfSAqL1xuICAjaXNVcmxFeGNsdWRlZFxuXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgU25hcHNob3RFbnRyeT59ICovXG4gICNzbmFwc2hvdHMgPSBuZXcgTWFwKClcblxuICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICNzbmFwc2hvdFBhdGhcblxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgI21heFNuYXBzaG90cyA9IEluZmluaXR5XG5cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAjYXV0b0ZsdXNoID0gZmFsc2VcblxuICAvKiogQHR5cGUge2ltcG9ydCgnLi9zbmFwc2hvdC11dGlscycpLkhlYWRlckZpbHRlcnN9ICovXG4gICNoZWFkZXJGaWx0ZXJzXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU25hcHNob3RSZWNvcmRlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1NuYXBzaG90UmVjb3JkZXJPcHRpb25zJlNuYXBzaG90UmVjb3JkZXJNYXRjaE9wdGlvbnN9IFtvcHRpb25zPXt9XSAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJlY29yZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy4jc25hcHNob3RQYXRoID0gb3B0aW9ucy5zbmFwc2hvdFBhdGhcbiAgICB0aGlzLiNtYXhTbmFwc2hvdHMgPSBvcHRpb25zLm1heFNuYXBzaG90cyB8fCBJbmZpbml0eVxuICAgIHRoaXMuI2F1dG9GbHVzaCA9IG9wdGlvbnMuYXV0b0ZsdXNoIHx8IGZhbHNlXG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gb3B0aW9ucy5mbHVzaEludGVydmFsIHx8IDMwMDAwIC8vIDMwIHNlY29uZHMgZGVmYXVsdFxuICAgIHRoaXMuX2ZsdXNoVGltZXIgPSBudWxsXG5cbiAgICAvLyBNYXRjaGluZyBjb25maWd1cmF0aW9uXG4gICAgLyoqIEB0eXBlIHtSZXF1aXJlZDxTbmFwc2hvdFJlY29yZGVyTWF0Y2hPcHRpb25zPn0gKi9cbiAgICB0aGlzLm1hdGNoT3B0aW9ucyA9IHtcbiAgICAgIG1hdGNoSGVhZGVyczogb3B0aW9ucy5tYXRjaEhlYWRlcnMgfHwgW10sIC8vIGVtcHR5IG1lYW5zIG1hdGNoIGFsbCBoZWFkZXJzXG4gICAgICBpZ25vcmVIZWFkZXJzOiBvcHRpb25zLmlnbm9yZUhlYWRlcnMgfHwgW10sXG4gICAgICBleGNsdWRlSGVhZGVyczogb3B0aW9ucy5leGNsdWRlSGVhZGVycyB8fCBbXSxcbiAgICAgIG1hdGNoQm9keTogb3B0aW9ucy5tYXRjaEJvZHkgIT09IGZhbHNlLCAvLyBkZWZhdWx0OiB0cnVlXG4gICAgICBtYXRjaFF1ZXJ5OiBvcHRpb25zLm1hdGNoUXVlcnkgIT09IGZhbHNlLCAvLyBkZWZhdWx0OiB0cnVlXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBvcHRpb25zLmNhc2VTZW5zaXRpdmUgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBwcm9jZXNzZWQgaGVhZGVyIHNldHMgdG8gYXZvaWQgcmVjcmVhdGluZyB0aGVtIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgICB0aGlzLiNoZWFkZXJGaWx0ZXJzID0gY3JlYXRlSGVhZGVyRmlsdGVycyh0aGlzLm1hdGNoT3B0aW9ucylcblxuICAgIC8vIFJlcXVlc3QgZmlsdGVyaW5nIGNhbGxiYWNrc1xuICAgIHRoaXMuc2hvdWxkUmVjb3JkID0gb3B0aW9ucy5zaG91bGRSZWNvcmQgfHwgKCgpID0+IHRydWUpIC8vIGZ1bmN0aW9uKHJlcXVlc3RPcHRzKSAtPiBib29sZWFuXG4gICAgdGhpcy5zaG91bGRQbGF5YmFjayA9IG9wdGlvbnMuc2hvdWxkUGxheWJhY2sgfHwgKCgpID0+IHRydWUpIC8vIGZ1bmN0aW9uKHJlcXVlc3RPcHRzKSAtPiBib29sZWFuXG5cbiAgICAvLyBVUkwgcGF0dGVybiBmaWx0ZXJpbmdcbiAgICB0aGlzLiNpc1VybEV4Y2x1ZGVkID0gaXNVcmxFeGNsdWRlZEZhY3Rvcnkob3B0aW9ucy5leGNsdWRlVXJscykgLy8gQXJyYXkgb2YgcmVnZXggcGF0dGVybnMgb3Igc3RyaW5nc1xuXG4gICAgLy8gU3RhcnQgYXV0by1mbHVzaCB0aW1lciBpZiBlbmFibGVkXG4gICAgaWYgKHRoaXMuI2F1dG9GbHVzaCAmJiB0aGlzLiNzbmFwc2hvdFBhdGgpIHtcbiAgICAgIHRoaXMuI3N0YXJ0QXV0b0ZsdXNoKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkcyBhIHJlcXVlc3QtcmVzcG9uc2UgaW50ZXJhY3Rpb25cbiAgICogQHBhcmFtIHtTbmFwc2hvdFJlcXVlc3RPcHRpb25zfSByZXF1ZXN0T3B0cyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1NuYXBzaG90RW50cnlSZXNwb25zZX0gcmVzcG9uc2UgLSBSZXNwb25zZSBkYXRhIHRvIHJlY29yZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSAtIFJlc29sdmVzIHdoZW4gdGhlIHJlY29yZGluZyBpcyBjb21wbGV0ZVxuICAgKi9cbiAgYXN5bmMgcmVjb3JkIChyZXF1ZXN0T3B0cywgcmVzcG9uc2UpIHtcbiAgICAvLyBDaGVjayBpZiByZWNvcmRpbmcgc2hvdWxkIGJlIGZpbHRlcmVkIG91dFxuICAgIGlmICghdGhpcy5zaG91bGRSZWNvcmQocmVxdWVzdE9wdHMpKSB7XG4gICAgICByZXR1cm4gLy8gU2tpcCByZWNvcmRpbmdcbiAgICB9XG5cbiAgICAvLyBDaGVjayBVUkwgZXhjbHVzaW9uIHBhdHRlcm5zXG4gICAgaWYgKHRoaXMuaXNVcmxFeGNsdWRlZChyZXF1ZXN0T3B0cykpIHtcbiAgICAgIHJldHVybiAvLyBTa2lwIHJlY29yZGluZ1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBmb3JtYXRSZXF1ZXN0S2V5KHJlcXVlc3RPcHRzLCB0aGlzLiNoZWFkZXJGaWx0ZXJzLCB0aGlzLm1hdGNoT3B0aW9ucylcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlUmVxdWVzdEhhc2gocmVxdWVzdClcblxuICAgIC8vIEV4dHJhY3QgcmVzcG9uc2UgZGF0YSAtIGFsd2F5cyBzdG9yZSBib2R5IGFzIGJhc2U2NFxuICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gbm9ybWFsaXplSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKVxuXG4gICAgLyoqIEB0eXBlIHtTbmFwc2hvdEVudHJ5UmVzcG9uc2V9ICovXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnM6IGZpbHRlckhlYWRlcnNGb3JTdG9yYWdlKG5vcm1hbGl6ZWRIZWFkZXJzLCB0aGlzLiNoZWFkZXJGaWx0ZXJzLCB0aGlzLm1hdGNoT3B0aW9ucyksXG4gICAgICBib2R5OiBCdWZmZXIuaXNCdWZmZXIocmVzcG9uc2UuYm9keSlcbiAgICAgICAgPyByZXNwb25zZS5ib2R5LnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICA6IEJ1ZmZlci5mcm9tKFN0cmluZyhyZXNwb25zZS5ib2R5IHx8ICcnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgdHJhaWxlcnM6IHJlc3BvbnNlLnRyYWlsZXJzXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG9sZGVzdCBzbmFwc2hvdCBpZiB3ZSBleGNlZWQgbWF4U25hcHNob3RzIGxpbWl0XG4gICAgaWYgKHRoaXMuI3NuYXBzaG90cy5zaXplID49IHRoaXMuI21heFNuYXBzaG90cyAmJiAhdGhpcy4jc25hcHNob3RzLmhhcyhoYXNoKSkge1xuICAgICAgY29uc3Qgb2xkZXN0S2V5ID0gdGhpcy4jc25hcHNob3RzLmtleXMoKS5uZXh0KCkudmFsdWVcbiAgICAgIHRoaXMuI3NuYXBzaG90cy5kZWxldGUob2xkZXN0S2V5KVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgc2VxdWVudGlhbCByZXNwb25zZXMgLSBpZiBzbmFwc2hvdCBleGlzdHMsIGFkZCB0byByZXNwb25zZXMgYXJyYXlcbiAgICBjb25zdCBleGlzdGluZ1NuYXBzaG90ID0gdGhpcy4jc25hcHNob3RzLmdldChoYXNoKVxuICAgIGlmIChleGlzdGluZ1NuYXBzaG90ICYmIGV4aXN0aW5nU25hcHNob3QucmVzcG9uc2VzKSB7XG4gICAgICBleGlzdGluZ1NuYXBzaG90LnJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlRGF0YSlcbiAgICAgIGV4aXN0aW5nU25hcHNob3QudGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3NuYXBzaG90cy5zZXQoaGFzaCwge1xuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZURhdGFdLCAvLyBBbHdheXMgc3RvcmUgYXMgYXJyYXkgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgIGNhbGxDb3VudDogMCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gQXV0by1mbHVzaCBpZiBlbmFibGVkXG4gICAgaWYgKHRoaXMuI2F1dG9GbHVzaCAmJiB0aGlzLiNzbmFwc2hvdFBhdGgpIHtcbiAgICAgIHRoaXMuI3NjaGVkdWxlRmx1c2goKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBVUkwgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gcmVjb3JkaW5nL3BsYXliYWNrXG4gICAqIEBwYXJhbSB7U25hcHNob3RSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdHMgLSBSZXF1ZXN0IG9wdGlvbnMgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBVUkwgaXMgZXhjbHVkZWRcbiAgICovXG4gIGlzVXJsRXhjbHVkZWQgKHJlcXVlc3RPcHRzKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0T3B0cy5wYXRoLCByZXF1ZXN0T3B0cy5vcmlnaW4pLnRvU3RyaW5nKClcbiAgICByZXR1cm4gdGhpcy4jaXNVcmxFeGNsdWRlZCh1cmwpXG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYSBtYXRjaGluZyBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHJlcXVlc3RcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcmVzcG9uc2UgYmFzZWQgb24gY2FsbCBjb3VudCBmb3Igc2VxdWVudGlhbCByZXNwb25zZXNcbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdFJlcXVlc3RPcHRpb25zfSByZXF1ZXN0T3B0cyAtIFJlcXVlc3Qgb3B0aW9ucyB0byBtYXRjaFxuICAgKiBAcmV0dXJucyB7U25hcHNob3RFbnRyeSZSZWNvcmQ8J3Jlc3BvbnNlJywgU25hcHNob3RFbnRyeVJlc3BvbnNlPnx1bmRlZmluZWR9IC0gTWF0Y2hpbmcgc25hcHNob3QgcmVzcG9uc2Ugb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgZmluZFNuYXBzaG90IChyZXF1ZXN0T3B0cykge1xuICAgIC8vIENoZWNrIGlmIHBsYXliYWNrIHNob3VsZCBiZSBmaWx0ZXJlZCBvdXRcbiAgICBpZiAoIXRoaXMuc2hvdWxkUGxheWJhY2socmVxdWVzdE9wdHMpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIFNraXAgcGxheWJhY2tcbiAgICB9XG5cbiAgICAvLyBDaGVjayBVUkwgZXhjbHVzaW9uIHBhdHRlcm5zXG4gICAgaWYgKHRoaXMuaXNVcmxFeGNsdWRlZChyZXF1ZXN0T3B0cykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gU2tpcCBwbGF5YmFja1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBmb3JtYXRSZXF1ZXN0S2V5KHJlcXVlc3RPcHRzLCB0aGlzLiNoZWFkZXJGaWx0ZXJzLCB0aGlzLm1hdGNoT3B0aW9ucylcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlUmVxdWVzdEhhc2gocmVxdWVzdClcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuI3NuYXBzaG90cy5nZXQoaGFzaClcblxuICAgIGlmICghc25hcHNob3QpIHJldHVybiB1bmRlZmluZWRcblxuICAgIC8vIEhhbmRsZSBzZXF1ZW50aWFsIHJlc3BvbnNlc1xuICAgIGNvbnN0IGN1cnJlbnRDYWxsQ291bnQgPSBzbmFwc2hvdC5jYWxsQ291bnQgfHwgMFxuICAgIGNvbnN0IHJlc3BvbnNlSW5kZXggPSBNYXRoLm1pbihjdXJyZW50Q2FsbENvdW50LCBzbmFwc2hvdC5yZXNwb25zZXMubGVuZ3RoIC0gMSlcbiAgICBzbmFwc2hvdC5jYWxsQ291bnQgPSBjdXJyZW50Q2FsbENvdW50ICsgMVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgcmVzcG9uc2U6IHNuYXBzaG90LnJlc3BvbnNlc1tyZXNwb25zZUluZGV4XVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBzbmFwc2hvdHMgZnJvbSBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZVBhdGhdIC0gT3B0aW9uYWwgZmlsZSBwYXRoIHRvIGxvYWQgc25hcHNob3RzIGZyb21cbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gLSBSZXNvbHZlcyB3aGVuIHNuYXBzaG90cyBhcmUgbG9hZGVkXG4gICAqL1xuICBhc3luYyBsb2FkU25hcHNob3RzIChmaWxlUGF0aCkge1xuICAgIGNvbnN0IHBhdGggPSBmaWxlUGF0aCB8fCB0aGlzLiNzbmFwc2hvdFBhdGhcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignU25hcHNob3QgcGF0aCBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWFkRmlsZShyZXNvbHZlKHBhdGgpLCAndXRmOCcpXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpXG5cbiAgICAgIC8vIENvbnZlcnQgYXJyYXkgZm9ybWF0IGJhY2sgdG8gTWFwXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgIHRoaXMuI3NuYXBzaG90cy5jbGVhcigpXG4gICAgICAgIGZvciAoY29uc3QgeyBoYXNoLCBzbmFwc2hvdCB9IG9mIHBhcnNlZCkge1xuICAgICAgICAgIHRoaXMuI3NuYXBzaG90cy5zZXQoaGFzaCwgc25hcHNob3QpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2FjeSBvYmplY3QgZm9ybWF0XG4gICAgICAgIHRoaXMuI3NuYXBzaG90cyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMocGFyc2VkKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIC8vIEZpbGUgZG9lc24ndCBleGlzdCB5ZXQgLSB0aGF0J3Mgb2sgZm9yIHJlY29yZGluZyBtb2RlXG4gICAgICAgIHRoaXMuI3NuYXBzaG90cy5jbGVhcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVW5kaWNpRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNuYXBzaG90cyBmcm9tICR7cGF0aH1gLCB7IGNhdXNlOiBlcnJvciB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyBzbmFwc2hvdHMgdG8gZmlsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVQYXRoXSAtIE9wdGlvbmFsIGZpbGUgcGF0aCB0byBzYXZlIHNuYXBzaG90c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gLSBSZXNvbHZlcyB3aGVuIHNuYXBzaG90cyBhcmUgc2F2ZWRcbiAgICovXG4gIGFzeW5jIHNhdmVTbmFwc2hvdHMgKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgcGF0aCA9IGZpbGVQYXRoIHx8IHRoaXMuI3NuYXBzaG90UGF0aFxuICAgIGlmICghcGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdTbmFwc2hvdCBwYXRoIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSByZXNvbHZlKHBhdGgpXG5cbiAgICAvLyBFbnN1cmUgZGlyZWN0b3J5IGV4aXN0c1xuICAgIGF3YWl0IG1rZGlyKGRpcm5hbWUocmVzb2x2ZWRQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSlcblxuICAgIC8vIENvbnZlcnQgTWFwIHRvIHNlcmlhbGl6YWJsZSBmb3JtYXRcbiAgICBjb25zdCBkYXRhID0gQXJyYXkuZnJvbSh0aGlzLiNzbmFwc2hvdHMuZW50cmllcygpKS5tYXAoKFtoYXNoLCBzbmFwc2hvdF0pID0+ICh7XG4gICAgICBoYXNoLFxuICAgICAgc25hcHNob3RcbiAgICB9KSlcblxuICAgIGF3YWl0IHdyaXRlRmlsZShyZXNvbHZlZFBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpLCB7IGZsdXNoOiB0cnVlIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCByZWNvcmRlZCBzbmFwc2hvdHNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgdGhpcy4jc25hcHNob3RzLmNsZWFyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWNvcmRlZCBzbmFwc2hvdHNcbiAgICogQHJldHVybiB7QXJyYXk8U25hcHNob3RFbnRyeT59IC0gQXJyYXkgb2YgYWxsIHJlY29yZGVkIHNuYXBzaG90c1xuICAgKi9cbiAgZ2V0U25hcHNob3RzICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNzbmFwc2hvdHMudmFsdWVzKCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBzbmFwc2hvdCBjb3VudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gTnVtYmVyIG9mIHJlY29yZGVkIHNuYXBzaG90c1xuICAgKi9cbiAgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NuYXBzaG90cy5zaXplXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGNhbGwgY291bnRzIGZvciBhbGwgc25hcHNob3RzICh1c2VmdWwgZm9yIHRlc3QgY2xlYW51cClcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZXNldENhbGxDb3VudHMgKCkge1xuICAgIGZvciAoY29uc3Qgc25hcHNob3Qgb2YgdGhpcy4jc25hcHNob3RzLnZhbHVlcygpKSB7XG4gICAgICBzbmFwc2hvdC5jYWxsQ291bnQgPSAwXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBzcGVjaWZpYyBzbmFwc2hvdCBieSByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTbmFwc2hvdFJlcXVlc3RPcHRpb25zfSByZXF1ZXN0T3B0cyAtIFJlcXVlc3Qgb3B0aW9ucyB0byBtYXRjaFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHNuYXBzaG90IHdhcyBkZWxldGVkLCBmYWxzZSBpZiBub3QgZm91bmRcbiAgICovXG4gIGRlbGV0ZVNuYXBzaG90IChyZXF1ZXN0T3B0cykge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBmb3JtYXRSZXF1ZXN0S2V5KHJlcXVlc3RPcHRzLCB0aGlzLiNoZWFkZXJGaWx0ZXJzLCB0aGlzLm1hdGNoT3B0aW9ucylcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlUmVxdWVzdEhhc2gocmVxdWVzdClcbiAgICByZXR1cm4gdGhpcy4jc25hcHNob3RzLmRlbGV0ZShoYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBzbmFwc2hvdFxuICAgKiBAcGFyYW0ge1NuYXBzaG90UmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRzIC0gUmVxdWVzdCBvcHRpb25zIHRvIG1hdGNoXG4gICAqIEByZXR1cm5zIHtTbmFwc2hvdEluZm98bnVsbH0gLSBTbmFwc2hvdCBpbmZvcm1hdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgZ2V0U25hcHNob3RJbmZvIChyZXF1ZXN0T3B0cykge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBmb3JtYXRSZXF1ZXN0S2V5KHJlcXVlc3RPcHRzLCB0aGlzLiNoZWFkZXJGaWx0ZXJzLCB0aGlzLm1hdGNoT3B0aW9ucylcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlUmVxdWVzdEhhc2gocmVxdWVzdClcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuI3NuYXBzaG90cy5nZXQoaGFzaClcblxuICAgIGlmICghc25hcHNob3QpIHJldHVybiBudWxsXG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFzaCxcbiAgICAgIHJlcXVlc3Q6IHNuYXBzaG90LnJlcXVlc3QsXG4gICAgICByZXNwb25zZUNvdW50OiBzbmFwc2hvdC5yZXNwb25zZXMgPyBzbmFwc2hvdC5yZXNwb25zZXMubGVuZ3RoIDogKHNuYXBzaG90LnJlc3BvbnNlID8gMSA6IDApLCAvLyAucmVzcG9uc2UgZm9yIGxlZ2FjeSBzbmFwc2hvdHNcbiAgICAgIGNhbGxDb3VudDogc25hcHNob3QuY2FsbENvdW50IHx8IDAsXG4gICAgICB0aW1lc3RhbXA6IHNuYXBzaG90LnRpbWVzdGFtcFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgc25hcHNob3RzIHdpdGggbmV3IGRhdGEgKGZ1bGwgcmVwbGFjZW1lbnQpXG4gICAqIEBwYXJhbSB7QXJyYXk8e2hhc2g6IHN0cmluZzsgc25hcHNob3Q6IFNuYXBzaG90RW50cnl9PnxSZWNvcmQ8c3RyaW5nLCBTbmFwc2hvdEVudHJ5Pn0gc25hcHNob3REYXRhIC0gTmV3IHNuYXBzaG90IGRhdGEgdG8gcmVwbGFjZSBleGlzdGluZyBvbmVzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVwbGFjZVNuYXBzaG90cyAoc25hcHNob3REYXRhKSB7XG4gICAgdGhpcy4jc25hcHNob3RzLmNsZWFyKClcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNuYXBzaG90RGF0YSkpIHtcbiAgICAgIGZvciAoY29uc3QgeyBoYXNoLCBzbmFwc2hvdCB9IG9mIHNuYXBzaG90RGF0YSkge1xuICAgICAgICB0aGlzLiNzbmFwc2hvdHMuc2V0KGhhc2gsIHNuYXBzaG90KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc25hcHNob3REYXRhICYmIHR5cGVvZiBzbmFwc2hvdERhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBMZWdhY3kgb2JqZWN0IGZvcm1hdFxuICAgICAgdGhpcy4jc25hcHNob3RzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhzbmFwc2hvdERhdGEpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGF1dG8tZmx1c2ggdGltZXJcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAjc3RhcnRBdXRvRmx1c2ggKCkge1xuICAgIHJldHVybiB0aGlzLiNzY2hlZHVsZUZsdXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgYXV0by1mbHVzaCB0aW1lclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gICNzdG9wQXV0b0ZsdXNoICgpIHtcbiAgICBpZiAodGhpcy4jZmx1c2hUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZmx1c2hUaW1lb3V0KVxuICAgICAgLy8gRW5zdXJlIGFueSBwZW5kaW5nIGZsdXNoIGlzIGNvbXBsZXRlZFxuICAgICAgdGhpcy5zYXZlU25hcHNob3RzKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gSWdub3JlIGZsdXNoIGVycm9yc1xuICAgICAgfSlcbiAgICAgIHRoaXMuI2ZsdXNoVGltZW91dCA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgZmx1c2ggKGRlYm91bmNlZCB0byBhdm9pZCBleGNlc3NpdmUgd3JpdGVzKVxuICAgKi9cbiAgI3NjaGVkdWxlRmx1c2ggKCkge1xuICAgIHRoaXMuI2ZsdXNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zYXZlU25hcHNob3RzKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgZmx1c2ggZXJyb3JzXG4gICAgICB9KVxuICAgICAgaWYgKHRoaXMuI2F1dG9GbHVzaCkge1xuICAgICAgICB0aGlzLiNmbHVzaFRpbWVvdXQ/LnJlZnJlc2goKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jZmx1c2hUaW1lb3V0ID0gbnVsbFxuICAgICAgfVxuICAgIH0sIDEwMDApIC8vIDEgc2Vjb25kIGRlYm91bmNlXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCBtZXRob2QgdG8gc3RvcCB0aW1lcnNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLiNzdG9wQXV0b0ZsdXNoKClcbiAgICBpZiAodGhpcy4jZmx1c2hUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZmx1c2hUaW1lb3V0KVxuICAgICAgdGhpcy4jZmx1c2hUaW1lb3V0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyBjbG9zZSBtZXRob2QgdGhhdCBzYXZlcyBhbGwgcmVjb3JkaW5ncyBhbmQgcGVyZm9ybXMgY2xlYW51cFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICAvLyBTYXZlIGFueSBwZW5kaW5nIHJlY29yZGluZ3MgaWYgd2UgaGF2ZSBhIHNuYXBzaG90IHBhdGhcbiAgICBpZiAodGhpcy4jc25hcHNob3RQYXRoICYmIHRoaXMuI3NuYXBzaG90cy5zaXplICE9PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVTbmFwc2hvdHMoKVxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gY2xlYW51cFxuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFNuYXBzaG90UmVjb3JkZXIsIGZvcm1hdFJlcXVlc3RLZXksIGNyZWF0ZVJlcXVlc3RIYXNoLCBmaWx0ZXJIZWFkZXJzRm9yTWF0Y2hpbmcsIGZpbHRlckhlYWRlcnNGb3JTdG9yYWdlLCBjcmVhdGVIZWFkZXJGaWx0ZXJzIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/snapshot-recorder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/snapshot-utils.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/mock/snapshot-utils.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../util/runtime-features.js */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\n/**\n * @typedef {Object} HeaderFilters\n * @property {Set<string>} ignore - Set of headers to ignore for matching\n * @property {Set<string>} exclude - Set of headers to exclude from matching\n * @property {Set<string>} match - Set of headers to match (empty means match\n */\n\n/**\n * Creates cached header sets for performance\n *\n * @param {import('./snapshot-recorder').SnapshotRecorderMatchOptions} matchOptions - Matching options for headers\n * @returns {HeaderFilters} - Cached sets for ignore, exclude, and match headers\n */\nfunction createHeaderFilters (matchOptions = {}) {\n  const { ignoreHeaders = [], excludeHeaders = [], matchHeaders = [], caseSensitive = false } = matchOptions\n\n  return {\n    ignore: new Set(ignoreHeaders.map(header => caseSensitive ? header : header.toLowerCase())),\n    exclude: new Set(excludeHeaders.map(header => caseSensitive ? header : header.toLowerCase())),\n    match: new Set(matchHeaders.map(header => caseSensitive ? header : header.toLowerCase()))\n  }\n}\n\nconst crypto = runtimeFeatures.has('crypto')\n  ? __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  : null\n\n/**\n * @callback HashIdFunction\n * @param {string} value - The value to hash\n * @returns {string} - The base64url encoded hash of the value\n */\n\n/**\n * Generates a hash for a given value\n * @type {HashIdFunction}\n */\nconst hashId = crypto?.hash\n  ? (value) => crypto.hash('sha256', value, 'base64url')\n  : (value) => Buffer.from(value).toString('base64url')\n\n/**\n * @typedef {(url: string) => boolean} IsUrlExcluded Checks if a URL matches any of the exclude patterns\n */\n\n/** @typedef {{[key: Lowercase<string>]: string}} NormalizedHeaders */\n/** @typedef {Array<string>} UndiciHeaders */\n/** @typedef {Record<string, string|string[]>} Headers */\n\n/**\n * @param {*} headers\n * @returns {headers is UndiciHeaders}\n */\nfunction isUndiciHeaders (headers) {\n  return Array.isArray(headers) && (headers.length & 1) === 0\n}\n\n/**\n * Factory function to create a URL exclusion checker\n * @param {Array<string| RegExp>} [excludePatterns=[]] - Array of patterns to exclude\n * @returns {IsUrlExcluded} - A function that checks if a URL matches any of the exclude patterns\n */\nfunction isUrlExcludedFactory (excludePatterns = []) {\n  if (excludePatterns.length === 0) {\n    return () => false\n  }\n\n  return function isUrlExcluded (url) {\n    let urlLowerCased\n\n    for (const pattern of excludePatterns) {\n      if (typeof pattern === 'string') {\n        if (!urlLowerCased) {\n          // Convert URL to lowercase only once\n          urlLowerCased = url.toLowerCase()\n        }\n        // Simple string match (case-insensitive)\n        if (urlLowerCased.includes(pattern.toLowerCase())) {\n          return true\n        }\n      } else if (pattern instanceof RegExp) {\n        // Regex pattern match\n        if (pattern.test(url)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Normalizes headers for consistent comparison\n *\n * @param {Object|UndiciHeaders} headers - Headers to normalize\n * @returns {NormalizedHeaders} - Normalized headers as a lowercase object\n */\nfunction normalizeHeaders (headers) {\n  /** @type {NormalizedHeaders} */\n  const normalizedHeaders = {}\n\n  if (!headers) return normalizedHeaders\n\n  // Handle array format (undici internal format: [name, value, name, value, ...])\n  if (isUndiciHeaders(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      const key = headers[i]\n      const value = headers[i + 1]\n      if (key && value !== undefined) {\n        // Convert Buffers to strings if needed\n        const keyStr = Buffer.isBuffer(key) ? key.toString() : key\n        const valueStr = Buffer.isBuffer(value) ? value.toString() : value\n        normalizedHeaders[keyStr.toLowerCase()] = valueStr\n      }\n    }\n    return normalizedHeaders\n  }\n\n  // Handle object format\n  if (headers && typeof headers === 'object') {\n    for (const [key, value] of Object.entries(headers)) {\n      if (key && typeof key === 'string') {\n        normalizedHeaders[key.toLowerCase()] = Array.isArray(value) ? value.join(', ') : String(value)\n      }\n    }\n  }\n\n  return normalizedHeaders\n}\n\nconst validSnapshotModes = /** @type {const} */ (['record', 'playback', 'update'])\n\n/** @typedef {typeof validSnapshotModes[number]} SnapshotMode */\n\n/**\n * @param {*} mode - The snapshot mode to validate\n * @returns {asserts mode is SnapshotMode}\n */\nfunction validateSnapshotMode (mode) {\n  if (!validSnapshotModes.includes(mode)) {\n    throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be one of: ${validSnapshotModes.join(', ')}`)\n  }\n}\n\nmodule.exports = {\n  createHeaderFilters,\n  hashId,\n  isUndiciHeaders,\n  normalizeHeaders,\n  isUrlExcludedFactory,\n  validateSnapshotMode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3NuYXBzaG90LXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDZGQUE2Qjs7QUFFakU7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGFBQWE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsK0NBQStDO0FBQy9DLFVBQVUsb0ZBQW9GOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1CQUFPLENBQUMsZ0NBQWE7QUFDekI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDOztBQUVBLGVBQWUsbUNBQW1DO0FBQ2xELGNBQWMsZUFBZTtBQUM3QixjQUFjLGlDQUFpQzs7QUFFL0M7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDLGNBQWMsbUNBQW1DOztBQUVqRDtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSyxvQkFBb0IsOEJBQThCO0FBQ3BIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXHNuYXBzaG90LXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IHJ1bnRpbWVGZWF0dXJlcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9ydW50aW1lLWZlYXR1cmVzLmpzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIZWFkZXJGaWx0ZXJzXG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSBpZ25vcmUgLSBTZXQgb2YgaGVhZGVycyB0byBpZ25vcmUgZm9yIG1hdGNoaW5nXG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSBleGNsdWRlIC0gU2V0IG9mIGhlYWRlcnMgdG8gZXhjbHVkZSBmcm9tIG1hdGNoaW5nXG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSBtYXRjaCAtIFNldCBvZiBoZWFkZXJzIHRvIG1hdGNoIChlbXB0eSBtZWFucyBtYXRjaFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjYWNoZWQgaGVhZGVyIHNldHMgZm9yIHBlcmZvcm1hbmNlXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vc25hcHNob3QtcmVjb3JkZXInKS5TbmFwc2hvdFJlY29yZGVyTWF0Y2hPcHRpb25zfSBtYXRjaE9wdGlvbnMgLSBNYXRjaGluZyBvcHRpb25zIGZvciBoZWFkZXJzXG4gKiBAcmV0dXJucyB7SGVhZGVyRmlsdGVyc30gLSBDYWNoZWQgc2V0cyBmb3IgaWdub3JlLCBleGNsdWRlLCBhbmQgbWF0Y2ggaGVhZGVyc1xuICovXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJGaWx0ZXJzIChtYXRjaE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGlnbm9yZUhlYWRlcnMgPSBbXSwgZXhjbHVkZUhlYWRlcnMgPSBbXSwgbWF0Y2hIZWFkZXJzID0gW10sIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSB9ID0gbWF0Y2hPcHRpb25zXG5cbiAgcmV0dXJuIHtcbiAgICBpZ25vcmU6IG5ldyBTZXQoaWdub3JlSGVhZGVycy5tYXAoaGVhZGVyID0+IGNhc2VTZW5zaXRpdmUgPyBoZWFkZXIgOiBoZWFkZXIudG9Mb3dlckNhc2UoKSkpLFxuICAgIGV4Y2x1ZGU6IG5ldyBTZXQoZXhjbHVkZUhlYWRlcnMubWFwKGhlYWRlciA9PiBjYXNlU2Vuc2l0aXZlID8gaGVhZGVyIDogaGVhZGVyLnRvTG93ZXJDYXNlKCkpKSxcbiAgICBtYXRjaDogbmV3IFNldChtYXRjaEhlYWRlcnMubWFwKGhlYWRlciA9PiBjYXNlU2Vuc2l0aXZlID8gaGVhZGVyIDogaGVhZGVyLnRvTG93ZXJDYXNlKCkpKVxuICB9XG59XG5cbmNvbnN0IGNyeXB0byA9IHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ2NyeXB0bycpXG4gID8gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuICA6IG51bGxcblxuLyoqXG4gKiBAY2FsbGJhY2sgSGFzaElkRnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBiYXNlNjR1cmwgZW5jb2RlZCBoYXNoIG9mIHRoZSB2YWx1ZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVzIGEgaGFzaCBmb3IgYSBnaXZlbiB2YWx1ZVxuICogQHR5cGUge0hhc2hJZEZ1bmN0aW9ufVxuICovXG5jb25zdCBoYXNoSWQgPSBjcnlwdG8/Lmhhc2hcbiAgPyAodmFsdWUpID0+IGNyeXB0by5oYXNoKCdzaGEyNTYnLCB2YWx1ZSwgJ2Jhc2U2NHVybCcpXG4gIDogKHZhbHVlKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoJ2Jhc2U2NHVybCcpXG5cbi8qKlxuICogQHR5cGVkZWYgeyh1cmw6IHN0cmluZykgPT4gYm9vbGVhbn0gSXNVcmxFeGNsdWRlZCBDaGVja3MgaWYgYSBVUkwgbWF0Y2hlcyBhbnkgb2YgdGhlIGV4Y2x1ZGUgcGF0dGVybnNcbiAqL1xuXG4vKiogQHR5cGVkZWYge3tba2V5OiBMb3dlcmNhc2U8c3RyaW5nPl06IHN0cmluZ319IE5vcm1hbGl6ZWRIZWFkZXJzICovXG4vKiogQHR5cGVkZWYge0FycmF5PHN0cmluZz59IFVuZGljaUhlYWRlcnMgKi9cbi8qKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgc3RyaW5nfHN0cmluZ1tdPn0gSGVhZGVycyAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gaGVhZGVyc1xuICogQHJldHVybnMge2hlYWRlcnMgaXMgVW5kaWNpSGVhZGVyc31cbiAqL1xuZnVuY3Rpb24gaXNVbmRpY2lIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGhlYWRlcnMpICYmIChoZWFkZXJzLmxlbmd0aCAmIDEpID09PSAwXG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYSBVUkwgZXhjbHVzaW9uIGNoZWNrZXJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfCBSZWdFeHA+fSBbZXhjbHVkZVBhdHRlcm5zPVtdXSAtIEFycmF5IG9mIHBhdHRlcm5zIHRvIGV4Y2x1ZGVcbiAqIEByZXR1cm5zIHtJc1VybEV4Y2x1ZGVkfSAtIEEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBVUkwgbWF0Y2hlcyBhbnkgb2YgdGhlIGV4Y2x1ZGUgcGF0dGVybnNcbiAqL1xuZnVuY3Rpb24gaXNVcmxFeGNsdWRlZEZhY3RvcnkgKGV4Y2x1ZGVQYXR0ZXJucyA9IFtdKSB7XG4gIGlmIChleGNsdWRlUGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICgpID0+IGZhbHNlXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gaXNVcmxFeGNsdWRlZCAodXJsKSB7XG4gICAgbGV0IHVybExvd2VyQ2FzZWRcblxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBleGNsdWRlUGF0dGVybnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF1cmxMb3dlckNhc2VkKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBVUkwgdG8gbG93ZXJjYXNlIG9ubHkgb25jZVxuICAgICAgICAgIHVybExvd2VyQ2FzZWQgPSB1cmwudG9Mb3dlckNhc2UoKVxuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXBsZSBzdHJpbmcgbWF0Y2ggKGNhc2UtaW5zZW5zaXRpdmUpXG4gICAgICAgIGlmICh1cmxMb3dlckNhc2VkLmluY2x1ZGVzKHBhdHRlcm4udG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgLy8gUmVnZXggcGF0dGVybiBtYXRjaFxuICAgICAgICBpZiAocGF0dGVybi50ZXN0KHVybCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGhlYWRlcnMgZm9yIGNvbnNpc3RlbnQgY29tcGFyaXNvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFVuZGljaUhlYWRlcnN9IGhlYWRlcnMgLSBIZWFkZXJzIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge05vcm1hbGl6ZWRIZWFkZXJzfSAtIE5vcm1hbGl6ZWQgaGVhZGVycyBhcyBhIGxvd2VyY2FzZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVycyAoaGVhZGVycykge1xuICAvKiogQHR5cGUge05vcm1hbGl6ZWRIZWFkZXJzfSAqL1xuICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IHt9XG5cbiAgaWYgKCFoZWFkZXJzKSByZXR1cm4gbm9ybWFsaXplZEhlYWRlcnNcblxuICAvLyBIYW5kbGUgYXJyYXkgZm9ybWF0ICh1bmRpY2kgaW50ZXJuYWwgZm9ybWF0OiBbbmFtZSwgdmFsdWUsIG5hbWUsIHZhbHVlLCAuLi5dKVxuICBpZiAoaXNVbmRpY2lIZWFkZXJzKGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBoZWFkZXJzW2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnNbaSArIDFdXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ29udmVydCBCdWZmZXJzIHRvIHN0cmluZ3MgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IGtleVN0ciA9IEJ1ZmZlci5pc0J1ZmZlcihrZXkpID8ga2V5LnRvU3RyaW5nKCkgOiBrZXlcbiAgICAgICAgY29uc3QgdmFsdWVTdHIgPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG4gICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzW2tleVN0ci50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlU3RyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkSGVhZGVyc1xuICB9XG5cbiAgLy8gSGFuZGxlIG9iamVjdCBmb3JtYXRcbiAgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgIGlmIChrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9ybWFsaXplZEhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogU3RyaW5nKHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkSGVhZGVyc1xufVxuXG5jb25zdCB2YWxpZFNuYXBzaG90TW9kZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydyZWNvcmQnLCAncGxheWJhY2snLCAndXBkYXRlJ10pXG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIHZhbGlkU25hcHNob3RNb2Rlc1tudW1iZXJdfSBTbmFwc2hvdE1vZGUgKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG1vZGUgLSBUaGUgc25hcHNob3QgbW9kZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Fzc2VydHMgbW9kZSBpcyBTbmFwc2hvdE1vZGV9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU25hcHNob3RNb2RlIChtb2RlKSB7XG4gIGlmICghdmFsaWRTbmFwc2hvdE1vZGVzLmluY2x1ZGVzKG1vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBJbnZhbGlkIHNuYXBzaG90IG1vZGU6ICR7bW9kZX0uIE11c3QgYmUgb25lIG9mOiAke3ZhbGlkU25hcHNob3RNb2Rlcy5qb2luKCcsICcpfWApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUhlYWRlckZpbHRlcnMsXG4gIGhhc2hJZCxcbiAgaXNVbmRpY2lIZWFkZXJzLFxuICBub3JtYWxpemVIZWFkZXJzLFxuICBpc1VybEV4Y2x1ZGVkRmFjdG9yeSxcbiAgdmFsaWRhdGVTbmFwc2hvdE1vZGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/snapshot-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/cache.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/util/cache.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  safeHTTPMethods,\n  pathHasQueryOrFragment\n} = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchOptions} opts\n */\nfunction makeCacheKey (opts) {\n  if (!opts.origin) {\n    throw new Error('opts.origin is undefined')\n  }\n\n  let fullPath = opts.path || '/'\n\n  if (opts.query && !pathHasQueryOrFragment(opts.path)) {\n    fullPath = serializePathWithQuery(fullPath, opts.query)\n  }\n\n  return {\n    origin: opts.origin.toString(),\n    method: opts.method,\n    path: fullPath,\n    headers: opts.headers\n  }\n}\n\n/**\n * @param {Record<string, string[] | string>}\n * @returns {Record<string, string[] | string>}\n */\nfunction normalizeHeaders (opts) {\n  let headers\n  if (opts.headers == null) {\n    headers = {}\n  } else if (typeof opts.headers[Symbol.iterator] === 'function') {\n    headers = {}\n    for (const x of opts.headers) {\n      if (!Array.isArray(x)) {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      const [key, val] = x\n      if (typeof key !== 'string' || typeof val !== 'string') {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      headers[key.toLowerCase()] = val\n    }\n  } else if (typeof opts.headers === 'object') {\n    headers = {}\n\n    for (const key of Object.keys(opts.headers)) {\n      headers[key.toLowerCase()] = opts.headers[key]\n    }\n  } else {\n    throw new Error('opts.headers is not an object')\n  }\n\n  return headers\n}\n\n/**\n * @param {any} key\n */\nfunction assertCacheKey (key) {\n  if (typeof key !== 'object') {\n    throw new TypeError(`expected key to be object, got ${typeof key}`)\n  }\n\n  for (const property of ['origin', 'method', 'path']) {\n    if (typeof key[property] !== 'string') {\n      throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`)\n    }\n  }\n\n  if (key.headers !== undefined && typeof key.headers !== 'object') {\n    throw new TypeError(`expected headers to be object, got ${typeof key}`)\n  }\n}\n\n/**\n * @param {any} value\n */\nfunction assertCacheValue (value) {\n  if (typeof value !== 'object') {\n    throw new TypeError(`expected value to be object, got ${typeof value}`)\n  }\n\n  for (const property of ['statusCode', 'cachedAt', 'staleAt', 'deleteAt']) {\n    if (typeof value[property] !== 'number') {\n      throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`)\n    }\n  }\n\n  if (typeof value.statusMessage !== 'string') {\n    throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`)\n  }\n\n  if (value.headers != null && typeof value.headers !== 'object') {\n    throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`)\n  }\n\n  if (value.vary !== undefined && typeof value.vary !== 'object') {\n    throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`)\n  }\n\n  if (value.etag !== undefined && typeof value.etag !== 'string') {\n    throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-cache-control\n * @see https://www.iana.org/assignments/http-cache-directives/http-cache-directives.xhtml\n\n * @param {string | string[]} header\n * @returns {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n */\nfunction parseCacheControlHeader (header) {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n   */\n  const output = {}\n\n  let directives\n  if (Array.isArray(header)) {\n    directives = []\n\n    for (const directive of header) {\n      directives.push(...directive.split(','))\n    }\n  } else {\n    directives = header.split(',')\n  }\n\n  for (let i = 0; i < directives.length; i++) {\n    const directive = directives[i].toLowerCase()\n    const keyValueDelimiter = directive.indexOf('=')\n\n    let key\n    let value\n    if (keyValueDelimiter !== -1) {\n      key = directive.substring(0, keyValueDelimiter).trimStart()\n      value = directive.substring(keyValueDelimiter + 1)\n    } else {\n      key = directive.trim()\n    }\n\n    switch (key) {\n      case 'min-fresh':\n      case 'max-stale':\n      case 'max-age':\n      case 's-maxage':\n      case 'stale-while-revalidate':\n      case 'stale-if-error': {\n        if (value === undefined || value[0] === ' ') {\n          continue\n        }\n\n        if (\n          value.length >= 2 &&\n          value[0] === '\"' &&\n          value[value.length - 1] === '\"'\n        ) {\n          value = value.substring(1, value.length - 1)\n        }\n\n        const parsedValue = parseInt(value, 10)\n        // eslint-disable-next-line no-self-compare\n        if (parsedValue !== parsedValue) {\n          continue\n        }\n\n        if (key === 'max-age' && key in output && output[key] >= parsedValue) {\n          continue\n        }\n\n        output[key] = parsedValue\n\n        break\n      }\n      case 'private':\n      case 'no-cache': {\n        if (value) {\n          // The private and no-cache directives can be unqualified (aka just\n          //  `private` or `no-cache`) or qualified (w/ a value). When they're\n          //  qualified, it's a list of headers like `no-cache=header1`,\n          //  `no-cache=\"header1\"`, or `no-cache=\"header1, header2\"`\n          // If we're given multiple headers, the comma messes us up since\n          //  we split the full header by commas. So, let's loop through the\n          //  remaining parts in front of us until we find one that ends in a\n          //  quote. We can then just splice all of the parts in between the\n          //  starting quote and the ending quote out of the directives array\n          //  and continue parsing like normal.\n          // https://www.rfc-editor.org/rfc/rfc9111.html#name-no-cache-2\n          if (value[0] === '\"') {\n            // Something like `no-cache=\"some-header\"` OR `no-cache=\"some-header, another-header\"`.\n\n            // Add the first header on and cut off the leading quote\n            const headers = [value.substring(1)]\n\n            let foundEndingQuote = value[value.length - 1] === '\"'\n            if (!foundEndingQuote) {\n              // Something like `no-cache=\"some-header, another-header\"`\n              //  This can still be something invalid, e.g. `no-cache=\"some-header, ...`\n              for (let j = i + 1; j < directives.length; j++) {\n                const nextPart = directives[j]\n                const nextPartLength = nextPart.length\n\n                headers.push(nextPart.trim())\n\n                if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '\"') {\n                  foundEndingQuote = true\n                  break\n                }\n              }\n            }\n\n            if (foundEndingQuote) {\n              let lastHeader = headers[headers.length - 1]\n              if (lastHeader[lastHeader.length - 1] === '\"') {\n                lastHeader = lastHeader.substring(0, lastHeader.length - 1)\n                headers[headers.length - 1] = lastHeader\n              }\n\n              if (key in output) {\n                output[key] = output[key].concat(headers)\n              } else {\n                output[key] = headers\n              }\n            }\n          } else {\n            // Something like `no-cache=\"some-header\"`\n            if (key in output) {\n              output[key] = output[key].concat(value)\n            } else {\n              output[key] = [value]\n            }\n          }\n\n          break\n        }\n      }\n      // eslint-disable-next-line no-fallthrough\n      case 'public':\n      case 'no-store':\n      case 'must-revalidate':\n      case 'proxy-revalidate':\n      case 'immutable':\n      case 'no-transform':\n      case 'must-understand':\n      case 'only-if-cached':\n        if (value) {\n          // These are qualified (something like `public=...`) when they aren't\n          //  allowed to be, skip\n          continue\n        }\n\n        output[key] = true\n        break\n      default:\n        // Ignore unknown directives as per https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.3-1\n        continue\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string | string[]} varyHeader Vary header from the server\n * @param {Record<string, string | string[]>} headers Request headers\n * @returns {Record<string, string | string[]>}\n */\nfunction parseVaryHeader (varyHeader, headers) {\n  if (typeof varyHeader === 'string' && varyHeader.includes('*')) {\n    return headers\n  }\n\n  const output = /** @type {Record<string, string | string[] | null>} */ ({})\n\n  const varyingHeaders = typeof varyHeader === 'string'\n    ? varyHeader.split(',')\n    : varyHeader\n\n  for (const header of varyingHeaders) {\n    const trimmedHeader = header.trim().toLowerCase()\n\n    output[trimmedHeader] = headers[trimmedHeader] ?? null\n  }\n\n  return output\n}\n\n/**\n * Note: this deviates from the spec a little. Empty etags (\"\", W/\"\") are valid,\n *  however, including them in cached resposnes serves little to no purpose.\n *\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-etag\n *\n * @param {string} etag\n * @returns {boolean}\n */\nfunction isEtagUsable (etag) {\n  if (etag.length <= 2) {\n    // Shortest an etag can be is two chars (just \"\"). This is where we deviate\n    //  from the spec requiring a min of 3 chars however\n    return false\n  }\n\n  if (etag[0] === '\"' && etag[etag.length - 1] === '\"') {\n    // ETag: \"\"asd123\"\" or ETag: \"W/\"asd123\"\", kinda undefined behavior in the\n    //  spec. Some servers will accept these while others don't.\n    // ETag: \"asd123\"\n    return !(etag[1] === '\"' || etag.startsWith('\"W/'))\n  }\n\n  if (etag.startsWith('W/\"') && etag[etag.length - 1] === '\"') {\n    // ETag: W/\"\", also where we deviate from the spec & require a min of 3\n    //  chars\n    // ETag: for W/\"\", W/\"asd123\"\n    return etag.length !== 4\n  }\n\n  // Anything else\n  return false\n}\n\n/**\n * @param {unknown} store\n * @returns {asserts store is import('../../types/cache-interceptor.d.ts').default.CacheStore}\n */\nfunction assertCacheStore (store, name = 'CacheStore') {\n  if (typeof store !== 'object' || store === null) {\n    throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? 'null' : typeof store}`)\n  }\n\n  for (const fn of ['get', 'createWriteStream', 'delete']) {\n    if (typeof store[fn] !== 'function') {\n      throw new TypeError(`${name} needs to have a \\`${fn}()\\` function`)\n    }\n  }\n}\n/**\n * @param {unknown} methods\n * @returns {asserts methods is import('../../types/cache-interceptor.d.ts').default.CacheMethods[]}\n */\nfunction assertCacheMethods (methods, name = 'CacheMethods') {\n  if (!Array.isArray(methods)) {\n    throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? 'null' : typeof methods}`)\n  }\n\n  if (methods.length === 0) {\n    throw new TypeError(`${name} needs to have at least one method`)\n  }\n\n  for (const method of methods) {\n    if (!safeHTTPMethods.includes(method)) {\n      throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(', ')}, got ${method}`)\n    }\n  }\n}\n\n/**\n * Creates a string key for request deduplication purposes.\n * This key is used to identify in-flight requests that can be shared.\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {Set<string>} [excludeHeaders] Set of lowercase header names to exclude from the key\n * @returns {string}\n */\nfunction makeDeduplicationKey (cacheKey, excludeHeaders) {\n  // Create a deterministic string key from the cache key\n  // Include origin, method, path, and sorted headers\n  let key = `${cacheKey.origin}:${cacheKey.method}:${cacheKey.path}`\n\n  if (cacheKey.headers) {\n    const sortedHeaders = Object.keys(cacheKey.headers).sort()\n    for (const header of sortedHeaders) {\n      // Skip excluded headers\n      if (excludeHeaders?.has(header.toLowerCase())) {\n        continue\n      }\n      const value = cacheKey.headers[header]\n      key += `:${header}=${Array.isArray(value) ? value.join(',') : value}`\n    }\n  }\n\n  return key\n}\n\nmodule.exports = {\n  makeCacheKey,\n  normalizeHeaders,\n  assertCacheKey,\n  assertCacheValue,\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable,\n  assertCacheMethods,\n  assertCacheStore,\n  makeDeduplicationKey\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUUxQixRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRXpEO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxvQkFBb0IscUJBQXFCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxvQkFBb0IsdUJBQXVCO0FBQ2pHO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsMkJBQTJCO0FBQ3JHOztBQUVBO0FBQ0EsdUVBQXVFLHFCQUFxQjtBQUM1Rjs7QUFFQTtBQUNBLGlFQUFpRSxrQkFBa0I7QUFDbkY7O0FBRUE7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBDQUEwQyxNQUFNOztBQUU1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sMEJBQTBCLHVDQUF1QztBQUNuSDs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sb0JBQW9CLEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNLDRCQUE0QiwyQ0FBMkM7QUFDekg7O0FBRUE7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUssOENBQThDLDJCQUEyQixRQUFRLE9BQU87QUFDckk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQStEO0FBQzFFLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGNBQWM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxHQUFHLCtDQUErQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcdXRpbFxcY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgc2FmZUhUVFBNZXRob2RzLFxuICBwYXRoSGFzUXVlcnlPckZyYWdtZW50XG59ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY29uc3QgeyBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoT3B0aW9uc30gb3B0c1xuICovXG5mdW5jdGlvbiBtYWtlQ2FjaGVLZXkgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLm9yaWdpbikge1xuICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5vcmlnaW4gaXMgdW5kZWZpbmVkJylcbiAgfVxuXG4gIGxldCBmdWxsUGF0aCA9IG9wdHMucGF0aCB8fCAnLydcblxuICBpZiAob3B0cy5xdWVyeSAmJiAhcGF0aEhhc1F1ZXJ5T3JGcmFnbWVudChvcHRzLnBhdGgpKSB7XG4gICAgZnVsbFBhdGggPSBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5KGZ1bGxQYXRoLCBvcHRzLnF1ZXJ5KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcmlnaW46IG9wdHMub3JpZ2luLnRvU3RyaW5nKCksXG4gICAgbWV0aG9kOiBvcHRzLm1ldGhvZCxcbiAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nW10gfCBzdHJpbmc+fVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdIHwgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVycyAob3B0cykge1xuICBsZXQgaGVhZGVyc1xuICBpZiAob3B0cy5oZWFkZXJzID09IG51bGwpIHtcbiAgICBoZWFkZXJzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5oZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBoZWFkZXJzID0ge31cbiAgICBmb3IgKGNvbnN0IHggb2Ygb3B0cy5oZWFkZXJzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmhlYWRlcnMgaXMgbm90IGEgdmFsaWQgaGVhZGVyIG1hcCcpXG4gICAgICB9XG4gICAgICBjb25zdCBba2V5LCB2YWxdID0geFxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5oZWFkZXJzIGlzIG5vdCBhIHZhbGlkIGhlYWRlciBtYXAnKVxuICAgICAgfVxuICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBoZWFkZXJzID0ge31cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gb3B0cy5oZWFkZXJzW2tleV1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmhlYWRlcnMgaXMgbm90IGFuIG9iamVjdCcpXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q2FjaGVLZXkgKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2Yga2V5fWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFsnb3JpZ2luJywgJ21ldGhvZCcsICdwYXRoJ10pIHtcbiAgICBpZiAodHlwZW9mIGtleVtwcm9wZXJ0eV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkuJHtwcm9wZXJ0eX0gdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2Yga2V5W3Byb3BlcnR5XX1gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkuaGVhZGVycyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBrZXkuaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBoZWFkZXJzIHRvIGJlIG9iamVjdCwgZ290ICR7dHlwZW9mIGtleX1gKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydENhY2hlVmFsdWUgKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2YgdmFsdWV9YClcbiAgfVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgWydzdGF0dXNDb2RlJywgJ2NhY2hlZEF0JywgJ3N0YWxlQXQnLCAnZGVsZXRlQXQnXSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUuJHtwcm9wZXJ0eX0gdG8gYmUgbnVtYmVyLCBnb3QgJHt0eXBlb2YgdmFsdWVbcHJvcGVydHldfWApXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5zdGF0dXNNZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlLnN0YXR1c01lc3NhZ2UgdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdmFsdWUuc3RhdHVzTWVzc2FnZX1gKVxuICB9XG5cbiAgaWYgKHZhbHVlLmhlYWRlcnMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB2YWx1ZS5yYXdIZWFkZXJzIHRvIGJlIG9iamVjdCwgZ290ICR7dHlwZW9mIHZhbHVlLmhlYWRlcnN9YClcbiAgfVxuXG4gIGlmICh2YWx1ZS52YXJ5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlLnZhcnkgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUudmFyeSB0byBiZSBvYmplY3QsIGdvdCAke3R5cGVvZiB2YWx1ZS52YXJ5fWApXG4gIH1cblxuICBpZiAodmFsdWUuZXRhZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZS5ldGFnICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlLmV0YWcgdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdmFsdWUuZXRhZ31gKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtY2FjaGUtY29udHJvbFxuICogQHNlZSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9odHRwLWNhY2hlLWRpcmVjdGl2ZXMvaHR0cC1jYWNoZS1kaXJlY3RpdmVzLnhodG1sXG5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGhlYWRlclxuICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc31cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIgKGhlYWRlcikge1xuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc31cbiAgICovXG4gIGNvbnN0IG91dHB1dCA9IHt9XG5cbiAgbGV0IGRpcmVjdGl2ZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyKSkge1xuICAgIGRpcmVjdGl2ZXMgPSBbXVxuXG4gICAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2YgaGVhZGVyKSB7XG4gICAgICBkaXJlY3RpdmVzLnB1c2goLi4uZGlyZWN0aXZlLnNwbGl0KCcsJykpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpcmVjdGl2ZXMgPSBoZWFkZXIuc3BsaXQoJywnKVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gZGlyZWN0aXZlc1tpXS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3Qga2V5VmFsdWVEZWxpbWl0ZXIgPSBkaXJlY3RpdmUuaW5kZXhPZignPScpXG5cbiAgICBsZXQga2V5XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKGtleVZhbHVlRGVsaW1pdGVyICE9PSAtMSkge1xuICAgICAga2V5ID0gZGlyZWN0aXZlLnN1YnN0cmluZygwLCBrZXlWYWx1ZURlbGltaXRlcikudHJpbVN0YXJ0KClcbiAgICAgIHZhbHVlID0gZGlyZWN0aXZlLnN1YnN0cmluZyhrZXlWYWx1ZURlbGltaXRlciArIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGRpcmVjdGl2ZS50cmltKClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnbWluLWZyZXNoJzpcbiAgICAgIGNhc2UgJ21heC1zdGFsZSc6XG4gICAgICBjYXNlICdtYXgtYWdlJzpcbiAgICAgIGNhc2UgJ3MtbWF4YWdlJzpcbiAgICAgIGNhc2UgJ3N0YWxlLXdoaWxlLXJldmFsaWRhdGUnOlxuICAgICAgY2FzZSAnc3RhbGUtaWYtZXJyb3InOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlWzBdID09PSAnICcpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgdmFsdWVbMF0gPT09ICdcIicgJiZcbiAgICAgICAgICB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJ1xuICAgICAgICApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9PSBwYXJzZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnbWF4LWFnZScgJiYga2V5IGluIG91dHB1dCAmJiBvdXRwdXRba2V5XSA+PSBwYXJzZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXRba2V5XSA9IHBhcnNlZFZhbHVlXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgY2FzZSAnbm8tY2FjaGUnOiB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBwcml2YXRlIGFuZCBuby1jYWNoZSBkaXJlY3RpdmVzIGNhbiBiZSB1bnF1YWxpZmllZCAoYWthIGp1c3RcbiAgICAgICAgICAvLyAgYHByaXZhdGVgIG9yIGBuby1jYWNoZWApIG9yIHF1YWxpZmllZCAody8gYSB2YWx1ZSkuIFdoZW4gdGhleSdyZVxuICAgICAgICAgIC8vICBxdWFsaWZpZWQsIGl0J3MgYSBsaXN0IG9mIGhlYWRlcnMgbGlrZSBgbm8tY2FjaGU9aGVhZGVyMWAsXG4gICAgICAgICAgLy8gIGBuby1jYWNoZT1cImhlYWRlcjFcImAsIG9yIGBuby1jYWNoZT1cImhlYWRlcjEsIGhlYWRlcjJcImBcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBnaXZlbiBtdWx0aXBsZSBoZWFkZXJzLCB0aGUgY29tbWEgbWVzc2VzIHVzIHVwIHNpbmNlXG4gICAgICAgICAgLy8gIHdlIHNwbGl0IHRoZSBmdWxsIGhlYWRlciBieSBjb21tYXMuIFNvLCBsZXQncyBsb29wIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gIHJlbWFpbmluZyBwYXJ0cyBpbiBmcm9udCBvZiB1cyB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGVuZHMgaW4gYVxuICAgICAgICAgIC8vICBxdW90ZS4gV2UgY2FuIHRoZW4ganVzdCBzcGxpY2UgYWxsIG9mIHRoZSBwYXJ0cyBpbiBiZXR3ZWVuIHRoZVxuICAgICAgICAgIC8vICBzdGFydGluZyBxdW90ZSBhbmQgdGhlIGVuZGluZyBxdW90ZSBvdXQgb2YgdGhlIGRpcmVjdGl2ZXMgYXJyYXlcbiAgICAgICAgICAvLyAgYW5kIGNvbnRpbnVlIHBhcnNpbmcgbGlrZSBub3JtYWwuXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLW5vLWNhY2hlLTJcbiAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBsaWtlIGBuby1jYWNoZT1cInNvbWUtaGVhZGVyXCJgIE9SIGBuby1jYWNoZT1cInNvbWUtaGVhZGVyLCBhbm90aGVyLWhlYWRlclwiYC5cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBmaXJzdCBoZWFkZXIgb24gYW5kIGN1dCBvZmYgdGhlIGxlYWRpbmcgcXVvdGVcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbdmFsdWUuc3Vic3RyaW5nKDEpXVxuXG4gICAgICAgICAgICBsZXQgZm91bmRFbmRpbmdRdW90ZSA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInXG4gICAgICAgICAgICBpZiAoIWZvdW5kRW5kaW5nUXVvdGUpIHtcbiAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGxpa2UgYG5vLWNhY2hlPVwic29tZS1oZWFkZXIsIGFub3RoZXItaGVhZGVyXCJgXG4gICAgICAgICAgICAgIC8vICBUaGlzIGNhbiBzdGlsbCBiZSBzb21ldGhpbmcgaW52YWxpZCwgZS5nLiBgbm8tY2FjaGU9XCJzb21lLWhlYWRlciwgLi4uYFxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBkaXJlY3RpdmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcnQgPSBkaXJlY3RpdmVzW2pdXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcnRMZW5ndGggPSBuZXh0UGFydC5sZW5ndGhcblxuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChuZXh0UGFydC50cmltKCkpXG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dFBhcnRMZW5ndGggIT09IDAgJiYgbmV4dFBhcnRbbmV4dFBhcnRMZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgZm91bmRFbmRpbmdRdW90ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3VuZEVuZGluZ1F1b3RlKSB7XG4gICAgICAgICAgICAgIGxldCBsYXN0SGVhZGVyID0gaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgIGlmIChsYXN0SGVhZGVyW2xhc3RIZWFkZXIubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBsYXN0SGVhZGVyID0gbGFzdEhlYWRlci5zdWJzdHJpbmcoMCwgbGFzdEhlYWRlci5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXSA9IGxhc3RIZWFkZXJcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChrZXkgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvdXRwdXRba2V5XS5jb25jYXQoaGVhZGVycylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGhlYWRlcnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgbGlrZSBgbm8tY2FjaGU9XCJzb21lLWhlYWRlclwiYFxuICAgICAgICAgICAgaWYgKGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvdXRwdXRba2V5XS5jb25jYXQodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IFt2YWx1ZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICBjYXNlICduby1zdG9yZSc6XG4gICAgICBjYXNlICdtdXN0LXJldmFsaWRhdGUnOlxuICAgICAgY2FzZSAncHJveHktcmV2YWxpZGF0ZSc6XG4gICAgICBjYXNlICdpbW11dGFibGUnOlxuICAgICAgY2FzZSAnbm8tdHJhbnNmb3JtJzpcbiAgICAgIGNhc2UgJ211c3QtdW5kZXJzdGFuZCc6XG4gICAgICBjYXNlICdvbmx5LWlmLWNhY2hlZCc6XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZXNlIGFyZSBxdWFsaWZpZWQgKHNvbWV0aGluZyBsaWtlIGBwdWJsaWM9Li4uYCkgd2hlbiB0aGV5IGFyZW4ndFxuICAgICAgICAgIC8vICBhbGxvd2VkIHRvIGJlLCBza2lwXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dFtrZXldID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gSWdub3JlIHVua25vd24gZGlyZWN0aXZlcyBhcyBwZXIgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNzZWN0aW9uLTUuMi4zLTFcbiAgICAgICAgY29udGludWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gdmFyeUhlYWRlciBWYXJ5IGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fSBoZWFkZXJzIFJlcXVlc3QgaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWYXJ5SGVhZGVyICh2YXJ5SGVhZGVyLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgdmFyeUhlYWRlciA9PT0gJ3N0cmluZycgJiYgdmFyeUhlYWRlci5pbmNsdWRlcygnKicpKSB7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsPn0gKi8gKHt9KVxuXG4gIGNvbnN0IHZhcnlpbmdIZWFkZXJzID0gdHlwZW9mIHZhcnlIZWFkZXIgPT09ICdzdHJpbmcnXG4gICAgPyB2YXJ5SGVhZGVyLnNwbGl0KCcsJylcbiAgICA6IHZhcnlIZWFkZXJcblxuICBmb3IgKGNvbnN0IGhlYWRlciBvZiB2YXJ5aW5nSGVhZGVycykge1xuICAgIGNvbnN0IHRyaW1tZWRIZWFkZXIgPSBoZWFkZXIudHJpbSgpLnRvTG93ZXJDYXNlKClcblxuICAgIG91dHB1dFt0cmltbWVkSGVhZGVyXSA9IGhlYWRlcnNbdHJpbW1lZEhlYWRlcl0gPz8gbnVsbFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIE5vdGU6IHRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhIGxpdHRsZS4gRW1wdHkgZXRhZ3MgKFwiXCIsIFcvXCJcIikgYXJlIHZhbGlkLFxuICogIGhvd2V2ZXIsIGluY2x1ZGluZyB0aGVtIGluIGNhY2hlZCByZXNwb3NuZXMgc2VydmVzIGxpdHRsZSB0byBubyBwdXJwb3NlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAuaHRtbCNuYW1lLWV0YWdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXRhZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRXRhZ1VzYWJsZSAoZXRhZykge1xuICBpZiAoZXRhZy5sZW5ndGggPD0gMikge1xuICAgIC8vIFNob3J0ZXN0IGFuIGV0YWcgY2FuIGJlIGlzIHR3byBjaGFycyAoanVzdCBcIlwiKS4gVGhpcyBpcyB3aGVyZSB3ZSBkZXZpYXRlXG4gICAgLy8gIGZyb20gdGhlIHNwZWMgcmVxdWlyaW5nIGEgbWluIG9mIDMgY2hhcnMgaG93ZXZlclxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGV0YWdbMF0gPT09ICdcIicgJiYgZXRhZ1tldGFnLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgLy8gRVRhZzogXCJcImFzZDEyM1wiXCIgb3IgRVRhZzogXCJXL1wiYXNkMTIzXCJcIiwga2luZGEgdW5kZWZpbmVkIGJlaGF2aW9yIGluIHRoZVxuICAgIC8vICBzcGVjLiBTb21lIHNlcnZlcnMgd2lsbCBhY2NlcHQgdGhlc2Ugd2hpbGUgb3RoZXJzIGRvbid0LlxuICAgIC8vIEVUYWc6IFwiYXNkMTIzXCJcbiAgICByZXR1cm4gIShldGFnWzFdID09PSAnXCInIHx8IGV0YWcuc3RhcnRzV2l0aCgnXCJXLycpKVxuICB9XG5cbiAgaWYgKGV0YWcuc3RhcnRzV2l0aCgnVy9cIicpICYmIGV0YWdbZXRhZy5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgIC8vIEVUYWc6IFcvXCJcIiwgYWxzbyB3aGVyZSB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgJiByZXF1aXJlIGEgbWluIG9mIDNcbiAgICAvLyAgY2hhcnNcbiAgICAvLyBFVGFnOiBmb3IgVy9cIlwiLCBXL1wiYXNkMTIzXCJcbiAgICByZXR1cm4gZXRhZy5sZW5ndGggIT09IDRcbiAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2VcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBzdG9yZVxuICogQHJldHVybnMge2Fzc2VydHMgc3RvcmUgaXMgaW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZVN0b3JlfVxuICovXG5mdW5jdGlvbiBhc3NlcnRDYWNoZVN0b3JlIChzdG9yZSwgbmFtZSA9ICdDYWNoZVN0b3JlJykge1xuICBpZiAodHlwZW9mIHN0b3JlICE9PSAnb2JqZWN0JyB8fCBzdG9yZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHR5cGUgb2YgJHtuYW1lfSB0byBiZSBhIENhY2hlU3RvcmUsIGdvdCAke3N0b3JlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHN0b3JlfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IGZuIG9mIFsnZ2V0JywgJ2NyZWF0ZVdyaXRlU3RyZWFtJywgJ2RlbGV0ZSddKSB7XG4gICAgaWYgKHR5cGVvZiBzdG9yZVtmbl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gbmVlZHMgdG8gaGF2ZSBhIFxcYCR7Zm59KClcXGAgZnVuY3Rpb25gKVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IG1ldGhvZHNcbiAqIEByZXR1cm5zIHthc3NlcnRzIG1ldGhvZHMgaXMgaW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZU1ldGhvZHNbXX1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q2FjaGVNZXRob2RzIChtZXRob2RzLCBuYW1lID0gJ0NhY2hlTWV0aG9kcycpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1ldGhvZHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9IG5lZWRzIHRvIGJlIGFuIGFycmF5LCBnb3QgJHttZXRob2RzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIG1ldGhvZHN9YClcbiAgfVxuXG4gIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgbWV0aG9kYClcbiAgfVxuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBpZiAoIXNhZmVIVFRQTWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbGVtZW50IG9mICR7bmFtZX0tYXJyYXkgbmVlZHMgdG8gYmUgb25lIG9mIGZvbGxvd2luZyB2YWx1ZXM6ICR7c2FmZUhUVFBNZXRob2RzLmpvaW4oJywgJyl9LCBnb3QgJHttZXRob2R9YClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGtleSBmb3IgcmVxdWVzdCBkZWR1cGxpY2F0aW9uIHB1cnBvc2VzLlxuICogVGhpcyBrZXkgaXMgdXNlZCB0byBpZGVudGlmeSBpbi1mbGlnaHQgcmVxdWVzdHMgdGhhdCBjYW4gYmUgc2hhcmVkLlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBjYWNoZUtleVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gW2V4Y2x1ZGVIZWFkZXJzXSBTZXQgb2YgbG93ZXJjYXNlIGhlYWRlciBuYW1lcyB0byBleGNsdWRlIGZyb20gdGhlIGtleVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbWFrZURlZHVwbGljYXRpb25LZXkgKGNhY2hlS2V5LCBleGNsdWRlSGVhZGVycykge1xuICAvLyBDcmVhdGUgYSBkZXRlcm1pbmlzdGljIHN0cmluZyBrZXkgZnJvbSB0aGUgY2FjaGUga2V5XG4gIC8vIEluY2x1ZGUgb3JpZ2luLCBtZXRob2QsIHBhdGgsIGFuZCBzb3J0ZWQgaGVhZGVyc1xuICBsZXQga2V5ID0gYCR7Y2FjaGVLZXkub3JpZ2lufToke2NhY2hlS2V5Lm1ldGhvZH06JHtjYWNoZUtleS5wYXRofWBcblxuICBpZiAoY2FjaGVLZXkuaGVhZGVycykge1xuICAgIGNvbnN0IHNvcnRlZEhlYWRlcnMgPSBPYmplY3Qua2V5cyhjYWNoZUtleS5oZWFkZXJzKS5zb3J0KClcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBzb3J0ZWRIZWFkZXJzKSB7XG4gICAgICAvLyBTa2lwIGV4Y2x1ZGVkIGhlYWRlcnNcbiAgICAgIGlmIChleGNsdWRlSGVhZGVycz8uaGFzKGhlYWRlci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjYWNoZUtleS5oZWFkZXJzW2hlYWRlcl1cbiAgICAgIGtleSArPSBgOiR7aGVhZGVyfT0ke0FycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWV9YFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ha2VDYWNoZUtleSxcbiAgbm9ybWFsaXplSGVhZGVycyxcbiAgYXNzZXJ0Q2FjaGVLZXksXG4gIGFzc2VydENhY2hlVmFsdWUsXG4gIHBhcnNlQ2FjaGVDb250cm9sSGVhZGVyLFxuICBwYXJzZVZhcnlIZWFkZXIsXG4gIGlzRXRhZ1VzYWJsZSxcbiAgYXNzZXJ0Q2FjaGVNZXRob2RzLFxuICBhc3NlcnRDYWNoZVN0b3JlLFxuICBtYWtlRGVkdXBsaWNhdGlvbktleVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/date.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/util/date.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-date-time-formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseHttpDate (date) {\n  // Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate\n  // Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format\n  // Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format\n\n  switch (date[3]) {\n    case ',': return parseImfDate(date)\n    case ' ': return parseAscTimeDate(date)\n    default: return parseRfc850Date(date)\n  }\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#preferred.date.format\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseImfDate (date) {\n  if (\n    date.length !== 29 ||\n    date[4] !== ' ' ||\n    date[7] !== ' ' ||\n    date[11] !== ' ' ||\n    date[16] !== ' ' ||\n    date[19] !== ':' ||\n    date[22] !== ':' ||\n    date[25] !== ' ' ||\n    date[26] !== 'G' ||\n    date[27] !== 'M' ||\n    date[28] !== 'T'\n  ) {\n    return undefined\n  }\n\n  let weekday = -1\n  if (date[0] === 'S' && date[1] === 'u' && date[2] === 'n') { // Sunday\n    weekday = 0\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n') { // Monday\n    weekday = 1\n  } else if (date[0] === 'T' && date[1] === 'u' && date[2] === 'e') { // Tuesday\n    weekday = 2\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd') { // Wednesday\n    weekday = 3\n  } else if (date[0] === 'T' && date[1] === 'h' && date[2] === 'u') { // Thursday\n    weekday = 4\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i') { // Friday\n    weekday = 5\n  } else if (date[0] === 'S' && date[1] === 'a' && date[2] === 't') { // Saturday\n    weekday = 6\n  } else {\n    return undefined // Not a valid day of the week\n  }\n\n  let day = 0\n  if (date[5] === '0') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(6)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(5)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(6)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let monthIdx = -1\n  if (\n    (date[8] === 'J' && date[9] === 'a' && date[10] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[8] === 'F' && date[9] === 'e' && date[10] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[8] === 'M' && date[9] === 'a')\n  ) {\n    if (date[10] === 'r') {\n      monthIdx = 2 // Mar\n    } else if (date[10] === 'y') {\n      monthIdx = 4 // May\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'J')\n  ) {\n    if (date[9] === 'a' && date[10] === 'n') {\n      monthIdx = 0 // Jan\n    } else if (date[9] === 'u') {\n      if (date[10] === 'n') {\n        monthIdx = 5 // Jun\n      } else if (date[10] === 'l') {\n        monthIdx = 6 // Jul\n      } else {\n        return undefined // Invalid month\n      }\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'A')\n  ) {\n    if (date[9] === 'p' && date[10] === 'r') {\n      monthIdx = 3 // Apr\n    } else if (date[9] === 'u' && date[10] === 'g') {\n      monthIdx = 7 // Aug\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'S' && date[9] === 'e' && date[10] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[8] === 'O' && date[9] === 'c' && date[10] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[8] === 'N' && date[9] === 'o' && date[10] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[8] === 'D' && date[9] === 'e' && date[10] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  const yearDigit1 = date.charCodeAt(12)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(13)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit3 = date.charCodeAt(14)\n  if (yearDigit3 < 48 || yearDigit3 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit4 = date.charCodeAt(15)\n  if (yearDigit4 < 48 || yearDigit4 > 57) {\n    return undefined // Not a digit\n  }\n  const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48)\n\n  let hour = 0\n  if (date[17] === '0') {\n    const code = date.charCodeAt(18)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(17)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(18)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[20] === '0') {\n    const code = date.charCodeAt(21)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(20)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(21)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[23] === '0') {\n    const code = date.charCodeAt(24)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(23)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(24)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseAscTimeDate (date) {\n  // This is assumed to be in UTC\n\n  if (\n    date.length !== 24 ||\n    date[7] !== ' ' ||\n    date[10] !== ' ' ||\n    date[19] !== ' '\n  ) {\n    return undefined\n  }\n\n  let weekday = -1\n  if (date[0] === 'S' && date[1] === 'u' && date[2] === 'n') { // Sunday\n    weekday = 0\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n') { // Monday\n    weekday = 1\n  } else if (date[0] === 'T' && date[1] === 'u' && date[2] === 'e') { // Tuesday\n    weekday = 2\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd') { // Wednesday\n    weekday = 3\n  } else if (date[0] === 'T' && date[1] === 'h' && date[2] === 'u') { // Thursday\n    weekday = 4\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i') { // Friday\n    weekday = 5\n  } else if (date[0] === 'S' && date[1] === 'a' && date[2] === 't') { // Saturday\n    weekday = 6\n  } else {\n    return undefined // Not a valid day of the week\n  }\n\n  let monthIdx = -1\n  if (\n    (date[4] === 'J' && date[5] === 'a' && date[6] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[4] === 'F' && date[5] === 'e' && date[6] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[4] === 'M' && date[5] === 'a')\n  ) {\n    if (date[6] === 'r') {\n      monthIdx = 2 // Mar\n    } else if (date[6] === 'y') {\n      monthIdx = 4 // May\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'J')\n  ) {\n    if (date[5] === 'a' && date[6] === 'n') {\n      monthIdx = 0 // Jan\n    } else if (date[5] === 'u') {\n      if (date[6] === 'n') {\n        monthIdx = 5 // Jun\n      } else if (date[6] === 'l') {\n        monthIdx = 6 // Jul\n      } else {\n        return undefined // Invalid month\n      }\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'A')\n  ) {\n    if (date[5] === 'p' && date[6] === 'r') {\n      monthIdx = 3 // Apr\n    } else if (date[5] === 'u' && date[6] === 'g') {\n      monthIdx = 7 // Aug\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'S' && date[5] === 'e' && date[6] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[4] === 'O' && date[5] === 'c' && date[6] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[4] === 'N' && date[5] === 'o' && date[6] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[4] === 'D' && date[5] === 'e' && date[6] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  let day = 0\n  if (date[8] === ' ') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(9)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(8)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(9)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let hour = 0\n  if (date[11] === '0') {\n    const code = date.charCodeAt(12)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(11)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(12)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[14] === '0') {\n    const code = date.charCodeAt(15)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(14)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(15)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[17] === '0') {\n    const code = date.charCodeAt(18)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(17)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(18)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const yearDigit1 = date.charCodeAt(20)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(21)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit3 = date.charCodeAt(22)\n  if (yearDigit3 < 48 || yearDigit3 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit4 = date.charCodeAt(23)\n  if (yearDigit4 < 48 || yearDigit4 > 57) {\n    return undefined // Not a digit\n  }\n  const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48)\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseRfc850Date (date) {\n  let commaIndex = -1\n\n  let weekday = -1\n  if (date[0] === 'S') {\n    if (date[1] === 'u' && date[2] === 'n' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n      weekday = 0 // Sunday\n      commaIndex = 6\n    } else if (date[1] === 'a' && date[2] === 't' && date[3] === 'u' && date[4] === 'r' && date[5] === 'd' && date[6] === 'a' && date[7] === 'y') {\n      weekday = 6 // Saturday\n      commaIndex = 8\n    }\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n    weekday = 1 // Monday\n    commaIndex = 6\n  } else if (date[0] === 'T') {\n    if (date[1] === 'u' && date[2] === 'e' && date[3] === 's' && date[4] === 'd' && date[5] === 'a' && date[6] === 'y') {\n      weekday = 2 // Tuesday\n      commaIndex = 7\n    } else if (date[1] === 'h' && date[2] === 'u' && date[3] === 'r' && date[4] === 's' && date[5] === 'd' && date[6] === 'a' && date[7] === 'y') {\n      weekday = 4 // Thursday\n      commaIndex = 8\n    }\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd' && date[3] === 'n' && date[4] === 'e' && date[5] === 's' && date[6] === 'd' && date[7] === 'a' && date[8] === 'y') {\n    weekday = 3 // Wednesday\n    commaIndex = 9\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n    weekday = 5 // Friday\n    commaIndex = 6\n  } else {\n    // Not a valid day name\n    return undefined\n  }\n\n  if (\n    date[commaIndex] !== ',' ||\n    (date.length - commaIndex - 1) !== 23 ||\n    date[commaIndex + 1] !== ' ' ||\n    date[commaIndex + 4] !== '-' ||\n    date[commaIndex + 8] !== '-' ||\n    date[commaIndex + 11] !== ' ' ||\n    date[commaIndex + 14] !== ':' ||\n    date[commaIndex + 17] !== ':' ||\n    date[commaIndex + 20] !== ' ' ||\n    date[commaIndex + 21] !== 'G' ||\n    date[commaIndex + 22] !== 'M' ||\n    date[commaIndex + 23] !== 'T'\n  ) {\n    return undefined\n  }\n\n  let day = 0\n  if (date[commaIndex + 2] === '0') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(commaIndex + 3)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 2)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(commaIndex + 3)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let monthIdx = -1\n  if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[commaIndex + 5] === 'F' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[commaIndex + 5] === 'M' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'r')\n  ) {\n    monthIdx = 2 // Mar\n  } else if (\n    (date[commaIndex + 5] === 'A' && date[commaIndex + 6] === 'p' && date[commaIndex + 7] === 'r')\n  ) {\n    monthIdx = 3 // Apr\n  } else if (\n    (date[commaIndex + 5] === 'M' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'y')\n  ) {\n    monthIdx = 4 // May\n  } else if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'n')\n  ) {\n    monthIdx = 5 // Jun\n  } else if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'l')\n  ) {\n    monthIdx = 6 // Jul\n  } else if (\n    (date[commaIndex + 5] === 'A' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'g')\n  ) {\n    monthIdx = 7 // Aug\n  } else if (\n    (date[commaIndex + 5] === 'S' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[commaIndex + 5] === 'O' && date[commaIndex + 6] === 'c' && date[commaIndex + 7] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[commaIndex + 5] === 'N' && date[commaIndex + 6] === 'o' && date[commaIndex + 7] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[commaIndex + 5] === 'D' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  const yearDigit1 = date.charCodeAt(commaIndex + 9)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(commaIndex + 10)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n\n  let year = (yearDigit1 - 48) * 10 + (yearDigit2 - 48) // Convert ASCII codes to number\n\n  // RFC 6265 states that the year is in the range 1970-2069.\n  // @see https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.1\n  //\n  // 3. If the year-value is greater than or equal to 70 and less than or\n  //    equal to 99, increment the year-value by 1900.\n  // 4. If the year-value is greater than or equal to 0 and less than or\n  //    equal to 69, increment the year-value by 2000.\n  year += year < 70 ? 2000 : 1900\n\n  let hour = 0\n  if (date[commaIndex + 12] === '0') {\n    const code = date.charCodeAt(commaIndex + 13)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 12)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(commaIndex + 13)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[commaIndex + 15] === '0') {\n    const code = date.charCodeAt(commaIndex + 16)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 15)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(commaIndex + 16)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[commaIndex + 18] === '0') {\n    const code = date.charCodeAt(commaIndex + 19)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 18)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(commaIndex + 19)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\nmodule.exports = {\n  parseHttpDate\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxJQUFJLGtFQUFrRTtBQUN0RTtBQUNBLElBQUksa0VBQWtFO0FBQ3RFO0FBQ0EsSUFBSSxrRUFBa0U7QUFDdEU7QUFDQSxJQUFJLGtFQUFrRTtBQUN0RTtBQUNBLElBQUksa0VBQWtFO0FBQ3RFO0FBQ0EsSUFBSSxrRUFBa0U7QUFDdEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxJQUFJLGtFQUFrRTtBQUN0RTtBQUNBLElBQUksa0VBQWtFO0FBQ3RFO0FBQ0EsSUFBSSxrRUFBa0U7QUFDdEU7QUFDQSxJQUFJLGtFQUFrRTtBQUN0RTtBQUNBLElBQUksa0VBQWtFO0FBQ3RFO0FBQ0EsSUFBSSxrRUFBa0U7QUFDdEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHV0aWxcXGRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMC5odG1sI25hbWUtZGF0ZS10aW1lLWZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVxuICogQHJldHVybnMge0RhdGUgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSHR0cERhdGUgKGRhdGUpIHtcbiAgLy8gU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQgICAgOyBJTUYtZml4ZGF0ZVxuICAvLyBTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQgICAgICAgICA7IEFOU0kgQydzIGFzY3RpbWUoKSBmb3JtYXRcbiAgLy8gU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UICAgOyBvYnNvbGV0ZSBSRkMgODUwIGZvcm1hdFxuXG4gIHN3aXRjaCAoZGF0ZVszXSkge1xuICAgIGNhc2UgJywnOiByZXR1cm4gcGFyc2VJbWZEYXRlKGRhdGUpXG4gICAgY2FzZSAnICc6IHJldHVybiBwYXJzZUFzY1RpbWVEYXRlKGRhdGUpXG4gICAgZGVmYXVsdDogcmV0dXJuIHBhcnNlUmZjODUwRGF0ZShkYXRlKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI3ByZWZlcnJlZC5kYXRlLmZvcm1hdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZSB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbWZEYXRlIChkYXRlKSB7XG4gIGlmIChcbiAgICBkYXRlLmxlbmd0aCAhPT0gMjkgfHxcbiAgICBkYXRlWzRdICE9PSAnICcgfHxcbiAgICBkYXRlWzddICE9PSAnICcgfHxcbiAgICBkYXRlWzExXSAhPT0gJyAnIHx8XG4gICAgZGF0ZVsxNl0gIT09ICcgJyB8fFxuICAgIGRhdGVbMTldICE9PSAnOicgfHxcbiAgICBkYXRlWzIyXSAhPT0gJzonIHx8XG4gICAgZGF0ZVsyNV0gIT09ICcgJyB8fFxuICAgIGRhdGVbMjZdICE9PSAnRycgfHxcbiAgICBkYXRlWzI3XSAhPT0gJ00nIHx8XG4gICAgZGF0ZVsyOF0gIT09ICdUJ1xuICApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBsZXQgd2Vla2RheSA9IC0xXG4gIGlmIChkYXRlWzBdID09PSAnUycgJiYgZGF0ZVsxXSA9PT0gJ3UnICYmIGRhdGVbMl0gPT09ICduJykgeyAvLyBTdW5kYXlcbiAgICB3ZWVrZGF5ID0gMFxuICB9IGVsc2UgaWYgKGRhdGVbMF0gPT09ICdNJyAmJiBkYXRlWzFdID09PSAnbycgJiYgZGF0ZVsyXSA9PT0gJ24nKSB7IC8vIE1vbmRheVxuICAgIHdlZWtkYXkgPSAxXG4gIH0gZWxzZSBpZiAoZGF0ZVswXSA9PT0gJ1QnICYmIGRhdGVbMV0gPT09ICd1JyAmJiBkYXRlWzJdID09PSAnZScpIHsgLy8gVHVlc2RheVxuICAgIHdlZWtkYXkgPSAyXG4gIH0gZWxzZSBpZiAoZGF0ZVswXSA9PT0gJ1cnICYmIGRhdGVbMV0gPT09ICdlJyAmJiBkYXRlWzJdID09PSAnZCcpIHsgLy8gV2VkbmVzZGF5XG4gICAgd2Vla2RheSA9IDNcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnVCcgJiYgZGF0ZVsxXSA9PT0gJ2gnICYmIGRhdGVbMl0gPT09ICd1JykgeyAvLyBUaHVyc2RheVxuICAgIHdlZWtkYXkgPSA0XG4gIH0gZWxzZSBpZiAoZGF0ZVswXSA9PT0gJ0YnICYmIGRhdGVbMV0gPT09ICdyJyAmJiBkYXRlWzJdID09PSAnaScpIHsgLy8gRnJpZGF5XG4gICAgd2Vla2RheSA9IDVcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnUycgJiYgZGF0ZVsxXSA9PT0gJ2EnICYmIGRhdGVbMl0gPT09ICd0JykgeyAvLyBTYXR1cmRheVxuICAgIHdlZWtkYXkgPSA2XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSB2YWxpZCBkYXkgb2YgdGhlIHdlZWtcbiAgfVxuXG4gIGxldCBkYXkgPSAwXG4gIGlmIChkYXRlWzVdID09PSAnMCcpIHtcbiAgICAvLyBTaW5nbGUgZGlnaXQgZGF5LCBlLmcuIFwiU3VuIE5vdiA2IDA4OjQ5OjM3IDE5OTRcIlxuICAgIGNvbnN0IGNvZGUgPSBkYXRlLmNoYXJDb2RlQXQoNilcbiAgICBpZiAoY29kZSA8IDQ5IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBkYXkgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KDUpXG4gICAgaWYgKGNvZGUxIDwgNDkgfHwgY29kZTEgPiA1MSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDEgYW5kIDNcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoNilcbiAgICBpZiAoY29kZTIgPCA0OCB8fCBjb2RlMiA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIGRheSA9IChjb2RlMSAtIDQ4KSAqIDEwICsgKGNvZGUyIC0gNDgpIC8vIENvbnZlcnQgQVNDSUkgY29kZXMgdG8gbnVtYmVyXG4gIH1cblxuICBsZXQgbW9udGhJZHggPSAtMVxuICBpZiAoXG4gICAgKGRhdGVbOF0gPT09ICdKJyAmJiBkYXRlWzldID09PSAnYScgJiYgZGF0ZVsxMF0gPT09ICduJylcbiAgKSB7XG4gICAgbW9udGhJZHggPSAwIC8vIEphblxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzhdID09PSAnRicgJiYgZGF0ZVs5XSA9PT0gJ2UnICYmIGRhdGVbMTBdID09PSAnYicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMSAvLyBGZWJcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVs4XSA9PT0gJ00nICYmIGRhdGVbOV0gPT09ICdhJylcbiAgKSB7XG4gICAgaWYgKGRhdGVbMTBdID09PSAncicpIHtcbiAgICAgIG1vbnRoSWR4ID0gMiAvLyBNYXJcbiAgICB9IGVsc2UgaWYgKGRhdGVbMTBdID09PSAneScpIHtcbiAgICAgIG1vbnRoSWR4ID0gNCAvLyBNYXlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBJbnZhbGlkIG1vbnRoXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzhdID09PSAnSicpXG4gICkge1xuICAgIGlmIChkYXRlWzldID09PSAnYScgJiYgZGF0ZVsxMF0gPT09ICduJykge1xuICAgICAgbW9udGhJZHggPSAwIC8vIEphblxuICAgIH0gZWxzZSBpZiAoZGF0ZVs5XSA9PT0gJ3UnKSB7XG4gICAgICBpZiAoZGF0ZVsxMF0gPT09ICduJykge1xuICAgICAgICBtb250aElkeCA9IDUgLy8gSnVuXG4gICAgICB9IGVsc2UgaWYgKGRhdGVbMTBdID09PSAnbCcpIHtcbiAgICAgICAgbW9udGhJZHggPSA2IC8vIEp1bFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBJbnZhbGlkIG1vbnRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gSW52YWxpZCBtb250aFxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVs4XSA9PT0gJ0EnKVxuICApIHtcbiAgICBpZiAoZGF0ZVs5XSA9PT0gJ3AnICYmIGRhdGVbMTBdID09PSAncicpIHtcbiAgICAgIG1vbnRoSWR4ID0gMyAvLyBBcHJcbiAgICB9IGVsc2UgaWYgKGRhdGVbOV0gPT09ICd1JyAmJiBkYXRlWzEwXSA9PT0gJ2cnKSB7XG4gICAgICBtb250aElkeCA9IDcgLy8gQXVnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gSW52YWxpZCBtb250aFxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVs4XSA9PT0gJ1MnICYmIGRhdGVbOV0gPT09ICdlJyAmJiBkYXRlWzEwXSA9PT0gJ3AnKVxuICApIHtcbiAgICBtb250aElkeCA9IDggLy8gU2VwXG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbOF0gPT09ICdPJyAmJiBkYXRlWzldID09PSAnYycgJiYgZGF0ZVsxMF0gPT09ICd0JylcbiAgKSB7XG4gICAgbW9udGhJZHggPSA5IC8vIE9jdFxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzhdID09PSAnTicgJiYgZGF0ZVs5XSA9PT0gJ28nICYmIGRhdGVbMTBdID09PSAndicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMTAgLy8gTm92XG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbOF0gPT09ICdEJyAmJiBkYXRlWzldID09PSAnZScgJiYgZGF0ZVsxMF0gPT09ICdjJylcbiAgKSB7XG4gICAgbW9udGhJZHggPSAxMSAvLyBEZWNcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3QgYSB2YWxpZCBtb250aFxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IHllYXJEaWdpdDEgPSBkYXRlLmNoYXJDb2RlQXQoMTIpXG4gIGlmICh5ZWFyRGlnaXQxIDwgNDggfHwgeWVhckRpZ2l0MSA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDIgPSBkYXRlLmNoYXJDb2RlQXQoMTMpXG4gIGlmICh5ZWFyRGlnaXQyIDwgNDggfHwgeWVhckRpZ2l0MiA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDMgPSBkYXRlLmNoYXJDb2RlQXQoMTQpXG4gIGlmICh5ZWFyRGlnaXQzIDwgNDggfHwgeWVhckRpZ2l0MyA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDQgPSBkYXRlLmNoYXJDb2RlQXQoMTUpXG4gIGlmICh5ZWFyRGlnaXQ0IDwgNDggfHwgeWVhckRpZ2l0NCA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXIgPSAoeWVhckRpZ2l0MSAtIDQ4KSAqIDEwMDAgKyAoeWVhckRpZ2l0MiAtIDQ4KSAqIDEwMCArICh5ZWFyRGlnaXQzIC0gNDgpICogMTAgKyAoeWVhckRpZ2l0NCAtIDQ4KVxuXG4gIGxldCBob3VyID0gMFxuICBpZiAoZGF0ZVsxN10gPT09ICcwJykge1xuICAgIGNvbnN0IGNvZGUgPSBkYXRlLmNoYXJDb2RlQXQoMTgpXG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgaG91ciA9IGNvZGUgLSA0OCAvLyBDb252ZXJ0IEFTQ0lJIGNvZGUgdG8gbnVtYmVyXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29kZTEgPSBkYXRlLmNoYXJDb2RlQXQoMTcpXG4gICAgaWYgKGNvZGUxIDwgNDggfHwgY29kZTEgPiA1MCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDAgYW5kIDJcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoMTgpXG4gICAgaWYgKGNvZGUyIDwgNDggfHwgY29kZTIgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBpZiAoY29kZTEgPT09IDUwICYmIGNvZGUyID4gNTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gSG91ciBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDIzXG4gICAgfVxuICAgIGhvdXIgPSAoY29kZTEgLSA0OCkgKiAxMCArIChjb2RlMiAtIDQ4KSAvLyBDb252ZXJ0IEFTQ0lJIGNvZGVzIHRvIG51bWJlclxuICB9XG5cbiAgbGV0IG1pbnV0ZSA9IDBcbiAgaWYgKGRhdGVbMjBdID09PSAnMCcpIHtcbiAgICBjb25zdCBjb2RlID0gZGF0ZS5jaGFyQ29kZUF0KDIxKVxuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIG1pbnV0ZSA9IGNvZGUgLSA0OCAvLyBDb252ZXJ0IEFTQ0lJIGNvZGUgdG8gbnVtYmVyXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29kZTEgPSBkYXRlLmNoYXJDb2RlQXQoMjApXG4gICAgaWYgKGNvZGUxIDwgNDggfHwgY29kZTEgPiA1Mykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDAgYW5kIDVcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoMjEpXG4gICAgaWYgKGNvZGUyIDwgNDggfHwgY29kZTIgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBtaW51dGUgPSAoY29kZTEgLSA0OCkgKiAxMCArIChjb2RlMiAtIDQ4KSAvLyBDb252ZXJ0IEFTQ0lJIGNvZGVzIHRvIG51bWJlclxuICB9XG5cbiAgbGV0IHNlY29uZCA9IDBcbiAgaWYgKGRhdGVbMjNdID09PSAnMCcpIHtcbiAgICBjb25zdCBjb2RlID0gZGF0ZS5jaGFyQ29kZUF0KDI0KVxuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIHNlY29uZCA9IGNvZGUgLSA0OCAvLyBDb252ZXJ0IEFTQ0lJIGNvZGUgdG8gbnVtYmVyXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29kZTEgPSBkYXRlLmNoYXJDb2RlQXQoMjMpXG4gICAgaWYgKGNvZGUxIDwgNDggfHwgY29kZTEgPiA1Mykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDAgYW5kIDVcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoMjQpXG4gICAgaWYgKGNvZGUyIDwgNDggfHwgY29kZTIgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBzZWNvbmQgPSAoY29kZTEgLSA0OCkgKiAxMCArIChjb2RlMiAtIDQ4KSAvLyBDb252ZXJ0IEFTQ0lJIGNvZGVzIHRvIG51bWJlclxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhJZHgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKVxuICByZXR1cm4gcmVzdWx0LmdldFVUQ0RheSgpID09PSB3ZWVrZGF5ID8gcmVzdWx0IDogdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI29ic29sZXRlLmRhdGUuZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZSB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VBc2NUaW1lRGF0ZSAoZGF0ZSkge1xuICAvLyBUaGlzIGlzIGFzc3VtZWQgdG8gYmUgaW4gVVRDXG5cbiAgaWYgKFxuICAgIGRhdGUubGVuZ3RoICE9PSAyNCB8fFxuICAgIGRhdGVbN10gIT09ICcgJyB8fFxuICAgIGRhdGVbMTBdICE9PSAnICcgfHxcbiAgICBkYXRlWzE5XSAhPT0gJyAnXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGxldCB3ZWVrZGF5ID0gLTFcbiAgaWYgKGRhdGVbMF0gPT09ICdTJyAmJiBkYXRlWzFdID09PSAndScgJiYgZGF0ZVsyXSA9PT0gJ24nKSB7IC8vIFN1bmRheVxuICAgIHdlZWtkYXkgPSAwXG4gIH0gZWxzZSBpZiAoZGF0ZVswXSA9PT0gJ00nICYmIGRhdGVbMV0gPT09ICdvJyAmJiBkYXRlWzJdID09PSAnbicpIHsgLy8gTW9uZGF5XG4gICAgd2Vla2RheSA9IDFcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnVCcgJiYgZGF0ZVsxXSA9PT0gJ3UnICYmIGRhdGVbMl0gPT09ICdlJykgeyAvLyBUdWVzZGF5XG4gICAgd2Vla2RheSA9IDJcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnVycgJiYgZGF0ZVsxXSA9PT0gJ2UnICYmIGRhdGVbMl0gPT09ICdkJykgeyAvLyBXZWRuZXNkYXlcbiAgICB3ZWVrZGF5ID0gM1xuICB9IGVsc2UgaWYgKGRhdGVbMF0gPT09ICdUJyAmJiBkYXRlWzFdID09PSAnaCcgJiYgZGF0ZVsyXSA9PT0gJ3UnKSB7IC8vIFRodXJzZGF5XG4gICAgd2Vla2RheSA9IDRcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnRicgJiYgZGF0ZVsxXSA9PT0gJ3InICYmIGRhdGVbMl0gPT09ICdpJykgeyAvLyBGcmlkYXlcbiAgICB3ZWVrZGF5ID0gNVxuICB9IGVsc2UgaWYgKGRhdGVbMF0gPT09ICdTJyAmJiBkYXRlWzFdID09PSAnYScgJiYgZGF0ZVsyXSA9PT0gJ3QnKSB7IC8vIFNhdHVyZGF5XG4gICAgd2Vla2RheSA9IDZcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIHZhbGlkIGRheSBvZiB0aGUgd2Vla1xuICB9XG5cbiAgbGV0IG1vbnRoSWR4ID0gLTFcbiAgaWYgKFxuICAgIChkYXRlWzRdID09PSAnSicgJiYgZGF0ZVs1XSA9PT0gJ2EnICYmIGRhdGVbNl0gPT09ICduJylcbiAgKSB7XG4gICAgbW9udGhJZHggPSAwIC8vIEphblxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzRdID09PSAnRicgJiYgZGF0ZVs1XSA9PT0gJ2UnICYmIGRhdGVbNl0gPT09ICdiJylcbiAgKSB7XG4gICAgbW9udGhJZHggPSAxIC8vIEZlYlxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzRdID09PSAnTScgJiYgZGF0ZVs1XSA9PT0gJ2EnKVxuICApIHtcbiAgICBpZiAoZGF0ZVs2XSA9PT0gJ3InKSB7XG4gICAgICBtb250aElkeCA9IDIgLy8gTWFyXG4gICAgfSBlbHNlIGlmIChkYXRlWzZdID09PSAneScpIHtcbiAgICAgIG1vbnRoSWR4ID0gNCAvLyBNYXlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBJbnZhbGlkIG1vbnRoXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzRdID09PSAnSicpXG4gICkge1xuICAgIGlmIChkYXRlWzVdID09PSAnYScgJiYgZGF0ZVs2XSA9PT0gJ24nKSB7XG4gICAgICBtb250aElkeCA9IDAgLy8gSmFuXG4gICAgfSBlbHNlIGlmIChkYXRlWzVdID09PSAndScpIHtcbiAgICAgIGlmIChkYXRlWzZdID09PSAnbicpIHtcbiAgICAgICAgbW9udGhJZHggPSA1IC8vIEp1blxuICAgICAgfSBlbHNlIGlmIChkYXRlWzZdID09PSAnbCcpIHtcbiAgICAgICAgbW9udGhJZHggPSA2IC8vIEp1bFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBJbnZhbGlkIG1vbnRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gSW52YWxpZCBtb250aFxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVs0XSA9PT0gJ0EnKVxuICApIHtcbiAgICBpZiAoZGF0ZVs1XSA9PT0gJ3AnICYmIGRhdGVbNl0gPT09ICdyJykge1xuICAgICAgbW9udGhJZHggPSAzIC8vIEFwclxuICAgIH0gZWxzZSBpZiAoZGF0ZVs1XSA9PT0gJ3UnICYmIGRhdGVbNl0gPT09ICdnJykge1xuICAgICAgbW9udGhJZHggPSA3IC8vIEF1Z1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIEludmFsaWQgbW9udGhcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbNF0gPT09ICdTJyAmJiBkYXRlWzVdID09PSAnZScgJiYgZGF0ZVs2XSA9PT0gJ3AnKVxuICApIHtcbiAgICBtb250aElkeCA9IDggLy8gU2VwXG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbNF0gPT09ICdPJyAmJiBkYXRlWzVdID09PSAnYycgJiYgZGF0ZVs2XSA9PT0gJ3QnKVxuICApIHtcbiAgICBtb250aElkeCA9IDkgLy8gT2N0XG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbNF0gPT09ICdOJyAmJiBkYXRlWzVdID09PSAnbycgJiYgZGF0ZVs2XSA9PT0gJ3YnKVxuICApIHtcbiAgICBtb250aElkeCA9IDEwIC8vIE5vdlxuICB9IGVsc2UgaWYgKFxuICAgIChkYXRlWzRdID09PSAnRCcgJiYgZGF0ZVs1XSA9PT0gJ2UnICYmIGRhdGVbNl0gPT09ICdjJylcbiAgKSB7XG4gICAgbW9udGhJZHggPSAxMSAvLyBEZWNcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3QgYSB2YWxpZCBtb250aFxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGxldCBkYXkgPSAwXG4gIGlmIChkYXRlWzhdID09PSAnICcpIHtcbiAgICAvLyBTaW5nbGUgZGlnaXQgZGF5LCBlLmcuIFwiU3VuIE5vdiA2IDA4OjQ5OjM3IDE5OTRcIlxuICAgIGNvbnN0IGNvZGUgPSBkYXRlLmNoYXJDb2RlQXQoOSlcbiAgICBpZiAoY29kZSA8IDQ5IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBkYXkgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KDgpXG4gICAgaWYgKGNvZGUxIDwgNDkgfHwgY29kZTEgPiA1MSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDEgYW5kIDNcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoOSlcbiAgICBpZiAoY29kZTIgPCA0OCB8fCBjb2RlMiA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIGRheSA9IChjb2RlMSAtIDQ4KSAqIDEwICsgKGNvZGUyIC0gNDgpIC8vIENvbnZlcnQgQVNDSUkgY29kZXMgdG8gbnVtYmVyXG4gIH1cblxuICBsZXQgaG91ciA9IDBcbiAgaWYgKGRhdGVbMTFdID09PSAnMCcpIHtcbiAgICBjb25zdCBjb2RlID0gZGF0ZS5jaGFyQ29kZUF0KDEyKVxuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIGhvdXIgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KDExKVxuICAgIGlmIChjb2RlMSA8IDQ4IHx8IGNvZGUxID4gNTApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXQgYmV0d2VlbiAwIGFuZCAyXG4gICAgfVxuICAgIGNvbnN0IGNvZGUyID0gZGF0ZS5jaGFyQ29kZUF0KDEyKVxuICAgIGlmIChjb2RlMiA8IDQ4IHx8IGNvZGUyID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgaWYgKGNvZGUxID09PSA1MCAmJiBjb2RlMiA+IDUxKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIEhvdXIgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAyM1xuICAgIH1cbiAgICBob3VyID0gKGNvZGUxIC0gNDgpICogMTAgKyAoY29kZTIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcbiAgfVxuXG4gIGxldCBtaW51dGUgPSAwXG4gIGlmIChkYXRlWzE0XSA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29kZSA9IGRhdGUuY2hhckNvZGVBdCgxNSlcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBtaW51dGUgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KDE0KVxuICAgIGlmIChjb2RlMSA8IDQ4IHx8IGNvZGUxID4gNTMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXQgYmV0d2VlbiAwIGFuZCA1XG4gICAgfVxuICAgIGNvbnN0IGNvZGUyID0gZGF0ZS5jaGFyQ29kZUF0KDE1KVxuICAgIGlmIChjb2RlMiA8IDQ4IHx8IGNvZGUyID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgbWludXRlID0gKGNvZGUxIC0gNDgpICogMTAgKyAoY29kZTIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcbiAgfVxuXG4gIGxldCBzZWNvbmQgPSAwXG4gIGlmIChkYXRlWzE3XSA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29kZSA9IGRhdGUuY2hhckNvZGVBdCgxOClcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBzZWNvbmQgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KDE3KVxuICAgIGlmIChjb2RlMSA8IDQ4IHx8IGNvZGUxID4gNTMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXQgYmV0d2VlbiAwIGFuZCA1XG4gICAgfVxuICAgIGNvbnN0IGNvZGUyID0gZGF0ZS5jaGFyQ29kZUF0KDE4KVxuICAgIGlmIChjb2RlMiA8IDQ4IHx8IGNvZGUyID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgc2Vjb25kID0gKGNvZGUxIC0gNDgpICogMTAgKyAoY29kZTIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcbiAgfVxuXG4gIGNvbnN0IHllYXJEaWdpdDEgPSBkYXRlLmNoYXJDb2RlQXQoMjApXG4gIGlmICh5ZWFyRGlnaXQxIDwgNDggfHwgeWVhckRpZ2l0MSA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDIgPSBkYXRlLmNoYXJDb2RlQXQoMjEpXG4gIGlmICh5ZWFyRGlnaXQyIDwgNDggfHwgeWVhckRpZ2l0MiA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDMgPSBkYXRlLmNoYXJDb2RlQXQoMjIpXG4gIGlmICh5ZWFyRGlnaXQzIDwgNDggfHwgeWVhckRpZ2l0MyA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXJEaWdpdDQgPSBkYXRlLmNoYXJDb2RlQXQoMjMpXG4gIGlmICh5ZWFyRGlnaXQ0IDwgNDggfHwgeWVhckRpZ2l0NCA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG4gIGNvbnN0IHllYXIgPSAoeWVhckRpZ2l0MSAtIDQ4KSAqIDEwMDAgKyAoeWVhckRpZ2l0MiAtIDQ4KSAqIDEwMCArICh5ZWFyRGlnaXQzIC0gNDgpICogMTAgKyAoeWVhckRpZ2l0NCAtIDQ4KVxuXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoSWR4LCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSlcbiAgcmV0dXJuIHJlc3VsdC5nZXRVVENEYXkoKSA9PT0gd2Vla2RheSA/IHJlc3VsdCA6IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNvYnNvbGV0ZS5kYXRlLmZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVxuICogQHJldHVybnMge0RhdGUgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmZjODUwRGF0ZSAoZGF0ZSkge1xuICBsZXQgY29tbWFJbmRleCA9IC0xXG5cbiAgbGV0IHdlZWtkYXkgPSAtMVxuICBpZiAoZGF0ZVswXSA9PT0gJ1MnKSB7XG4gICAgaWYgKGRhdGVbMV0gPT09ICd1JyAmJiBkYXRlWzJdID09PSAnbicgJiYgZGF0ZVszXSA9PT0gJ2QnICYmIGRhdGVbNF0gPT09ICdhJyAmJiBkYXRlWzVdID09PSAneScpIHtcbiAgICAgIHdlZWtkYXkgPSAwIC8vIFN1bmRheVxuICAgICAgY29tbWFJbmRleCA9IDZcbiAgICB9IGVsc2UgaWYgKGRhdGVbMV0gPT09ICdhJyAmJiBkYXRlWzJdID09PSAndCcgJiYgZGF0ZVszXSA9PT0gJ3UnICYmIGRhdGVbNF0gPT09ICdyJyAmJiBkYXRlWzVdID09PSAnZCcgJiYgZGF0ZVs2XSA9PT0gJ2EnICYmIGRhdGVbN10gPT09ICd5Jykge1xuICAgICAgd2Vla2RheSA9IDYgLy8gU2F0dXJkYXlcbiAgICAgIGNvbW1hSW5kZXggPSA4XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGVbMF0gPT09ICdNJyAmJiBkYXRlWzFdID09PSAnbycgJiYgZGF0ZVsyXSA9PT0gJ24nICYmIGRhdGVbM10gPT09ICdkJyAmJiBkYXRlWzRdID09PSAnYScgJiYgZGF0ZVs1XSA9PT0gJ3knKSB7XG4gICAgd2Vla2RheSA9IDEgLy8gTW9uZGF5XG4gICAgY29tbWFJbmRleCA9IDZcbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnVCcpIHtcbiAgICBpZiAoZGF0ZVsxXSA9PT0gJ3UnICYmIGRhdGVbMl0gPT09ICdlJyAmJiBkYXRlWzNdID09PSAncycgJiYgZGF0ZVs0XSA9PT0gJ2QnICYmIGRhdGVbNV0gPT09ICdhJyAmJiBkYXRlWzZdID09PSAneScpIHtcbiAgICAgIHdlZWtkYXkgPSAyIC8vIFR1ZXNkYXlcbiAgICAgIGNvbW1hSW5kZXggPSA3XG4gICAgfSBlbHNlIGlmIChkYXRlWzFdID09PSAnaCcgJiYgZGF0ZVsyXSA9PT0gJ3UnICYmIGRhdGVbM10gPT09ICdyJyAmJiBkYXRlWzRdID09PSAncycgJiYgZGF0ZVs1XSA9PT0gJ2QnICYmIGRhdGVbNl0gPT09ICdhJyAmJiBkYXRlWzddID09PSAneScpIHtcbiAgICAgIHdlZWtkYXkgPSA0IC8vIFRodXJzZGF5XG4gICAgICBjb21tYUluZGV4ID0gOFxuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRlWzBdID09PSAnVycgJiYgZGF0ZVsxXSA9PT0gJ2UnICYmIGRhdGVbMl0gPT09ICdkJyAmJiBkYXRlWzNdID09PSAnbicgJiYgZGF0ZVs0XSA9PT0gJ2UnICYmIGRhdGVbNV0gPT09ICdzJyAmJiBkYXRlWzZdID09PSAnZCcgJiYgZGF0ZVs3XSA9PT0gJ2EnICYmIGRhdGVbOF0gPT09ICd5Jykge1xuICAgIHdlZWtkYXkgPSAzIC8vIFdlZG5lc2RheVxuICAgIGNvbW1hSW5kZXggPSA5XG4gIH0gZWxzZSBpZiAoZGF0ZVswXSA9PT0gJ0YnICYmIGRhdGVbMV0gPT09ICdyJyAmJiBkYXRlWzJdID09PSAnaScgJiYgZGF0ZVszXSA9PT0gJ2QnICYmIGRhdGVbNF0gPT09ICdhJyAmJiBkYXRlWzVdID09PSAneScpIHtcbiAgICB3ZWVrZGF5ID0gNSAvLyBGcmlkYXlcbiAgICBjb21tYUluZGV4ID0gNlxuICB9IGVsc2Uge1xuICAgIC8vIE5vdCBhIHZhbGlkIGRheSBuYW1lXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKFxuICAgIGRhdGVbY29tbWFJbmRleF0gIT09ICcsJyB8fFxuICAgIChkYXRlLmxlbmd0aCAtIGNvbW1hSW5kZXggLSAxKSAhPT0gMjMgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyAxXSAhPT0gJyAnIHx8XG4gICAgZGF0ZVtjb21tYUluZGV4ICsgNF0gIT09ICctJyB8fFxuICAgIGRhdGVbY29tbWFJbmRleCArIDhdICE9PSAnLScgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyAxMV0gIT09ICcgJyB8fFxuICAgIGRhdGVbY29tbWFJbmRleCArIDE0XSAhPT0gJzonIHx8XG4gICAgZGF0ZVtjb21tYUluZGV4ICsgMTddICE9PSAnOicgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyAyMF0gIT09ICcgJyB8fFxuICAgIGRhdGVbY29tbWFJbmRleCArIDIxXSAhPT0gJ0cnIHx8XG4gICAgZGF0ZVtjb21tYUluZGV4ICsgMjJdICE9PSAnTScgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyAyM10gIT09ICdUJ1xuICApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBsZXQgZGF5ID0gMFxuICBpZiAoZGF0ZVtjb21tYUluZGV4ICsgMl0gPT09ICcwJykge1xuICAgIC8vIFNpbmdsZSBkaWdpdCBkYXksIGUuZy4gXCJTdW4gTm92IDYgMDg6NDk6MzcgMTk5NFwiXG4gICAgY29uc3QgY29kZSA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMylcbiAgICBpZiAoY29kZSA8IDQ5IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBkYXkgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KGNvbW1hSW5kZXggKyAyKVxuICAgIGlmIChjb2RlMSA8IDQ5IHx8IGNvZGUxID4gNTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXQgYmV0d2VlbiAxIGFuZCAzXG4gICAgfVxuICAgIGNvbnN0IGNvZGUyID0gZGF0ZS5jaGFyQ29kZUF0KGNvbW1hSW5kZXggKyAzKVxuICAgIGlmIChjb2RlMiA8IDQ4IHx8IGNvZGUyID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgZGF5ID0gKGNvZGUxIC0gNDgpICogMTAgKyAoY29kZTIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcbiAgfVxuXG4gIGxldCBtb250aElkeCA9IC0xXG4gIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdKJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2EnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAnbicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMCAvLyBKYW5cbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdGJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2UnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAnYicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMSAvLyBGZWJcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdNJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2EnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAncicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMiAvLyBNYXJcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdBJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ3AnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAncicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMyAvLyBBcHJcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdNJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2EnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAneScpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gNCAvLyBNYXlcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdKJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ3UnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAnbicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gNSAvLyBKdW5cbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdKJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ3UnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAnbCcpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gNiAvLyBKdWxcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdBJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ3UnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAnZycpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gNyAvLyBBdWdcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdTJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2UnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAncCcpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gOCAvLyBTZXBcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdPJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ2MnICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAndCcpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gOSAvLyBPY3RcbiAgfSBlbHNlIGlmIChcbiAgICAoZGF0ZVtjb21tYUluZGV4ICsgNV0gPT09ICdOJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA2XSA9PT0gJ28nICYmIGRhdGVbY29tbWFJbmRleCArIDddID09PSAndicpXG4gICkge1xuICAgIG1vbnRoSWR4ID0gMTAgLy8gTm92XG4gIH0gZWxzZSBpZiAoXG4gICAgKGRhdGVbY29tbWFJbmRleCArIDVdID09PSAnRCcgJiYgZGF0ZVtjb21tYUluZGV4ICsgNl0gPT09ICdlJyAmJiBkYXRlW2NvbW1hSW5kZXggKyA3XSA9PT0gJ2MnKVxuICApIHtcbiAgICBtb250aElkeCA9IDExIC8vIERlY1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdCBhIHZhbGlkIG1vbnRoXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgeWVhckRpZ2l0MSA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgOSlcbiAgaWYgKHllYXJEaWdpdDEgPCA0OCB8fCB5ZWFyRGlnaXQxID4gNTcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gIH1cbiAgY29uc3QgeWVhckRpZ2l0MiA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMTApXG4gIGlmICh5ZWFyRGlnaXQyIDwgNDggfHwgeWVhckRpZ2l0MiA+IDU3KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICB9XG5cbiAgbGV0IHllYXIgPSAoeWVhckRpZ2l0MSAtIDQ4KSAqIDEwICsgKHllYXJEaWdpdDIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcblxuICAvLyBSRkMgNjI2NSBzdGF0ZXMgdGhhdCB0aGUgeWVhciBpcyBpbiB0aGUgcmFuZ2UgMTk3MC0yMDY5LlxuICAvLyBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjI2NSNzZWN0aW9uLTUuMS4xXG4gIC8vXG4gIC8vIDMuIElmIHRoZSB5ZWFyLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA3MCBhbmQgbGVzcyB0aGFuIG9yXG4gIC8vICAgIGVxdWFsIHRvIDk5LCBpbmNyZW1lbnQgdGhlIHllYXItdmFsdWUgYnkgMTkwMC5cbiAgLy8gNC4gSWYgdGhlIHllYXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiBvclxuICAvLyAgICBlcXVhbCB0byA2OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDIwMDAuXG4gIHllYXIgKz0geWVhciA8IDcwID8gMjAwMCA6IDE5MDBcblxuICBsZXQgaG91ciA9IDBcbiAgaWYgKGRhdGVbY29tbWFJbmRleCArIDEyXSA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29kZSA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMTMpXG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgaG91ciA9IGNvZGUgLSA0OCAvLyBDb252ZXJ0IEFTQ0lJIGNvZGUgdG8gbnVtYmVyXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29kZTEgPSBkYXRlLmNoYXJDb2RlQXQoY29tbWFJbmRleCArIDEyKVxuICAgIGlmIChjb2RlMSA8IDQ4IHx8IGNvZGUxID4gNTApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXQgYmV0d2VlbiAwIGFuZCAyXG4gICAgfVxuICAgIGNvbnN0IGNvZGUyID0gZGF0ZS5jaGFyQ29kZUF0KGNvbW1hSW5kZXggKyAxMylcbiAgICBpZiAoY29kZTIgPCA0OCB8fCBjb2RlMiA+IDU3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0XG4gICAgfVxuICAgIGlmIChjb2RlMSA9PT0gNTAgJiYgY29kZTIgPiA1MSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBIb3VyIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMjNcbiAgICB9XG4gICAgaG91ciA9IChjb2RlMSAtIDQ4KSAqIDEwICsgKGNvZGUyIC0gNDgpIC8vIENvbnZlcnQgQVNDSUkgY29kZXMgdG8gbnVtYmVyXG4gIH1cblxuICBsZXQgbWludXRlID0gMFxuICBpZiAoZGF0ZVtjb21tYUluZGV4ICsgMTVdID09PSAnMCcpIHtcbiAgICBjb25zdCBjb2RlID0gZGF0ZS5jaGFyQ29kZUF0KGNvbW1hSW5kZXggKyAxNilcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBtaW51dGUgPSBjb2RlIC0gNDggLy8gQ29udmVydCBBU0NJSSBjb2RlIHRvIG51bWJlclxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUxID0gZGF0ZS5jaGFyQ29kZUF0KGNvbW1hSW5kZXggKyAxNSlcbiAgICBpZiAoY29kZTEgPCA0OCB8fCBjb2RlMSA+IDUzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIC8vIE5vdCBhIGRpZ2l0IGJldHdlZW4gMCBhbmQgNVxuICAgIH1cbiAgICBjb25zdCBjb2RlMiA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMTYpXG4gICAgaWYgKGNvZGUyIDwgNDggfHwgY29kZTIgPiA1Nykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdFxuICAgIH1cbiAgICBtaW51dGUgPSAoY29kZTEgLSA0OCkgKiAxMCArIChjb2RlMiAtIDQ4KSAvLyBDb252ZXJ0IEFTQ0lJIGNvZGVzIHRvIG51bWJlclxuICB9XG5cbiAgbGV0IHNlY29uZCA9IDBcbiAgaWYgKGRhdGVbY29tbWFJbmRleCArIDE4XSA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29kZSA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMTkpXG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgc2Vjb25kID0gY29kZSAtIDQ4IC8vIENvbnZlcnQgQVNDSUkgY29kZSB0byBudW1iZXJcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb2RlMSA9IGRhdGUuY2hhckNvZGVBdChjb21tYUluZGV4ICsgMTgpXG4gICAgaWYgKGNvZGUxIDwgNDggfHwgY29kZTEgPiA1Mykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBOb3QgYSBkaWdpdCBiZXR3ZWVuIDAgYW5kIDVcbiAgICB9XG4gICAgY29uc3QgY29kZTIgPSBkYXRlLmNoYXJDb2RlQXQoY29tbWFJbmRleCArIDE5KVxuICAgIGlmIChjb2RlMiA8IDQ4IHx8IGNvZGUyID4gNTcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgLy8gTm90IGEgZGlnaXRcbiAgICB9XG4gICAgc2Vjb25kID0gKGNvZGUxIC0gNDgpICogMTAgKyAoY29kZTIgLSA0OCkgLy8gQ29udmVydCBBU0NJSSBjb2RlcyB0byBudW1iZXJcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoSWR4LCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSlcbiAgcmV0dXJuIHJlc3VsdC5nZXRVVENEYXkoKSA9PT0gd2Vla2RheSA/IHJlc3VsdCA6IHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VIdHRwRGF0ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/date.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/promise.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/util/promise.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @template {*} T\n * @typedef {Object} DeferredPromise\n * @property {Promise<T>} promise\n * @property {(value?: T) => void} resolve\n * @property {(reason?: any) => void} reject\n */\n\n/**\n * @template {*} T\n * @returns {DeferredPromise<T>} An object containing a promise and its resolve/reject methods.\n */\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nmodule.exports = {\n  createDeferredPromise\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3Byb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxjQUFjLEdBQUc7QUFDakIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsWUFBWTtBQUMxQixjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHdCQUF3QjtBQUN0Qzs7QUFFQTtBQUNBLGNBQWMsR0FBRztBQUNqQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHV0aWxcXHByb21pc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHRlbXBsYXRlIHsqfSBUXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZlcnJlZFByb21pc2VcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHByb3BlcnR5IHsodmFsdWU/OiBUKSA9PiB2b2lkfSByZXNvbHZlXG4gKiBAcHJvcGVydHkgeyhyZWFzb24/OiBhbnkpID0+IHZvaWR9IHJlamVjdFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHsqfSBUXG4gKiBAcmV0dXJucyB7RGVmZXJyZWRQcm9taXNlPFQ+fSBBbiBvYmplY3QgY29udGFpbmluZyBhIHByb21pc2UgYW5kIGl0cyByZXNvbHZlL3JlamVjdCBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFByb21pc2UgKCkge1xuICBsZXQgcmVzXG4gIGxldCByZWpcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlXG4gICAgcmVqID0gcmVqZWN0XG4gIH0pXG5cbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzLCByZWplY3Q6IHJlaiB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVEZWZlcnJlZFByb21pc2Vcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/runtime-features.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/util/runtime-features.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/** @typedef {`node:${string}`} NodeModuleName */\n\n/** @type {Record<NodeModuleName, () => any>} */\nconst lazyLoaders = {\n  __proto__: null,\n  'node:crypto': () => __webpack_require__(/*! node:crypto */ \"node:crypto\"),\n  'node:sqlite': () => __webpack_require__(/*! node:sqlite */ \"node:sqlite\"),\n  'node:worker_threads': () => __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\"),\n  'node:zlib': () => __webpack_require__(/*! node:zlib */ \"node:zlib\")\n}\n\n/**\n * @param {NodeModuleName} moduleName\n * @returns {boolean}\n */\nfunction detectRuntimeFeatureByNodeModule (moduleName) {\n  try {\n    lazyLoaders[moduleName]()\n    return true\n  } catch (err) {\n    if (err.code !== 'ERR_UNKNOWN_BUILTIN_MODULE' && err.code !== 'ERR_NO_CRYPTO') {\n      throw err\n    }\n    return false\n  }\n}\n\n/**\n * @param {NodeModuleName} moduleName\n * @param {string} property\n * @returns {boolean}\n */\nfunction detectRuntimeFeatureByExportedProperty (moduleName, property) {\n  const module = lazyLoaders[moduleName]()\n  return typeof module[property] !== 'undefined'\n}\n\nconst runtimeFeaturesByExportedProperty = /** @type {const} */ (['markAsUncloneable', 'zstd'])\n\n/** @type {Record<RuntimeFeatureByExportedProperty, [NodeModuleName, string]>} */\nconst exportedPropertyLookup = {\n  markAsUncloneable: ['node:worker_threads', 'markAsUncloneable'],\n  zstd: ['node:zlib', 'createZstdDecompress']\n}\n\n/** @typedef {typeof runtimeFeaturesByExportedProperty[number]} RuntimeFeatureByExportedProperty */\n\nconst runtimeFeaturesAsNodeModule = /** @type {const} */ (['crypto', 'sqlite'])\n/** @typedef {typeof runtimeFeaturesAsNodeModule[number]} RuntimeFeatureByNodeModule */\n\nconst features = /** @type {const} */ ([\n  ...runtimeFeaturesAsNodeModule,\n  ...runtimeFeaturesByExportedProperty\n])\n\n/** @typedef {typeof features[number]} Feature */\n\n/**\n * @param {Feature} feature\n * @returns {boolean}\n */\nfunction detectRuntimeFeature (feature) {\n  if (runtimeFeaturesAsNodeModule.includes(/** @type {RuntimeFeatureByNodeModule} */ (feature))) {\n    return detectRuntimeFeatureByNodeModule(`node:${feature}`)\n  } else if (runtimeFeaturesByExportedProperty.includes(/** @type {RuntimeFeatureByExportedProperty} */ (feature))) {\n    const [moduleName, property] = exportedPropertyLookup[feature]\n    return detectRuntimeFeatureByExportedProperty(moduleName, property)\n  }\n  throw new TypeError(`unknown feature: ${feature}`)\n}\n\n/**\n * @class\n * @name RuntimeFeatures\n */\nclass RuntimeFeatures {\n  /** @type {Map<Feature, boolean>} */\n  #map = new Map()\n\n  /**\n   * Clears all cached feature detections.\n   */\n  clear () {\n    this.#map.clear()\n  }\n\n  /**\n   * @param {Feature} feature\n   * @returns {boolean}\n   */\n  has (feature) {\n    return (\n      this.#map.get(feature) ?? this.#detectRuntimeFeature(feature)\n    )\n  }\n\n  /**\n   * @param {Feature} feature\n   * @param {boolean} value\n   */\n  set (feature, value) {\n    if (features.includes(feature) === false) {\n      throw new TypeError(`unknown feature: ${feature}`)\n    }\n    this.#map.set(feature, value)\n  }\n\n  /**\n   * @param {Feature} feature\n   * @returns {boolean}\n   */\n  #detectRuntimeFeature (feature) {\n    const result = detectRuntimeFeature(feature)\n    this.#map.set(feature, result)\n    return result\n  }\n}\n\nconst instance = new RuntimeFeatures()\n\nmodule.exports.runtimeFeatures = instance\nmodule.exports[\"default\"] = instance\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3J1bnRpbWUtZmVhdHVyZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxRQUFRLE9BQU8sR0FBRzs7QUFFaEMsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLGdDQUFhO0FBQzVDLHVCQUF1QixtQkFBTyxDQUFDLGdDQUFhO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLGdEQUFxQjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyw0QkFBVztBQUN4Qzs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsT0FBTzs7QUFFNUQsV0FBVyxvRUFBb0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrREFBa0Q7O0FBRWhFLCtDQUErQyxPQUFPO0FBQ3RELGNBQWMsNENBQTRDOztBQUUxRCw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7O0FBRUEsY0FBYyx5QkFBeUI7O0FBRXZDO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0RBQXNELDRCQUE0QjtBQUNsRixvREFBb0QsUUFBUTtBQUM1RCxJQUFJLCtEQUErRCxrQ0FBa0M7QUFDckc7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5Qix5QkFBc0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx1dGlsXFxydW50aW1lLWZlYXR1cmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge2Bub2RlOiR7c3RyaW5nfWB9IE5vZGVNb2R1bGVOYW1lICovXG5cbi8qKiBAdHlwZSB7UmVjb3JkPE5vZGVNb2R1bGVOYW1lLCAoKSA9PiBhbnk+fSAqL1xuY29uc3QgbGF6eUxvYWRlcnMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgJ25vZGU6Y3J5cHRvJzogKCkgPT4gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKSxcbiAgJ25vZGU6c3FsaXRlJzogKCkgPT4gcmVxdWlyZSgnbm9kZTpzcWxpdGUnKSxcbiAgJ25vZGU6d29ya2VyX3RocmVhZHMnOiAoKSA9PiByZXF1aXJlKCdub2RlOndvcmtlcl90aHJlYWRzJyksXG4gICdub2RlOnpsaWInOiAoKSA9PiByZXF1aXJlKCdub2RlOnpsaWInKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZU1vZHVsZU5hbWV9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkZXRlY3RSdW50aW1lRmVhdHVyZUJ5Tm9kZU1vZHVsZSAobW9kdWxlTmFtZSkge1xuICB0cnkge1xuICAgIGxhenlMb2FkZXJzW21vZHVsZU5hbWVdKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfVU5LTk9XTl9CVUlMVElOX01PRFVMRScgJiYgZXJyLmNvZGUgIT09ICdFUlJfTk9fQ1JZUFRPJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlTW9kdWxlTmFtZX0gbW9kdWxlTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0UnVudGltZUZlYXR1cmVCeUV4cG9ydGVkUHJvcGVydHkgKG1vZHVsZU5hbWUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG1vZHVsZSA9IGxhenlMb2FkZXJzW21vZHVsZU5hbWVdKClcbiAgcmV0dXJuIHR5cGVvZiBtb2R1bGVbcHJvcGVydHldICE9PSAndW5kZWZpbmVkJ1xufVxuXG5jb25zdCBydW50aW1lRmVhdHVyZXNCeUV4cG9ydGVkUHJvcGVydHkgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydtYXJrQXNVbmNsb25lYWJsZScsICd6c3RkJ10pXG5cbi8qKiBAdHlwZSB7UmVjb3JkPFJ1bnRpbWVGZWF0dXJlQnlFeHBvcnRlZFByb3BlcnR5LCBbTm9kZU1vZHVsZU5hbWUsIHN0cmluZ10+fSAqL1xuY29uc3QgZXhwb3J0ZWRQcm9wZXJ0eUxvb2t1cCA9IHtcbiAgbWFya0FzVW5jbG9uZWFibGU6IFsnbm9kZTp3b3JrZXJfdGhyZWFkcycsICdtYXJrQXNVbmNsb25lYWJsZSddLFxuICB6c3RkOiBbJ25vZGU6emxpYicsICdjcmVhdGVac3RkRGVjb21wcmVzcyddXG59XG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIHJ1bnRpbWVGZWF0dXJlc0J5RXhwb3J0ZWRQcm9wZXJ0eVtudW1iZXJdfSBSdW50aW1lRmVhdHVyZUJ5RXhwb3J0ZWRQcm9wZXJ0eSAqL1xuXG5jb25zdCBydW50aW1lRmVhdHVyZXNBc05vZGVNb2R1bGUgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydjcnlwdG8nLCAnc3FsaXRlJ10pXG4vKiogQHR5cGVkZWYge3R5cGVvZiBydW50aW1lRmVhdHVyZXNBc05vZGVNb2R1bGVbbnVtYmVyXX0gUnVudGltZUZlYXR1cmVCeU5vZGVNb2R1bGUgKi9cblxuY29uc3QgZmVhdHVyZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAuLi5ydW50aW1lRmVhdHVyZXNBc05vZGVNb2R1bGUsXG4gIC4uLnJ1bnRpbWVGZWF0dXJlc0J5RXhwb3J0ZWRQcm9wZXJ0eVxuXSlcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgZmVhdHVyZXNbbnVtYmVyXX0gRmVhdHVyZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdFJ1bnRpbWVGZWF0dXJlIChmZWF0dXJlKSB7XG4gIGlmIChydW50aW1lRmVhdHVyZXNBc05vZGVNb2R1bGUuaW5jbHVkZXMoLyoqIEB0eXBlIHtSdW50aW1lRmVhdHVyZUJ5Tm9kZU1vZHVsZX0gKi8gKGZlYXR1cmUpKSkge1xuICAgIHJldHVybiBkZXRlY3RSdW50aW1lRmVhdHVyZUJ5Tm9kZU1vZHVsZShgbm9kZToke2ZlYXR1cmV9YClcbiAgfSBlbHNlIGlmIChydW50aW1lRmVhdHVyZXNCeUV4cG9ydGVkUHJvcGVydHkuaW5jbHVkZXMoLyoqIEB0eXBlIHtSdW50aW1lRmVhdHVyZUJ5RXhwb3J0ZWRQcm9wZXJ0eX0gKi8gKGZlYXR1cmUpKSkge1xuICAgIGNvbnN0IFttb2R1bGVOYW1lLCBwcm9wZXJ0eV0gPSBleHBvcnRlZFByb3BlcnR5TG9va3VwW2ZlYXR1cmVdXG4gICAgcmV0dXJuIGRldGVjdFJ1bnRpbWVGZWF0dXJlQnlFeHBvcnRlZFByb3BlcnR5KG1vZHVsZU5hbWUsIHByb3BlcnR5KVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYHVua25vd24gZmVhdHVyZTogJHtmZWF0dXJlfWApXG59XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbmFtZSBSdW50aW1lRmVhdHVyZXNcbiAqL1xuY2xhc3MgUnVudGltZUZlYXR1cmVzIHtcbiAgLyoqIEB0eXBlIHtNYXA8RmVhdHVyZSwgYm9vbGVhbj59ICovXG4gICNtYXAgPSBuZXcgTWFwKClcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgZmVhdHVyZSBkZXRlY3Rpb25zLlxuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuI21hcC5jbGVhcigpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzIChmZWF0dXJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuI21hcC5nZXQoZmVhdHVyZSkgPz8gdGhpcy4jZGV0ZWN0UnVudGltZUZlYXR1cmUoZmVhdHVyZSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHNldCAoZmVhdHVyZSwgdmFsdWUpIHtcbiAgICBpZiAoZmVhdHVyZXMuaW5jbHVkZXMoZmVhdHVyZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bmtub3duIGZlYXR1cmU6ICR7ZmVhdHVyZX1gKVxuICAgIH1cbiAgICB0aGlzLiNtYXAuc2V0KGZlYXR1cmUsIHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICNkZXRlY3RSdW50aW1lRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdFJ1bnRpbWVGZWF0dXJlKGZlYXR1cmUpXG4gICAgdGhpcy4jbWFwLnNldChmZWF0dXJlLCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNvbnN0IGluc3RhbmNlID0gbmV3IFJ1bnRpbWVGZWF0dXJlcygpXG5cbm1vZHVsZS5leHBvcnRzLnJ1bnRpbWVGZWF0dXJlcyA9IGluc3RhbmNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gaW5zdGFuY2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/runtime-features.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/stats.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/util/stats.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  kConnected,\n  kPending,\n  kRunning,\n  kSize,\n  kFree,\n  kQueued\n} = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nclass ClientStats {\n  constructor (client) {\n    this.connected = client[kConnected]\n    this.pending = client[kPending]\n    this.running = client[kRunning]\n    this.size = client[kSize]\n  }\n}\n\nclass PoolStats {\n  constructor (pool) {\n    this.connected = pool[kConnected]\n    this.free = pool[kFree]\n    this.pending = pool[kPending]\n    this.queued = pool[kQueued]\n    this.running = pool[kRunning]\n    this.size = pool[kSize]\n  }\n}\n\nmodule.exports = { ClientStats, PoolStats }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHV0aWxcXHN0YXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIGtDb25uZWN0ZWQsXG4gIGtQZW5kaW5nLFxuICBrUnVubmluZyxcbiAga1NpemUsXG4gIGtGcmVlLFxuICBrUXVldWVkXG59ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY2xhc3MgQ2xpZW50U3RhdHMge1xuICBjb25zdHJ1Y3RvciAoY2xpZW50KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBjbGllbnRba0Nvbm5lY3RlZF1cbiAgICB0aGlzLnBlbmRpbmcgPSBjbGllbnRba1BlbmRpbmddXG4gICAgdGhpcy5ydW5uaW5nID0gY2xpZW50W2tSdW5uaW5nXVxuICAgIHRoaXMuc2l6ZSA9IGNsaWVudFtrU2l6ZV1cbiAgfVxufVxuXG5jbGFzcyBQb29sU3RhdHMge1xuICBjb25zdHJ1Y3RvciAocG9vbCkge1xuICAgIHRoaXMuY29ubmVjdGVkID0gcG9vbFtrQ29ubmVjdGVkXVxuICAgIHRoaXMuZnJlZSA9IHBvb2xba0ZyZWVdXG4gICAgdGhpcy5wZW5kaW5nID0gcG9vbFtrUGVuZGluZ11cbiAgICB0aGlzLnF1ZXVlZCA9IHBvb2xba1F1ZXVlZF1cbiAgICB0aGlzLnJ1bm5pbmcgPSBwb29sW2tSdW5uaW5nXVxuICAgIHRoaXMuc2l6ZSA9IHBvb2xba1NpemVdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IENsaWVudFN0YXRzLCBQb29sU3RhdHMgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/stats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\n/**\n * This module offers an optimized timer implementation designed for scenarios\n * where high precision is not critical.\n *\n * The timer achieves faster performance by using a low-resolution approach,\n * with an accuracy target of within 500ms. This makes it particularly useful\n * for timers with delays of 1 second or more, where exact timing is less\n * crucial.\n *\n * It's important to note that Node.js timers are inherently imprecise, as\n * delays can occur due to the event loop being blocked by other operations.\n * Consequently, timers may trigger later than their scheduled time.\n */\n\n/**\n * The fastNow variable contains the internal fast timer clock value.\n *\n * @type {number}\n */\nlet fastNow = 0\n\n/**\n * RESOLUTION_MS represents the target resolution time in milliseconds.\n *\n * @type {number}\n * @default 1000\n */\nconst RESOLUTION_MS = 1e3\n\n/**\n * TICK_MS defines the desired interval in milliseconds between each tick.\n * The target value is set to half the resolution time, minus 1 ms, to account\n * for potential event loop overhead.\n *\n * @type {number}\n * @default 499\n */\nconst TICK_MS = (RESOLUTION_MS >> 1) - 1\n\n/**\n * fastNowTimeout is a Node.js timer used to manage and process\n * the FastTimers stored in the `fastTimers` array.\n *\n * @type {NodeJS.Timeout}\n */\nlet fastNowTimeout\n\n/**\n * The kFastTimer symbol is used to identify FastTimer instances.\n *\n * @type {Symbol}\n */\nconst kFastTimer = Symbol('kFastTimer')\n\n/**\n * The fastTimers array contains all active FastTimers.\n *\n * @type {FastTimer[]}\n */\nconst fastTimers = []\n\n/**\n * These constants represent the various states of a FastTimer.\n */\n\n/**\n * The `NOT_IN_LIST` constant indicates that the FastTimer is not included\n * in the `fastTimers` array. Timers with this status will not be processed\n * during the next tick by the `onTick` function.\n *\n * A FastTimer can be re-added to the `fastTimers` array by invoking the\n * `refresh` method on the FastTimer instance.\n *\n * @type {-2}\n */\nconst NOT_IN_LIST = -2\n\n/**\n * The `TO_BE_CLEARED` constant indicates that the FastTimer is scheduled\n * for removal from the `fastTimers` array. A FastTimer in this state will\n * be removed in the next tick by the `onTick` function and will no longer\n * be processed.\n *\n * This status is also set when the `clear` method is called on the FastTimer instance.\n *\n * @type {-1}\n */\nconst TO_BE_CLEARED = -1\n\n/**\n * The `PENDING` constant signifies that the FastTimer is awaiting processing\n * in the next tick by the `onTick` function. Timers with this status will have\n * their `_idleStart` value set and their status updated to `ACTIVE` in the next tick.\n *\n * @type {0}\n */\nconst PENDING = 0\n\n/**\n * The `ACTIVE` constant indicates that the FastTimer is active and waiting\n * for its timer to expire. During the next tick, the `onTick` function will\n * check if the timer has expired, and if so, it will execute the associated callback.\n *\n * @type {1}\n */\nconst ACTIVE = 1\n\n/**\n * The onTick function processes the fastTimers array.\n *\n * @returns {void}\n */\nfunction onTick () {\n  /**\n   * Increment the fastNow value by the TICK_MS value, despite the actual time\n   * that has passed since the last tick. This approach ensures independence\n   * from the system clock and delays caused by a blocked event loop.\n   *\n   * @type {number}\n   */\n  fastNow += TICK_MS\n\n  /**\n   * The `idx` variable is used to iterate over the `fastTimers` array.\n   * Expired timers are removed by replacing them with the last element in the array.\n   * Consequently, `idx` is only incremented when the current element is not removed.\n   *\n   * @type {number}\n   */\n  let idx = 0\n\n  /**\n   * The len variable will contain the length of the fastTimers array\n   * and will be decremented when a FastTimer should be removed from the\n   * fastTimers array.\n   *\n   * @type {number}\n   */\n  let len = fastTimers.length\n\n  while (idx < len) {\n    /**\n     * @type {FastTimer}\n     */\n    const timer = fastTimers[idx]\n\n    // If the timer is in the ACTIVE state and the timer has expired, it will\n    // be processed in the next tick.\n    if (timer._state === PENDING) {\n      // Set the _idleStart value to the fastNow value minus the TICK_MS value\n      // to account for the time the timer was in the PENDING state.\n      timer._idleStart = fastNow - TICK_MS\n      timer._state = ACTIVE\n    } else if (\n      timer._state === ACTIVE &&\n      fastNow >= timer._idleStart + timer._idleTimeout\n    ) {\n      timer._state = TO_BE_CLEARED\n      timer._idleStart = -1\n      timer._onTimeout(timer._timerArg)\n    }\n\n    if (timer._state === TO_BE_CLEARED) {\n      timer._state = NOT_IN_LIST\n\n      // Move the last element to the current index and decrement len if it is\n      // not the only element in the array.\n      if (--len !== 0) {\n        fastTimers[idx] = fastTimers[len]\n      }\n    } else {\n      ++idx\n    }\n  }\n\n  // Set the length of the fastTimers array to the new length and thus\n  // removing the excess FastTimers elements from the array.\n  fastTimers.length = len\n\n  // If there are still active FastTimers in the array, refresh the Timer.\n  // If there are no active FastTimers, the timer will be refreshed again\n  // when a new FastTimer is instantiated.\n  if (fastTimers.length !== 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  // If the fastNowTimeout is already set and the Timer has the refresh()-\n  // method available, call it to refresh the timer.\n  // Some timer objects returned by setTimeout may not have a .refresh()\n  // method (e.g. mocked timers in tests).\n  if (fastNowTimeout?.refresh) {\n    fastNowTimeout.refresh()\n    // fastNowTimeout is not instantiated yet or refresh is not availabe,\n    // create a new Timer.\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTick, TICK_MS)\n    // If the Timer has an unref method, call it to allow the process to exit,\n    // if there are no other active handles. When using fake timers or mocked\n    // environments (like Jest), .unref() may not be defined,\n    fastNowTimeout?.unref()\n  }\n}\n\n/**\n * The `FastTimer` class is a data structure designed to store and manage\n * timer information.\n */\nclass FastTimer {\n  [kFastTimer] = true\n\n  /**\n   * The state of the timer, which can be one of the following:\n   * - NOT_IN_LIST (-2)\n   * - TO_BE_CLEARED (-1)\n   * - PENDING (0)\n   * - ACTIVE (1)\n   *\n   * @type {-2|-1|0|1}\n   * @private\n   */\n  _state = NOT_IN_LIST\n\n  /**\n   * The number of milliseconds to wait before calling the callback.\n   *\n   * @type {number}\n   * @private\n   */\n  _idleTimeout = -1\n\n  /**\n   * The time in milliseconds when the timer was started. This value is used to\n   * calculate when the timer should expire.\n   *\n   * @type {number}\n   * @default -1\n   * @private\n   */\n  _idleStart = -1\n\n  /**\n   * The function to be executed when the timer expires.\n   * @type {Function}\n   * @private\n   */\n  _onTimeout\n\n  /**\n   * The argument to be passed to the callback when the timer expires.\n   *\n   * @type {*}\n   * @private\n   */\n  _timerArg\n\n  /**\n   * @constructor\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should wait\n   * before the specified function or code is executed.\n   * @param {*} arg\n   */\n  constructor (callback, delay, arg) {\n    this._onTimeout = callback\n    this._idleTimeout = delay\n    this._timerArg = arg\n\n    this.refresh()\n  }\n\n  /**\n   * Sets the timer's start time to the current time, and reschedules the timer\n   * to call its callback at the previously specified duration adjusted to the\n   * current time.\n   * Using this on a timer that has already called its callback will reactivate\n   * the timer.\n   *\n   * @returns {void}\n   */\n  refresh () {\n    // In the special case that the timer is not in the list of active timers,\n    // add it back to the array to be processed in the next tick by the onTick\n    // function.\n    if (this._state === NOT_IN_LIST) {\n      fastTimers.push(this)\n    }\n\n    // If the timer is the only active timer, refresh the fastNowTimeout for\n    // better resolution.\n    if (!fastNowTimeout || fastTimers.length === 1) {\n      refreshTimeout()\n    }\n\n    // Setting the state to PENDING will cause the timer to be reset in the\n    // next tick by the onTick function.\n    this._state = PENDING\n  }\n\n  /**\n   * The `clear` method cancels the timer, preventing it from executing.\n   *\n   * @returns {void}\n   * @private\n   */\n  clear () {\n    // Set the state to TO_BE_CLEARED to mark the timer for removal in the next\n    // tick by the onTick function.\n    this._state = TO_BE_CLEARED\n\n    // Reset the _idleStart value to -1 to indicate that the timer is no longer\n    // active.\n    this._idleStart = -1\n  }\n}\n\n/**\n * This module exports a setTimeout and clearTimeout function that can be\n * used as a drop-in replacement for the native functions.\n */\nmodule.exports = {\n  /**\n   * The setTimeout() method sets a timer which executes a function once the\n   * timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {NodeJS.Timeout|FastTimer}\n   */\n  setTimeout (callback, delay, arg) {\n    // If the delay is less than or equal to the RESOLUTION_MS value return a\n    // native Node.js Timer instance.\n    return delay <= RESOLUTION_MS\n      ? setTimeout(callback, delay, arg)\n      : new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated Timer previously created\n   * by calling setTimeout.\n   *\n   * @param {NodeJS.Timeout|FastTimer} timeout\n   */\n  clearTimeout (timeout) {\n    // If the timeout is a FastTimer, call its own clear method.\n    if (timeout[kFastTimer]) {\n      /**\n       * @type {FastTimer}\n       */\n      timeout.clear()\n      // Otherwise it is an instance of a native NodeJS.Timeout, so call the\n      // Node.js native clearTimeout function.\n    } else {\n      clearTimeout(timeout)\n    }\n  },\n  /**\n   * The setFastTimeout() method sets a fastTimer which executes a function once\n   * the timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {FastTimer}\n   */\n  setFastTimeout (callback, delay, arg) {\n    return new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated FastTimer previously\n   * created by calling setFastTimeout.\n   *\n   * @param {FastTimer} timeout\n   */\n  clearFastTimeout (timeout) {\n    timeout.clear()\n  },\n  /**\n   * The now method returns the value of the internal fast timer clock.\n   *\n   * @returns {number}\n   */\n  now () {\n    return fastNow\n  },\n  /**\n   * Trigger the onTick function to process the fastTimers array.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   * @param {number} [delay=0] The delay in milliseconds to add to the now value.\n   */\n  tick (delay = 0) {\n    fastNow += delay - RESOLUTION_MS + 1\n    onTick()\n    onTick()\n  },\n  /**\n   * Reset FastTimers.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  reset () {\n    fastNow = 0\n    fastTimers.length = 0\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = null\n  },\n  /**\n   * Exporting for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  kFastTimer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHV0aWxcXHRpbWVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBvZmZlcnMgYW4gb3B0aW1pemVkIHRpbWVyIGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciBzY2VuYXJpb3NcbiAqIHdoZXJlIGhpZ2ggcHJlY2lzaW9uIGlzIG5vdCBjcml0aWNhbC5cbiAqXG4gKiBUaGUgdGltZXIgYWNoaWV2ZXMgZmFzdGVyIHBlcmZvcm1hbmNlIGJ5IHVzaW5nIGEgbG93LXJlc29sdXRpb24gYXBwcm9hY2gsXG4gKiB3aXRoIGFuIGFjY3VyYWN5IHRhcmdldCBvZiB3aXRoaW4gNTAwbXMuIFRoaXMgbWFrZXMgaXQgcGFydGljdWxhcmx5IHVzZWZ1bFxuICogZm9yIHRpbWVycyB3aXRoIGRlbGF5cyBvZiAxIHNlY29uZCBvciBtb3JlLCB3aGVyZSBleGFjdCB0aW1pbmcgaXMgbGVzc1xuICogY3J1Y2lhbC5cbiAqXG4gKiBJdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgTm9kZS5qcyB0aW1lcnMgYXJlIGluaGVyZW50bHkgaW1wcmVjaXNlLCBhc1xuICogZGVsYXlzIGNhbiBvY2N1ciBkdWUgdG8gdGhlIGV2ZW50IGxvb3AgYmVpbmcgYmxvY2tlZCBieSBvdGhlciBvcGVyYXRpb25zLlxuICogQ29uc2VxdWVudGx5LCB0aW1lcnMgbWF5IHRyaWdnZXIgbGF0ZXIgdGhhbiB0aGVpciBzY2hlZHVsZWQgdGltZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBmYXN0Tm93IHZhcmlhYmxlIGNvbnRhaW5zIHRoZSBpbnRlcm5hbCBmYXN0IHRpbWVyIGNsb2NrIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBmYXN0Tm93ID0gMFxuXG4vKipcbiAqIFJFU09MVVRJT05fTVMgcmVwcmVzZW50cyB0aGUgdGFyZ2V0IHJlc29sdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDEwMDBcbiAqL1xuY29uc3QgUkVTT0xVVElPTl9NUyA9IDFlM1xuXG4vKipcbiAqIFRJQ0tfTVMgZGVmaW5lcyB0aGUgZGVzaXJlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBlYWNoIHRpY2suXG4gKiBUaGUgdGFyZ2V0IHZhbHVlIGlzIHNldCB0byBoYWxmIHRoZSByZXNvbHV0aW9uIHRpbWUsIG1pbnVzIDEgbXMsIHRvIGFjY291bnRcbiAqIGZvciBwb3RlbnRpYWwgZXZlbnQgbG9vcCBvdmVyaGVhZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgNDk5XG4gKi9cbmNvbnN0IFRJQ0tfTVMgPSAoUkVTT0xVVElPTl9NUyA+PiAxKSAtIDFcblxuLyoqXG4gKiBmYXN0Tm93VGltZW91dCBpcyBhIE5vZGUuanMgdGltZXIgdXNlZCB0byBtYW5hZ2UgYW5kIHByb2Nlc3NcbiAqIHRoZSBGYXN0VGltZXJzIHN0b3JlZCBpbiB0aGUgYGZhc3RUaW1lcnNgIGFycmF5LlxuICpcbiAqIEB0eXBlIHtOb2RlSlMuVGltZW91dH1cbiAqL1xubGV0IGZhc3ROb3dUaW1lb3V0XG5cbi8qKlxuICogVGhlIGtGYXN0VGltZXIgc3ltYm9sIGlzIHVzZWQgdG8gaWRlbnRpZnkgRmFzdFRpbWVyIGluc3RhbmNlcy5cbiAqXG4gKiBAdHlwZSB7U3ltYm9sfVxuICovXG5jb25zdCBrRmFzdFRpbWVyID0gU3ltYm9sKCdrRmFzdFRpbWVyJylcblxuLyoqXG4gKiBUaGUgZmFzdFRpbWVycyBhcnJheSBjb250YWlucyBhbGwgYWN0aXZlIEZhc3RUaW1lcnMuXG4gKlxuICogQHR5cGUge0Zhc3RUaW1lcltdfVxuICovXG5jb25zdCBmYXN0VGltZXJzID0gW11cblxuLyoqXG4gKiBUaGVzZSBjb25zdGFudHMgcmVwcmVzZW50IHRoZSB2YXJpb3VzIHN0YXRlcyBvZiBhIEZhc3RUaW1lci5cbiAqL1xuXG4vKipcbiAqIFRoZSBgTk9UX0lOX0xJU1RgIGNvbnN0YW50IGluZGljYXRlcyB0aGF0IHRoZSBGYXN0VGltZXIgaXMgbm90IGluY2x1ZGVkXG4gKiBpbiB0aGUgYGZhc3RUaW1lcnNgIGFycmF5LiBUaW1lcnMgd2l0aCB0aGlzIHN0YXR1cyB3aWxsIG5vdCBiZSBwcm9jZXNzZWRcbiAqIGR1cmluZyB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbi5cbiAqXG4gKiBBIEZhc3RUaW1lciBjYW4gYmUgcmUtYWRkZWQgdG8gdGhlIGBmYXN0VGltZXJzYCBhcnJheSBieSBpbnZva2luZyB0aGVcbiAqIGByZWZyZXNoYCBtZXRob2Qgb24gdGhlIEZhc3RUaW1lciBpbnN0YW5jZS5cbiAqXG4gKiBAdHlwZSB7LTJ9XG4gKi9cbmNvbnN0IE5PVF9JTl9MSVNUID0gLTJcblxuLyoqXG4gKiBUaGUgYFRPX0JFX0NMRUFSRURgIGNvbnN0YW50IGluZGljYXRlcyB0aGF0IHRoZSBGYXN0VGltZXIgaXMgc2NoZWR1bGVkXG4gKiBmb3IgcmVtb3ZhbCBmcm9tIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuIEEgRmFzdFRpbWVyIGluIHRoaXMgc3RhdGUgd2lsbFxuICogYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbiBhbmQgd2lsbCBubyBsb25nZXJcbiAqIGJlIHByb2Nlc3NlZC5cbiAqXG4gKiBUaGlzIHN0YXR1cyBpcyBhbHNvIHNldCB3aGVuIHRoZSBgY2xlYXJgIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIEZhc3RUaW1lciBpbnN0YW5jZS5cbiAqXG4gKiBAdHlwZSB7LTF9XG4gKi9cbmNvbnN0IFRPX0JFX0NMRUFSRUQgPSAtMVxuXG4vKipcbiAqIFRoZSBgUEVORElOR2AgY29uc3RhbnQgc2lnbmlmaWVzIHRoYXQgdGhlIEZhc3RUaW1lciBpcyBhd2FpdGluZyBwcm9jZXNzaW5nXG4gKiBpbiB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbi4gVGltZXJzIHdpdGggdGhpcyBzdGF0dXMgd2lsbCBoYXZlXG4gKiB0aGVpciBgX2lkbGVTdGFydGAgdmFsdWUgc2V0IGFuZCB0aGVpciBzdGF0dXMgdXBkYXRlZCB0byBgQUNUSVZFYCBpbiB0aGUgbmV4dCB0aWNrLlxuICpcbiAqIEB0eXBlIHswfVxuICovXG5jb25zdCBQRU5ESU5HID0gMFxuXG4vKipcbiAqIFRoZSBgQUNUSVZFYCBjb25zdGFudCBpbmRpY2F0ZXMgdGhhdCB0aGUgRmFzdFRpbWVyIGlzIGFjdGl2ZSBhbmQgd2FpdGluZ1xuICogZm9yIGl0cyB0aW1lciB0byBleHBpcmUuIER1cmluZyB0aGUgbmV4dCB0aWNrLCB0aGUgYG9uVGlja2AgZnVuY3Rpb24gd2lsbFxuICogY2hlY2sgaWYgdGhlIHRpbWVyIGhhcyBleHBpcmVkLCBhbmQgaWYgc28sIGl0IHdpbGwgZXhlY3V0ZSB0aGUgYXNzb2NpYXRlZCBjYWxsYmFjay5cbiAqXG4gKiBAdHlwZSB7MX1cbiAqL1xuY29uc3QgQUNUSVZFID0gMVxuXG4vKipcbiAqIFRoZSBvblRpY2sgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZSBmYXN0VGltZXJzIGFycmF5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBvblRpY2sgKCkge1xuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBmYXN0Tm93IHZhbHVlIGJ5IHRoZSBUSUNLX01TIHZhbHVlLCBkZXNwaXRlIHRoZSBhY3R1YWwgdGltZVxuICAgKiB0aGF0IGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgdGljay4gVGhpcyBhcHByb2FjaCBlbnN1cmVzIGluZGVwZW5kZW5jZVxuICAgKiBmcm9tIHRoZSBzeXN0ZW0gY2xvY2sgYW5kIGRlbGF5cyBjYXVzZWQgYnkgYSBibG9ja2VkIGV2ZW50IGxvb3AuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmYXN0Tm93ICs9IFRJQ0tfTVNcblxuICAvKipcbiAgICogVGhlIGBpZHhgIHZhcmlhYmxlIGlzIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuXG4gICAqIEV4cGlyZWQgdGltZXJzIGFyZSByZW1vdmVkIGJ5IHJlcGxhY2luZyB0aGVtIHdpdGggdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAqIENvbnNlcXVlbnRseSwgYGlkeGAgaXMgb25seSBpbmNyZW1lbnRlZCB3aGVuIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgbm90IHJlbW92ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsZXQgaWR4ID0gMFxuXG4gIC8qKlxuICAgKiBUaGUgbGVuIHZhcmlhYmxlIHdpbGwgY29udGFpbiB0aGUgbGVuZ3RoIG9mIHRoZSBmYXN0VGltZXJzIGFycmF5XG4gICAqIGFuZCB3aWxsIGJlIGRlY3JlbWVudGVkIHdoZW4gYSBGYXN0VGltZXIgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICogZmFzdFRpbWVycyBhcnJheS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBsZW4gPSBmYXN0VGltZXJzLmxlbmd0aFxuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RmFzdFRpbWVyfVxuICAgICAqL1xuICAgIGNvbnN0IHRpbWVyID0gZmFzdFRpbWVyc1tpZHhdXG5cbiAgICAvLyBJZiB0aGUgdGltZXIgaXMgaW4gdGhlIEFDVElWRSBzdGF0ZSBhbmQgdGhlIHRpbWVyIGhhcyBleHBpcmVkLCBpdCB3aWxsXG4gICAgLy8gYmUgcHJvY2Vzc2VkIGluIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKHRpbWVyLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgLy8gU2V0IHRoZSBfaWRsZVN0YXJ0IHZhbHVlIHRvIHRoZSBmYXN0Tm93IHZhbHVlIG1pbnVzIHRoZSBUSUNLX01TIHZhbHVlXG4gICAgICAvLyB0byBhY2NvdW50IGZvciB0aGUgdGltZSB0aGUgdGltZXIgd2FzIGluIHRoZSBQRU5ESU5HIHN0YXRlLlxuICAgICAgdGltZXIuX2lkbGVTdGFydCA9IGZhc3ROb3cgLSBUSUNLX01TXG4gICAgICB0aW1lci5fc3RhdGUgPSBBQ1RJVkVcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGltZXIuX3N0YXRlID09PSBBQ1RJVkUgJiZcbiAgICAgIGZhc3ROb3cgPj0gdGltZXIuX2lkbGVTdGFydCArIHRpbWVyLl9pZGxlVGltZW91dFxuICAgICkge1xuICAgICAgdGltZXIuX3N0YXRlID0gVE9fQkVfQ0xFQVJFRFxuICAgICAgdGltZXIuX2lkbGVTdGFydCA9IC0xXG4gICAgICB0aW1lci5fb25UaW1lb3V0KHRpbWVyLl90aW1lckFyZylcbiAgICB9XG5cbiAgICBpZiAodGltZXIuX3N0YXRlID09PSBUT19CRV9DTEVBUkVEKSB7XG4gICAgICB0aW1lci5fc3RhdGUgPSBOT1RfSU5fTElTVFxuXG4gICAgICAvLyBNb3ZlIHRoZSBsYXN0IGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgaW5kZXggYW5kIGRlY3JlbWVudCBsZW4gaWYgaXQgaXNcbiAgICAgIC8vIG5vdCB0aGUgb25seSBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgIGlmICgtLWxlbiAhPT0gMCkge1xuICAgICAgICBmYXN0VGltZXJzW2lkeF0gPSBmYXN0VGltZXJzW2xlbl1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKytpZHhcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmFzdFRpbWVycyBhcnJheSB0byB0aGUgbmV3IGxlbmd0aCBhbmQgdGh1c1xuICAvLyByZW1vdmluZyB0aGUgZXhjZXNzIEZhc3RUaW1lcnMgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkuXG4gIGZhc3RUaW1lcnMubGVuZ3RoID0gbGVuXG5cbiAgLy8gSWYgdGhlcmUgYXJlIHN0aWxsIGFjdGl2ZSBGYXN0VGltZXJzIGluIHRoZSBhcnJheSwgcmVmcmVzaCB0aGUgVGltZXIuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBhY3RpdmUgRmFzdFRpbWVycywgdGhlIHRpbWVyIHdpbGwgYmUgcmVmcmVzaGVkIGFnYWluXG4gIC8vIHdoZW4gYSBuZXcgRmFzdFRpbWVyIGlzIGluc3RhbnRpYXRlZC5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgcmVmcmVzaFRpbWVvdXQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hUaW1lb3V0ICgpIHtcbiAgLy8gSWYgdGhlIGZhc3ROb3dUaW1lb3V0IGlzIGFscmVhZHkgc2V0IGFuZCB0aGUgVGltZXIgaGFzIHRoZSByZWZyZXNoKCktXG4gIC8vIG1ldGhvZCBhdmFpbGFibGUsIGNhbGwgaXQgdG8gcmVmcmVzaCB0aGUgdGltZXIuXG4gIC8vIFNvbWUgdGltZXIgb2JqZWN0cyByZXR1cm5lZCBieSBzZXRUaW1lb3V0IG1heSBub3QgaGF2ZSBhIC5yZWZyZXNoKClcbiAgLy8gbWV0aG9kIChlLmcuIG1vY2tlZCB0aW1lcnMgaW4gdGVzdHMpLlxuICBpZiAoZmFzdE5vd1RpbWVvdXQ/LnJlZnJlc2gpIHtcbiAgICBmYXN0Tm93VGltZW91dC5yZWZyZXNoKClcbiAgICAvLyBmYXN0Tm93VGltZW91dCBpcyBub3QgaW5zdGFudGlhdGVkIHlldCBvciByZWZyZXNoIGlzIG5vdCBhdmFpbGFiZSxcbiAgICAvLyBjcmVhdGUgYSBuZXcgVGltZXIuXG4gIH0gZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGZhc3ROb3dUaW1lb3V0KVxuICAgIGZhc3ROb3dUaW1lb3V0ID0gc2V0VGltZW91dChvblRpY2ssIFRJQ0tfTVMpXG4gICAgLy8gSWYgdGhlIFRpbWVyIGhhcyBhbiB1bnJlZiBtZXRob2QsIGNhbGwgaXQgdG8gYWxsb3cgdGhlIHByb2Nlc3MgdG8gZXhpdCxcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgYWN0aXZlIGhhbmRsZXMuIFdoZW4gdXNpbmcgZmFrZSB0aW1lcnMgb3IgbW9ja2VkXG4gICAgLy8gZW52aXJvbm1lbnRzIChsaWtlIEplc3QpLCAudW5yZWYoKSBtYXkgbm90IGJlIGRlZmluZWQsXG4gICAgZmFzdE5vd1RpbWVvdXQ/LnVucmVmKClcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgRmFzdFRpbWVyYCBjbGFzcyBpcyBhIGRhdGEgc3RydWN0dXJlIGRlc2lnbmVkIHRvIHN0b3JlIGFuZCBtYW5hZ2VcbiAqIHRpbWVyIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBGYXN0VGltZXIge1xuICBba0Zhc3RUaW1lcl0gPSB0cnVlXG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0ZSBvZiB0aGUgdGltZXIsIHdoaWNoIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogLSBOT1RfSU5fTElTVCAoLTIpXG4gICAqIC0gVE9fQkVfQ0xFQVJFRCAoLTEpXG4gICAqIC0gUEVORElORyAoMClcbiAgICogLSBBQ1RJVkUgKDEpXG4gICAqXG4gICAqIEB0eXBlIHstMnwtMXwwfDF9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhdGUgPSBOT1RfSU5fTElTVFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pZGxlVGltZW91dCA9IC0xXG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB3aGVuIHRoZSB0aW1lciB3YXMgc3RhcnRlZC4gVGhpcyB2YWx1ZSBpcyB1c2VkIHRvXG4gICAqIGNhbGN1bGF0ZSB3aGVuIHRoZSB0aW1lciBzaG91bGQgZXhwaXJlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lkbGVTdGFydCA9IC0xXG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSB0aW1lciBleHBpcmVzLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UaW1lb3V0XG5cbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudCB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RpbWVyQXJnXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSB0aW1lclxuICAgKiBleHBpcmVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB0aW1lciBzaG91bGQgd2FpdFxuICAgKiBiZWZvcmUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvciBjb2RlIGlzIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0geyp9IGFyZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBkZWxheSwgYXJnKSB7XG4gICAgdGhpcy5fb25UaW1lb3V0ID0gY2FsbGJhY2tcbiAgICB0aGlzLl9pZGxlVGltZW91dCA9IGRlbGF5XG4gICAgdGhpcy5fdGltZXJBcmcgPSBhcmdcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGltZXIncyBzdGFydCB0aW1lIHRvIHRoZSBjdXJyZW50IHRpbWUsIGFuZCByZXNjaGVkdWxlcyB0aGUgdGltZXJcbiAgICogdG8gY2FsbCBpdHMgY2FsbGJhY2sgYXQgdGhlIHByZXZpb3VzbHkgc3BlY2lmaWVkIGR1cmF0aW9uIGFkanVzdGVkIHRvIHRoZVxuICAgKiBjdXJyZW50IHRpbWUuXG4gICAqIFVzaW5nIHRoaXMgb24gYSB0aW1lciB0aGF0IGhhcyBhbHJlYWR5IGNhbGxlZCBpdHMgY2FsbGJhY2sgd2lsbCByZWFjdGl2YXRlXG4gICAqIHRoZSB0aW1lci5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZWZyZXNoICgpIHtcbiAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHRoYXQgdGhlIHRpbWVyIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgdGltZXJzLFxuICAgIC8vIGFkZCBpdCBiYWNrIHRvIHRoZSBhcnJheSB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIG5leHQgdGljayBieSB0aGUgb25UaWNrXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBOT1RfSU5fTElTVCkge1xuICAgICAgZmFzdFRpbWVycy5wdXNoKHRoaXMpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRpbWVyIGlzIHRoZSBvbmx5IGFjdGl2ZSB0aW1lciwgcmVmcmVzaCB0aGUgZmFzdE5vd1RpbWVvdXQgZm9yXG4gICAgLy8gYmV0dGVyIHJlc29sdXRpb24uXG4gICAgaWYgKCFmYXN0Tm93VGltZW91dCB8fCBmYXN0VGltZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVmcmVzaFRpbWVvdXQoKVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgdGhlIHN0YXRlIHRvIFBFTkRJTkcgd2lsbCBjYXVzZSB0aGUgdGltZXIgdG8gYmUgcmVzZXQgaW4gdGhlXG4gICAgLy8gbmV4dCB0aWNrIGJ5IHRoZSBvblRpY2sgZnVuY3Rpb24uXG4gICAgdGhpcy5fc3RhdGUgPSBQRU5ESU5HXG4gIH1cblxuICAvKipcbiAgICogVGhlIGBjbGVhcmAgbWV0aG9kIGNhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGl0IGZyb20gZXhlY3V0aW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICAvLyBTZXQgdGhlIHN0YXRlIHRvIFRPX0JFX0NMRUFSRUQgdG8gbWFyayB0aGUgdGltZXIgZm9yIHJlbW92YWwgaW4gdGhlIG5leHRcbiAgICAvLyB0aWNrIGJ5IHRoZSBvblRpY2sgZnVuY3Rpb24uXG4gICAgdGhpcy5fc3RhdGUgPSBUT19CRV9DTEVBUkVEXG5cbiAgICAvLyBSZXNldCB0aGUgX2lkbGVTdGFydCB2YWx1ZSB0byAtMSB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0aW1lciBpcyBubyBsb25nZXJcbiAgICAvLyBhY3RpdmUuXG4gICAgdGhpcy5faWRsZVN0YXJ0ID0gLTFcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgYSBzZXRUaW1lb3V0IGFuZCBjbGVhclRpbWVvdXQgZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAqIHVzZWQgYXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgbmF0aXZlIGZ1bmN0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgc2V0VGltZW91dCgpIG1ldGhvZCBzZXRzIGEgdGltZXIgd2hpY2ggZXhlY3V0ZXMgYSBmdW5jdGlvbiBvbmNlIHRoZVxuICAgKiB0aW1lciBleHBpcmVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSB0aW1lclxuICAgKiBleHBpcmVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB0aW1lciBzaG91bGRcbiAgICogd2FpdCBiZWZvcmUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvciBjb2RlIGlzIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0geyp9IFthcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogd2hlbiB0aGUgdGltZXIgZXhwaXJlcy5cbiAgICogQHJldHVybnMge05vZGVKUy5UaW1lb3V0fEZhc3RUaW1lcn1cbiAgICovXG4gIHNldFRpbWVvdXQgKGNhbGxiYWNrLCBkZWxheSwgYXJnKSB7XG4gICAgLy8gSWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgUkVTT0xVVElPTl9NUyB2YWx1ZSByZXR1cm4gYVxuICAgIC8vIG5hdGl2ZSBOb2RlLmpzIFRpbWVyIGluc3RhbmNlLlxuICAgIHJldHVybiBkZWxheSA8PSBSRVNPTFVUSU9OX01TXG4gICAgICA/IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBhcmcpXG4gICAgICA6IG5ldyBGYXN0VGltZXIoY2FsbGJhY2ssIGRlbGF5LCBhcmcpXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgY2xlYXJUaW1lb3V0IG1ldGhvZCBjYW5jZWxzIGFuIGluc3RhbnRpYXRlZCBUaW1lciBwcmV2aW91c2x5IGNyZWF0ZWRcbiAgICogYnkgY2FsbGluZyBzZXRUaW1lb3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVKUy5UaW1lb3V0fEZhc3RUaW1lcn0gdGltZW91dFxuICAgKi9cbiAgY2xlYXJUaW1lb3V0ICh0aW1lb3V0KSB7XG4gICAgLy8gSWYgdGhlIHRpbWVvdXQgaXMgYSBGYXN0VGltZXIsIGNhbGwgaXRzIG93biBjbGVhciBtZXRob2QuXG4gICAgaWYgKHRpbWVvdXRba0Zhc3RUaW1lcl0pIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0Zhc3RUaW1lcn1cbiAgICAgICAqL1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgICAvLyBPdGhlcndpc2UgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgYSBuYXRpdmUgTm9kZUpTLlRpbWVvdXQsIHNvIGNhbGwgdGhlXG4gICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBjbGVhclRpbWVvdXQgZnVuY3Rpb24uXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzZXRGYXN0VGltZW91dCgpIG1ldGhvZCBzZXRzIGEgZmFzdFRpbWVyIHdoaWNoIGV4ZWN1dGVzIGEgZnVuY3Rpb24gb25jZVxuICAgKiB0aGUgdGltZXIgZXhwaXJlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgdGltZXJcbiAgICogZXhwaXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdGltZXIgc2hvdWxkXG4gICAqIHdhaXQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb3IgY29kZSBpcyBleGVjdXRlZC5cbiAgICogQHBhcmFtIHsqfSBbYXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqIEByZXR1cm5zIHtGYXN0VGltZXJ9XG4gICAqL1xuICBzZXRGYXN0VGltZW91dCAoY2FsbGJhY2ssIGRlbGF5LCBhcmcpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RUaW1lcihjYWxsYmFjaywgZGVsYXksIGFyZylcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBjbGVhclRpbWVvdXQgbWV0aG9kIGNhbmNlbHMgYW4gaW5zdGFudGlhdGVkIEZhc3RUaW1lciBwcmV2aW91c2x5XG4gICAqIGNyZWF0ZWQgYnkgY2FsbGluZyBzZXRGYXN0VGltZW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtGYXN0VGltZXJ9IHRpbWVvdXRcbiAgICovXG4gIGNsZWFyRmFzdFRpbWVvdXQgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsZWFyKClcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBub3cgbWV0aG9kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBpbnRlcm5hbCBmYXN0IHRpbWVyIGNsb2NrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgbm93ICgpIHtcbiAgICByZXR1cm4gZmFzdE5vd1xuICB9LFxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgb25UaWNrIGZ1bmN0aW9uIHRvIHByb2Nlc3MgdGhlIGZhc3RUaW1lcnMgYXJyYXkuXG4gICAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gICAqIE1hcmtpbmcgYXMgZGVwcmVjYXRlZCB0byBkaXNjb3VyYWdlIGFueSB1c2Ugb3V0c2lkZSBvZiB0ZXN0aW5nLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gYWRkIHRvIHRoZSBub3cgdmFsdWUuXG4gICAqL1xuICB0aWNrIChkZWxheSA9IDApIHtcbiAgICBmYXN0Tm93ICs9IGRlbGF5IC0gUkVTT0xVVElPTl9NUyArIDFcbiAgICBvblRpY2soKVxuICAgIG9uVGljaygpXG4gIH0sXG4gIC8qKlxuICAgKiBSZXNldCBGYXN0VGltZXJzLlxuICAgKiBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBNYXJraW5nIGFzIGRlcHJlY2F0ZWQgdG8gZGlzY291cmFnZSBhbnkgdXNlIG91dHNpZGUgb2YgdGVzdGluZy5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlc2V0ICgpIHtcbiAgICBmYXN0Tm93ID0gMFxuICAgIGZhc3RUaW1lcnMubGVuZ3RoID0gMFxuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IG51bGxcbiAgfSxcbiAgLyoqXG4gICAqIEV4cG9ydGluZyBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBNYXJraW5nIGFzIGRlcHJlY2F0ZWQgdG8gZGlzY291cmFnZSBhbnkgdXNlIG91dHNpZGUgb2YgdGVzdGluZy5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGtGYXN0VGltZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cache/util.js\")\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { cloneResponse, fromInnerResponse, getResponseState } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { Request, fromInnerRequest, getRequestState } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { urlIsHttpHttpsScheme, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { createDeferredPromise } = __webpack_require__(/*! ../../util/promise */ \"(rsc)/./node_modules/undici/lib/util/promise.js\")\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = getRequestState(request)\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = getRequestState(new Request(request))\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (webidl.is.Request(request)) {\n      innerRequest = getRequestState(request)\n    } else { // 3.\n      innerRequest = getRequestState(new Request(request))\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = getResponseState(response)\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (webidl.is.Request(request)) {\n      r = getRequestState(request)\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = getRequestState(new Request(request))\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          undefined,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(cloneResponse(response), 'immutable')\n\n      responseList.push(responseObject)\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(\n  webidl.is.Response,\n  'Response'\n)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDdEQsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEscURBQXFELEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDMUYsUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLDhFQUFrQjtBQUNqRixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDBFQUFnQjtBQUM3QyxRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMsd0VBQWU7QUFDdEUsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjs7QUFFOUQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsa0RBQWtEO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyB1cmxFcXVhbHMsIGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBjbG9uZVJlc3BvbnNlLCBmcm9tSW5uZXJSZXNwb25zZSwgZ2V0UmVzcG9uc2VTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBSZXF1ZXN0LCBmcm9tSW5uZXJSZXF1ZXN0LCBnZXRSZXF1ZXN0U3RhdGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyB1cmxJc0h0dHBIdHRwc1NjaGVtZSwgcmVhZEFsbEJ5dGVzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IHsgY3JlYXRlRGVmZXJyZWRQcm9taXNlIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL3Byb21pc2UnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1jYWNoZS1iYXRjaC1vcGVyYXRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlQmF0Y2hPcGVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7J2RlbGV0ZScgfCAncHV0J30gdHlwZVxuICogQHByb3BlcnR5IHthbnl9IHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAqIEB0eXBlZGVmIHtbYW55LCBhbnldW119IHJlcXVlc3RSZXNwb25zZUxpc3RcbiAqL1xuXG5jbGFzcyBDYWNoZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gICAqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGFyZ3VtZW50c1sxXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLm1hdGNoJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgY29uc3QgcCA9IHRoaXMuI2ludGVybmFsTWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucywgMSlcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHBbMF1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoQWxsIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5tYXRjaEFsbCdcbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxNYXRjaEFsbChyZXF1ZXN0LCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgYWRkIChyZXF1ZXN0KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUuYWRkJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3JlcXVlc3RdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlc3BvbnNlQXJyYXlQcm9taXNlID0gdGhpcy5hZGRBbGwocmVxdWVzdHMpXG5cbiAgICAvLyAzLlxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZUFycmF5UHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgYWRkQWxsIChyZXF1ZXN0cykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmFkZEFsbCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgIC8vIDMuXG4gICAgZm9yIChsZXQgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCBpcyBub3QgYWxsb3dlZCddXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuXG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDMuMVxuICAgICAgY29uc3QgciA9IGdldFJlcXVlc3RTdGF0ZShyZXF1ZXN0KVxuXG4gICAgICAvLyAzLjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpIHx8IHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVC4nXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICAvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIGZldGNoaW5nPltdfSAqL1xuICAgIGNvbnN0IGZldGNoQ29udHJvbGxlcnMgPSBbXVxuXG4gICAgLy8gNS5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIC8vIDUuMVxuICAgICAgY29uc3QgciA9IGdldFJlcXVlc3RTdGF0ZShuZXcgUmVxdWVzdChyZXF1ZXN0KSlcblxuICAgICAgLy8gNS4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUuJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjRcbiAgICAgIHIuaW5pdGlhdG9yID0gJ2ZldGNoJ1xuICAgICAgci5kZXN0aW5hdGlvbiA9ICdzdWJyZXNvdXJjZSdcblxuICAgICAgLy8gNS41XG4gICAgICByZXF1ZXN0TGlzdC5wdXNoKHIpXG5cbiAgICAgIC8vIDUuNlxuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgICAgLy8gNS43XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLnB1c2goZmV0Y2hpbmcoe1xuICAgICAgICByZXF1ZXN0OiByLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNiB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID4gMjk5KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUgb3IgdGhlIHJlcXVlc3QgZmFpbGVkLidcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkgeyAvLyAyLlxuICAgICAgICAgICAgLy8gMi4xXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAgICAgICAvLyAyLjJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgICAvLyAyLjIuMVxuICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9KSlcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignYWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLlxuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KSlcblxuICAgICAgLy8gNS44XG4gICAgICByZXNwb25zZVByb21pc2VzLnB1c2gocmVzcG9uc2VQcm9taXNlLnByb21pc2UpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICBjb25zdCBwID0gUHJvbWlzZS5hbGwocmVzcG9uc2VQcm9taXNlcylcblxuICAgIC8vIDcuXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcFxuXG4gICAgLy8gNy4xXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyA3LjJcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyA3LjNcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNy4zLjFcbiAgICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ3B1dCcsIC8vIDcuMy4yXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RMaXN0W2luZGV4XSwgLy8gNy4zLjNcbiAgICAgICAgcmVzcG9uc2UgLy8gNy4zLjRcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbikgLy8gNy4zLjVcblxuICAgICAgaW5kZXgrKyAvLyA3LjMuNlxuICAgIH1cblxuICAgIC8vIDcuNVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LjYuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyA3LjYuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyA3LjYuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDcuNi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNy42LjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNy43XG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBwdXQgKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUucHV0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgcmVzcG9uc2UgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZShyZXNwb25zZSwgcHJlZml4LCAncmVzcG9uc2UnKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgaW5uZXJSZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAod2ViaWRsLmlzLlJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIGlubmVyUmVxdWVzdCA9IGdldFJlcXVlc3RTdGF0ZShyZXF1ZXN0KVxuICAgIH0gZWxzZSB7IC8vIDMuXG4gICAgICBpbm5lclJlcXVlc3QgPSBnZXRSZXF1ZXN0U3RhdGUobmV3IFJlcXVlc3QocmVxdWVzdCkpXG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGlubmVyUmVxdWVzdC51cmwpIHx8IGlubmVyUmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYW4gaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VUJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIGNvbnN0IGlubmVyUmVzcG9uc2UgPSBnZXRSZXNwb25zZVN0YXRlKHJlc3BvbnNlKVxuXG4gICAgLy8gNi5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ0dvdCAyMDYgc3RhdHVzJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA3LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JykpIHtcbiAgICAgIC8vIDcuMS5cbiAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgICAgLy8gNy4yLlxuICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgIC8vIDcuMi4xXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdHb3QgKiB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgJiYgKGlzRGlzdHVyYmVkKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pIHx8IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0ubG9ja2VkKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc3BvbnNlIGJvZHkgaXMgbG9ja2VkIG9yIGRpc3R1cmJlZCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gOS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UoaW5uZXJSZXNwb25zZSlcblxuICAgIC8vIDEwLlxuICAgIGNvbnN0IGJvZHlSZWFkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxMS5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDExLjFcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW1cblxuICAgICAgLy8gMTEuMlxuICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgICAgIC8vIDExLjNcbiAgICAgIHJlYWRBbGxCeXRlcyhyZWFkZXIsIGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlLCBib2R5UmVhZFByb21pc2UucmVqZWN0KVxuICAgIH0gZWxzZSB7XG4gICAgICBib2R5UmVhZFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgLy8gMTIuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyAxMy5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ3B1dCcsIC8vIDE0LlxuICAgICAgcmVxdWVzdDogaW5uZXJSZXF1ZXN0LCAvLyAxNS5cbiAgICAgIHJlc3BvbnNlOiBjbG9uZWRSZXNwb25zZSAvLyAxNi5cbiAgICB9XG5cbiAgICAvLyAxNy5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgLy8gMTkuXG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBib2R5UmVhZFByb21pc2UucHJvbWlzZVxuXG4gICAgaWYgKGNsb25lZFJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY2xvbmVkUmVzcG9uc2UuYm9keS5zb3VyY2UgPSBieXRlc1xuICAgIH1cblxuICAgIC8vIDE5LjFcbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTkuMi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDE5LjIuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyAxOS4yLjNcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyAxOS4yLjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9IGVsc2UgeyAvLyAxOS4yLjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBkZWxldGUgKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZXF1ZXN0fVxuICAgICAqL1xuICAgIGxldCByID0gbnVsbFxuXG4gICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICByID0gZ2V0UmVxdWVzdFN0YXRlKHJlcXVlc3QpXG5cbiAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKVxuXG4gICAgICByID0gZ2V0UmVxdWVzdFN0YXRlKG5ldyBSZXF1ZXN0KHJlcXVlc3QpKVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgcmVxdWVzdDogcixcbiAgICAgIG9wdGlvbnNcbiAgICB9XG5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG4gICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSghIXJlcXVlc3RSZXNwb25zZXM/Lmxlbmd0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGUta2V5c1xuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxyZWFkb25seSBSZXF1ZXN0W10+fVxuICAgKi9cbiAgYXN5bmMga2V5cyAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUua2V5cydcblxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDIuMVxuICAgICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykgeyAvLyAyLjJcbiAgICAgICAgciA9IGdldFJlcXVlc3RTdGF0ZShuZXcgUmVxdWVzdChyZXF1ZXN0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIC8vIDUuMi4xLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgLy8gNS4zLjIuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA1LjQuMVxuICAgICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgICAvLyA1LjQuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPYmplY3QgPSBmcm9tSW5uZXJSZXF1ZXN0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwsXG4gICAgICAgICAgJ2ltbXV0YWJsZSdcbiAgICAgICAgKVxuICAgICAgICAvLyA1LjQuMi4xXG4gICAgICAgIHJlcXVlc3RMaXN0LnB1c2gocmVxdWVzdE9iamVjdClcbiAgICAgIH1cblxuICAgICAgLy8gNS40LjNcbiAgICAgIHByb21pc2UucmVzb2x2ZShPYmplY3QuZnJlZXplKHJlcXVlc3RMaXN0KSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2JhdGNoLWNhY2hlLW9wZXJhdGlvbnMtYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2JhdGNoQ2FjaGVPcGVyYXRpb25zIChvcGVyYXRpb25zKSB7XG4gICAgLy8gMS5cbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgLy8gMi5cbiAgICBjb25zdCBiYWNrdXBDYWNoZSA9IFsuLi5jYWNoZV1cblxuICAgIC8vIDMuXG4gICAgY29uc3QgYWRkZWRJdGVtcyA9IFtdXG5cbiAgICAvLyA0LjFcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIHRyeSB7XG4gICAgICAvLyA0LjJcbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgLy8gNC4yLjFcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlICE9PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24udHlwZSAhPT0gJ3B1dCcpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ29wZXJhdGlvbiB0eXBlIGRvZXMgbm90IG1hdGNoIFwiZGVsZXRlXCIgb3IgXCJwdXRcIidcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24ucmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnZGVsZXRlIG9wZXJhdGlvbiBzaG91bGQgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjNcbiAgICAgICAgaWYgKHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zLCBhZGRlZEl0ZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCc/Pz8nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjRcbiAgICAgICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgICAgICAvLyA0LjIuNVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgLy8gNC4yLjUuMVxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucylcblxuICAgICAgICAgIC8vIFRPRE86IHRoZSBzcGVjIGlzIHdyb25nLCB0aGlzIGlzIG5lZWRlZCB0byBwYXNzIFdQVHNcbiAgICAgICAgICBpZiAocmVxdWVzdFJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi41LjJcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNS4yLjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSAncHV0JykgeyAvLyA0LjIuNlxuICAgICAgICAgIC8vIDQuMi42LjFcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLnJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3B1dCBvcGVyYXRpb24gc2hvdWxkIGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuMlxuICAgICAgICAgIGNvbnN0IHIgPSBvcGVyYXRpb24ucmVxdWVzdFxuXG4gICAgICAgICAgLy8gNC4yLjYuM1xuICAgICAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdleHBlY3RlZCBodHRwIG9yIGh0dHBzIHNjaGVtZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNFxuICAgICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ25vdCBnZXQgbWV0aG9kJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi41XG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ29wdGlvbnMgbXVzdCBub3QgYmUgZGVmaW5lZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNlxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0KVxuXG4gICAgICAgICAgLy8gNC4yLjYuN1xuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi42LjcuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi44XG4gICAgICAgICAgY2FjaGUucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG5cbiAgICAgICAgICAvLyA0LjIuNi4xMFxuICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuN1xuICAgICAgICByZXN1bHRMaXN0LnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgfVxuXG4gICAgICAvLyA0LjNcbiAgICAgIHJldHVybiByZXN1bHRMaXN0XG4gICAgfSBjYXRjaCAoZSkgeyAvLyA1LlxuICAgICAgLy8gNS4xXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QubGVuZ3RoID0gMFxuXG4gICAgICAvLyA1LjJcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGJhY2t1cENhY2hlXG5cbiAgICAgIC8vIDUuM1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNxdWVyeS1jYWNoZVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gdGFyZ2V0U3RvcmFnZVxuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNxdWVyeUNhY2hlIChyZXF1ZXN0UXVlcnksIG9wdGlvbnMsIHRhcmdldFN0b3JhZ2UpIHtcbiAgICAvKiogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9ICovXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0U3RvcmFnZSA/PyB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IFtjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZV0gPSByZXF1ZXN0UmVzcG9uc2VcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0ocmVxdWVzdFF1ZXJ5LCBjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3JlcXVlc3QtbWF0Y2hlcy1jYWNoZWQtaXRlbS1hbGdvcml0aG1cbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueSB8IG51bGx9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zIHwgdW5kZWZpbmVkfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSAocmVxdWVzdFF1ZXJ5LCByZXF1ZXN0LCByZXNwb25zZSA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiAob3B0aW9ucz8uaWdub3JlTWV0aG9kID09PSBmYWxzZSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyAgIHJldHVybiBmYWxzZVxuICAgIC8vIH1cblxuICAgIGNvbnN0IHF1ZXJ5VVJMID0gbmV3IFVSTChyZXF1ZXN0UXVlcnkudXJsKVxuXG4gICAgY29uc3QgY2FjaGVkVVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybClcblxuICAgIGlmIChvcHRpb25zPy5pZ25vcmVTZWFyY2gpIHtcbiAgICAgIGNhY2hlZFVSTC5zZWFyY2ggPSAnJ1xuXG4gICAgICBxdWVyeVVSTC5zZWFyY2ggPSAnJ1xuICAgIH1cblxuICAgIGlmICghdXJsRXF1YWxzKHF1ZXJ5VVJMLCBjYWNoZWRVUkwsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICByZXNwb25zZSA9PSBudWxsIHx8XG4gICAgICBvcHRpb25zPy5pZ25vcmVWYXJ5IHx8XG4gICAgICAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0VmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuICAgICAgY29uc3QgcXVlcnlWYWx1ZSA9IHJlcXVlc3RRdWVyeS5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcblxuICAgICAgLy8gSWYgb25lIGhhcyB0aGUgaGVhZGVyIGFuZCB0aGUgb3RoZXIgZG9lc24ndCwgb3Igb25lIGhhc1xuICAgICAgLy8gYSBkaWZmZXJlbnQgdmFsdWUgdGhhbiB0aGUgb3RoZXIsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHJlcXVlc3RWYWx1ZSAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI2ludGVybmFsTWF0Y2hBbGwgKHJlcXVlc3QsIG9wdGlvbnMsIG1heFJlc3BvbnNlcyA9IEluZmluaXR5KSB7XG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAyLjIuMVxuICAgICAgICByID0gZ2V0UmVxdWVzdFN0YXRlKG5ldyBSZXF1ZXN0KHJlcXVlc3QpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVzcG9uc2VzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICAvLyBXZSBkb24ndCBpbXBsZW1lbnQgQ09ScyBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvb3Agb3ZlciB0aGUgcmVzcG9uc2VzLCB5YXkhXG5cbiAgICAvLyA1LjUuMVxuICAgIGNvbnN0IHJlc3BvbnNlTGlzdCA9IFtdXG5cbiAgICAvLyA1LjUuMlxuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA1LjUuMi4xXG4gICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKGNsb25lUmVzcG9uc2UocmVzcG9uc2UpLCAnaW1tdXRhYmxlJylcblxuICAgICAgcmVzcG9uc2VMaXN0LnB1c2gocmVzcG9uc2VPYmplY3QpXG5cbiAgICAgIGlmIChyZXNwb25zZUxpc3QubGVuZ3RoID49IG1heFJlc3BvbnNlcykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDYuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzcG9uc2VMaXN0KVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhY2hlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbWF0Y2hBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwdXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuY29uc3QgY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMgPSBbXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVTZWFyY2gnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVNZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVWYXJ5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzLFxuICB7XG4gICAga2V5OiAnY2FjaGVOYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5SZXNwb25zZSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5pcy5SZXNwb25zZSxcbiAgJ1Jlc3BvbnNlJ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8UmVxdWVzdEluZm8+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/undici/lib/web/cache/cache.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match')\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.open'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsbUVBQVM7QUFDbkMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9COztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcY2FjaGVzdG9yYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IENhY2hlIH0gPSByZXF1aXJlKCcuL2NhY2hlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuXG5jbGFzcyBDYWNoZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LW5hbWUtdG8tY2FjaGUtbWFwXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vY2FjaGUnKS5yZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2NhY2hlcyA9IG5ldyBNYXAoKVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdDYWNoZVN0b3JhZ2UubWF0Y2gnKVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIDEuXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVOYW1lICE9IG51bGwpIHtcbiAgICAgIC8vIDEuMS4xLjFcbiAgICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKG9wdGlvbnMuY2FjaGVOYW1lKSkge1xuICAgICAgICAvLyAxLjEuMS4xLjFcbiAgICAgICAgY29uc3QgY2FjaGVMaXN0ID0gdGhpcy4jY2FjaGVzLmdldChvcHRpb25zLmNhY2hlTmFtZSlcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGVMaXN0KVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDIuXG4gICAgICAvLyAyLjJcbiAgICAgIGZvciAoY29uc3QgY2FjaGVMaXN0IG9mIHRoaXMuI2NhY2hlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgLy8gMi4yLjEuMlxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKHJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWhhc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgaGFzIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGVTdG9yYWdlLmhhcydcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICAvLyAyLjEuMVxuICAgIC8vIDIuMlxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGVzdG9yYWdlLW9wZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZT59XG4gICAqL1xuICBhc3luYyBvcGVuIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGVTdG9yYWdlLm9wZW4nXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lLCBwcmVmaXgsICdjYWNoZU5hbWUnKVxuXG4gICAgLy8gMi4xXG4gICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKSkge1xuICAgICAgLy8gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJykgIT09IGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpXG5cbiAgICAgIC8vIDIuMS4xXG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMuI2NhY2hlcy5nZXQoY2FjaGVOYW1lKVxuXG4gICAgICAvLyAyLjEuMS4xXG4gICAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICAgIH1cblxuICAgIC8vIDIuMlxuICAgIGNvbnN0IGNhY2hlID0gW11cblxuICAgIC8vIDIuM1xuICAgIHRoaXMuI2NhY2hlcy5zZXQoY2FjaGVOYW1lLCBjYWNoZSlcblxuICAgIC8vIDIuNFxuICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1kZWxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZSAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlU3RvcmFnZS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lLCBwcmVmaXgsICdjYWNoZU5hbWUnKVxuXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5kZWxldGUoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2Uta2V5c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59XG4gICAqL1xuICBhc3luYyBrZXlzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICAvLyAyLjFcbiAgICBjb25zdCBrZXlzID0gdGhpcy4jY2FjaGVzLmtleXMoKVxuXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIFsuLi5rZXlzXVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhY2hlU3RvcmFnZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0NhY2hlU3RvcmFnZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlU3RvcmFnZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction getFieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (isValidHeaderName(value)) {\n      values.push(value)\n    }\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  getFieldValues\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWU7O0FBRXJEO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNhY2hlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgaXNWYWxpZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1lcXVhbHNcbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSBleGNsdWRlRnJhZ21lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxFcXVhbHMgKEEsIEIsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRBID0gVVJMU2VyaWFsaXplcihBLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgY29uc3Qgc2VyaWFsaXplZEIgPSBVUkxTZXJpYWxpemVyKEIsIGV4Y2x1ZGVGcmFnbWVudClcblxuICByZXR1cm4gc2VyaWFsaXplZEEgPT09IHNlcmlhbGl6ZWRCXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi82OTRkMjBkMTM0Y2I1NTNkOGQ4OWU1NTAwYjkxNDgwMTJiMWJhMjk5L2NvbnRlbnQvYnJvd3Nlci9jYWNoZV9zdG9yYWdlL2NhY2hlX3N0b3JhZ2VfY2FjaGUuY2MjTDI2MC1MMjYyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWVzIChoZWFkZXIpIHtcbiAgYXNzZXJ0KGhlYWRlciAhPT0gbnVsbClcblxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIGZvciAobGV0IHZhbHVlIG9mIGhlYWRlci5zcGxpdCgnLCcpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIGlmIChpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVybEVxdWFscyxcbiAgZ2V0RmllbGRWYWx1ZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1hdHRyaWJ1dGUtdmFsdWUtc2l6ZVxuY29uc3QgbWF4QXR0cmlidXRlVmFsdWVTaXplID0gMTAyNFxuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tbmFtZS12YWx1ZS1wYWlyLXNpemVcbmNvbnN0IG1heE5hbWVWYWx1ZVBhaXJTaXplID0gNDA5NlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4QXR0cmlidXRlVmFsdWVTaXplLFxuICBtYXhOYW1lVmFsdWVQYWlyU2l6ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/undici/lib/web/cookies/parse.js\")\nconst { stringify } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\n\nconst brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean))\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number} [expires]\n * @property {number} [maxAge]\n * @property {string} [domain]\n * @property {string} [path]\n * @property {boolean} [secure]\n * @property {boolean} [httpOnly]\n * @property {'Strict'|'Lax'|'None'} [sameSite]\n * @property {string[]} [unparsed]\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getCookies')\n\n  brandChecks(headers)\n\n  const cookie = headers.get('cookie')\n\n  /** @type {Record<string, string>} */\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  brandChecks(headers)\n\n  const prefix = 'deleteCookie'\n  webidl.argumentLengthCheck(arguments, 2, prefix)\n\n  name = webidl.converters.DOMString(name, prefix, 'name')\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getSetCookies')\n\n  brandChecks(headers)\n\n  const cookies = headers.getSetCookie()\n\n  if (!cookies) {\n    return []\n  }\n\n  return cookies.map((pair) => parseSetCookie(pair))\n}\n\n/**\n * Parses a cookie string\n * @param {string} cookie\n */\nfunction parseCookie (cookie) {\n  cookie = webidl.converters.DOMString(cookie)\n\n  return parseSetCookie(cookie)\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, 'setCookie')\n\n  brandChecks(headers)\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('set-cookie', str, true)\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: () => []\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie,\n  parseCookie\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMscUVBQVM7QUFDNUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUTtBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsOEVBQWtCOztBQUU5Qzs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsVUFBVTtBQUN4Qjs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsd0JBQXdCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdDQUFnQyxZQUFZO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY29va2llc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGFyc2VTZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5cbmNvbnN0IGJyYW5kQ2hlY2tzID0gd2ViaWRsLmJyYW5kQ2hlY2tNdWx0aXBsZShbSGVhZGVycywgZ2xvYmFsVGhpcy5IZWFkZXJzXS5maWx0ZXIoQm9vbGVhbikpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29va2llXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0RhdGV8bnVtYmVyfSBbZXhwaXJlc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4QWdlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkb21haW5dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BhdGhdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZWN1cmVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtodHRwT25seV1cbiAqIEBwcm9wZXJ0eSB7J1N0cmljdCd8J0xheCd8J05vbmUnfSBbc2FtZVNpdGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbdW5wYXJzZWRdXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ2dldENvb2tpZXMnKVxuXG4gIGJyYW5kQ2hlY2tzKGhlYWRlcnMpXG5cbiAgY29uc3QgY29va2llID0gaGVhZGVycy5nZXQoJ2Nvb2tpZScpXG5cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICBjb25zdCBvdXQgPSB7fVxuXG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBjb29raWUuc3BsaXQoJzsnKSkge1xuICAgIGNvbnN0IFtuYW1lLCAuLi52YWx1ZV0gPSBwaWVjZS5zcGxpdCgnPScpXG5cbiAgICBvdXRbbmFtZS50cmltKCldID0gdmFsdWUuam9pbignPScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IHBhdGg/OiBzdHJpbmcsIGRvbWFpbj86IHN0cmluZyB9fHVuZGVmaW5lZH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUNvb2tpZSAoaGVhZGVycywgbmFtZSwgYXR0cmlidXRlcykge1xuICBicmFuZENoZWNrcyhoZWFkZXJzKVxuXG4gIGNvbnN0IHByZWZpeCA9ICdkZWxldGVDb29raWUnXG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gIGF0dHJpYnV0ZXMgPSB3ZWJpZGwuY29udmVydGVycy5EZWxldGVDb29raWVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpXG5cbiAgLy8gTWF0Y2hlcyBiZWhhdmlvciBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvYmxvYi82MzgyN2IxNjMzMGI4MjQ4OWEwNDYxNDAyN2MzM2I3OTA0ZTA4YmU1L2h0dHAvY29va2llLnRzI0wyNzhcbiAgc2V0Q29va2llKGhlYWRlcnMsIHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiAnJyxcbiAgICBleHBpcmVzOiBuZXcgRGF0ZSgwKSxcbiAgICAuLi5hdHRyaWJ1dGVzXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7Q29va2llW119XG4gKi9cbmZ1bmN0aW9uIGdldFNldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2V0U2V0Q29va2llcycpXG5cbiAgYnJhbmRDaGVja3MoaGVhZGVycylcblxuICBjb25zdCBjb29raWVzID0gaGVhZGVycy5nZXRTZXRDb29raWUoKVxuXG4gIGlmICghY29va2llcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXMubWFwKChwYWlyKSA9PiBwYXJzZVNldENvb2tpZShwYWlyKSlcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBjb29raWUgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gY29va2llXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29va2llIChjb29raWUpIHtcbiAgY29va2llID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNvb2tpZSlcblxuICByZXR1cm4gcGFyc2VTZXRDb29raWUoY29va2llKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtDb29raWV9IGNvb2tpZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHNldENvb2tpZSAoaGVhZGVycywgY29va2llKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ3NldENvb2tpZScpXG5cbiAgYnJhbmRDaGVja3MoaGVhZGVycylcblxuICBjb29raWUgPSB3ZWJpZGwuY29udmVydGVycy5Db29raWUoY29va2llKVxuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShjb29raWUpXG5cbiAgaWYgKHN0cikge1xuICAgIGhlYWRlcnMuYXBwZW5kKCdzZXQtY29va2llJywgc3RyLCB0cnVlKVxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3BhdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5Db29raWUgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICduYW1lJ1xuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAga2V5OiAndmFsdWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcigodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10odmFsdWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICB9KSxcbiAgICBrZXk6ICdleHBpcmVzJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSksXG4gICAga2V5OiAnbWF4QWdlJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAnZG9tYWluJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdzZWN1cmUnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiksXG4gICAga2V5OiAnaHR0cE9ubHknLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAga2V5OiAnc2FtZVNpdGUnLFxuICAgIGFsbG93ZWRWYWx1ZXM6IFsnU3RyaWN0JywgJ0xheCcsICdOb25lJ11cbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAndW5wYXJzZWQnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gW11cbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvb2tpZXMsXG4gIGRlbGV0ZUNvb2tpZSxcbiAgZ2V0U2V0Q29va2llcyxcbiAgc2V0Q29va2llLFxuICBwYXJzZUNvb2tpZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/cookies/constants.js\")\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { unescape: qsUnescape } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns {import('./index').Cookie|null} if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  // https://datatracker.ietf.org/doc/html/rfc6265\n  // To maximize compatibility with user agents, servers that wish to\n  // store arbitrary data in a cookie-value SHOULD encode that data, for\n  // example, using Base64 [RFC4648].\n  return {\n    name, value: qsUnescape(value), ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {Object.<string, unknown>} [cookieAttributeList={}]\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsb0VBQVU7QUFDL0QsUUFBUSw4Q0FBOEMsRUFBRSxtQkFBTyxDQUFDLDZFQUFhO0FBQzdFLFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUTtBQUMvQyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLDBDQUFrQjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHdCQUF3QjtBQUN4QjtBQUNBLCtDQUErQztBQUMvQztBQUNBLGlDQUFpQztBQUNqQyx1QkFBdUI7O0FBRXZCLHVEQUF1RDtBQUN2RDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLDBCQUEwQix1QkFBdUI7QUFDNUQ7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLHlDQUF5QyxjQUFjLEdBQUcsZUFBZTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNvb2tpZXNcXHBhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IH0gPSByZXF1aXJlKCcuLi9pbmZyYScpXG5jb25zdCB7IG1heE5hbWVWYWx1ZVBhaXJTaXplLCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgaXNDVExFeGNsdWRpbmdIdGFiIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyB1bmVzY2FwZTogcXNVbmVzY2FwZSB9ID0gcmVxdWlyZSgnbm9kZTpxdWVyeXN0cmluZycpXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFBhcnNlcyB0aGUgZmllbGQtdmFsdWUgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyIHN0cmluZy5cbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvb2tpZXxudWxsfSBpZiB0aGUgaGVhZGVyIGlzIGludmFsaWQsIG51bGwgd2lsbCBiZSByZXR1cm5lZFxuICovXG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZSAoaGVhZGVyKSB7XG4gIC8vIDEuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4MDAtMDggLyAleDBBLTFGIC8gJXg3RlxuICAvLyAgICBjaGFyYWN0ZXIgKENUTCBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBIVEFCKTogQWJvcnQgdGhlc2Ugc3RlcHMgYW5kXG4gIC8vICAgIGlnbm9yZSB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChpc0NUTEV4Y2x1ZGluZ0h0YWIoaGVhZGVyKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgbmFtZVZhbHVlUGFpciA9ICcnXG4gIGxldCB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICBsZXQgbmFtZSA9ICcnXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMi4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGhlYWRlci5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sXG4gICAgLy8gICAgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIiksIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBjb25zaXN0IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIHNldC1jb29raWUtc3RyaW5nXG4gICAgLy8gICAgKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgbmFtZVZhbHVlUGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgaGVhZGVyLCBwb3NpdGlvbilcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSBoZWFkZXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgYWxsIHRoZSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgY29udGFpbmVkIGluIHRoZSBzZXQtY29va2llLXN0cmluZywgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGlzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgbmFtZVZhbHVlUGFpciA9IGhlYWRlclxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgbGFja3MgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyLCB0aGVuXG4gIC8vICAgIHRoZSBuYW1lIHN0cmluZyBpcyBlbXB0eSwgYW5kIHRoZSB2YWx1ZSBzdHJpbmcgaXMgdGhlIHZhbHVlIG9mXG4gIC8vICAgIG5hbWUtdmFsdWUtcGFpci5cbiAgaWYgKCFuYW1lVmFsdWVQYWlyLmluY2x1ZGVzKCc9JykpIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJcbiAgfSBlbHNlIHtcbiAgICAvLyAgICBPdGhlcndpc2UsIHRoZSBuYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5XG4gICAgLy8gICAgZW1wdHkpIHZhbHVlIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3RcbiAgICAvLyAgICAleDNEIChcIj1cIikgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gICAgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgbmFtZVZhbHVlUGFpcixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH1cblxuICAvLyA0LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgbmFtZVxuICAvLyAgICBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmcuXG4gIG5hbWUgPSBuYW1lLnRyaW0oKVxuICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gIC8vIDUuIElmIHRoZSBzdW0gb2YgdGhlIGxlbmd0aHMgb2YgdGhlIG5hbWUgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nXG4gIC8vICAgIGlzIG1vcmUgdGhhbiA0MDk2IG9jdGV0cywgYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGlnbm9yZSB0aGUgc2V0LVxuICAvLyAgICBjb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAobmFtZS5sZW5ndGggKyB2YWx1ZS5sZW5ndGggPiBtYXhOYW1lVmFsdWVQYWlyU2l6ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyA2LiBUaGUgY29va2llLW5hbWUgaXMgdGhlIG5hbWUgc3RyaW5nLCBhbmQgdGhlIGNvb2tpZS12YWx1ZSBpcyB0aGVcbiAgLy8gICAgdmFsdWUgc3RyaW5nLlxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzYyNjVcbiAgLy8gVG8gbWF4aW1pemUgY29tcGF0aWJpbGl0eSB3aXRoIHVzZXIgYWdlbnRzLCBzZXJ2ZXJzIHRoYXQgd2lzaCB0b1xuICAvLyBzdG9yZSBhcmJpdHJhcnkgZGF0YSBpbiBhIGNvb2tpZS12YWx1ZSBTSE9VTEQgZW5jb2RlIHRoYXQgZGF0YSwgZm9yXG4gIC8vIGV4YW1wbGUsIHVzaW5nIEJhc2U2NCBbUkZDNDY0OF0uXG4gIHJldHVybiB7XG4gICAgbmFtZSwgdmFsdWU6IHFzVW5lc2NhcGUodmFsdWUpLCAuLi5wYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlbWFpbmluZyBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXJcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IHVucGFyc2VkQXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgdW5rbm93bj59IFtjb29raWVBdHRyaWJ1dGVMaXN0PXt9XVxuICovXG5mdW5jdGlvbiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyAodW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0ID0ge30pIHtcbiAgLy8gMS4gSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mXG4gIC8vICAgIHRoZXNlIHN0ZXBzLlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb29raWVBdHRyaWJ1dGVMaXN0XG4gIH1cblxuICAvLyAyLiBEaXNjYXJkIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgKHdoaWNoXG4gIC8vICAgIHdpbGwgYmUgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyKS5cbiAgYXNzZXJ0KHVucGFyc2VkQXR0cmlidXRlc1swXSA9PT0gJzsnKVxuICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoMSlcblxuICBsZXQgY29va2llQXYgPSAnJ1xuXG4gIC8vIDMuIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuICAvLyAgICBjaGFyYWN0ZXI6XG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIENvbnN1bWUgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgIGNvb2tpZUF2ID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnOycsXG4gICAgICB1bnBhcnNlZEF0dHJpYnV0ZXMsXG4gICAgICB7IHBvc2l0aW9uOiAwIH1cbiAgICApXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKGNvb2tpZUF2Lmxlbmd0aClcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBDb25zdW1lIHRoZSByZW1haW5kZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMuXG4gICAgY29va2llQXYgPSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICB9XG5cbiAgLy8gTGV0IHRoZSBjb29raWUtYXYgc3RyaW5nIGJlIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGluIHRoaXMgc3RlcC5cblxuICBsZXQgYXR0cmlidXRlTmFtZSA9ICcnXG4gIGxldCBhdHRyaWJ1dGVWYWx1ZSA9ICcnXG5cbiAgLy8gNC4gSWYgdGhlIGNvb2tpZS1hdiBzdHJpbmcgY29udGFpbnMgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyOlxuICBpZiAoY29va2llQXYuaW5jbHVkZXMoJz0nKSkge1xuICAgIC8vIDEuIFRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGVcbiAgICAvLyAgICBjaGFyYWN0ZXJzIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmdcbiAgICAvLyAgICBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBjb29raWVBdixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIGF0dHJpYnV0ZVZhbHVlID0gY29va2llQXYuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGVudGlyZSBjb29raWUtYXZcbiAgICAvLyAgICBzdHJpbmcsIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZyBpcyBlbXB0eS5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29va2llQXZcbiAgfVxuXG4gIC8vIDUuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBhdHRyaWJ1dGUtXG4gIC8vICAgIG5hbWUgc3RyaW5nIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZy5cbiAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudHJpbSgpXG4gIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlVmFsdWUudHJpbSgpXG5cbiAgLy8gNi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBsb25nZXIgdGhhbiAxMDI0IG9jdGV0cywgaWdub3JlIHRoZVxuICAvLyAgICBjb29raWUtYXYgc3RyaW5nIGFuZCByZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID4gbWF4QXR0cmlidXRlVmFsdWVTaXplKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgfVxuXG4gIC8vIDcuIFByb2Nlc3MgdGhlIGF0dHJpYnV0ZS1uYW1lIGFuZCBhdHRyaWJ1dGUtdmFsdWUgYWNjb3JkaW5nIHRvIHRoZVxuICAvLyAgICByZXF1aXJlbWVudHMgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy4gIChOb3RpY2UgdGhhdFxuICAvLyAgICBhdHRyaWJ1dGVzIHdpdGggdW5yZWNvZ25pemVkIGF0dHJpYnV0ZS1uYW1lcyBhcmUgaWdub3JlZC4pXG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjFcbiAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgLy8gXCJFeHBpcmVzXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG4gIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZXhwaXJlcycpIHtcbiAgICAvLyAxLiBMZXQgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgYXR0cmlidXRlLXZhbHVlXG4gICAgLy8gICAgYXMgY29va2llLWRhdGUgKHNlZSBTZWN0aW9uIDUuMS4xKS5cbiAgICBjb25zdCBleHBpcnlUaW1lID0gbmV3IERhdGUoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyAyLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmVcbiAgICAvLyAgICB0aGUgY29va2llLWF2LlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5leHBpcmVzID0gZXhwaXJ5VGltZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdtYXgtYWdlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiTWF4LVxuICAgIC8vIEFnZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCBhIERJR0lUIG9yIGFcbiAgICAvLyAgICBcIi1cIiBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGNvbnN0IGNoYXJDb2RlID0gYXR0cmlidXRlVmFsdWUuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKChjaGFyQ29kZSA8IDQ4IHx8IGNoYXJDb2RlID4gNTcpICYmIGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLScpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYSBub24tRElHSVRcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGlmICghL15cXGQrJC8udGVzdChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGRlbHRhLXNlY29uZHMgYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlci5cbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBOdW1iZXIoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyA0LiBMZXQgY29va2llLWFnZS1saW1pdCBiZSB0aGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNvb2tpZSAod2hpY2hcbiAgICAvLyAgICBTSE9VTEQgYmUgNDAwIGRheXMgb3IgbGVzcywgc2VlIFNlY3Rpb24gNC4xLjIuMikuXG5cbiAgICAvLyA1LiBTZXQgZGVsdGEtc2Vjb25kcyB0byB0aGUgc21hbGxlciBvZiBpdHMgcHJlc2VudCB2YWx1ZSBhbmQgY29va2llLVxuICAgIC8vICAgIGFnZS1saW1pdC5cbiAgICAvLyBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVNlY29uZHMgKiAxMDAwLCBtYXhFeHBpcmVzTXMpXG5cbiAgICAvLyA2LiBJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS1cbiAgICAvLyAgICB0aW1lIGJlIHRoZSBlYXJsaWVzdCByZXByZXNlbnRhYmxlIGRhdGUgYW5kIHRpbWUuICBPdGhlcndpc2UsIGxldFxuICAgIC8vICAgIHRoZSBleHBpcnktdGltZSBiZSB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lIHBsdXMgZGVsdGEtc2Vjb25kc1xuICAgIC8vICAgIHNlY29uZHMuXG4gICAgLy8gY29uc3QgZXhwaXJ5VGltZSA9IGRlbHRhU2Vjb25kcyA8PSAwID8gRGF0ZS5ub3coKSA6IERhdGUubm93KCkgKyBkZWx0YVNlY29uZHNcblxuICAgIC8vIDcuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgTWF4LUFnZSBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGV4cGlyeS10aW1lLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QubWF4QWdlID0gZGVsdGFTZWNvbmRzXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2RvbWFpbicpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjNcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIkRvbWFpblwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBMZXQgY29va2llLWRvbWFpbiBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgIGxldCBjb29raWVEb21haW4gPSBhdHRyaWJ1dGVWYWx1ZVxuXG4gICAgLy8gMi4gSWYgY29va2llLWRvbWFpbiBzdGFydHMgd2l0aCAleDJFIChcIi5cIiksIGxldCBjb29raWUtZG9tYWluIGJlXG4gICAgLy8gICAgY29va2llLWRvbWFpbiB3aXRob3V0IGl0cyBsZWFkaW5nICV4MkUgKFwiLlwiKS5cbiAgICBpZiAoY29va2llRG9tYWluWzBdID09PSAnLicpIHtcbiAgICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi5zbGljZSgxKVxuICAgIH1cblxuICAgIC8vIDMuIENvbnZlcnQgdGhlIGNvb2tpZS1kb21haW4gdG8gbG93ZXIgY2FzZS5cbiAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNC4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBEb21haW4gYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtZG9tYWluLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZG9tYWluID0gY29va2llRG9tYWluXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3BhdGgnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC40XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJQYXRoXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAgICAvLyAgICBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90ICV4MkYgKFwiL1wiKTpcbiAgICBsZXQgY29va2llUGF0aCA9ICcnXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy8nKSB7XG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgIGNvb2tpZVBhdGggPSAnLydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICAgIGNvb2tpZVBhdGggPSBhdHRyaWJ1dGVWYWx1ZVxuICAgIH1cblxuICAgIC8vIDIuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgUGF0aCBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1wYXRoLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QucGF0aCA9IGNvb2tpZVBhdGhcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2VjdXJlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNVxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiU2VjdXJlXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3RcbiAgICAvLyB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zZWN1cmUgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2h0dHBvbmx5Jykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJIdHRwT25seVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1cbiAgICAvLyBhdHRyaWJ1dGUtbGlzdCB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIEh0dHBPbmx5IGFuZCBhbiBlbXB0eVxuICAgIC8vIGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuaHR0cE9ubHkgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NhbWVzaXRlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuN1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJTYW1lU2l0ZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzOlxuXG4gICAgLy8gMS4gTGV0IGVuZm9yY2VtZW50IGJlIFwiRGVmYXVsdFwiLlxuICAgIGxldCBlbmZvcmNlbWVudCA9ICdEZWZhdWx0J1xuXG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVWYWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgLy8gMi4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIk5vbmVcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTm9uZVwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbm9uZScpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdOb25lJ1xuICAgIH1cblxuICAgIC8vIDMuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJTdHJpY3RcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiU3RyaWN0XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdzdHJpY3QnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnU3RyaWN0J1xuICAgIH1cblxuICAgIC8vIDQuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJMYXhcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTGF4XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdsYXgnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTGF4J1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgXCJTYW1lU2l0ZVwiIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2ZcbiAgICAvLyAgICBlbmZvcmNlbWVudC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNhbWVTaXRlID0gZW5mb3JjZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkID8/PSBbXVxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZC5wdXNoKGAke2F0dHJpYnV0ZU5hbWV9PSR7YXR0cmlidXRlVmFsdWV9YClcbiAgfVxuXG4gIC8vIDguIFJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVNldENvb2tpZSxcbiAgcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction isCTLExcludingHtab (value) {\n  for (let i = 0; i < value.length; ++i) {\n    const code = value.charCodeAt(i)\n\n    if (\n      (code >= 0x00 && code <= 0x08) ||\n      (code >= 0x0A && code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (let i = 0; i < name.length; ++i) {\n    const code = name.charCodeAt(i)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31), SP and HT\n      code > 0x7E || // exclude non-ascii and DEL\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x3C || // <\n      code === 0x3E || // >\n      code === 0x40 || // @\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x3A || // :\n      code === 0x5C || // \\\n      code === 0x2F || // /\n      code === 0x5B || // [\n      code === 0x5D || // ]\n      code === 0x3F || // ?\n      code === 0x3D || // =\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  let len = value.length\n  let i = 0\n\n  // if the value is wrapped in DQUOTE\n  if (value[0] === '\"') {\n    if (len === 1 || value[len - 1] !== '\"') {\n      throw new Error('Invalid cookie value')\n    }\n    --len\n    ++i\n  }\n\n  while (i < len) {\n    const code = value.charCodeAt(i++)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code > 0x7E || // non-ascii and DEL (127)\n      code === 0x22 || // \"\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x5C // \\\n    ) {\n      throw new Error('Invalid cookie value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (let i = 0; i < path.length; ++i) {\n    const code = path.charCodeAt(i)\n\n    if (\n      code < 0x20 || // exclude CTLs (0-31)\n      code === 0x7F || // DEL\n      code === 0x3B // ;\n    ) {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\nconst IMFDays = [\n  'Sun', 'Mon', 'Tue', 'Wed',\n  'Thu', 'Fri', 'Sat'\n]\n\nconst IMFMonths = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  validateCookieName,\n  validateCookiePath,\n  validateCookieValue,\n  toIMFDate,\n  stringify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKLElBQUk7O0FBRUosOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwwQkFBMEIsSUFBSSxxQ0FBcUMsRUFBRSwrQkFBK0IsRUFBRSx1QkFBdUIsRUFBRSxxQ0FBcUMsR0FBRyx1Q0FBdUMsR0FBRyx3Q0FBd0M7QUFDclE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWSxHQUFHLGFBQWE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVcsR0FBRyxnQkFBZ0I7QUFDOUM7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNvb2tpZXNcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDVExFeGNsdWRpbmdIdGFiICh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIChjb2RlID49IDB4MDAgJiYgY29kZSA8PSAweDA4KSB8fFxuICAgICAgKGNvZGUgPj0gMHgwQSAmJiBjb2RlIDw9IDB4MUYpIHx8XG4gICAgICBjb2RlID09PSAweDdGXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gQ0hBUiAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNoYXJhY3RlciAob2N0ZXRzIDAgLSAxMjcpPlxuIHRva2VuICAgICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU5hbWUgKG5hbWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IG5hbWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKSwgU1AgYW5kIEhUXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBleGNsdWRlIG5vbi1hc2NpaSBhbmQgREVMXG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgzQyB8fCAvLyA8XG4gICAgICBjb2RlID09PSAweDNFIHx8IC8vID5cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHg1QyB8fCAvLyBcXFxuICAgICAgY29kZSA9PT0gMHgyRiB8fCAvLyAvXG4gICAgICBjb2RlID09PSAweDVCIHx8IC8vIFtcbiAgICAgIGNvZGUgPT09IDB4NUQgfHwgLy8gXVxuICAgICAgY29kZSA9PT0gMHgzRiB8fCAvLyA/XG4gICAgICBjb2RlID09PSAweDNEIHx8IC8vID1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG5hbWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXG4gY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gICAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llVmFsdWUgKHZhbHVlKSB7XG4gIGxldCBsZW4gPSB2YWx1ZS5sZW5ndGhcbiAgbGV0IGkgPSAwXG5cbiAgLy8gaWYgdGhlIHZhbHVlIGlzIHdyYXBwZWQgaW4gRFFVT1RFXG4gIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgIGlmIChsZW4gPT09IDEgfHwgdmFsdWVbbGVuIC0gMV0gIT09ICdcIicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgICAtLWxlblxuICAgICsraVxuICB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKyspXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBub24tYXNjaWkgYW5kIERFTCAoMTI3KVxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4NUMgLy8gXFxcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVQYXRoIChwYXRoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIwIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSlcbiAgICAgIGNvZGUgPT09IDB4N0YgfHwgLy8gREVMXG4gICAgICBjb2RlID09PSAweDNCIC8vIDtcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgcGF0aCcpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSSBoYXZlIG5vIGlkZWEgd2h5IHRoZXNlIHZhbHVlcyBhcmVuJ3QgYWxsb3dlZCB0byBiZSBob25lc3QsXG4gKiBidXQgRGVubyB0ZXN0cyB0aGVzZS4gLSBLaGFmcmFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVEb21haW4gKGRvbWFpbikge1xuICBpZiAoXG4gICAgZG9tYWluLnN0YXJ0c1dpdGgoJy0nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLicpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCctJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBkb21haW4nKVxuICB9XG59XG5cbmNvbnN0IElNRkRheXMgPSBbXG4gICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLFxuICAnVGh1JywgJ0ZyaScsICdTYXQnXG5dXG5cbmNvbnN0IElNRk1vbnRocyA9IFtcbiAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ1xuXVxuXG5jb25zdCBJTUZQYWRkZWROdW1iZXJzID0gQXJyYXkoNjEpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tNy4xLjEuMVxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGF0ZVxuICBJTUYtZml4ZGF0ZSAgPSBkYXktbmFtZSBcIixcIiBTUCBkYXRlMSBTUCB0aW1lLW9mLWRheSBTUCBHTVRcbiAgOyBmaXhlZCBsZW5ndGgvem9uZS9jYXBpdGFsaXphdGlvbiBzdWJzZXQgb2YgdGhlIGZvcm1hdFxuICA7IHNlZSBTZWN0aW9uIDMuMyBvZiBbUkZDNTMyMl1cblxuICBkYXktbmFtZSAgICAgPSAleDRELjZGLjZFIDsgXCJNb25cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0Ljc1LjY1IDsgXCJUdWVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU3LjY1LjY0IDsgXCJXZWRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0LjY4Ljc1IDsgXCJUaHVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjcyLjY5IDsgXCJGcmlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjYxLjc0IDsgXCJTYXRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjc1LjZFIDsgXCJTdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgZGF0ZTEgICAgICAgID0gZGF5IFNQIG1vbnRoIFNQIHllYXJcbiAgICAgICAgICAgICAgICAgIDsgZS5nLiwgMDIgSnVuIDE5ODJcblxuICBkYXkgICAgICAgICAgPSAyRElHSVRcbiAgbW9udGggICAgICAgID0gJXg0QS42MS42RSA7IFwiSmFuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni42NS42MiA7IFwiRmViXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43MiA7IFwiTWFyXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43MC43MiA7IFwiQXByXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43OSA7IFwiTWF5XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42RSA7IFwiSnVuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42QyA7IFwiSnVsXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43NS42NyA7IFwiQXVnXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42NS43MCA7IFwiU2VwXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ri42My43NCA7IFwiT2N0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RS42Ri43NiA7IFwiTm92XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0NC42NS42MyA7IFwiRGVjXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIHllYXIgICAgICAgICA9IDRESUdJVFxuXG4gIEdNVCAgICAgICAgICA9ICV4NDcuNEQuNTQgOyBcIkdNVFwiLCBjYXNlLXNlbnNpdGl2ZVxuXG4gIHRpbWUtb2YtZGF5ICA9IGhvdXIgXCI6XCIgbWludXRlIFwiOlwiIHNlY29uZFxuICAgICAgICAgICAgICA7IDAwOjAwOjAwIC0gMjM6NTk6NjAgKGxlYXAgc2Vjb25kKVxuXG4gIGhvdXIgICAgICAgICA9IDJESUdJVFxuICBtaW51dGUgICAgICAgPSAyRElHSVRcbiAgc2Vjb25kICAgICAgID0gMkRJR0lUXG4gKi9cbmZ1bmN0aW9uIHRvSU1GRGF0ZSAoZGF0ZSkge1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIH1cblxuICByZXR1cm4gYCR7SU1GRGF5c1tkYXRlLmdldFVUQ0RheSgpXX0sICR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ0RhdGUoKV19ICR7SU1GTW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV19ICR7ZGF0ZS5nZXRVVENGdWxsWWVhcigpfSAke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENIb3VycygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDTWludXRlcygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDU2Vjb25kcygpXX0gR01UYFxufVxuXG4vKipcbiBtYXgtYWdlLWF2ICAgICAgICA9IFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgICAgICAgICAgICAgOyBJbiBwcmFjdGljZSwgYm90aCBleHBpcmVzLWF2IGFuZCBtYXgtYWdlLWF2XG4gICAgICAgICAgICAgICAgICAgICAgIDsgYXJlIGxpbWl0ZWQgdG8gZGF0ZXMgcmVwcmVzZW50YWJsZSBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgOyB1c2VyIGFnZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFnZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU1heEFnZSAobWF4QWdlKSB7XG4gIGlmIChtYXhBZ2UgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBtYXgtYWdlJylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUjc2VjdGlvbi00LjEuMVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db29raWV9IGNvb2tpZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGNvb2tpZSkge1xuICBpZiAoY29va2llLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhbGlkYXRlQ29va2llTmFtZShjb29raWUubmFtZSlcbiAgdmFsaWRhdGVDb29raWVWYWx1ZShjb29raWUudmFsdWUpXG5cbiAgY29uc3Qgb3V0ID0gW2Ake2Nvb2tpZS5uYW1lfT0ke2Nvb2tpZS52YWx1ZX1gXVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMVxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjJcbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgfVxuXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX0hvc3QtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICAgIGNvb2tpZS5kb21haW4gPSBudWxsXG4gICAgY29va2llLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgb3V0LnB1c2goJ1NlY3VyZScpXG4gIH1cblxuICBpZiAoY29va2llLmh0dHBPbmx5KSB7XG4gICAgb3V0LnB1c2goJ0h0dHBPbmx5JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29va2llLm1heEFnZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZU1heEFnZShjb29raWUubWF4QWdlKVxuICAgIG91dC5wdXNoKGBNYXgtQWdlPSR7Y29va2llLm1heEFnZX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICB2YWxpZGF0ZUNvb2tpZURvbWFpbihjb29raWUuZG9tYWluKVxuICAgIG91dC5wdXNoKGBEb21haW49JHtjb29raWUuZG9tYWlufWApXG4gIH1cblxuICBpZiAoY29va2llLnBhdGgpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZVBhdGgoY29va2llLnBhdGgpXG4gICAgb3V0LnB1c2goYFBhdGg9JHtjb29raWUucGF0aH1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5leHBpcmVzICYmIGNvb2tpZS5leHBpcmVzLnRvU3RyaW5nKCkgIT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgb3V0LnB1c2goYEV4cGlyZXM9JHt0b0lNRkRhdGUoY29va2llLmV4cGlyZXMpfWApXG4gIH1cblxuICBpZiAoY29va2llLnNhbWVTaXRlKSB7XG4gICAgb3V0LnB1c2goYFNhbWVTaXRlPSR7Y29va2llLnNhbWVTaXRlfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29va2llLnVucGFyc2VkKSB7XG4gICAgaWYgKCFwYXJ0LmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bnBhcnNlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgW2tleSwgLi4udmFsdWVdID0gcGFydC5zcGxpdCgnPScpXG5cbiAgICBvdXQucHVzaChgJHtrZXkudHJpbSgpfT0ke3ZhbHVlLmpvaW4oJz0nKX1gKVxuICB9XG5cbiAgcmV0dXJuIG91dC5qb2luKCc7ICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NUTEV4Y2x1ZGluZ0h0YWIsXG4gIHZhbGlkYXRlQ29va2llTmFtZSxcbiAgdmFsaWRhdGVDb29raWVQYXRoLFxuICB2YWxpZGF0ZUNvb2tpZVZhbHVlLFxuICB0b0lNRkRhdGUsXG4gIHN0cmluZ2lmeVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/eventsource/util.js\")\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} [lastEventId] The last event ID received from the server.\n * @property {string} [origin] The origin of the event source.\n * @property {number} [reconnectionTime] The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer|null}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {boolean} [options.readableObjectMode]\n   * @param {eventSourceSettings} [options.eventSourceSettings]\n   * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id !== undefined || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventSourceStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id !== undefined && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsdUVBQVE7O0FBRTlEO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLGdFQUFnRTtBQUM3RTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZXZlbnRzb3VyY2VcXGV2ZW50c291cmNlLXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGlzQVNDSUlOdW1iZXIsIGlzVmFsaWRMYXN0RXZlbnRJZCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyW119IEJPTVxuICovXG5jb25zdCBCT00gPSBbMHhFRiwgMHhCQiwgMHhCRl1cbi8qKlxuICogQHR5cGUgezEwfSBMRlxuICovXG5jb25zdCBMRiA9IDB4MEFcbi8qKlxuICogQHR5cGUgezEzfSBDUlxuICovXG5jb25zdCBDUiA9IDB4MERcbi8qKlxuICogQHR5cGUgezU4fSBDT0xPTlxuICovXG5jb25zdCBDT0xPTiA9IDB4M0Fcbi8qKlxuICogQHR5cGUgezMyfSBTUEFDRVxuICovXG5jb25zdCBTUEFDRSA9IDB4MjBcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudF0gVGhlIGV2ZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RhdGFdIFRoZSBkYXRhIG9mIHRoZSBtZXNzYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gQSB1bmlxdWUgSUQgZm9yIHRoZSBldmVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmV0cnldIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgZXZlbnRTb3VyY2VTZXR0aW5nc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFzdEV2ZW50SWRdIFRoZSBsYXN0IGV2ZW50IElEIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3JpZ2luXSBUaGUgb3JpZ2luIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlY29ubmVjdGlvblRpbWVdIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbmNsYXNzIEV2ZW50U291cmNlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgc3RhdGVcblxuICAvKipcbiAgICogTGVhZGluZyBieXRlLW9yZGVyLW1hcmsgY2hlY2suXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2tCT00gPSB0cnVlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgY3JsZkNoZWNrID0gZmFsc2VcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBldmVudEVuZENoZWNrID0gZmFsc2VcblxuICAvKipcbiAgICogQHR5cGUge0J1ZmZlcnxudWxsfVxuICAgKi9cbiAgYnVmZmVyID0gbnVsbFxuXG4gIHBvcyA9IDBcblxuICBldmVudCA9IHtcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICBpZDogdW5kZWZpbmVkLFxuICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZV1cbiAgICogQHBhcmFtIHtldmVudFNvdXJjZVNldHRpbmdzfSBbb3B0aW9ucy5ldmVudFNvdXJjZVNldHRpbmdzXVxuICAgKiBAcGFyYW0geyhjaHVuazogYW55LCBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nIHwgdW5kZWZpbmVkKSA9PiBib29sZWFufSBbb3B0aW9ucy5wdXNoXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIEVuYWJsZSBvYmplY3QgbW9kZSBhcyBFdmVudFNvdXJjZVN0cmVhbSBlbWl0cyBvYmplY3RzIG9mIHNoYXBlXG4gICAgLy8gRXZlbnRTb3VyY2VTdHJlYW1FdmVudFxuICAgIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlID0gdHJ1ZVxuXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMuc3RhdGUgPSBvcHRpb25zLmV2ZW50U291cmNlU2V0dGluZ3MgfHwge31cbiAgICBpZiAob3B0aW9ucy5wdXNoKSB7XG4gICAgICB0aGlzLnB1c2ggPSBvcHRpb25zLnB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZW5jb2RpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfdHJhbnNmb3JtIChjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENhY2hlIHRoZSBjaHVuayBpbiB0aGUgYnVmZmVyLCBhcyB0aGUgZGF0YSBtaWdodCBub3QgYmUgY29tcGxldGUgd2hpbGVcbiAgICAvLyBwcm9jZXNzaW5nIGl0XG4gICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUgaXMgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGhhbmRsZVxuICAgIC8vIGluY29taW5nIGNodW5rc1xuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsIGNodW5rXSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIgPSBjaHVua1xuICAgIH1cblxuICAgIC8vIFN0cmlwIGxlYWRpbmcgYnl0ZS1vcmRlci1tYXJrIGlmIHdlIG9wZW5lZCB0aGUgc3RyZWFtIGFuZCBzdGFydGVkXG4gICAgLy8gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIGluY29taW5nIGRhdGFcbiAgICBpZiAodGhpcy5jaGVja0JPTSkge1xuICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBieXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBCT01cbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBUaGUgYnVmZmVyIG9ubHkgY29udGFpbnMgb25lIGJ5dGUgc28gd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgdHdvIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdHdvIGJ5dGVzXG4gICAgICAgICAgLy8gb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YSwgYmVjYXVzZSB0aGUgdGhpcmQgYnl0ZVxuICAgICAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGRldGVybWluZSBpZiBpdCBpcyB0aGUgQk9NIG9yIG5vdFxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aHJlZSBieXRlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHRocmVlXG4gICAgICAgICAgLy8gYnl0ZXMgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBjYW4gZHJvcCB0aGUgYnVmZmVyZWQgZGF0YSwgYXMgaXQgaXMgb25seSB0aGUgQk9NXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBBd2FpdCBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgdGhlIEJPTSwgd2UgY2FuIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGRhdGFcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgaXMgbG9uZ2VyIHRoYW4gMyBieXRlcywgc28gd2UgY2FuIGRyb3AgdGhlIEJPTSBpZiBpdCBpc1xuICAgICAgICAgIC8vIHByZXNlbnRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsxXSA9PT0gQk9NWzFdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsyXSA9PT0gQk9NWzJdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIEJPTSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkoMylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYW4gZW5kLW9mLWxpbmUsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbHNvIGFuIGVuZC1vZi1saW5lLlxuICAgICAgaWYgKHRoaXMuZXZlbnRFbmRDaGVjaykge1xuICAgICAgICAvLyBJZiB0aGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB0aGVuIHRoZSBldmVudFxuICAgICAgICAvLyBpcyBmaW5pc2hlZCBhbmQgd2UgY2FuIHByb2Nlc3MgaXRcblxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgbGluZSBlbmRlZCB3aXRoIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIC8vIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAgICAgaWYgKHRoaXMuY3JsZkNoZWNrKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkLCB3ZSBjYW4gcmVtb3ZlIGl0XG4gICAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyIGFuZCByZXNldCB0aGUgY3JsZkNoZWNrIGZsYWdcbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBMRikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcblxuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgbGluZSBmZWVkIGlzIG5vdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQuIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFuXG4gICAgICAgICAgICAvLyBlbmQtb2YtbGluZSBjaGFyYWN0ZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQuIFdlIHNpbXBseSBjb250aW51ZSB0aGUgbG9vcCB0byBjaGVjayB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICAvLyBBcyB3ZSByZW1vdmVkIHRoZSBsaW5lIGZlZWQgZnJvbSB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlXG4gICAgICAgICAgICAvLyBjcmxmQ2hlY2sgZmxhZyB0byBmYWxzZSwgd2UgYmFzaWNhbGx5IGRvbid0IG1ha2UgYW55XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGEgbGluZSBmZWVkIGFuZCBhIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBzZXQgdGhlIGNybGZDaGVjayBmbGFnIHRvIHRydWUsIGFzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQgc28gd2UgY2FuIHJlbW92ZSBpdCBmcm9tIHRoZVxuICAgICAgICAgIC8vIGJ1ZmZlclxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmV2ZW50LmV2ZW50IHx8IHRoaXMuZXZlbnQuaWQgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmV2ZW50LnJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFdmVudCh0aGlzLmV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsZWFyRXZlbnQoKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhbiBlbmQtb2YtbGluZSwgdGhlbiB0aGUgZXZlbnRcbiAgICAgICAgLy8gaXMgbm90IGZpbmlzaGVkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBldmVudEVuZENoZWNrIGZsYWdcbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB3ZSBjYW4gcHJvY2VzcyB0aGVcbiAgICAgIC8vIGxpbmVcbiAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWRcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCB3ZSBjYW4gcHJvY2VzcyB0aGUgbGluZSBhcyB3ZSByZWFjaGVkIGFuXG4gICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBhcnNlTGluZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvcyksIHRoaXMuZXZlbnQpXG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBhcyB3ZSByZW1vdmVkIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5wb3MgPSAwXG4gICAgICAgIC8vIEEgbGluZSB3YXMgcHJvY2Vzc2VkIGFuZCB0aGlzIGNvdWxkIGJlIHRoZSBlbmQgb2YgdGhlIGV2ZW50LiBXZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgZW1wdHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAvLyBmaW5pc2hlZC5cbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcysrXG4gICAgfVxuXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBsaW5lXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2VTdHJlYW1FdmVudH0gZXZlbnRcbiAgICovXG4gIHBhcnNlTGluZSAobGluZSwgZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgbGluZSBpcyBlbXB0eSAoYSBibGFuayBsaW5lKVxuICAgIC8vIERpc3BhdGNoIHRoZSBldmVudCwgYXMgZGVmaW5lZCBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgX3RyYW5zZm9ybSBtZXRob2RcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICAvLyBJZ25vcmUgdGhlIGxpbmUuXG4gICAgY29uc3QgY29sb25Qb3NpdGlvbiA9IGxpbmUuaW5kZXhPZihDT0xPTilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gJydcbiAgICBsZXQgdmFsdWUgPSAnJ1xuXG4gICAgLy8gSWYgdGhlIGxpbmUgY29udGFpbnMgYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIGlmIChjb2xvblBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBiZWZvcmUgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCBmaWVsZCBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHRoZXJlIGlzIGEgbW9yZSBwZXJmb3JtYW50IHdheSB0byBleHRyYWN0IHRoZVxuICAgICAgLy8gZmllbGRcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICAgIGZpZWxkID0gbGluZS5zdWJhcnJheSgwLCBjb2xvblBvc2l0aW9uKS50b1N0cmluZygndXRmOCcpXG5cbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYWZ0ZXIgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCB2YWx1ZSBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIElmIHZhbHVlIHN0YXJ0cyB3aXRoIGEgVSswMDIwIFNQQUNFIGNoYXJhY3RlciwgcmVtb3ZlIGl0IGZyb20gdmFsdWUuXG4gICAgICBsZXQgdmFsdWVTdGFydCA9IGNvbG9uUG9zaXRpb24gKyAxXG4gICAgICBpZiAobGluZVt2YWx1ZVN0YXJ0XSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgKyt2YWx1ZVN0YXJ0XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIHZhbHVlXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICB2YWx1ZSA9IGxpbmUuc3ViYXJyYXkodmFsdWVTdGFydCkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzdHJpbmcgaXMgbm90IGVtcHR5IGJ1dCBkb2VzIG5vdCBjb250YWluIGEgVSswMDNBIENPTE9OXG4gICAgICAvLyBjaGFyYWN0ZXIgKDopXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhlIGZpZWxkIHVzaW5nIHRoZSBzdGVwcyBkZXNjcmliZWQgYmVsb3csIHVzaW5nIHRoZSB3aG9sZVxuICAgICAgLy8gbGluZSBhcyB0aGUgZmllbGQgbmFtZSwgYW5kIHRoZSBlbXB0eSBzdHJpbmcgYXMgdGhlIGZpZWxkIHZhbHVlLlxuICAgICAgZmllbGQgPSBsaW5lLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIHZhbHVlID0gJydcbiAgICB9XG5cbiAgICAvLyBNb2RpZnkgdGhlIGV2ZW50IHdpdGggdGhlIGZpZWxkIG5hbWUgYW5kIHZhbHVlLiBUaGUgdmFsdWUgaXMgYWxzb1xuICAgIC8vIGRlY29kZWQgYXMgVVRGLThcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgaWYgKGV2ZW50W2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gKz0gYFxcbiR7dmFsdWV9YFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgIGlmIChpc0FTQ0lJTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgaWYgKGlzVmFsaWRMYXN0RXZlbnRJZCh2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlU3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRXZlbnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJldHJ5ICYmIGlzQVNDSUlOdW1iZXIoZXZlbnQucmV0cnkpKSB7XG4gICAgICB0aGlzLnN0YXRlLnJlY29ubmVjdGlvblRpbWUgPSBwYXJzZUludChldmVudC5yZXRyeSwgMTApXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmlkICE9PSB1bmRlZmluZWQgJiYgaXNWYWxpZExhc3RFdmVudElkKGV2ZW50LmlkKSkge1xuICAgICAgdGhpcy5zdGF0ZS5sYXN0RXZlbnRJZCA9IGV2ZW50LmlkXG4gICAgfVxuXG4gICAgLy8gb25seSBkaXNwYXRjaCBldmVudCwgd2hlbiBkYXRhIGlzIHByb3ZpZGVkXG4gICAgaWYgKGV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgdHlwZTogZXZlbnQuZXZlbnQgfHwgJ21lc3NhZ2UnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgICBsYXN0RXZlbnRJZDogdGhpcy5zdGF0ZS5sYXN0RXZlbnRJZCxcbiAgICAgICAgICBvcmlnaW46IHRoaXMuc3RhdGUub3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY2xlYXJFdmVudCAoKSB7XG4gICAgdGhpcy5ldmVudCA9IHtcbiAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiB1bmRlZmluZWQsXG4gICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgcmV0cnk6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRXZlbnRTb3VyY2VTdHJlYW1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\")\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @typedef ReadyState\n * @type {0|1|2}\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url\n  #withCredentials = false\n\n  /**\n   * @type {ReadyState}\n   */\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict={}]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url)\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.node.dispatcher || eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: eventSourceInitDict.node.reconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials === true) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {ReadyState}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (!isNetworkError(response)) {\n        return this.#reconnect()\n      }\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {void}\n   */\n  #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    setTimeout(() => {\n      // 5. Queue a task to run the following steps:\n\n      //   1. If the EventSource object's readyState attribute is not set to\n      //      CONNECTING, then return.\n      if (this.#readyState !== CONNECTING) return\n\n      //   2. Let request be the EventSource object's request.\n      //   3. If the EventSource object's last event ID string is not the empty\n      //      string, then:\n      //      1. Let lastEventIDValue be the EventSource object's last event ID\n      //         string, encoded as UTF-8.\n      //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n      //         list.\n      if (this.#state.lastEventId.length) {\n        this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n      }\n\n      //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n      this.#connect()\n    }, this.#state.reconnectionTime)?.unref()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n      this.#events.open = fn\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n      this.#events.message = fn\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n      this.#events.error = fn\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  },\n  {\n    key: 'node', // undici only\n    converter: webidl.dictionaryConverter([\n      {\n        key: 'reconnectionTime',\n        converter: webidl.converters['unsigned long'],\n        defaultValue: () => defaultReconnectionTime\n      },\n      {\n        key: 'dispatcher',\n        converter: webidl.converters.any\n      }\n    ]),\n    defaultValue: () => ({})\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ3ZDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLG1HQUFzQjtBQUM1RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3JELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDaEUsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUN0RCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLDRDQUE0Qzs7QUFFeEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFxldmVudHNvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgRXZlbnRTb3VyY2VTdHJlYW0gfSA9IHJlcXVpcmUoJy4vZXZlbnRzb3VyY2Utc3RyZWFtJylcbmNvbnN0IHsgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IH0gPSByZXF1aXJlKCcuLi93ZWJzb2NrZXQvZXZlbnRzJylcbmNvbnN0IHsgaXNOZXR3b3JrRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3Jlc3BvbnNlJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5cbmxldCBleHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG4vKipcbiAqIEEgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBtdXN0IGluaXRpYWxseSBiZSBhbiBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHZhbHVlLFxuICogcHJvYmFibHkgaW4gdGhlIHJlZ2lvbiBvZiBhIGZldyBzZWNvbmRzLlxuICpcbiAqIEluIENvbXBhcmlzb246XG4gKiAtIENocm9tZSB1c2VzIDMwMDBtcy5cbiAqIC0gRGVubyB1c2VzIDUwMDBtcy5cbiAqXG4gKiBAdHlwZSB7MzAwMH1cbiAqL1xuY29uc3QgZGVmYXVsdFJlY29ubmVjdGlvblRpbWUgPSAzMDAwXG5cbi8qKlxuICogVGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICogQHR5cGVkZWYgUmVhZHlTdGF0ZVxuICogQHR5cGUgezB8MXwyfVxuICogQHJlYWRvbmx5XG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI2RvbS1ldmVudHNvdXJjZS1yZWFkeXN0YXRlLWRldlxuICovXG5cbi8qKlxuICogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCB5ZXQgYmVlbiBlc3RhYmxpc2hlZCwgb3IgaXQgd2FzIGNsb3NlZCBhbmQgdGhlIHVzZXJcbiAqIGFnZW50IGlzIHJlY29ubmVjdGluZy5cbiAqIEB0eXBlIHswfVxuICovXG5jb25zdCBDT05ORUNUSU5HID0gMFxuXG4vKipcbiAqIFRoZSB1c2VyIGFnZW50IGhhcyBhbiBvcGVuIGNvbm5lY3Rpb24gYW5kIGlzIGRpc3BhdGNoaW5nIGV2ZW50cyBhcyBpdFxuICogcmVjZWl2ZXMgdGhlbS5cbiAqIEB0eXBlIHsxfVxuICovXG5jb25zdCBPUEVOID0gMVxuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIGlzIG5vdCBvcGVuLCBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IHRyeWluZyB0byByZWNvbm5lY3QuXG4gKiBAdHlwZSB7Mn1cbiAqL1xuY29uc3QgQ0xPU0VEID0gMlxuXG4vKipcbiAqIFJlcXVlc3RzIGZvciB0aGUgZWxlbWVudCB3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCIgYW5kIHRoZWlyIGNyZWRlbnRpYWxzIG1vZGUgc2V0IHRvIFwic2FtZS1vcmlnaW5cIi5cbiAqIEB0eXBlIHsnYW5vbnltb3VzJ31cbiAqL1xuY29uc3QgQU5PTllNT1VTID0gJ2Fub255bW91cydcblxuLyoqXG4gKiBSZXF1ZXN0cyBmb3IgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wiIGFuZCB0aGVpciBjcmVkZW50aWFscyBtb2RlIHNldCB0byBcImluY2x1ZGVcIi5cbiAqIEB0eXBlIHsndXNlLWNyZWRlbnRpYWxzJ31cbiAqL1xuY29uc3QgVVNFX0NSRURFTlRJQUxTID0gJ3VzZS1jcmVkZW50aWFscydcblxuLyoqXG4gKiBUaGUgRXZlbnRTb3VyY2UgaW50ZXJmYWNlIGlzIHVzZWQgdG8gcmVjZWl2ZSBzZXJ2ZXItc2VudCBldmVudHMuIEl0XG4gKiBjb25uZWN0cyB0byBhIHNlcnZlciBvdmVyIEhUVFAgYW5kIHJlY2VpdmVzIGV2ZW50cyBpbiB0ZXh0L2V2ZW50LXN0cmVhbVxuICogZm9ybWF0IHdpdGhvdXQgY2xvc2luZyB0aGUgY29ubmVjdGlvbi5cbiAqIEBleHRlbmRzIHtFdmVudFRhcmdldH1cbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc2VydmVyLXNlbnQtZXZlbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2V2ZW50cyA9IHtcbiAgICBvcGVuOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIG1lc3NhZ2U6IG51bGxcbiAgfVxuXG4gICN1cmxcbiAgI3dpdGhDcmVkZW50aWFscyA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtSZWFkeVN0YXRlfVxuICAgKi9cbiAgI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgI3JlcXVlc3QgPSBudWxsXG4gICNjb250cm9sbGVyID0gbnVsbFxuXG4gICNkaXNwYXRjaGVyXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vZXZlbnRzb3VyY2Utc3RyZWFtJykuZXZlbnRTb3VyY2VTZXR0aW5nc31cbiAgICovXG4gICNzdGF0ZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlSW5pdH0gW2V2ZW50U291cmNlSW5pdERpY3Q9e31dXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjdGhlLWV2ZW50c291cmNlLWludGVyZmFjZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgZXZlbnRTb3VyY2VJbml0RGljdCA9IHt9KSB7XG4gICAgLy8gMS4gTGV0IGV2IGJlIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdC5cbiAgICBzdXBlcigpXG5cbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0V2ZW50U291cmNlIGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgaWYgKCFleHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICAgIGV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0V2ZW50U291cmNlIGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgY29kZTogJ1VORElDSS1FUydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybClcbiAgICBldmVudFNvdXJjZUluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdChldmVudFNvdXJjZUluaXREaWN0LCBwcmVmaXgsICdldmVudFNvdXJjZUluaXREaWN0JylcblxuICAgIHRoaXMuI2Rpc3BhdGNoZXIgPSBldmVudFNvdXJjZUluaXREaWN0Lm5vZGUuZGlzcGF0Y2hlciB8fCBldmVudFNvdXJjZUluaXREaWN0LmRpc3BhdGNoZXJcbiAgICB0aGlzLiNzdGF0ZSA9IHtcbiAgICAgIGxhc3RFdmVudElkOiAnJyxcbiAgICAgIHJlY29ubmVjdGlvblRpbWU6IGV2ZW50U291cmNlSW5pdERpY3Qubm9kZS5yZWNvbm5lY3Rpb25UaW1lXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHNldHRpbmdzIGJlIGV2J3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNlbnZpcm9ubWVudC1zZXR0aW5ncy1vYmplY3RcbiAgICBjb25zdCBzZXR0aW5ncyA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3RcblxuICAgIGxldCB1cmxSZWNvcmRcblxuICAgIHRyeSB7XG4gICAgICAvLyAzLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgZW5jb2RpbmctcGFyc2luZyBhIFVSTCBnaXZlbiB1cmwsIHJlbGF0aXZlIHRvIHNldHRpbmdzLlxuICAgICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIHNldHRpbmdzLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpXG4gICAgICB0aGlzLiNzdGF0ZS5vcmlnaW4gPSB1cmxSZWNvcmQub3JpZ2luXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gNC4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihlLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDUuIFNldCBldidzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpcy4jdXJsID0gdXJsUmVjb3JkLmhyZWZcblxuICAgIC8vIDYuIExldCBjb3JzQXR0cmlidXRlU3RhdGUgYmUgQW5vbnltb3VzLlxuICAgIGxldCBjb3JzQXR0cmlidXRlU3RhdGUgPSBBTk9OWU1PVVNcblxuICAgIC8vIDcuIElmIHRoZSB2YWx1ZSBvZiBldmVudFNvdXJjZUluaXREaWN0J3Mgd2l0aENyZWRlbnRpYWxzIG1lbWJlciBpcyB0cnVlLFxuICAgIC8vIHRoZW4gc2V0IGNvcnNBdHRyaWJ1dGVTdGF0ZSB0byBVc2UgQ3JlZGVudGlhbHMgYW5kIHNldCBldidzXG4gICAgLy8gd2l0aENyZWRlbnRpYWxzIGF0dHJpYnV0ZSB0byB0cnVlLlxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgICAgY29yc0F0dHJpYnV0ZVN0YXRlID0gVVNFX0NSRURFTlRJQUxTXG4gICAgICB0aGlzLiN3aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gOC4gTGV0IHJlcXVlc3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIHBvdGVudGlhbC1DT1JTIHJlcXVlc3QgZ2l2ZW5cbiAgICAvLyB1cmxSZWNvcmQsIHRoZSBlbXB0eSBzdHJpbmcsIGFuZCBjb3JzQXR0cmlidXRlU3RhdGUuXG4gICAgY29uc3QgaW5pdFJlcXVlc3QgPSB7XG4gICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICBrZWVwYWxpdmU6IHRydWUsXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3VybHMtYW5kLWZldGNoaW5nLmh0bWwjY29ycy1zZXR0aW5ncy1hdHRyaWJ1dGVzXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBjcmVkZW50aWFsczogY29yc0F0dHJpYnV0ZVN0YXRlID09PSAnYW5vbnltb3VzJ1xuICAgICAgICA/ICdzYW1lLW9yaWdpbidcbiAgICAgICAgOiAnb21pdCcsXG4gICAgICByZWZlcnJlcjogJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIDkuIFNldCByZXF1ZXN0J3MgY2xpZW50IHRvIHNldHRpbmdzLlxuICAgIGluaXRSZXF1ZXN0LmNsaWVudCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3RcblxuICAgIC8vIDEwLiBVc2VyIGFnZW50cyBtYXkgc2V0IChgQWNjZXB0YCwgYHRleHQvZXZlbnQtc3RyZWFtYCkgaW4gcmVxdWVzdCdzIGhlYWRlciBsaXN0LlxuICAgIGluaXRSZXF1ZXN0LmhlYWRlcnNMaXN0ID0gW1snYWNjZXB0JywgeyBuYW1lOiAnYWNjZXB0JywgdmFsdWU6ICd0ZXh0L2V2ZW50LXN0cmVhbScgfV1dXG5cbiAgICAvLyAxMS4gU2V0IHJlcXVlc3QncyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgICBpbml0UmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcblxuICAgIC8vIDEyLiBTZXQgcmVxdWVzdCdzIGluaXRpYXRvciB0eXBlIHRvIFwib3RoZXJcIi5cbiAgICBpbml0UmVxdWVzdC5pbml0aWF0b3IgPSAnb3RoZXInXG5cbiAgICBpbml0UmVxdWVzdC51cmxMaXN0ID0gW25ldyBVUkwodGhpcy4jdXJsKV1cblxuICAgIC8vIDEzLiBTZXQgZXYncyByZXF1ZXN0IHRvIHJlcXVlc3QuXG4gICAgdGhpcy4jcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KGluaXRSZXF1ZXN0KVxuXG4gICAgdGhpcy4jY29ubmVjdCgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhpcyBFdmVudFNvdXJjZSBvYmplY3QncyBjb25uZWN0aW9uLiBJdCBjYW4gaGF2ZSB0aGVcbiAgICogdmFsdWVzIGRlc2NyaWJlZCBiZWxvdy5cbiAgICogQHJldHVybnMge1JlYWR5U3RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkeVN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVJMIHByb3ZpZGluZyB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCB1cmwgKCkge1xuICAgIHJldHVybiB0aGlzLiN1cmxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIEV2ZW50U291cmNlIG9iamVjdCB3YXNcbiAgICogaW5zdGFudGlhdGVkIHdpdGggQ09SUyBjcmVkZW50aWFscyBzZXQgKHRydWUpLCBvciBub3QgKGZhbHNlLCB0aGUgZGVmYXVsdCkuXG4gICAqL1xuICBnZXQgd2l0aENyZWRlbnRpYWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy4jd2l0aENyZWRlbnRpYWxzXG4gIH1cblxuICAjY29ubmVjdCAoKSB7XG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICByZXF1ZXN0OiB0aGlzLiNyZXF1ZXN0LFxuICAgICAgZGlzcGF0Y2hlcjogdGhpcy4jZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIDE0LiBMZXQgcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5IGdpdmVuIHJlc3BvbnNlIHJlcyBiZSB0aGUgZm9sbG93aW5nIHN0ZXA6IGlmIHJlcyBpcyBub3QgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uLlxuICAgIGNvbnN0IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFpc05ldHdvcmtFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlY29ubmVjdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTUuIEZldGNoIHJlcXVlc3QsIHdpdGggcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IHNldCB0byBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkuLi5cbiAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHlcblxuICAgIC8vIGFuZCBwcm9jZXNzUmVzcG9uc2Ugc2V0IHRvIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ2l2ZW4gcmVzcG9uc2UgcmVzOlxuICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgcmVzIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuXG4gICAgICBpZiAoaXNOZXR3b3JrRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgIC8vIDEuIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIGZhaWwgdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50XG4gICAgICAgIC8vIG11c3QgcXVldWUgYSB0YXNrIHdoaWNoLCBpZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGFcbiAgICAgICAgLy8gdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUQsIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFRFxuICAgICAgICAvLyBhbmQgZmlyZXMgYW4gZXZlbnQgbmFtZWQgZXJyb3IgYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC4gT25jZSB0aGVcbiAgICAgICAgLy8gdXNlciBhZ2VudCBoYXMgZmFpbGVkIHRoZSBjb25uZWN0aW9uLCBpdCBkb2VzIG5vdCBhdHRlbXB0IHRvXG4gICAgICAgIC8vIHJlY29ubmVjdC5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgcmVzIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiByZWVzdGFibGlzaCB0aGVcbiAgICAgICAgICAvLyBjb25uZWN0aW9uLCB1bmxlc3MgdGhlIHVzZXIgYWdlbnQga25vd3MgdGhhdCB0byBiZSBmdXRpbGUsIGluXG4gICAgICAgICAgLy8gd2hpY2ggY2FzZSB0aGUgdXNlciBhZ2VudCBtYXkgZmFpbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNyZWNvbm5lY3QoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVzJ3Mgc3RhdHVzIGlzIG5vdCAyMDAsIG9yIGlmIHJlcydzIGBDb250ZW50LVR5cGVgXG4gICAgICAvLyBpcyBub3QgYHRleHQvZXZlbnQtc3RyZWFtYCwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2NvbnRlbnQtdHlwZScsIHRydWUpXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IGNvbnRlbnRUeXBlICE9PSBudWxsID8gcGFyc2VNSU1FVHlwZShjb250ZW50VHlwZSkgOiAnZmFpbHVyZSdcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlVmFsaWQgPSBtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlLmVzc2VuY2UgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbSdcbiAgICAgIGlmIChcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgfHxcbiAgICAgICAgY29udGVudFR5cGVWYWxpZCA9PT0gZmFsc2VcbiAgICAgICkge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYW5ub3VuY2UgdGhlIGNvbm5lY3Rpb24gYW5kIGludGVycHJldCByZXMncyBib2R5XG4gICAgICAvLyBsaW5lIGJ5IGxpbmUuXG5cbiAgICAgIC8vIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIGFubm91bmNlIHRoZSBjb25uZWN0aW9uLCB0aGUgdXNlciBhZ2VudFxuICAgICAgLy8gbXVzdCBxdWV1ZSBhIHRhc2sgd2hpY2gsIGlmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYVxuICAgICAgLy8gdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUQsIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIE9QRU5cbiAgICAgIC8vIGFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBvcGVuIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NzZS1wcm9jZXNzaW5nLW1vZGVsXG4gICAgICB0aGlzLiNyZWFkeVN0YXRlID0gT1BFTlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKVxuXG4gICAgICAvLyBJZiByZWRpcmVjdGVkIHRvIGEgZGlmZmVyZW50IG9yaWdpbiwgc2V0IHRoZSBvcmlnaW4gdG8gdGhlIG5ldyBvcmlnaW4uXG4gICAgICB0aGlzLiNzdGF0ZS5vcmlnaW4gPSByZXNwb25zZS51cmxMaXN0W3Jlc3BvbnNlLnVybExpc3QubGVuZ3RoIC0gMV0ub3JpZ2luXG5cbiAgICAgIGNvbnN0IGV2ZW50U291cmNlU3RyZWFtID0gbmV3IEV2ZW50U291cmNlU3RyZWFtKHtcbiAgICAgICAgZXZlbnRTb3VyY2VTZXR0aW5nczogdGhpcy4jc3RhdGUsXG4gICAgICAgIHB1c2g6IChldmVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVGYXN0TWVzc2FnZUV2ZW50KFxuICAgICAgICAgICAgZXZlbnQudHlwZSxcbiAgICAgICAgICAgIGV2ZW50Lm9wdGlvbnNcbiAgICAgICAgICApKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBwaXBlbGluZShyZXNwb25zZS5ib2R5LnN0cmVhbSxcbiAgICAgICAgZXZlbnRTb3VyY2VTdHJlYW0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yPy5hYm9ydGVkID09PSBmYWxzZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNjb250cm9sbGVyID0gZmV0Y2hpbmcoZmV0Y2hQYXJhbXMpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNzc2UtcHJvY2Vzc2luZy1tb2RlbFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gICNyZWNvbm5lY3QgKCkge1xuICAgIC8vIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIHJlZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uLCB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgLy8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHMuIFRoZXNlIHN0ZXBzIGFyZSBydW4gaW4gcGFyYWxsZWwsIG5vdCBhcyBwYXJ0IG9mXG4gICAgLy8gYSB0YXNrLiAoVGhlIHRhc2tzIHRoYXQgaXQgcXVldWVzLCBvZiBjb3Vyc2UsIGFyZSBydW4gbGlrZSBub3JtYWwgdGFza3NcbiAgICAvLyBhbmQgbm90IHRoZW1zZWx2ZXMgaW4gcGFyYWxsZWwuKVxuXG4gICAgLy8gMS4gUXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuXG4gICAgLy8gICAxLiBJZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIENMT1NFRCwgYWJvcnQgdGhlIHRhc2suXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG5cbiAgICAvLyAgIDIuIFNldCB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ09OTkVDVElORy5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICAgLy8gICAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIGVycm9yIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcblxuICAgIC8vIDIuIFdhaXQgYSBkZWxheSBlcXVhbCB0byB0aGUgcmVjb25uZWN0aW9uIHRpbWUgb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIDUuIFF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgICAgLy8gICAxLiBJZiB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgbm90IHNldCB0b1xuICAgICAgLy8gICAgICBDT05ORUNUSU5HLCB0aGVuIHJldHVybi5cbiAgICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlICE9PSBDT05ORUNUSU5HKSByZXR1cm5cblxuICAgICAgLy8gICAyLiBMZXQgcmVxdWVzdCBiZSB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgcmVxdWVzdC5cbiAgICAgIC8vICAgMy4gSWYgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIGxhc3QgZXZlbnQgSUQgc3RyaW5nIGlzIG5vdCB0aGUgZW1wdHlcbiAgICAgIC8vICAgICAgc3RyaW5nLCB0aGVuOlxuICAgICAgLy8gICAgICAxLiBMZXQgbGFzdEV2ZW50SURWYWx1ZSBiZSB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgbGFzdCBldmVudCBJRFxuICAgICAgLy8gICAgICAgICBzdHJpbmcsIGVuY29kZWQgYXMgVVRGLTguXG4gICAgICAvLyAgICAgIDIuIFNldCAoYExhc3QtRXZlbnQtSURgLCBsYXN0RXZlbnRJRFZhbHVlKSBpbiByZXF1ZXN0J3MgaGVhZGVyXG4gICAgICAvLyAgICAgICAgIGxpc3QuXG4gICAgICBpZiAodGhpcy4jc3RhdGUubGFzdEV2ZW50SWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdsYXN0LWV2ZW50LWlkJywgdGhpcy4jc3RhdGUubGFzdEV2ZW50SWQsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIC8vICAgNC4gRmV0Y2ggcmVxdWVzdCBhbmQgcHJvY2VzcyB0aGUgcmVzcG9uc2Ugb2J0YWluZWQgaW4gdGhpcyBmYXNoaW9uLCBpZiBhbnksIGFzIGRlc2NyaWJlZCBlYXJsaWVyIGluIHRoaXMgc2VjdGlvbi5cbiAgICAgIHRoaXMuI2Nvbm5lY3QoKVxuICAgIH0sIHRoaXMuI3N0YXRlLnJlY29ubmVjdGlvblRpbWUpPy51bnJlZigpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLCBpZiBhbnksIGFuZCBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0b1xuICAgKiBDTE9TRUQuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXZlbnRTb3VyY2UpXG5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ0xPU0VEXG4gICAgdGhpcy4jY29udHJvbGxlci5hYm9ydCgpXG4gICAgdGhpcy4jcmVxdWVzdCA9IG51bGxcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgbGlzdGVuZXIpXG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpXG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKVxuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBDT05ORUNUSU5HOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ09OTkVDVElORyxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1BFTjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IE9QRU4sXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIENMT1NFRDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IENMT1NFRCxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZSwgY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycylcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLnByb3RvdHlwZSwgY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycylcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UucHJvdG90eXBlLCB7XG4gIGNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ub3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB3aXRoQ3JlZGVudGlhbHM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkV2ZW50U291cmNlSW5pdERpY3QgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICd3aXRoQ3JlZGVudGlhbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJywgLy8gdW5kaWNpIG9ubHlcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9LFxuICB7XG4gICAga2V5OiAnbm9kZScsIC8vIHVuZGljaSBvbmx5XG4gICAgY29udmVydGVyOiB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gICAgICB7XG4gICAgICAgIGtleTogJ3JlY29ubmVjdGlvblRpbWUnLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ2Rpc3BhdGNoZXInLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICAgICAgfVxuICAgIF0pLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gKHt9KVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRXZlbnRTb3VyY2UsXG4gIGRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidLastEventId (value) {\n  // LastEventId should not contain U+0000 NULL\n  return value.indexOf('\\u0000') === -1\n}\n\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isASCIINumber (value) {\n  if (value.length === 0) return false\n  for (let i = 0; i < value.length; i++) {\n    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false\n  }\n  return true\n}\n\nmodule.exports = {\n  isValidLastEventId,\n  isASCIINumber\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBMYXN0RXZlbnRJZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRMYXN0RXZlbnRJZCAodmFsdWUpIHtcbiAgLy8gTGFzdEV2ZW50SWQgc2hvdWxkIG5vdCBjb250YWluIFUrMDAwMCBOVUxMXG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKCdcXHUwMDAwJykgPT09IC0xXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGJhc2UgMTAgZGlnaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FTQ0lJTnVtYmVyICh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KGkpIDwgMHgzMCB8fCB2YWx1ZS5jaGFyQ29kZUF0KGkpID4gMHgzOSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzVmFsaWRMYXN0RXZlbnRJZCxcbiAgaXNBU0NJSU51bWJlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  ReadableStreamFrom,\n  readableStreamClose,\n  fullyReadBody,\n  extractMimeType\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { FormData, setFormDataState } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isErrored, isDisturbed } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\")\nconst { createDeferredPromise } = __webpack_require__(/*! ../../util/promise */ \"(rsc)/./node_modules/undici/lib/util/promise.js\")\nconst { parseJSONFromBytes } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ../../encoding */ \"(rsc)/./node_modules/undici/lib/encoding/index.js\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features.js */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\nconst random = runtimeFeatures.has('crypto')\n  ? (__webpack_require__(/*! node:crypto */ \"node:crypto\").randomInt)\n  : (max) => Math.floor(Math.random() * max)\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst streamRegistry = new FinalizationRegistry((weakRef) => {\n  const stream = weakRef.deref()\n  if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n    stream.cancel('Response object has been garbage collected').catch(noop)\n  }\n})\n\n/**\n * Extract a body with type from a byte sequence or BodyInit object\n *\n * @param {import('../../../types').BodyInit} object - The BodyInit object to extract from\n * @param {boolean} [keepalive=false] - If true, indicates that the body\n * @returns {[{stream: ReadableStream, source: any, length: number | null}, string | null]} - Returns a tuple containing the body and its type\n *\n * @see https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n */\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n  let controller = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (webidl.is.ReadableStream(object)) {\n    stream = object\n  } else if (webidl.is.Blob(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running objects get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      pull () {},\n      start (c) {\n        controller = c\n      },\n      cancel () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(webidl.is.ReadableStream(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (webidl.is.URLSearchParams(object)) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (webidl.is.BufferSource(object)) {\n    // Set source to a copy of the bytes held by object.\n    source = webidl.util.getCopyOfBytesHeldByBufferSource(object)\n  } else if (webidl.is.FormData(object)) {\n    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n    const formdataEscape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with objects entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${formdataEscape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${formdataEscape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${formdataEscape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    // CRLF is appended to the body to function with legacy servers and match other implementations.\n    // https://github.com/curl/curl/blob/3434c6b46e682452973972e8313613dfa58cd690/lib/mime.c#L1029-L1030\n    // https://github.com/form-data/form-data/issues/63\n    const chunk = textEncoder.encode(`--${boundary}--\\r\\n`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (webidl.is.Blob(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to objects size.\n    length = object.size\n\n    // If objects type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to sources length.\n  if (typeof source === 'string' || isUint8Array(source)) {\n    action = () => {\n      length = typeof source === 'string' ? Buffer.byteLength(source) : source.length\n      return source\n    }\n  }\n\n  // 12. If action is non-null, then run these steps in parallel:\n  if (action != null) {\n    ;(async () => {\n      // 1. Run action.\n      const result = action()\n\n      // 2. Whenever one or more bytes are available and stream is not errored,\n      //    enqueue the result of creating a Uint8Array from the available bytes into stream.\n      const iterator = result?.[Symbol.asyncIterator]?.()\n      if (iterator) {\n        for await (const bytes of iterator) {\n          if (isErrored(stream)) break\n          if (bytes.length) {\n            controller.enqueue(new Uint8Array(bytes))\n          }\n        }\n      } else if (result?.length && !isErrored(stream)) {\n        controller.enqueue(typeof result === 'string' ? textEncoder.encode(result) : new Uint8Array(result))\n      }\n\n      // 3. When running action is done, close stream.\n      queueMicrotask(() => readableStreamClose(controller))\n    })()\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n/**\n * @typedef {object} ExtractBodyResult\n * @property {ReadableStream<Uint8Array<ArrayBuffer>>} stream - The ReadableStream containing the body data\n * @property {any} source - The original source of the body data\n * @property {number | null} length - The length of the body data, or null\n */\n\n/**\n * Safely extract a body with type from a byte sequence or BodyInit object.\n *\n * @param {import('../../../types').BodyInit} object - The BodyInit object to extract from\n * @param {boolean} [keepalive=false] - If true, indicates that the body\n * @returns {[ExtractBodyResult, string | null]} - Returns a tuple containing the body and its type\n *\n * @see https://fetch.spec.whatwg.org/#bodyinit-safely-extract\n */\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (webidl.is.ReadableStream(object)) {\n    // Assert: object is neither disturbed nor locked.\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let  out1, out2  be the result of teeing bodys stream.\n  const { 0: out1, 1: out2 } = body.stream.tee()\n\n  // 2. Set bodys stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction bodyMixinMethods (instance, getInternalState) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is thiss\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(getInternalState(this))\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance, getInternalState)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance, getInternalState)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance, getInternalState)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance, getInternalState)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(getInternalState(this))\n\n        // 2. If mimeType is non-null, then switch on mimeTypes essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              // 2. If that fails for some reason, then throw a TypeError.\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              setFormDataState(fd, parsed)\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance, getInternalState)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in thiss relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance, getInternalState)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype, getInternalState) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {any} object internal state\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {any} instance\n * @param {(target: any) => any} getInternalState\n */\nfunction consumeBody (object, convertBytesToJSValue, instance, getInternalState) {\n  try {\n    webidl.brandCheck(object, instance)\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  const state = getInternalState(object)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(state)) {\n    return Promise.reject(new TypeError('Body is unusable: Body has already been read'))\n  }\n\n  if (state.aborted) {\n    return Promise.reject(new DOMException('The operation was aborted.', 'AbortError'))\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = promise.reject\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If objects body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (state.body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read objects body given successSteps,\n  //    errorSteps, and objects relevant global object.\n  fullyReadBody(state.body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {any} object internal state\n */\nfunction bodyUnusable (object) {\n  const body = object.body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its bodys stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {any} requestOrResponse internal state\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponses requests header list.\n  // 3. Otherwise, set headers to requestOrResponses responses header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse.headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  bodyUnusable\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUNwQixRQUFRLDZCQUE2QixFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDM0QsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3hELFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsd0NBQWlCO0FBQ2xELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNuRCxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsdUZBQW1CO0FBQy9ELFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7QUFDOUQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ2pELFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDcEQsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGdHQUFnQzs7QUFFcEU7QUFDQSxJQUFJLGlFQUFnQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFdBQVcsU0FBUztBQUNwQixhQUFhLEVBQUUsMkRBQTJELGtCQUFrQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsT0FBTztBQUNQ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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLEtBQUs7QUFDaEIsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGJvZHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGV4dHJhY3RNaW1lVHlwZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEZvcm1EYXRhLCBzZXRGb3JtRGF0YVN0YXRlIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBpc0Vycm9yZWQsIGlzRGlzdHVyYmVkIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGlzVWludDhBcnJheSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEtcGFyc2VyJylcbmNvbnN0IHsgY3JlYXRlRGVmZXJyZWRQcm9taXNlIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL3Byb21pc2UnKVxuY29uc3QgeyBwYXJzZUpTT05Gcm9tQnl0ZXMgfSA9IHJlcXVpcmUoJy4uL2luZnJhJylcbmNvbnN0IHsgdXRmOERlY29kZUJ5dGVzIH0gPSByZXF1aXJlKCcuLi8uLi9lbmNvZGluZycpXG5jb25zdCB7IHJ1bnRpbWVGZWF0dXJlcyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ydW50aW1lLWZlYXR1cmVzLmpzJylcblxuY29uc3QgcmFuZG9tID0gcnVudGltZUZlYXR1cmVzLmhhcygnY3J5cHRvJylcbiAgPyByZXF1aXJlKCdub2RlOmNyeXB0bycpLnJhbmRvbUludFxuICA6IChtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBzdHJlYW1SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgod2Vha1JlZikgPT4ge1xuICBjb25zdCBzdHJlYW0gPSB3ZWFrUmVmLmRlcmVmKClcbiAgaWYgKHN0cmVhbSAmJiAhc3RyZWFtLmxvY2tlZCAmJiAhaXNEaXN0dXJiZWQoc3RyZWFtKSAmJiAhaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICBzdHJlYW0uY2FuY2VsKCdSZXNwb25zZSBvYmplY3QgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQnKS5jYXRjaChub29wKVxuICB9XG59KVxuXG4vKipcbiAqIEV4dHJhY3QgYSBib2R5IHdpdGggdHlwZSBmcm9tIGEgYnl0ZSBzZXF1ZW5jZSBvciBCb2R5SW5pdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vLi4vdHlwZXMnKS5Cb2R5SW5pdH0gb2JqZWN0IC0gVGhlIEJvZHlJbml0IG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBhbGl2ZT1mYWxzZV0gLSBJZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGUgYm9keVxuICogQHJldHVybnMge1t7c3RyZWFtOiBSZWFkYWJsZVN0cmVhbSwgc291cmNlOiBhbnksIGxlbmd0aDogbnVtYmVyIHwgbnVsbH0sIHN0cmluZyB8IG51bGxdfSAtIFJldHVybnMgYSB0dXBsZSBjb250YWluaW5nIHRoZSBib2R5IGFuZCBpdHMgdHlwZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICovXG5mdW5jdGlvbiBleHRyYWN0Qm9keSAob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgc3RyZWFtIGJlIG51bGwuXG4gIGxldCBzdHJlYW0gPSBudWxsXG4gIGxldCBjb250cm9sbGVyID0gbnVsbFxuXG4gIC8vIDIuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbiBzZXQgc3RyZWFtIHRvIG9iamVjdC5cbiAgaWYgKHdlYmlkbC5pcy5SZWFkYWJsZVN0cmVhbShvYmplY3QpKSB7XG4gICAgc3RyZWFtID0gb2JqZWN0XG4gIH0gZWxzZSBpZiAod2ViaWRsLmlzLkJsb2Iob2JqZWN0KSkge1xuICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgb2JqZWN0IGlzIGEgQmxvYiBvYmplY3QsIHNldCBzdHJlYW0gdG8gdGhlXG4gICAgLy8gICAgcmVzdWx0IG9mIHJ1bm5pbmcgb2JqZWN04oCZcyBnZXQgc3RyZWFtLlxuICAgIHN0cmVhbSA9IG9iamVjdC5zdHJlYW0oKVxuICB9IGVsc2Uge1xuICAgIC8vIDQuIE90aGVyd2lzZSwgc2V0IHN0cmVhbSB0byBhIG5ldyBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIGFuZCBzZXRcbiAgICAvLyAgICB1cCBzdHJlYW0gd2l0aCBieXRlIHJlYWRpbmcgc3VwcG9ydC5cbiAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgcHVsbCAoKSB7fSxcbiAgICAgIHN0YXJ0IChjKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjXG4gICAgICB9LFxuICAgICAgY2FuY2VsICgpIHt9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KHdlYmlkbC5pcy5SZWFkYWJsZVN0cmVhbShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKHdlYmlkbC5pcy5VUkxTZWFyY2hQYXJhbXMob2JqZWN0KSkge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAod2ViaWRsLmlzLkJ1ZmZlclNvdXJjZShvYmplY3QpKSB7XG4gICAgLy8gU2V0IHNvdXJjZSB0byBhIGNvcHkgb2YgdGhlIGJ5dGVzIGhlbGQgYnkgb2JqZWN0LlxuICAgIHNvdXJjZSA9IHdlYmlkbC51dGlsLmdldENvcHlPZkJ5dGVzSGVsZEJ5QnVmZmVyU291cmNlKG9iamVjdClcbiAgfSBlbHNlIGlmICh3ZWJpZGwuaXMuRm9ybURhdGEob2JqZWN0KSkge1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gYC0tLS1mb3JtZGF0YS11bmRpY2ktMCR7YCR7cmFuZG9tKDFlMTEpfWAucGFkU3RhcnQoMTEsICcwJyl9YFxuICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYFxuXG4gICAgLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuICAgIGNvbnN0IGZvcm1kYXRhRXNjYXBlID0gKHN0cikgPT5cbiAgICAgIHN0ci5yZXBsYWNlKC9cXG4vZywgJyUwQScpLnJlcGxhY2UoL1xcci9nLCAnJTBEJykucmVwbGFjZSgvXCIvZywgJyUyMicpXG4gICAgY29uc3Qgbm9ybWFsaXplTGluZWZlZWRzID0gKHZhbHVlKSA9PiB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCAnXFxyXFxuJylcblxuICAgIC8vIFNldCBhY3Rpb24gdG8gdGhpcyBzdGVwOiBydW4gdGhlIG11bHRpcGFydC9mb3JtLWRhdGFcbiAgICAvLyBlbmNvZGluZyBhbGdvcml0aG0sIHdpdGggb2JqZWN04oCZcyBlbnRyeSBsaXN0IGFuZCBVVEYtOC5cbiAgICAvLyAtIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBib2R5IGlzIGltbXV0YWJsZSBhbmQgY2FuJ3QgYmUgY2hhbmdlZCBhZnRlcndvcmRzXG4gICAgLy8gLSBUaGF0IHRoZSBjb250ZW50LWxlbmd0aCBpcyBjYWxjdWxhdGVkIGluIGFkdmFuY2UuXG4gICAgLy8gLSBBbmQgdGhhdCBhbGwgcGFydHMgYXJlIHByZS1lbmNvZGVkIGFuZCByZWFkeSB0byBiZSBzZW50LlxuXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBjb25zdCBybiA9IG5ldyBVaW50OEFycmF5KFsxMywgMTBdKSAvLyAnXFxyXFxuJ1xuICAgIGxlbmd0aCA9IDBcbiAgICBsZXQgaGFzVW5rbm93blNpemVWYWx1ZSA9IGZhbHNlXG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2Ygb2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShwcmVmaXggK1xuICAgICAgICAgIGA7IG5hbWU9XCIke2Zvcm1kYXRhRXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICBgXFxyXFxuXFxyXFxuJHtub3JtYWxpemVMaW5lZmVlZHModmFsdWUpfVxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7cHJlZml4fTsgbmFtZT1cIiR7Zm9ybWRhdGFFc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgICh2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2Zvcm1kYXRhRXNjYXBlKHZhbHVlLm5hbWUpfVwiYCA6ICcnKSArICdcXHJcXG4nICtcbiAgICAgICAgICBgQ29udGVudC1UeXBlOiAke1xuICAgICAgICAgICAgdmFsdWUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgIH1cXHJcXG5cXHJcXG5gKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaywgdmFsdWUsIHJuKVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGggKyB2YWx1ZS5zaXplICsgcm4uYnl0ZUxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc1Vua25vd25TaXplVmFsdWUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDUkxGIGlzIGFwcGVuZGVkIHRvIHRoZSBib2R5IHRvIGZ1bmN0aW9uIHdpdGggbGVnYWN5IHNlcnZlcnMgYW5kIG1hdGNoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3VybC9jdXJsL2Jsb2IvMzQzNGM2YjQ2ZTY4MjQ1Mjk3Mzk3MmU4MzEzNjEzZGZhNThjZDY5MC9saWIvbWltZS5jI0wxMDI5LUwxMDMwXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzYzXG4gICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLVxcclxcbmApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWBcbiAgfSBlbHNlIGlmICh3ZWJpZGwuaXMuQmxvYihvYmplY3QpKSB7XG4gICAgLy8gQmxvYlxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byBvYmplY3QuXG4gICAgc291cmNlID0gb2JqZWN0XG5cbiAgICAvLyBTZXQgbGVuZ3RoIHRvIG9iamVjdOKAmXMgc2l6ZS5cbiAgICBsZW5ndGggPSBvYmplY3Quc2l6ZVxuXG4gICAgLy8gSWYgb2JqZWN04oCZcyB0eXBlIGF0dHJpYnV0ZSBpcyBub3QgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIHNldFxuICAgIC8vIHR5cGUgdG8gaXRzIHZhbHVlLlxuICAgIGlmIChvYmplY3QudHlwZSkge1xuICAgICAgdHlwZSA9IG9iamVjdC50eXBlXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYga2VlcGFsaXZlIGlzIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGtlZXBhbGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2VlcGFsaXZlJylcbiAgICB9XG5cbiAgICAvLyBJZiBvYmplY3QgaXMgZGlzdHVyYmVkIG9yIGxvY2tlZCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChvYmplY3QpIHx8IG9iamVjdC5sb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdSZXNwb25zZSBib2R5IG9iamVjdCBzaG91bGQgbm90IGJlIGRpc3R1cmJlZCBvciBsb2NrZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgc3RyZWFtID1cbiAgICAgIHdlYmlkbC5pcy5SZWFkYWJsZVN0cmVhbShvYmplY3QpID8gb2JqZWN0IDogUmVhZGFibGVTdHJlYW1Gcm9tKG9iamVjdClcbiAgfVxuXG4gIC8vIDExLiBJZiBzb3VyY2UgaXMgYSBieXRlIHNlcXVlbmNlLCB0aGVuIHNldCBhY3Rpb24gdG8gYVxuICAvLyBzdGVwIHRoYXQgcmV0dXJucyBzb3VyY2UgYW5kIGxlbmd0aCB0byBzb3VyY2XigJlzIGxlbmd0aC5cbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnIHx8IGlzVWludDhBcnJheShzb3VyY2UpKSB7XG4gICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgbGVuZ3RoID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBCdWZmZXIuYnl0ZUxlbmd0aChzb3VyY2UpIDogc291cmNlLmxlbmd0aFxuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBJZiBhY3Rpb24gaXMgbm9uLW51bGwsIHRoZW4gcnVuIHRoZXNlIHN0ZXBzIGluIHBhcmFsbGVsOlxuICBpZiAoYWN0aW9uICE9IG51bGwpIHtcbiAgICA7KGFzeW5jICgpID0+IHtcbiAgICAgIC8vIDEuIFJ1biBhY3Rpb24uXG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24oKVxuXG4gICAgICAvLyAyLiBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAvLyAgICBlbnF1ZXVlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBVaW50OEFycmF5IGZyb20gdGhlIGF2YWlsYWJsZSBieXRlcyBpbnRvIHN0cmVhbS5cbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVzdWx0Py5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdPy4oKVxuICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYnl0ZXMgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICBpZiAoaXNFcnJvcmVkKHN0cmVhbSkpIGJyZWFrXG4gICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0Py5sZW5ndGggJiYgIWlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyA/IHRleHRFbmNvZGVyLmVuY29kZShyZXN1bHQpIDogbmV3IFVpbnQ4QXJyYXkocmVzdWx0KSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIpKVxuICAgIH0pKClcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRXh0cmFjdEJvZHlSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7UmVhZGFibGVTdHJlYW08VWludDhBcnJheTxBcnJheUJ1ZmZlcj4+fSBzdHJlYW0gLSBUaGUgUmVhZGFibGVTdHJlYW0gY29udGFpbmluZyB0aGUgYm9keSBkYXRhXG4gKiBAcHJvcGVydHkge2FueX0gc291cmNlIC0gVGhlIG9yaWdpbmFsIHNvdXJjZSBvZiB0aGUgYm9keSBkYXRhXG4gKiBAcHJvcGVydHkge251bWJlciB8IG51bGx9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJvZHkgZGF0YSwgb3IgbnVsbFxuICovXG5cbi8qKlxuICogU2FmZWx5IGV4dHJhY3QgYSBib2R5IHdpdGggdHlwZSBmcm9tIGEgYnl0ZSBzZXF1ZW5jZSBvciBCb2R5SW5pdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uLy4uL3R5cGVzJykuQm9keUluaXR9IG9iamVjdCAtIFRoZSBCb2R5SW5pdCBvYmplY3QgdG8gZXh0cmFjdCBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwYWxpdmU9ZmFsc2VdIC0gSWYgdHJ1ZSwgaW5kaWNhdGVzIHRoYXQgdGhlIGJvZHlcbiAqIEByZXR1cm5zIHtbRXh0cmFjdEJvZHlSZXN1bHQsIHN0cmluZyB8IG51bGxdfSAtIFJldHVybnMgYSB0dXBsZSBjb250YWluaW5nIHRoZSBib2R5IGFuZCBpdHMgdHlwZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlpbml0LXNhZmVseS1leHRyYWN0XG4gKi9cbmZ1bmN0aW9uIHNhZmVseUV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIC8vIFRvIHNhZmVseSBleHRyYWN0IGEgYm9keSBhbmQgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tXG4gIC8vIGEgYnl0ZSBzZXF1ZW5jZSBvciBCb2R5SW5pdCBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuOlxuICBpZiAod2ViaWRsLmlzLlJlYWRhYmxlU3RyZWFtKG9iamVjdCkpIHtcbiAgICAvLyBBc3NlcnQ6IG9iamVjdCBpcyBuZWl0aGVyIGRpc3R1cmJlZCBub3IgbG9ja2VkLlxuICAgIGFzc2VydCghdXRpbC5pc0Rpc3R1cmJlZChvYmplY3QpLCAnVGhlIGJvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nKVxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChib2R5KSB7XG4gIC8vIFRvIGNsb25lIGEgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jbG9uZVxuXG4gIC8vIDEuIExldCDCqyBvdXQxLCBvdXQyIMK7IGJlIHRoZSByZXN1bHQgb2YgdGVlaW5nIGJvZHnigJlzIHN0cmVhbS5cbiAgY29uc3QgeyAwOiBvdXQxLCAxOiBvdXQyIH0gPSBib2R5LnN0cmVhbS50ZWUoKVxuXG4gIC8vIDIuIFNldCBib2R54oCZcyBzdHJlYW0gdG8gb3V0MS5cbiAgYm9keS5zdHJlYW0gPSBvdXQxXG5cbiAgLy8gMy4gUmV0dXJuIGEgYm9keSB3aG9zZSBzdHJlYW0gaXMgb3V0MiBhbmQgb3RoZXIgbWVtYmVycyBhcmUgY29waWVkIGZyb20gYm9keS5cbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IG91dDIsXG4gICAgbGVuZ3RoOiBib2R5Lmxlbmd0aCxcbiAgICBzb3VyY2U6IGJvZHkuc291cmNlXG4gIH1cbn1cblxuZnVuY3Rpb24gYm9keU1peGluTWV0aG9kcyAoaW5zdGFuY2UsIGdldEludGVybmFsU3RhdGUpIHtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICBibG9iICgpIHtcbiAgICAgIC8vIFRoZSBibG9iKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgQmxvYiB3aG9zZVxuICAgICAgLy8gY29udGVudHMgYXJlIGJ5dGVzIGFuZCB3aG9zZSB0eXBlIGF0dHJpYnV0ZSBpcyB0aGlz4oCZc1xuICAgICAgLy8gTUlNRSB0eXBlLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBib2R5TWltZVR5cGUoZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKSlcblxuICAgICAgICBpZiAobWltZVR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICBtaW1lVHlwZSA9ICcnXG4gICAgICAgIH0gZWxzZSBpZiAobWltZVR5cGUpIHtcbiAgICAgICAgICBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShtaW1lVHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIEJsb2Igd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzIGFuZCB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAvLyBpcyBtaW1lVHlwZS5cbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtieXRlc10sIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICAgIH0sIGluc3RhbmNlLCBnZXRJbnRlcm5hbFN0YXRlKVxuICAgIH0sXG5cbiAgICBhcnJheUJ1ZmZlciAoKSB7XG4gICAgICAvLyBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAvLyBvZiBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBuZXcgQXJyYXlCdWZmZXJcbiAgICAgIC8vIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcy5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCAoYnl0ZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXJcbiAgICAgIH0sIGluc3RhbmNlLCBnZXRJbnRlcm5hbFN0YXRlKVxuICAgIH0sXG5cbiAgICB0ZXh0ICgpIHtcbiAgICAgIC8vIFRoZSB0ZXh0KCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBVVEYtOCBkZWNvZGUuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgdXRmOERlY29kZUJ5dGVzLCBpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSlcbiAgICB9LFxuXG4gICAganNvbiAoKSB7XG4gICAgICAvLyBUaGUganNvbigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgcGFyc2UgSlNPTiBmcm9tIGJ5dGVzLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIHBhcnNlSlNPTkZyb21CeXRlcywgaW5zdGFuY2UsIGdldEludGVybmFsU3RhdGUpXG4gICAgfSxcblxuICAgIGZvcm1EYXRhICgpIHtcbiAgICAgIC8vIFRoZSBmb3JtRGF0YSgpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczpcbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gMS4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgZ2V0IHRoZSBNSU1FIHR5cGUgd2l0aCB0aGlzLlxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZShnZXRJbnRlcm5hbFN0YXRlKHRoaXMpKVxuXG4gICAgICAgIC8vIDIuIElmIG1pbWVUeXBlIGlzIG5vbi1udWxsLCB0aGVuIHN3aXRjaCBvbiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBhbmQgcnVuXG4gICAgICAgIC8vICAgIHRoZSBjb3JyZXNwb25kaW5nIHN0ZXBzOlxuICAgICAgICBpZiAobWltZVR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1pbWVUeXBlLmVzc2VuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGFydC9mb3JtLWRhdGEnOiB7XG4gICAgICAgICAgICAgIC8vIDEuIC4uLiBbbG9uZyBzdGVwXVxuICAgICAgICAgICAgICAvLyAyLiBJZiB0aGF0IGZhaWxzIGZvciBzb21lIHJlYXNvbiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIodmFsdWUsIG1pbWVUeXBlKVxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3QsIGFwcGVuZGluZyBlYWNoIGVudHJ5LFxuICAgICAgICAgICAgICAvLyAgICByZXN1bHRpbmcgZnJvbSB0aGUgcGFyc2luZyBvcGVyYXRpb24sIHRvIGl0cyBlbnRyeSBsaXN0LlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgICAgICAgIHNldEZvcm1EYXRhU3RhdGUoZmQsIHBhcnNlZClcblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gTGV0IGVudHJpZXMgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGJ5dGVzLlxuICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh2YWx1ZS50b1N0cmluZygpKVxuXG4gICAgICAgICAgICAgIC8vIDIuIElmIGVudHJpZXMgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cblxuICAgICAgICAgICAgICAvLyAzLiBSZXR1cm4gYSBuZXcgRm9ybURhdGEgb2JqZWN0IHdob3NlIGVudHJ5IGxpc3QgaXMgZW50cmllcy5cbiAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKVxuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZmQuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gVGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSB3YXMgbm90IG9uZSBvZiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBvciBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLidcbiAgICAgICAgKVxuICAgICAgfSwgaW5zdGFuY2UsIGdldEludGVybmFsU3RhdGUpXG4gICAgfSxcblxuICAgIGJ5dGVzICgpIHtcbiAgICAgIC8vIFRoZSBieXRlcygpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBjb25zdW1lIGJvZHlcbiAgICAgIC8vIHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIHRoZVxuICAgICAgLy8gcmVzdWx0IG9mIGNyZWF0aW5nIGEgVWludDhBcnJheSBmcm9tIGJ5dGVzIGluIHRoaXPigJlzIHJlbGV2YW50IHJlYWxtLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG4gICAgICB9LCBpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5mdW5jdGlvbiBtaXhpbkJvZHkgKHByb3RvdHlwZSwgZ2V0SW50ZXJuYWxTdGF0ZSkge1xuICBPYmplY3QuYXNzaWduKHByb3RvdHlwZS5wcm90b3R5cGUsIGJvZHlNaXhpbk1ldGhvZHMocHJvdG90eXBlLCBnZXRJbnRlcm5hbFN0YXRlKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0IGludGVybmFsIHN0YXRlXG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdW5rbm93bn0gY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gKiBAcGFyYW0ge2FueX0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7KHRhcmdldDogYW55KSA9PiBhbnl9IGdldEludGVybmFsU3RhdGVcbiAqL1xuZnVuY3Rpb24gY29uc3VtZUJvZHkgKG9iamVjdCwgY29udmVydEJ5dGVzVG9KU1ZhbHVlLCBpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSkge1xuICB0cnkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSlcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShvYmplY3QpXG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIHVudXNhYmxlLCB0aGVuIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWRcbiAgLy8gICAgd2l0aCBhIFR5cGVFcnJvci5cbiAgaWYgKGJvZHlVbnVzYWJsZShzdGF0ZSkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQm9keSBpcyB1bnVzYWJsZTogQm9keSBoYXMgYWxyZWFkeSBiZWVuIHJlYWQnKSlcbiAgfVxuXG4gIGlmIChzdGF0ZS5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgfVxuXG4gIC8vIDIuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGdpdmVuIGVycm9yIGJlIHRvIHJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGNvbnN0IGVycm9yU3RlcHMgPSBwcm9taXNlLnJlamVjdFxuXG4gIC8vIDQuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGRhdGEgYmUgdG8gcmVzb2x2ZVxuICAvLyAgICBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICAvLyAgICB3aXRoIGRhdGEuIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzXG4gIC8vICAgIHdpdGggdGhhdCBleGNlcHRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUoZGF0YSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JTdGVwcyhlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDUuIElmIG9iamVjdOKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBzdWNjZXNzU3RlcHMgd2l0aCBhblxuICAvLyAgICBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICBpZiAoc3RhdGUuYm9keSA9PSBudWxsKSB7XG4gICAgc3VjY2Vzc1N0ZXBzKEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKSlcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgb2JqZWN04oCZcyBib2R5IGdpdmVuIHN1Y2Nlc3NTdGVwcyxcbiAgLy8gICAgZXJyb3JTdGVwcywgYW5kIG9iamVjdOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdC5cbiAgZnVsbHlSZWFkQm9keShzdGF0ZS5ib2R5LCBzdWNjZXNzU3RlcHMsIGVycm9yU3RlcHMpXG5cbiAgLy8gNy4gUmV0dXJuIHByb21pc2UuXG4gIHJldHVybiBwcm9taXNlLnByb21pc2Vcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0IGludGVybmFsIHN0YXRlXG4gKi9cbmZ1bmN0aW9uIGJvZHlVbnVzYWJsZSAob2JqZWN0KSB7XG4gIGNvbnN0IGJvZHkgPSBvYmplY3QuYm9keVxuXG4gIC8vIEFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEJvZHkgaW50ZXJmYWNlIG1peGluIGlzXG4gIC8vIHNhaWQgdG8gYmUgdW51c2FibGUgaWYgaXRzIGJvZHkgaXMgbm9uLW51bGwgYW5kXG4gIC8vIGl0cyBib2R54oCZcyBzdHJlYW0gaXMgZGlzdHVyYmVkIG9yIGxvY2tlZC5cbiAgcmV0dXJuIGJvZHkgIT0gbnVsbCAmJiAoYm9keS5zdHJlYW0ubG9ja2VkIHx8IHV0aWwuaXNEaXN0dXJiZWQoYm9keS5zdHJlYW0pKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1taW1lLXR5cGVcbiAqIEBwYXJhbSB7YW55fSByZXF1ZXN0T3JSZXNwb25zZSBpbnRlcm5hbCBzdGF0ZVxuICovXG5mdW5jdGlvbiBib2R5TWltZVR5cGUgKHJlcXVlc3RPclJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCBoZWFkZXJzIGJlIG51bGwuXG4gIC8vIDIuIElmIHJlcXVlc3RPclJlc3BvbnNlIGlzIGEgUmVxdWVzdCBvYmplY3QsIHRoZW4gc2V0IGhlYWRlcnMgdG8gcmVxdWVzdE9yUmVzcG9uc2XigJlzIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyAzLiBPdGhlcndpc2UsIHNldCBoZWFkZXJzIHRvIHJlcXVlc3RPclJlc3BvbnNl4oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL2hlYWRlcnMnKS5IZWFkZXJzTGlzdH0gKi9cbiAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3RPclJlc3BvbnNlLmhlYWRlcnNMaXN0XG5cbiAgLy8gNC4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBhIE1JTUUgdHlwZSBmcm9tIGhlYWRlcnMuXG4gIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKGhlYWRlcnMpXG5cbiAgLy8gNS4gSWYgbWltZVR5cGUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKG1pbWVUeXBlID09PSAnZmFpbHVyZScpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dHJhY3RCb2R5LFxuICBzYWZlbHlFeHRyYWN0Qm9keSxcbiAgY2xvbmVCb2R5LFxuICBtaXhpbkJvZHksXG4gIHN0cmVhbVJlZ2lzdHJ5LFxuICBib2R5VW51c2FibGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nconst corsSafeListedMethods = /** @type {const} */ (['GET', 'HEAD', 'POST'])\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods)\n\nconst nullBodyStatus = /** @type {const} */ ([101, 204, 205, 304])\n\nconst redirectStatus = /** @type {const} */ ([301, 302, 303, 307, 308])\nconst redirectStatusSet = new Set(redirectStatus)\n\n/**\n * @see https://fetch.spec.whatwg.org/#block-bad-port\n */\nconst badPorts = /** @type {const} */ ([\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '4190', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6679',\n  '6697', '10080'\n])\nconst badPortsSet = new Set(badPorts)\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header\n */\nconst referrerPolicyTokens = /** @type {const} */ ([\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n])\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\n */\nconst referrerPolicy = /** @type {const} */ ([\n  '',\n  ...referrerPolicyTokens\n])\nconst referrerPolicyTokensSet = new Set(referrerPolicyTokens)\n\nconst requestRedirect = /** @type {const} */ (['follow', 'manual', 'error'])\n\nconst safeMethods = /** @type {const} */ (['GET', 'HEAD', 'OPTIONS', 'TRACE'])\nconst safeMethodsSet = new Set(safeMethods)\n\nconst requestMode = /** @type {const} */ (['navigate', 'same-origin', 'no-cors', 'cors'])\n\nconst requestCredentials = /** @type {const} */ (['omit', 'same-origin', 'include'])\n\nconst requestCache = /** @type {const} */ ([\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-body-header-name\n */\nconst requestBodyHeader = /** @type {const} */ ([\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#enumdef-requestduplex\n */\nconst requestDuplex = /** @type {const} */ ([\n  'half'\n])\n\n/**\n * @see http://fetch.spec.whatwg.org/#forbidden-method\n */\nconst forbiddenMethods = /** @type {const} */ (['CONNECT', 'TRACE', 'TRACK'])\nconst forbiddenMethodsSet = new Set(forbiddenMethods)\n\nconst subresource = /** @type {const} */ ([\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n])\nconst subresourceSet = new Set(subresource)\n\nmodule.exports = {\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex,\n  subresourceSet,\n  badPortsSet,\n  redirectStatusSet,\n  corsSafeListedMethodsSet,\n  safeMethodsSet,\n  forbiddenMethodsSet,\n  referrerPolicyTokens: referrerPolicyTokensSet\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBLGtDQUFrQyxPQUFPOztBQUV6QyxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTzs7QUFFMUMsK0JBQStCLE9BQU87QUFDdEM7O0FBRUEsK0JBQStCLE9BQU87O0FBRXRDLHNDQUFzQyxPQUFPOztBQUU3QyxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnR0VUJywgJ0hFQUQnLCAnUE9TVCddKVxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0ID0gbmV3IFNldChjb3JzU2FmZUxpc3RlZE1ldGhvZHMpXG5cbmNvbnN0IG51bGxCb2R5U3RhdHVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsxMDEsIDIwNCwgMjA1LCAzMDRdKVxuXG5jb25zdCByZWRpcmVjdFN0YXR1cyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKVxuY29uc3QgcmVkaXJlY3RTdGF0dXNTZXQgPSBuZXcgU2V0KHJlZGlyZWN0U3RhdHVzKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Jsb2NrLWJhZC1wb3J0XG4gKi9cbmNvbnN0IGJhZFBvcnRzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJzEnLCAnNycsICc5JywgJzExJywgJzEzJywgJzE1JywgJzE3JywgJzE5JywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI1JywgJzM3JywgJzQyJywgJzQzJywgJzUzJywgJzY5JywgJzc3JywgJzc5JyxcbiAgJzg3JywgJzk1JywgJzEwMScsICcxMDInLCAnMTAzJywgJzEwNCcsICcxMDknLCAnMTEwJywgJzExMScsICcxMTMnLCAnMTE1JywgJzExNycsICcxMTknLCAnMTIzJywgJzEzNScsICcxMzcnLFxuICAnMTM5JywgJzE0MycsICcxNjEnLCAnMTc5JywgJzM4OScsICc0MjcnLCAnNDY1JywgJzUxMicsICc1MTMnLCAnNTE0JywgJzUxNScsICc1MjYnLCAnNTMwJywgJzUzMScsICc1MzInLFxuICAnNTQwJywgJzU0OCcsICc1NTQnLCAnNTU2JywgJzU2MycsICc1ODcnLCAnNjAxJywgJzYzNicsICc5ODknLCAnOTkwJywgJzk5MycsICc5OTUnLCAnMTcxOScsICcxNzIwJywgJzE3MjMnLFxuICAnMjA0OScsICczNjU5JywgJzQwNDUnLCAnNDE5MCcsICc1MDYwJywgJzUwNjEnLCAnNjAwMCcsICc2NTY2JywgJzY2NjUnLCAnNjY2NicsICc2NjY3JywgJzY2NjgnLCAnNjY2OScsICc2Njc5JyxcbiAgJzY2OTcnLCAnMTAwODAnXG5dKVxuY29uc3QgYmFkUG9ydHNTZXQgPSBuZXcgU2V0KGJhZFBvcnRzKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljeS1oZWFkZXJcbiAqL1xuY29uc3QgcmVmZXJyZXJQb2xpY3lUb2tlbnMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnbm8tcmVmZXJyZXInLFxuICAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuICAnc2FtZS1vcmlnaW4nLFxuICAnb3JpZ2luJyxcbiAgJ3N0cmljdC1vcmlnaW4nLFxuICAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAndW5zYWZlLXVybCdcbl0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXNcbiAqL1xuY29uc3QgcmVmZXJyZXJQb2xpY3kgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnJyxcbiAgLi4ucmVmZXJyZXJQb2xpY3lUb2tlbnNcbl0pXG5jb25zdCByZWZlcnJlclBvbGljeVRva2Vuc1NldCA9IG5ldyBTZXQocmVmZXJyZXJQb2xpY3lUb2tlbnMpXG5cbmNvbnN0IHJlcXVlc3RSZWRpcmVjdCA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ2ZvbGxvdycsICdtYW51YWwnLCAnZXJyb3InXSlcblxuY29uc3Qgc2FmZU1ldGhvZHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ10pXG5jb25zdCBzYWZlTWV0aG9kc1NldCA9IG5ldyBTZXQoc2FmZU1ldGhvZHMpXG5cbmNvbnN0IHJlcXVlc3RNb2RlID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnbmF2aWdhdGUnLCAnc2FtZS1vcmlnaW4nLCAnbm8tY29ycycsICdjb3JzJ10pXG5cbmNvbnN0IHJlcXVlc3RDcmVkZW50aWFscyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ29taXQnLCAnc2FtZS1vcmlnaW4nLCAnaW5jbHVkZSddKVxuXG5jb25zdCByZXF1ZXN0Q2FjaGUgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnZGVmYXVsdCcsXG4gICduby1zdG9yZScsXG4gICdyZWxvYWQnLFxuICAnbm8tY2FjaGUnLFxuICAnZm9yY2UtY2FjaGUnLFxuICAnb25seS1pZi1jYWNoZWQnXG5dKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtYm9keS1oZWFkZXItbmFtZVxuICovXG5jb25zdCByZXF1ZXN0Qm9keUhlYWRlciA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdjb250ZW50LWVuY29kaW5nJyxcbiAgJ2NvbnRlbnQtbGFuZ3VhZ2UnLFxuICAnY29udGVudC1sb2NhdGlvbicsXG4gICdjb250ZW50LXR5cGUnLFxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwMjFcbiAgLy8gJ0NvbnRlbnQtTGVuZ3RoJyBpcyBhIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgd2hpY2ggaXMgdHlwaWNhbGx5XG4gIC8vIHJlbW92ZWQgaW4gdGhlIEhlYWRlcnMgaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHVuZGljaSBkb2Vzbid0XG4gIC8vIGZpbHRlciBvdXQgaGVhZGVycywgc28gd2UgYWRkIGl0IGhlcmUuXG4gICdjb250ZW50LWxlbmd0aCdcbl0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZW51bWRlZi1yZXF1ZXN0ZHVwbGV4XG4gKi9cbmNvbnN0IHJlcXVlc3REdXBsZXggPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnaGFsZidcbl0pXG5cbi8qKlxuICogQHNlZSBodHRwOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmb3JiaWRkZW4tbWV0aG9kXG4gKi9cbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydDT05ORUNUJywgJ1RSQUNFJywgJ1RSQUNLJ10pXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzU2V0ID0gbmV3IFNldChmb3JiaWRkZW5NZXRob2RzKVxuXG5jb25zdCBzdWJyZXNvdXJjZSA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdhdWRpbycsXG4gICdhdWRpb3dvcmtsZXQnLFxuICAnZm9udCcsXG4gICdpbWFnZScsXG4gICdtYW5pZmVzdCcsXG4gICdwYWludHdvcmtsZXQnLFxuICAnc2NyaXB0JyxcbiAgJ3N0eWxlJyxcbiAgJ3RyYWNrJyxcbiAgJ3ZpZGVvJyxcbiAgJ3hzbHQnLFxuICAnJ1xuXSlcbmNvbnN0IHN1YnJlc291cmNlU2V0ID0gbmV3IFNldChzdWJyZXNvdXJjZSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN1YnJlc291cmNlLFxuICBmb3JiaWRkZW5NZXRob2RzLFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZWRpcmVjdFN0YXR1cyxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzLFxuICBudWxsQm9keVN0YXR1cyxcbiAgc2FmZU1ldGhvZHMsXG4gIGJhZFBvcnRzLFxuICByZXF1ZXN0RHVwbGV4LFxuICBzdWJyZXNvdXJjZVNldCxcbiAgYmFkUG9ydHNTZXQsXG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQsXG4gIHNhZmVNZXRob2RzU2V0LFxuICBmb3JiaWRkZW5NZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeVRva2VuczogcmVmZXJyZXJQb2xpY3lUb2tlbnNTZXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { forgivingBase64, collectASequenceOfCodePoints, collectASequenceOfCodePointsFast, isomorphicDecode, removeASCIIWhitespace, removeChars } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[-!#$%&'*+.^_|~A-Za-z0-9]+$/u\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/u // eslint-disable-line\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/u // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURLs scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(?:\\u0020*)base64$/ui.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020+)$/u, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  let i = 0\n  // 2. For each byte byte in input:\n  while (i < length) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n    ++i\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeTypes parameters[parameterName] does not exist\n    // then set mimeTypes parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean} [extractValue=false]\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue = false) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeTypes\n  //    type, U+002F (/), and mimeTypes subtype.\n  let serialization = essence\n\n  // 2. For each name  value of mimeTypes parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/[\\\\\"]/ug, '\\\\$&')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeTypes essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeTypes essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsd0lBQXdJLEVBQUUsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFcEs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtB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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxkYXRhLXVybC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBmb3JnaXZpbmdCYXNlNjQsIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LCBpc29tb3JwaGljRGVjb2RlLCByZW1vdmVBU0NJSVdoaXRlc3BhY2UsIHJlbW92ZUNoYXJzIH0gPSByZXF1aXJlKCcuLi9pbmZyYScpXG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9UT0tFTl9DT0RFUE9JTlRTID0gL15bLSEjJCUmJyorLl5ffH5BLVphLXowLTldKyQvdVxuY29uc3QgSFRUUF9XSElURVNQQUNFX1JFR0VYID0gL1tcXHUwMDBBXFx1MDAwRFxcdTAwMDlcXHUwMDIwXS91IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1xdW90ZWQtc3RyaW5nLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyA9IC9eW1xcdTAwMDlcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdKyQvdSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkYXRhLXVybC1wcm9jZXNzb3Jcbi8qKiBAcGFyYW0ge1VSTH0gZGF0YVVSTCAqL1xuZnVuY3Rpb24gZGF0YVVSTFByb2Nlc3NvciAoZGF0YVVSTCkge1xuICAvLyAxLiBBc3NlcnQ6IGRhdGFVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIi5cbiAgYXNzZXJ0KGRhdGFVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpXG5cbiAgLy8gMi4gTGV0IGlucHV0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgVVJMXG4gIC8vIHNlcmlhbGl6ZXIgb24gZGF0YVVSTCB3aXRoIGV4Y2x1ZGUgZnJhZ21lbnRcbiAgLy8gc2V0IHRvIHRydWUuXG4gIGxldCBpbnB1dCA9IFVSTFNlcmlhbGl6ZXIoZGF0YVVSTCwgdHJ1ZSlcblxuICAvLyAzLiBSZW1vdmUgdGhlIGxlYWRpbmcgXCJkYXRhOlwiIHN0cmluZyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDUpXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIHBvaW50IGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyA1LiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFcbiAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IGVxdWFsXG4gIC8vIHRvIFUrMDAyQyAoLCksIGdpdmVuIHBvc2l0aW9uLlxuICBsZXQgbWltZVR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLCcsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDYuIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBtaW1lVHlwZS5cbiAgLy8gVW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHdlIG5lZWQgdG8gc3RvcmUgdGhlXG4gIC8vIGxlbmd0aCBiZWNhdXNlIGlmIHRoZSBtaW1ldHlwZSBoYXMgc3BhY2VzIHJlbW92ZWQsXG4gIC8vIHRoZSB3cm9uZyBhbW91bnQgd2lsbCBiZSBzbGljZWQgZnJvbSB0aGUgaW5wdXQgaW5cbiAgLy8gc3RlcCAjOVxuICBjb25zdCBtaW1lVHlwZUxlbmd0aCA9IG1pbWVUeXBlLmxlbmd0aFxuICBtaW1lVHlwZSA9IHJlbW92ZUFTQ0lJV2hpdGVzcGFjZShtaW1lVHlwZSwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyA3LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW5cbiAgLy8gcmV0dXJuIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDguIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDkuIExldCBlbmNvZGVkQm9keSBiZSB0aGUgcmVtYWluZGVyIG9mIGlucHV0LlxuICBjb25zdCBlbmNvZGVkQm9keSA9IGlucHV0LnNsaWNlKG1pbWVUeXBlTGVuZ3RoICsgMSlcblxuICAvLyAxMC4gTGV0IGJvZHkgYmUgdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgZW5jb2RlZEJvZHkuXG4gIGxldCBib2R5ID0gc3RyaW5nUGVyY2VudERlY29kZShlbmNvZGVkQm9keSlcblxuICAvLyAxMS4gSWYgbWltZVR5cGUgZW5kcyB3aXRoIFUrMDAzQiAoOyksIGZvbGxvd2VkIGJ5XG4gIC8vIHplcm8gb3IgbW9yZSBVKzAwMjAgU1BBQ0UsIGZvbGxvd2VkIGJ5IGFuIEFTQ0lJXG4gIC8vIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIFwiYmFzZTY0XCIsIHRoZW46XG4gIGlmICgvOyg/OlxcdTAwMjAqKWJhc2U2NCQvdWkudGVzdChtaW1lVHlwZSkpIHtcbiAgICAvLyAxLiBMZXQgc3RyaW5nQm9keSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGUgb2YgYm9keS5cbiAgICBjb25zdCBzdHJpbmdCb2R5ID0gaXNvbW9ycGhpY0RlY29kZShib2R5KVxuXG4gICAgLy8gMi4gU2V0IGJvZHkgdG8gdGhlIGZvcmdpdmluZy1iYXNlNjQgZGVjb2RlIG9mXG4gICAgLy8gc3RyaW5nQm9keS5cbiAgICBib2R5ID0gZm9yZ2l2aW5nQmFzZTY0KHN0cmluZ0JvZHkpXG5cbiAgICAvLyAzLiBJZiBib2R5IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGJvZHkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDQuIFJlbW92ZSB0aGUgbGFzdCA2IGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtNilcblxuICAgIC8vIDUuIFJlbW92ZSB0cmFpbGluZyBVKzAwMjAgU1BBQ0UgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZSxcbiAgICAvLyBpZiBhbnkuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC8oXFx1MDAyMCspJC91LCAnJylcblxuICAgIC8vIDYuIFJlbW92ZSB0aGUgbGFzdCBVKzAwM0IgKDspIGNvZGUgcG9pbnQgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgLy8gMTIuIElmIG1pbWVUeXBlIHN0YXJ0cyB3aXRoIFUrMDAzQiAoOyksIHRoZW4gcHJlcGVuZFxuICAvLyBcInRleHQvcGxhaW5cIiB0byBtaW1lVHlwZS5cbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoJzsnKSkge1xuICAgIG1pbWVUeXBlID0gJ3RleHQvcGxhaW4nICsgbWltZVR5cGVcbiAgfVxuXG4gIC8vIDEzLiBMZXQgbWltZVR5cGVSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gIC8vIG1pbWVUeXBlLlxuICBsZXQgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gIC8vIDE0LiBJZiBtaW1lVHlwZVJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHNldFxuICAvLyBtaW1lVHlwZVJlY29yZCB0byB0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUkuXG4gIGlmIChtaW1lVHlwZVJlY29yZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKCd0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUknKVxuICB9XG5cbiAgLy8gMTUuIFJldHVybiBhIG5ldyBkYXRhOiBVUkwgc3RydWN0IHdob3NlIE1JTUVcbiAgLy8gdHlwZSBpcyBtaW1lVHlwZVJlY29yZCBhbmQgYm9keSBpcyBib2R5LlxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtc3RydWN0XG4gIHJldHVybiB7IG1pbWVUeXBlOiBtaW1lVHlwZVJlY29yZCwgYm9keSB9XG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuLyoqXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4Y2x1ZGVGcmFnbWVudFxuICovXG5mdW5jdGlvbiBVUkxTZXJpYWxpemVyICh1cmwsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGlmICghZXhjbHVkZUZyYWdtZW50KSB7XG4gICAgcmV0dXJuIHVybC5ocmVmXG4gIH1cblxuICBjb25zdCBocmVmID0gdXJsLmhyZWZcbiAgY29uc3QgaGFzaExlbmd0aCA9IHVybC5oYXNoLmxlbmd0aFxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBoYXNoTGVuZ3RoID09PSAwID8gaHJlZiA6IGhyZWYuc3Vic3RyaW5nKDAsIGhyZWYubGVuZ3RoIC0gaGFzaExlbmd0aClcblxuICBpZiAoIWhhc2hMZW5ndGggJiYgaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuc2xpY2UoMCwgLTEpXG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZFxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0cmluZy1wZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gc3RyaW5nUGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBpbnB1dC5cbiAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShpbnB1dClcblxuICAvLyAyLiBSZXR1cm4gdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgYnl0ZXMuXG4gIHJldHVybiBwZXJjZW50RGVjb2RlKGJ5dGVzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKi9cbmZ1bmN0aW9uIGlzSGV4Q2hhckJ5dGUgKGJ5dGUpIHtcbiAgLy8gMC05IEEtRiBhLWZcbiAgcmV0dXJuIChieXRlID49IDB4MzAgJiYgYnl0ZSA8PSAweDM5KSB8fCAoYnl0ZSA+PSAweDQxICYmIGJ5dGUgPD0gMHg0NikgfHwgKGJ5dGUgPj0gMHg2MSAmJiBieXRlIDw9IDB4NjYpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqL1xuZnVuY3Rpb24gaGV4Qnl0ZVRvTnVtYmVyIChieXRlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gMC05XG4gICAgYnl0ZSA+PSAweDMwICYmIGJ5dGUgPD0gMHgzOVxuICAgICAgPyAoYnl0ZSAtIDQ4KVxuICAgIC8vIENvbnZlcnQgdG8gdXBwZXJjYXNlXG4gICAgLy8gKChieXRlICYgMHhERikgLSA2NSkgKyAxMFxuICAgICAgOiAoKGJ5dGUgJiAweERGKSAtIDU1KVxuICApXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0ICovXG5mdW5jdGlvbiBwZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgLy8gMS4gTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IGogPSAwXG4gIGxldCBpID0gMFxuICAvLyAyLiBGb3IgZWFjaCBieXRlIGJ5dGUgaW4gaW5wdXQ6XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgY29uc3QgYnl0ZSA9IGlucHV0W2ldXG5cbiAgICAvLyAxLiBJZiBieXRlIGlzIG5vdCAweDI1ICglKSwgdGhlbiBhcHBlbmQgYnl0ZSB0byBvdXRwdXQuXG4gICAgaWYgKGJ5dGUgIT09IDB4MjUpIHtcbiAgICAgIG91dHB1dFtqKytdID0gYnl0ZVxuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBieXRlIGlzIDB4MjUgKCUpIGFuZCB0aGUgbmV4dCB0d28gYnl0ZXNcbiAgICAvLyBhZnRlciBieXRlIGluIGlucHV0IGFyZSBub3QgaW4gdGhlIHJhbmdlc1xuICAgIC8vIDB4MzAgKDApIHRvIDB4MzkgKDkpLCAweDQxIChBKSB0byAweDQ2IChGKSxcbiAgICAvLyBhbmQgMHg2MSAoYSkgdG8gMHg2NiAoZiksIGFsbCBpbmNsdXNpdmUsIGFwcGVuZCBieXRlXG4gICAgLy8gdG8gb3V0cHV0LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBieXRlID09PSAweDI1ICYmXG4gICAgICAhKGlzSGV4Q2hhckJ5dGUoaW5wdXRbaSArIDFdKSAmJiBpc0hleENoYXJCeXRlKGlucHV0W2kgKyAyXSkpXG4gICAgKSB7XG4gICAgICBvdXRwdXRbaisrXSA9IDB4MjVcblxuICAgIC8vIDMuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gTGV0IGJ5dGVQb2ludCBiZSB0aGUgdHdvIGJ5dGVzIGFmdGVyIGJ5dGUgaW4gaW5wdXQsXG4gICAgICAvLyBkZWNvZGVkLCBhbmQgdGhlbiBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAgICAvLyAyLiBBcHBlbmQgYSBieXRlIHdob3NlIHZhbHVlIGlzIGJ5dGVQb2ludCB0byBvdXRwdXQuXG4gICAgICBvdXRwdXRbaisrXSA9IChoZXhCeXRlVG9OdW1iZXIoaW5wdXRbaSArIDFdKSA8PCA0KSB8IGhleEJ5dGVUb051bWJlcihpbnB1dFtpICsgMl0pXG5cbiAgICAgIC8vIDMuIFNraXAgdGhlIG5leHQgdHdvIGJ5dGVzIGluIGlucHV0LlxuICAgICAgaSArPSAyXG4gICAgfVxuICAgICsraVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIGxlbmd0aCA9PT0gaiA/IG91dHB1dCA6IG91dHB1dC5zdWJhcnJheSgwLCBqKVxufVxuXG4vLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWEtbWltZS10eXBlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlIChpbnB1dCkge1xuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZVxuICAvLyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKGlucHV0LCB0cnVlLCB0cnVlKVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCxcbiAgLy8gaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZVxuICAvLyBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDJGICgvKSBmcm9tXG4gIC8vIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgdHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcvJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNC4gSWYgdHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gIGlmICh0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gcmV0dXJuXG4gIC8vIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwMkYgKC8pLilcbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIExldCBzdWJ0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mXG4gIC8vIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuXG4gIC8vIHBvc2l0aW9uLlxuICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICc7JyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gOC4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBzdWJ0eXBlLlxuICBzdWJ0eXBlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2Uoc3VidHlwZSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gOS4gSWYgc3VidHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3Qoc3VidHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCB0eXBlTG93ZXJjYXNlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHN1YnR5cGVMb3dlcmNhc2UgPSBzdWJ0eXBlLnRvTG93ZXJDYXNlKClcblxuICAvLyAxMC4gTGV0IG1pbWVUeXBlIGJlIGEgbmV3IE1JTUUgdHlwZSByZWNvcmQgd2hvc2UgdHlwZVxuICAvLyBpcyB0eXBlLCBpbiBBU0NJSSBsb3dlcmNhc2UsIGFuZCBzdWJ0eXBlIGlzIHN1YnR5cGUsXG4gIC8vIGluIEFTQ0lJIGxvd2VyY2FzZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGVcbiAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgdHlwZTogdHlwZUxvd2VyY2FzZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlTG93ZXJjYXNlLFxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBwYXJhbWV0ZXJzOiBuZXcgTWFwKCksXG4gICAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGUtZXNzZW5jZVxuICAgIGVzc2VuY2U6IGAke3R5cGVMb3dlcmNhc2V9LyR7c3VidHlwZUxvd2VyY2FzZX1gXG4gIH1cblxuICAvLyAxMS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gMS4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzQiAoOykuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tIGlucHV0IGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gICAgICBjaGFyID0+IEhUVFBfV0hJVEVTUEFDRV9SRUdFWC50ZXN0KGNoYXIpLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDMuIExldCBwYXJhbWV0ZXJOYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gICAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAvLyBvciBVKzAwM0QgKD0pIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnOycgJiYgY2hhciAhPT0gJz0nLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDQuIFNldCBwYXJhbWV0ZXJOYW1lIHRvIHBhcmFtZXRlck5hbWUsIGluIEFTQ0lJXG4gICAgLy8gbG93ZXJjYXNlLlxuICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDUuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAgIC8vIFUrMDAzQiAoOyksIHRoZW4gY29udGludWUuXG4gICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnOycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzRCAoPSkuKVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgIH1cblxuICAgIC8vIDYuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDcuIExldCBwYXJhbWV0ZXJWYWx1ZSBiZSBudWxsLlxuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZSA9IG51bGxcblxuICAgIC8vIDguIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgIC8vIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvblxuICAgICAgLy8gYW5kIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCB0cnVlKVxuXG4gICAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAgIC8vIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgICAgLy8gMi4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBwYXJhbWV0ZXJWYWx1ZS5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UocGFyYW1ldGVyVmFsdWUsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAvLyAzLiBJZiBwYXJhbWV0ZXJWYWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBzb2xlbHkgY29udGFpbnMgSFRUUCB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gcGFyYW1ldGVyVmFsdWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgcXVvdGVkLXN0cmluZyB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gZG9lcyBub3QgZXhpc3RcbiAgICAvLyB0aGVuIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSB0byBwYXJhbWV0ZXJWYWx1ZS5cbiAgICBpZiAoXG4gICAgICBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QocGFyYW1ldGVyTmFtZSkgJiZcbiAgICAgIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDAgfHwgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUy50ZXN0KHBhcmFtZXRlclZhbHVlKSkgJiZcbiAgICAgICFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcyhwYXJhbWV0ZXJOYW1lKVxuICAgICkge1xuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWFuLWh0dHAtcXVvdGVkLXN0cmluZ1xuLy8gdGVzdHM6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLWh0dHAtcXVvdGVkLXN0cmluZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleHRyYWN0VmFsdWU9ZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcgKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHBvc2l0aW9uU3RhcnQgYmUgcG9zaXRpb24uXG4gIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDMuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0XG4gIC8vIGlzIFUrMDAyMiAoXCIpLlxuICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKVxuXG4gIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzXG4gICAgLy8gdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpIG9yIFUrMDA1QyAoXFwpIGZyb20gaW5wdXQsIGdpdmVuXG4gICAgLy8gcG9zaXRpb24sIHRvIHZhbHVlLlxuICAgIHZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnXFxcXCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHF1b3RlT3JCYWNrc2xhc2ggYmUgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluXG4gICAgLy8gaW5wdXQuXG4gICAgY29uc3QgcXVvdGVPckJhY2tzbGFzaCA9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDUuIElmIHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDVDIChcXCksIHRoZW46XG4gICAgaWYgKHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcXFxcJykge1xuICAgICAgLy8gMS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGFwcGVuZFxuICAgICAgLy8gVSswMDVDIChcXCkgdG8gdmFsdWUgYW5kIGJyZWFrLlxuICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgICAvLyAzLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA2LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIEFzc2VydDogcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwMjIgKFwiKS5cbiAgICAgIGFzc2VydChxdW90ZU9yQmFja3NsYXNoID09PSAnXCInKVxuXG4gICAgICAvLyAyLiBCcmVhay5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZyBpcyBzZXQsIHRoZW4gcmV0dXJuIHZhbHVlLlxuICBpZiAoZXh0cmFjdFZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdGhlIGNvZGUgcG9pbnRzIGZyb20gcG9zaXRpb25TdGFydCB0byBwb3NpdGlvbixcbiAgLy8gaW5jbHVzaXZlLCB3aXRoaW4gaW5wdXQuXG4gIHJldHVybiBpbnB1dC5zbGljZShwb3NpdGlvblN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtbWltZS10eXBlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScpXG4gIGNvbnN0IHsgcGFyYW1ldGVycywgZXNzZW5jZSB9ID0gbWltZVR5cGVcblxuICAvLyAxLiBMZXQgc2VyaWFsaXphdGlvbiBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBtaW1lVHlwZeKAmXNcbiAgLy8gICAgdHlwZSwgVSswMDJGICgvKSwgYW5kIG1pbWVUeXBl4oCZcyBzdWJ0eXBlLlxuICBsZXQgc2VyaWFsaXphdGlvbiA9IGVzc2VuY2VcblxuICAvLyAyLiBGb3IgZWFjaCBuYW1lIOKGkiB2YWx1ZSBvZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyczpcbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzLmVudHJpZXMoKSkge1xuICAgIC8vIDEuIEFwcGVuZCBVKzAwM0IgKDspIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnOydcblxuICAgIC8vIDIuIEFwcGVuZCBuYW1lIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSBuYW1lXG5cbiAgICAvLyAzLiBBcHBlbmQgVSswMDNEICg9KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJz0nXG5cbiAgICAvLyA0LiBJZiB2YWx1ZSBkb2VzIG5vdCBzb2xlbHkgY29udGFpbiBIVFRQIHRva2VuIGNvZGVcbiAgICAvLyAgICBwb2ludHMgb3IgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHZhbHVlKSkge1xuICAgICAgLy8gMS4gUHJlY2VkZSBlYWNoIG9jY3VycmVuY2Ugb2YgVSswMDIyIChcIikgb3JcbiAgICAgIC8vICAgIFUrMDA1QyAoXFwpIGluIHZhbHVlIHdpdGggVSswMDVDIChcXCkuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1tcXFxcXCJdL3VnLCAnXFxcXCQmJylcblxuICAgICAgLy8gMi4gUHJlcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlXG5cbiAgICAgIC8vIDMuIEFwcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9ICdcIidcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgdmFsdWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IHZhbHVlXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gc2VyaWFsaXphdGlvbi5cbiAgcmV0dXJuIHNlcmlhbGl6YXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2UgKGNoYXIpIHtcbiAgLy8gXCJcXHJcXG5cXHQgXCJcbiAgcmV0dXJuIGNoYXIgPT09IDB4MDBkIHx8IGNoYXIgPT09IDB4MDBhIHx8IGNoYXIgPT09IDB4MDA5IHx8IGNoYXIgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsZWFkaW5nPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFpbGluZz10cnVlXVxuICovXG5mdW5jdGlvbiByZW1vdmVIVFRQV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIHJldHVybiByZW1vdmVDaGFycyhzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBpc0hUVFBXaGl0ZVNwYWNlKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW5pbWl6ZS1hLXN1cHBvcnRlZC1taW1lLXR5cGVcbiAqIEBwYXJhbSB7RXhjbHVkZTxSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZU1JTUVUeXBlPiwgJ2ZhaWx1cmUnPn0gbWltZVR5cGVcbiAqL1xuZnVuY3Rpb24gbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgc3dpdGNoIChtaW1lVHlwZS5lc3NlbmNlKSB7XG4gICAgY2FzZSAnYXBwbGljYXRpb24vZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veC1lY21hc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94LWphdmFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjAnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMSc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4yJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjMnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuNCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS41JzpcbiAgICBjYXNlICd0ZXh0L2pzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvbGl2ZXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC94LWVjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQveC1qYXZhc2NyaXB0JzpcbiAgICAgIC8vIDEuIElmIG1pbWVUeXBlIGlzIGEgSmF2YVNjcmlwdCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwidGV4dC9qYXZhc2NyaXB0XCIuXG4gICAgICByZXR1cm4gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICBjYXNlICd0ZXh0L2pzb24nOlxuICAgICAgLy8gMi4gSWYgbWltZVR5cGUgaXMgYSBKU09OIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi9qc29uXCIuXG4gICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgY2FzZSAnaW1hZ2Uvc3ZnK3htbCc6XG4gICAgICAvLyAzLiBJZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcImltYWdlL3N2Zyt4bWxcIiwgdGhlbiByZXR1cm4gXCJpbWFnZS9zdmcreG1sXCIuXG4gICAgICByZXR1cm4gJ2ltYWdlL3N2Zyt4bWwnXG4gICAgY2FzZSAndGV4dC94bWwnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3htbCc6XG4gICAgICAvLyA0LiBJZiBtaW1lVHlwZSBpcyBhbiBYTUwgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL3htbFwiLlxuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnXG4gIH1cblxuICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBhIEpTT04gTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIi5cbiAgaWYgKG1pbWVUeXBlLnN1YnR5cGUuZW5kc1dpdGgoJytqc29uJykpIHtcbiAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH1cblxuICAvLyA0LiBJZiBtaW1lVHlwZSBpcyBhbiBYTUwgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL3htbFwiLlxuICBpZiAobWltZVR5cGUuc3VidHlwZS5lbmRzV2l0aCgnK3htbCcpKSB7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnXG4gIH1cblxuICAvLyA1LiBJZiBtaW1lVHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIgYWdlbnQsIHRoZW4gcmV0dXJuIG1pbWVUeXBl4oCZcyBlc3NlbmNlLlxuICAvLyBUZWNobmljYWxseSwgbm9kZSBkb2Vzbid0IHN1cHBvcnQgYW55IG1pbWV0eXBlcy5cblxuICAvLyA2LiBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgcmV0dXJuICcnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXRhVVJMUHJvY2Vzc29yLFxuICBVUkxTZXJpYWxpemVyLFxuICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICBwYXJzZU1JTUVUeXBlLFxuICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLFxuICBzZXJpYWxpemVBTWltZVR5cGUsXG4gIHJlbW92ZUhUVFBXaGl0ZXNwYWNlLFxuICBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlLFxuICBIVFRQX1RPS0VOX0NPREVQT0lOVFNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { HTTP_TOKEN_CODEPOINTS } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isomorphicDecode } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ../../encoding */ \"(rsc)/./node_modules/undici/lib/encoding/index.js\")\n\nconst dd = Buffer.from('--')\nconst decoder = new TextDecoder()\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeTypes essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeTypes parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeTypes\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    throw parsingError('missing boundary in content-type header')\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: Per RFC 2046 Section 5.1.1, we must ignore anything before the\n  // first boundary delimiter line (preamble). Search for the first boundary.\n  const firstBoundaryIndex = input.indexOf(boundary)\n\n  if (firstBoundaryIndex === -1) {\n    throw parsingError('no boundary found in multipart body')\n  }\n\n  // Start parsing from the first boundary, ignoring any preamble\n  position.position = firstBoundaryIndex\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      throw parsingError('expected a value starting with -- and the boundary')\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: Per RFC 2046 Section 5.1.1, we must ignore anything after the\n    // final boundary delimiter (epilogue). Check for -- or --CRLF and return\n    // regardless of what follows.\n    if (bufferStartsWith(input, dd, position)) {\n      // Found closing boundary delimiter (--), ignore any epilogue\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        throw parsingError('expected boundary after body')\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(webidl.is.USVString(name))\n    assert((typeof value === 'string' && webidl.is.USVString(value)) || webidl.is.File(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * Parses content-disposition attributes (e.g., name=\"value\" or filename*=utf-8''encoded)\n * @param {Buffer} input\n * @param {{ position: number }} position\n * @returns {{ name: string, value: string }}\n */\nfunction parseContentDispositionAttribute (input, position) {\n  // Skip leading semicolon and whitespace\n  if (input[position.position] === 0x3b /* ; */) {\n    position.position++\n  }\n\n  // Skip whitespace\n  collectASequenceOfBytes(\n    (char) => char === 0x20 || char === 0x09,\n    input,\n    position\n  )\n\n  // Collect attribute name (token characters)\n  const attributeName = collectASequenceOfBytes(\n    (char) => isToken(char) && char !== 0x3d && char !== 0x2a, // not = or *\n    input,\n    position\n  )\n\n  if (attributeName.length === 0) {\n    return null\n  }\n\n  const attrNameStr = attributeName.toString('ascii').toLowerCase()\n\n  // Check for extended notation (attribute*)\n  const isExtended = input[position.position] === 0x2a /* * */\n  if (isExtended) {\n    position.position++ // skip *\n  }\n\n  // Expect = sign\n  if (input[position.position] !== 0x3d /* = */) {\n    return null\n  }\n  position.position++ // skip =\n\n  // Skip whitespace\n  collectASequenceOfBytes(\n    (char) => char === 0x20 || char === 0x09,\n    input,\n    position\n  )\n\n  let value\n\n  if (isExtended) {\n    // Extended attribute format: charset'language'encoded-value\n    const headerValue = collectASequenceOfBytes(\n      (char) => char !== 0x20 && char !== 0x0d && char !== 0x0a && char !== 0x3b, // not space, CRLF, or ;\n      input,\n      position\n    )\n\n    // Check for utf-8'' prefix (case insensitive)\n    if (\n      (headerValue[0] !== 0x75 && headerValue[0] !== 0x55) || // u or U\n      (headerValue[1] !== 0x74 && headerValue[1] !== 0x54) || // t or T\n      (headerValue[2] !== 0x66 && headerValue[2] !== 0x46) || // f or F\n      headerValue[3] !== 0x2d || // -\n      headerValue[4] !== 0x38 // 8\n    ) {\n      throw parsingError('unknown encoding, expected utf-8\\'\\'')\n    }\n\n    // Skip utf-8'' and decode the rest\n    value = decodeURIComponent(decoder.decode(headerValue.subarray(7)))\n  } else if (input[position.position] === 0x22 /* \" */) {\n    // Quoted string\n    position.position++ // skip opening quote\n\n    const quotedValue = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x22, // not LF, CR, or \"\n      input,\n      position\n    )\n\n    if (input[position.position] !== 0x22) {\n      throw parsingError('Closing quote not found')\n    }\n    position.position++ // skip closing quote\n\n    value = decoder.decode(quotedValue)\n      .replace(/%0A/ig, '\\n')\n      .replace(/%0D/ig, '\\r')\n      .replace(/%22/g, '\"')\n  } else {\n    // Token value (no quotes)\n    const tokenValue = collectASequenceOfBytes(\n      (char) => isToken(char) && char !== 0x3b, // not ;\n      input,\n      position\n    )\n\n    value = decoder.decode(tokenValue)\n  }\n\n  return { name: attrNameStr, value }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        throw parsingError('header name is null')\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      throw parsingError('header name does not match the field-name token production')\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      throw parsingError('expected :')\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        name = filename = null\n\n        // Collect the disposition type (should be \"form-data\")\n        const dispositionType = collectASequenceOfBytes(\n          (char) => isToken(char),\n          input,\n          position\n        )\n\n        if (dispositionType.toString('ascii').toLowerCase() !== 'form-data') {\n          throw parsingError('expected form-data for content-disposition header')\n        }\n\n        // Parse attributes recursively until CRLF\n        while (\n          position.position < input.length &&\n          input[position.position] !== 0x0d &&\n          input[position.position + 1] !== 0x0a\n        ) {\n          const attribute = parseContentDispositionAttribute(input, position)\n\n          if (!attribute) {\n            break\n          }\n\n          if (attribute.name === 'name') {\n            name = attribute.value\n          } else if (attribute.name === 'filename') {\n            filename = attribute.value\n          }\n        }\n\n        if (name === null) {\n          throw parsingError('name attribute is required in content-disposition header')\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction parsingError (cause) {\n  return new TypeError('Failed to parse body as FormData.', { cause: new TypeError(cause) })\n}\n\n/**\n * CTL            = <any US-ASCII control character\n *                  (octets 0 - 31) and DEL (127)>\n * @param {number} char\n */\nfunction isCTL (char) {\n  return char <= 0x1f || char === 0x7f\n}\n\n/**\n * tspecials :=  \"(\" / \")\" / \"<\" / \">\" / \"@\" /\n *                \",\" / \";\" / \":\" / \"\\\" / <\">\n *                \"/\" / \"[\" / \"]\" / \"?\" / \"=\"\n *                ; Must be in quoted-string,\n *                ; to use within parameter values\n * @param {number} char\n */\nfunction isTSpecial (char) {\n  return (\n    char === 0x28 || // (\n    char === 0x29 || // )\n    char === 0x3c || // <\n    char === 0x3e || // >\n    char === 0x40 || // @\n    char === 0x2c || // ,\n    char === 0x3b || // ;\n    char === 0x3a || // :\n    char === 0x5c || // \\\n    char === 0x22 || // \"\n    char === 0x2f || // /\n    char === 0x5b || // [\n    char === 0x5d || // ]\n    char === 0x3f || // ?\n    char === 0x3d    // +\n  )\n}\n\n/**\n * token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,\n *          or tspecials>\n * @param {number} char\n */\nfunction isToken (char) {\n  return (\n    char <= 0x7f &&  // ascii\n    char !== 0x20 && // space\n    char !== 0x09 &&\n    !isCTL(char) &&\n    !isTSpecial(char)\n  )\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDbEUsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQ3RELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDMUMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQy9DLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBZ0I7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbURBQW1EO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsZUFBZTs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7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YTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZSxhQUFhO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsNkJBQTZCO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmb3JtZGF0YS1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgSFRUUF9UT0tFTl9DT0RFUE9JTlRTIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgbWFrZUVudHJ5IH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBpc29tb3JwaGljRGVjb2RlIH0gPSByZXF1aXJlKCcuLi9pbmZyYScpXG5jb25zdCB7IHV0ZjhEZWNvZGVCeXRlcyB9ID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcnKVxuXG5jb25zdCBkZCA9IEJ1ZmZlci5mcm9tKCctLScpXG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNcbiAqL1xuZnVuY3Rpb24gaXNBc2NpaVN0cmluZyAoY2hhcnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7ICsraSkge1xuICAgIGlmICgoY2hhcnMuY2hhckNvZGVBdChpKSAmIH4weDdGKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI211bHRpcGFydC1mb3JtLWRhdGEtYm91bmRhcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJvdW5kYXJ5IChib3VuZGFyeSkge1xuICBjb25zdCBsZW5ndGggPSBib3VuZGFyeS5sZW5ndGhcblxuICAvLyAtIGl0cyBsZW5ndGggaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyNyBhbmQgbGVzc2VyIG9yIGVxdWFsIHRvIDcwLCBhbmRcbiAgaWYgKGxlbmd0aCA8IDI3IHx8IGxlbmd0aCA+IDcwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtIGl0IGlzIGNvbXBvc2VkIGJ5IGJ5dGVzIGluIHRoZSByYW5nZXMgMHgzMCB0byAweDM5LCAweDQxIHRvIDB4NUEsIG9yXG4gIC8vICAgMHg2MSB0byAweDdBLCBpbmNsdXNpdmUgKEFTQ0lJIGFscGhhbnVtZXJpYyksIG9yIHdoaWNoIGFyZSAweDI3ICgnKSxcbiAgLy8gICAweDJEICgtKSBvciAweDVGIChfKS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNwID0gYm91bmRhcnkuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKCEoXG4gICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxuICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1YSkgfHxcbiAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N2EpIHx8XG4gICAgICBjcCA9PT0gMHgyNyB8fFxuICAgICAgY3AgPT09IDB4MmQgfHxcbiAgICAgIGNwID09PSAweDVmXG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jbXVsdGlwYXJ0LWZvcm0tZGF0YS1wYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHtSZXR1cm5UeXBlPGltcG9ydCgnLi9kYXRhLXVybCcpWydwYXJzZU1JTUVUeXBlJ10+fSBtaW1lVHlwZVxuICovXG5mdW5jdGlvbiBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciAoaW5wdXQsIG1pbWVUeXBlKSB7XG4gIC8vIDEuIEFzc2VydDogbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIuXG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlLmVzc2VuY2UgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJylcblxuICBjb25zdCBib3VuZGFyeVN0cmluZyA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdib3VuZGFyeScpXG5cbiAgLy8gMi4gSWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIGZhaWx1cmUuXG4gIC8vICAgIE90aGVyd2lzZSwgbGV0IGJvdW5kYXJ5IGJlIHRoZSByZXN1bHQgb2YgVVRGLTggZGVjb2RpbmcgbWltZVR5cGXigJlzXG4gIC8vICAgIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXS5cbiAgaWYgKGJvdW5kYXJ5U3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ21pc3NpbmcgYm91bmRhcnkgaW4gY29udGVudC10eXBlIGhlYWRlcicpXG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IEJ1ZmZlci5mcm9tKGAtLSR7Ym91bmRhcnlTdHJpbmd9YCwgJ3V0ZjgnKVxuXG4gIC8vIDMuIExldCBlbnRyeSBsaXN0IGJlIGFuIGVtcHR5IGVudHJ5IGxpc3QuXG4gIGNvbnN0IGVudHJ5TGlzdCA9IFtdXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciB0byBhIGJ5dGUgaW4gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdFxuICAvLyAgICB0aGUgZmlyc3QgYnl0ZS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyBOb3RlOiBQZXIgUkZDIDIwNDYgU2VjdGlvbiA1LjEuMSwgd2UgbXVzdCBpZ25vcmUgYW55dGhpbmcgYmVmb3JlIHRoZVxuICAvLyBmaXJzdCBib3VuZGFyeSBkZWxpbWl0ZXIgbGluZSAocHJlYW1ibGUpLiBTZWFyY2ggZm9yIHRoZSBmaXJzdCBib3VuZGFyeS5cbiAgY29uc3QgZmlyc3RCb3VuZGFyeUluZGV4ID0gaW5wdXQuaW5kZXhPZihib3VuZGFyeSlcblxuICBpZiAoZmlyc3RCb3VuZGFyeUluZGV4ID09PSAtMSkge1xuICAgIHRocm93IHBhcnNpbmdFcnJvcignbm8gYm91bmRhcnkgZm91bmQgaW4gbXVsdGlwYXJ0IGJvZHknKVxuICB9XG5cbiAgLy8gU3RhcnQgcGFyc2luZyBmcm9tIHRoZSBmaXJzdCBib3VuZGFyeSwgaWdub3JpbmcgYW55IHByZWFtYmxlXG4gIHBvc2l0aW9uLnBvc2l0aW9uID0gZmlyc3RCb3VuZGFyeUluZGV4XG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyA1LjEuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgyRCAweDJEXG4gICAgLy8gICAgICAoYC0tYCkgZm9sbG93ZWQgYnkgYm91bmRhcnksIGFkdmFuY2UgcG9zaXRpb24gYnkgMiArIHRoZSBsZW5ndGggb2ZcbiAgICAvLyAgICAgIGJvdW5kYXJ5LiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgIC8vIE5vdGU6IGJvdW5kYXJ5IGlzIHBhZGRlZCB3aXRoIDIgZGFzaGVzIGFscmVhZHksIG5vIG5lZWQgdG8gYWRkIDIuXG4gICAgaWYgKGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBwb3NpdGlvbi5wb3NpdGlvbiArIGJvdW5kYXJ5Lmxlbmd0aCkuZXF1YWxzKGJvdW5kYXJ5KSkge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm91bmRhcnkubGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHBhcnNpbmdFcnJvcignZXhwZWN0ZWQgYSB2YWx1ZSBzdGFydGluZyB3aXRoIC0tIGFuZCB0aGUgYm91bmRhcnknKVxuICAgIH1cblxuICAgIC8vIDUuMi4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyAweDJEIDB4MkQgMHgwRCAweDBBXG4gICAgLy8gICAgICAoYC0tYCBmb2xsb3dlZCBieSBDUiBMRikgZm9sbG93ZWQgYnkgdGhlIGVuZCBvZiBpbnB1dCwgcmV0dXJuIGVudHJ5IGxpc3QuXG4gICAgLy8gTm90ZTogUGVyIFJGQyAyMDQ2IFNlY3Rpb24gNS4xLjEsIHdlIG11c3QgaWdub3JlIGFueXRoaW5nIGFmdGVyIHRoZVxuICAgIC8vIGZpbmFsIGJvdW5kYXJ5IGRlbGltaXRlciAoZXBpbG9ndWUpLiBDaGVjayBmb3IgLS0gb3IgLS1DUkxGIGFuZCByZXR1cm5cbiAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgZm9sbG93cy5cbiAgICBpZiAoYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGQsIHBvc2l0aW9uKSkge1xuICAgICAgLy8gRm91bmQgY2xvc2luZyBib3VuZGFyeSBkZWxpbWl0ZXIgKC0tKSwgaWdub3JlIGFueSBlcGlsb2d1ZVxuICAgICAgcmV0dXJuIGVudHJ5TGlzdFxuICAgIH1cblxuICAgIC8vIDUuMy4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoIDB4MERcbiAgICAvLyAgICAgIDB4MEEgKENSIExGKSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCB8fCBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIENSTEYnKVxuICAgIH1cblxuICAgIC8vIDUuNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBuZXdsaW5lLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG5cbiAgICAvLyA1LjUuIExldCBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gICAgLy8gICAgICBtdWx0aXBhcnQvZm9ybS1kYXRhIGhlYWRlcnMgb24gaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0XG4gICAgLy8gICAgICBpcyBub3QgZmFpbHVyZS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyhpbnB1dCwgcG9zaXRpb24pXG5cbiAgICBsZXQgeyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH0gPSByZXN1bHRcblxuICAgIC8vIDUuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBlbXB0eSBsaW5lIHRoYXQgbWFya3NcbiAgICAvLyAgICAgIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnMuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcblxuICAgIC8vIDUuNy4gTGV0IGJvZHkgYmUgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gICAgbGV0IGJvZHlcblxuICAgIC8vIDUuOC4gQm9keSBsb29wOiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICAgIC8vIFRPRE86IHRoZSBzdGVwcyBoZXJlIGFyZSBjb21wbGV0ZWx5IHdyb25nXG4gICAge1xuICAgICAgY29uc3QgYm91bmRhcnlJbmRleCA9IGlucHV0LmluZGV4T2YoYm91bmRhcnkuc3ViYXJyYXkoMiksIHBvc2l0aW9uLnBvc2l0aW9uKVxuXG4gICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBib3VuZGFyeSBhZnRlciBib2R5JylcbiAgICAgIH1cblxuICAgICAgYm9keSA9IGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBib3VuZGFyeUluZGV4IC0gNClcblxuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm9keS5sZW5ndGhcblxuICAgICAgLy8gTm90ZTogcG9zaXRpb24gbXVzdCBiZSBhZHZhbmNlZCBieSB0aGUgYm9keSdzIGxlbmd0aCBiZWZvcmUgYmVpbmdcbiAgICAgIC8vIGRlY29kZWQsIG90aGVyd2lzZSB0aGUgcGFyc2luZyB3aWxsIGZhaWwuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCksICdiYXNlNjQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuOS4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoXG4gICAgLy8gICAgICAweDBEIDB4MEEgKENSIExGKSwgcmV0dXJuIGZhaWx1cmUuIE90aGVyd2lzZSwgYWR2YW5jZSBwb3NpdGlvbiBieSAyLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgfHwgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBDUkxGJylcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICAgIH1cblxuICAgIC8vIDUuMTAuIElmIGZpbGVuYW1lIGlzIG5vdCBudWxsOlxuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKGZpbGVuYW1lICE9PSBudWxsKSB7XG4gICAgICAvLyA1LjEwLjEuIElmIGNvbnRlbnRUeXBlIGlzIG51bGwsIHNldCBjb250ZW50VHlwZSB0byBcInRleHQvcGxhaW5cIi5cbiAgICAgIGNvbnRlbnRUeXBlID8/PSAndGV4dC9wbGFpbidcblxuICAgICAgLy8gNS4xMC4yLiBJZiBjb250ZW50VHlwZSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nLCBzZXQgY29udGVudFR5cGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgICAgLy8gTm90ZTogYGJ1ZmZlci5pc0FzY2lpYCBjYW4gYmUgdXNlZCBhdCB6ZXJvLWNvc3QsIGJ1dCBjb252ZXJ0aW5nIGEgc3RyaW5nIHRvIGEgYnVmZmVyIGlzIGEgaGlnaCBvdmVyaGVhZC5cbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBhIHJlbGF0aXZlbHkgc21hbGwgc3RyaW5nLCBzbyBpdCBpcyBmYXN0ZXIgdG8gdXNlIGBTdHJpbmcjY2hhckNvZGVBdGAuXG4gICAgICBpZiAoIWlzQXNjaWlTdHJpbmcoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGNvbnRlbnRUeXBlID0gJydcbiAgICAgIH1cblxuICAgICAgLy8gNS4xMC4zLiBMZXQgdmFsdWUgYmUgYSBuZXcgRmlsZSBvYmplY3Qgd2l0aCBuYW1lIGZpbGVuYW1lLCB0eXBlIGNvbnRlbnRUeXBlLCBhbmQgYm9keSBib2R5LlxuICAgICAgdmFsdWUgPSBuZXcgRmlsZShbYm9keV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDUuMTEuIE90aGVyd2lzZTpcblxuICAgICAgLy8gNS4xMS4xLiBMZXQgdmFsdWUgYmUgdGhlIFVURi04IGRlY29kaW5nIHdpdGhvdXQgQk9NIG9mIGJvZHkuXG4gICAgICB2YWx1ZSA9IHV0ZjhEZWNvZGVCeXRlcyhCdWZmZXIuZnJvbShib2R5KSlcbiAgICB9XG5cbiAgICAvLyA1LjEyLiBBc3NlcnQ6IG5hbWUgaXMgYSBzY2FsYXIgdmFsdWUgc3RyaW5nIGFuZCB2YWx1ZSBpcyBlaXRoZXIgYSBzY2FsYXIgdmFsdWUgc3RyaW5nIG9yIGEgRmlsZSBvYmplY3QuXG4gICAgYXNzZXJ0KHdlYmlkbC5pcy5VU1ZTdHJpbmcobmFtZSkpXG4gICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHdlYmlkbC5pcy5VU1ZTdHJpbmcodmFsdWUpKSB8fCB3ZWJpZGwuaXMuRmlsZSh2YWx1ZSkpXG5cbiAgICAvLyA1LjEzLiBDcmVhdGUgYW4gZW50cnkgd2l0aCBuYW1lIGFuZCB2YWx1ZSwgYW5kIGFwcGVuZCBpdCB0byBlbnRyeSBsaXN0LlxuICAgIGVudHJ5TGlzdC5wdXNoKG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIGNvbnRlbnQtZGlzcG9zaXRpb24gYXR0cmlidXRlcyAoZS5nLiwgbmFtZT1cInZhbHVlXCIgb3IgZmlsZW5hbWUqPXV0Zi04JydlbmNvZGVkKVxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICogQHJldHVybnMge3sgbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIH19XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29udGVudERpc3Bvc2l0aW9uQXR0cmlidXRlIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gU2tpcCBsZWFkaW5nIHNlbWljb2xvbiBhbmQgd2hpdGVzcGFjZVxuICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDNiIC8qIDsgKi8pIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyBTa2lwIHdoaXRlc3BhY2VcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgKGNoYXIpID0+IGNoYXIgPT09IDB4MjAgfHwgY2hhciA9PT0gMHgwOSxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gQ29sbGVjdCBhdHRyaWJ1dGUgbmFtZSAodG9rZW4gY2hhcmFjdGVycylcbiAgY29uc3QgYXR0cmlidXRlTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgIChjaGFyKSA9PiBpc1Rva2VuKGNoYXIpICYmIGNoYXIgIT09IDB4M2QgJiYgY2hhciAhPT0gMHgyYSwgLy8gbm90ID0gb3IgKlxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICBpZiAoYXR0cmlidXRlTmFtZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgYXR0ck5hbWVTdHIgPSBhdHRyaWJ1dGVOYW1lLnRvU3RyaW5nKCdhc2NpaScpLnRvTG93ZXJDYXNlKClcblxuICAvLyBDaGVjayBmb3IgZXh0ZW5kZWQgbm90YXRpb24gKGF0dHJpYnV0ZSopXG4gIGNvbnN0IGlzRXh0ZW5kZWQgPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09IDB4MmEgLyogKiAqL1xuICBpZiAoaXNFeHRlbmRlZCkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uKysgLy8gc2tpcCAqXG4gIH1cblxuICAvLyBFeHBlY3QgPSBzaWduXG4gIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4M2QgLyogPSAqLykge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcG9zaXRpb24ucG9zaXRpb24rKyAvLyBza2lwID1cblxuICAvLyBTa2lwIHdoaXRlc3BhY2VcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgKGNoYXIpID0+IGNoYXIgPT09IDB4MjAgfHwgY2hhciA9PT0gMHgwOSxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgbGV0IHZhbHVlXG5cbiAgaWYgKGlzRXh0ZW5kZWQpIHtcbiAgICAvLyBFeHRlbmRlZCBhdHRyaWJ1dGUgZm9ybWF0OiBjaGFyc2V0J2xhbmd1YWdlJ2VuY29kZWQtdmFsdWVcbiAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MjAgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4M2IsIC8vIG5vdCBzcGFjZSwgQ1JMRiwgb3IgO1xuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIENoZWNrIGZvciB1dGYtOCcnIHByZWZpeCAoY2FzZSBpbnNlbnNpdGl2ZSlcbiAgICBpZiAoXG4gICAgICAoaGVhZGVyVmFsdWVbMF0gIT09IDB4NzUgJiYgaGVhZGVyVmFsdWVbMF0gIT09IDB4NTUpIHx8IC8vIHUgb3IgVVxuICAgICAgKGhlYWRlclZhbHVlWzFdICE9PSAweDc0ICYmIGhlYWRlclZhbHVlWzFdICE9PSAweDU0KSB8fCAvLyB0IG9yIFRcbiAgICAgIChoZWFkZXJWYWx1ZVsyXSAhPT0gMHg2NiAmJiBoZWFkZXJWYWx1ZVsyXSAhPT0gMHg0NikgfHwgLy8gZiBvciBGXG4gICAgICBoZWFkZXJWYWx1ZVszXSAhPT0gMHgyZCB8fCAvLyAtXG4gICAgICBoZWFkZXJWYWx1ZVs0XSAhPT0gMHgzOCAvLyA4XG4gICAgKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ3Vua25vd24gZW5jb2RpbmcsIGV4cGVjdGVkIHV0Zi04XFwnXFwnJylcbiAgICB9XG5cbiAgICAvLyBTa2lwIHV0Zi04JycgYW5kIGRlY29kZSB0aGUgcmVzdFxuICAgIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZXIuZGVjb2RlKGhlYWRlclZhbHVlLnN1YmFycmF5KDcpKSlcbiAgfSBlbHNlIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09IDB4MjIgLyogXCIgKi8pIHtcbiAgICAvLyBRdW90ZWQgc3RyaW5nXG4gICAgcG9zaXRpb24ucG9zaXRpb24rKyAvLyBza2lwIG9wZW5pbmcgcXVvdGVcblxuICAgIGNvbnN0IHF1b3RlZFZhbHVlID0gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4MjIsIC8vIG5vdCBMRiwgQ1IsIG9yIFwiXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgyMikge1xuICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdDbG9zaW5nIHF1b3RlIG5vdCBmb3VuZCcpXG4gICAgfVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKysgLy8gc2tpcCBjbG9zaW5nIHF1b3RlXG5cbiAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKHF1b3RlZFZhbHVlKVxuICAgICAgLnJlcGxhY2UoLyUwQS9pZywgJ1xcbicpXG4gICAgICAucmVwbGFjZSgvJTBEL2lnLCAnXFxyJylcbiAgICAgIC5yZXBsYWNlKC8lMjIvZywgJ1wiJylcbiAgfSBlbHNlIHtcbiAgICAvLyBUb2tlbiB2YWx1ZSAobm8gcXVvdGVzKVxuICAgIGNvbnN0IHRva2VuVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgIChjaGFyKSA9PiBpc1Rva2VuKGNoYXIpICYmIGNoYXIgIT09IDB4M2IsIC8vIG5vdCA7XG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZSh0b2tlblZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHsgbmFtZTogYXR0ck5hbWVTdHIsIHZhbHVlIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtbXVsdGlwYXJ0LWZvcm0tZGF0YS1oZWFkZXJzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFIZWFkZXJzIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZSBiZSBudWxsLlxuICBsZXQgbmFtZSA9IG51bGxcbiAgbGV0IGZpbGVuYW1lID0gbnVsbFxuICBsZXQgY29udGVudFR5cGUgPSBudWxsXG4gIGxldCBlbmNvZGluZyA9IG51bGxcblxuICAvLyAyLiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDIuMS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEEgKENSIExGKTpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDBkICYmIGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gPT09IDB4MGEpIHtcbiAgICAgIC8vIDIuMS4xLiBJZiBuYW1lIGlzIG51bGwsIHJldHVybiBmYWlsdXJlLlxuICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdoZWFkZXIgbmFtZSBpcyBudWxsJylcbiAgICAgIH1cblxuICAgICAgLy8gMi4xLjIuIFJldHVybiBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUuXG4gICAgICByZXR1cm4geyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH1cbiAgICB9XG5cbiAgICAvLyAyLjIuIExldCBoZWFkZXIgbmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgIC8vICAgICAgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4M0EgKDopLCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgaGVhZGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDNhLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuMy4gUmVtb3ZlIGFueSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBmcm9tIHRoZSBzdGFydCBvciBlbmQgb2YgaGVhZGVyIG5hbWUuXG4gICAgaGVhZGVyTmFtZSA9IHJlbW92ZUNoYXJzKGhlYWRlck5hbWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDIuNC4gSWYgaGVhZGVyIG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGZpZWxkLW5hbWUgdG9rZW4gcHJvZHVjdGlvbiwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChoZWFkZXJOYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2hlYWRlciBuYW1lIGRvZXMgbm90IG1hdGNoIHRoZSBmaWVsZC1uYW1lIHRva2VuIHByb2R1Y3Rpb24nKVxuICAgIH1cblxuICAgIC8vIDIuNS4gSWYgdGhlIGJ5dGUgYXQgcG9zaXRpb24gaXMgbm90IDB4M0EgKDopLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDNhKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIDonKVxuICAgIH1cblxuICAgIC8vIDIuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuNy4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vICAgICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gMHgyMCB8fCBjaGFyID09PSAweDA5LFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuOC4gQnl0ZS1sb3dlcmNhc2UgaGVhZGVyIG5hbWUgYW5kIHN3aXRjaCBvbiB0aGUgcmVzdWx0OlxuICAgIHN3aXRjaCAoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShoZWFkZXJOYW1lKSkge1xuICAgICAgY2FzZSAnY29udGVudC1kaXNwb3NpdGlvbic6IHtcbiAgICAgICAgbmFtZSA9IGZpbGVuYW1lID0gbnVsbFxuXG4gICAgICAgIC8vIENvbGxlY3QgdGhlIGRpc3Bvc2l0aW9uIHR5cGUgKHNob3VsZCBiZSBcImZvcm0tZGF0YVwiKVxuICAgICAgICBjb25zdCBkaXNwb3NpdGlvblR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gaXNUb2tlbihjaGFyKSxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGRpc3Bvc2l0aW9uVHlwZS50b1N0cmluZygnYXNjaWknKS50b0xvd2VyQ2FzZSgpICE9PSAnZm9ybS1kYXRhJykge1xuICAgICAgICAgIHRocm93IHBhcnNpbmdFcnJvcignZXhwZWN0ZWQgZm9ybS1kYXRhIGZvciBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBhdHRyaWJ1dGVzIHJlY3Vyc2l2ZWx5IHVudGlsIENSTEZcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDBkICYmXG4gICAgICAgICAgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBwYXJzZUNvbnRlbnREaXNwb3NpdGlvbkF0dHJpYnV0ZShpbnB1dCwgcG9zaXRpb24pXG5cbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUgPT09ICduYW1lJykge1xuICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLm5hbWUgPT09ICdmaWxlbmFtZScpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYXR0cmlidXRlLnZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ25hbWUgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGluIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyJylcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXR5cGUnOiB7XG4gICAgICAgIC8vIDEuIExldCBoZWFkZXIgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gICAgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyAyLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBoZWFkZXIgdmFsdWUuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgLy8gMy4gU2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgY29udGVudFR5cGUgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJzoge1xuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICBoZWFkZXJWYWx1ZSA9IHJlbW92ZUNoYXJzKGhlYWRlclZhbHVlLCBmYWxzZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgICAgIGVuY29kaW5nID0gaXNvbW9ycGhpY0RlY29kZShoZWFkZXJWYWx1ZSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICAvLyAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBXG4gICAgLy8gICAgICAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKHBhc3QgdGhlIG5ld2xpbmUpLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBDUkxGJylcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IG51bWJlcikgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICBsZXQgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIHdoaWxlIChzdGFydCA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbc3RhcnRdKSkge1xuICAgICsrc3RhcnRcbiAgfVxuXG4gIHJldHVybiBpbnB1dC5zdWJhcnJheShwb3NpdGlvbi5wb3NpdGlvbiwgKHBvc2l0aW9uLnBvc2l0aW9uID0gc3RhcnQpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSB0cmFpbGluZ1xuICogQHBhcmFtIHsoY2hhckNvZGU6IG51bWJlcikgPT4gYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiByZW1vdmVDaGFycyAoYnVmLCBsZWFkaW5nLCB0cmFpbGluZywgcHJlZGljYXRlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBidWYubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgd2hpbGUgKGxlYWQgPCBidWYubGVuZ3RoICYmIHByZWRpY2F0ZShidWZbbGVhZF0pKSBsZWFkKytcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIHdoaWxlICh0cmFpbCA+IDAgJiYgcHJlZGljYXRlKGJ1Zlt0cmFpbF0pKSB0cmFpbC0tXG4gIH1cblxuICByZXR1cm4gbGVhZCA9PT0gMCAmJiB0cmFpbCA9PT0gYnVmLmxlbmd0aCAtIDEgPyBidWYgOiBidWYuc3ViYXJyYXkobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB7QHBhcmFtIGJ1ZmZlcn0gc3RhcnRzIHdpdGgge0BwYXJhbSBzdGFydH1cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzdGFydFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gYnVmZmVyU3RhcnRzV2l0aCAoYnVmZmVyLCBzdGFydCwgcG9zaXRpb24pIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzdGFydC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGJ1ZmZlcltwb3NpdGlvbi5wb3NpdGlvbiArIGldKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBwYXJzaW5nRXJyb3IgKGNhdXNlKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYm9keSBhcyBGb3JtRGF0YS4nLCB7IGNhdXNlOiBuZXcgVHlwZUVycm9yKGNhdXNlKSB9KVxufVxuXG4vKipcbiAqIENUTCAgICAgICAgICAgID0gPGFueSBVUy1BU0NJSSBjb250cm9sIGNoYXJhY3RlclxuICogICAgICAgICAgICAgICAgICAob2N0ZXRzIDAgLSAzMSkgYW5kIERFTCAoMTI3KT5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQ1RMIChjaGFyKSB7XG4gIHJldHVybiBjaGFyIDw9IDB4MWYgfHwgY2hhciA9PT0gMHg3ZlxufVxuXG4vKipcbiAqIHRzcGVjaWFscyA6PSAgXCIoXCIgLyBcIilcIiAvIFwiPFwiIC8gXCI+XCIgLyBcIkBcIiAvXG4gKiAgICAgICAgICAgICAgICBcIixcIiAvIFwiO1wiIC8gXCI6XCIgLyBcIlxcXCIgLyA8XCI+XG4gKiAgICAgICAgICAgICAgICBcIi9cIiAvIFwiW1wiIC8gXCJdXCIgLyBcIj9cIiAvIFwiPVwiXG4gKiAgICAgICAgICAgICAgICA7IE11c3QgYmUgaW4gcXVvdGVkLXN0cmluZyxcbiAqICAgICAgICAgICAgICAgIDsgdG8gdXNlIHdpdGhpbiBwYXJhbWV0ZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhclxuICovXG5mdW5jdGlvbiBpc1RTcGVjaWFsIChjaGFyKSB7XG4gIHJldHVybiAoXG4gICAgY2hhciA9PT0gMHgyOCB8fCAvLyAoXG4gICAgY2hhciA9PT0gMHgyOSB8fCAvLyApXG4gICAgY2hhciA9PT0gMHgzYyB8fCAvLyA8XG4gICAgY2hhciA9PT0gMHgzZSB8fCAvLyA+XG4gICAgY2hhciA9PT0gMHg0MCB8fCAvLyBAXG4gICAgY2hhciA9PT0gMHgyYyB8fCAvLyAsXG4gICAgY2hhciA9PT0gMHgzYiB8fCAvLyA7XG4gICAgY2hhciA9PT0gMHgzYSB8fCAvLyA6XG4gICAgY2hhciA9PT0gMHg1YyB8fCAvLyBcXFxuICAgIGNoYXIgPT09IDB4MjIgfHwgLy8gXCJcbiAgICBjaGFyID09PSAweDJmIHx8IC8vIC9cbiAgICBjaGFyID09PSAweDViIHx8IC8vIFtcbiAgICBjaGFyID09PSAweDVkIHx8IC8vIF1cbiAgICBjaGFyID09PSAweDNmIHx8IC8vID9cbiAgICBjaGFyID09PSAweDNkICAgIC8vICtcbiAgKVxufVxuXG4vKipcbiAqIHRva2VuIDo9IDEqPGFueSAoVVMtQVNDSUkpIENIQVIgZXhjZXB0IFNQQUNFLCBDVExzLFxuICogICAgICAgICAgb3IgdHNwZWNpYWxzPlxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNUb2tlbiAoY2hhcikge1xuICByZXR1cm4gKFxuICAgIGNoYXIgPD0gMHg3ZiAmJiAgLy8gYXNjaWlcbiAgICBjaGFyICE9PSAweDIwICYmIC8vIHNwYWNlXG4gICAgY2hhciAhPT0gMHgwOSAmJlxuICAgICFpc0NUTChjaGFyKSAmJlxuICAgICFpc1RTcGVjaWFsKGNoYXIpXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG11bHRpcGFydEZvcm1EYXRhUGFyc2VyLFxuICB2YWxpZGF0ZUJvdW5kYXJ5XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { iteratorMixin } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  #state = []\n\n  constructor (form = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.append'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to thiss entry list.\n    this.#state.push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from thiss entry list.\n    this.#state = this.#state.filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.get'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return null.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // thiss entry list.\n    return this.#state[idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.getAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from thiss entry list.\n    return this.#state\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in thiss entry list; otherwise false.\n    return this.#state.findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.set'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in thiss entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this.#state = [\n        ...this.#state.slice(0, idx),\n        entry,\n        ...this.#state.slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to thiss entry list.\n      this.#state.push(entry)\n    }\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    const state = this.#state.reduce((a, b) => {\n      if (a[b.name]) {\n        if (Array.isArray(a[b.name])) {\n          a[b.name].push(b.value)\n        } else {\n          a[b.name] = [a[b.name], b.value]\n        }\n      } else {\n        a[b.name] = b.value\n      }\n\n      return a\n    }, { __proto__: null })\n\n    options.depth ??= depth\n    options.colors ??= true\n\n    const output = nodeUtil.formatWithOptions(options, state)\n\n    // remove [Object null prototype]\n    return `FormData ${output.slice(output.indexOf(']') + 2)}`\n  }\n\n  /**\n   * @param {FormData} formData\n   */\n  static getFormDataState (formData) {\n    return formData.#state\n  }\n\n  /**\n   * @param {FormData} formData\n   * @param {any[]} newState\n   */\n  static setFormDataState (formData, newState) {\n    formData.#state = newState\n  }\n}\n\nconst { getFormDataState, setFormDataState } = FormData\nReflect.deleteProperty(FormData, 'getFormDataState')\nReflect.deleteProperty(FormData, 'setFormDataState')\n\niteratorMixin('FormData', FormData, getFormDataState, 'name', 'value')\n\nObject.defineProperties(FormData.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  getAll: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // Note: This operation was done by the webidl converter USVString.\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!webidl.is.File(value)) {\n      value = new File([value], 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = new File([value], filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nwebidl.is.FormData = webidl.util.MakeTypeAssertion(FormData)\n\nmodule.exports = { FormData, makeEntry, setFormDataState }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDekQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSSxpQkFBaUI7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEOztBQUVBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEscUNBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmb3JtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpdGVyYXRvck1peGluIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbi8vIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jZm9ybWRhdGFcbmNsYXNzIEZvcm1EYXRhIHtcbiAgI3N0YXRlID0gW11cblxuICBjb25zdHJ1Y3RvciAoZm9ybSA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBpZiAoZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICBwcmVmaXg6ICdGb3JtRGF0YSBjb25zdHJ1Y3RvcicsXG4gICAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCddXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuYXBwZW5kJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgd2ViaWRsLmlzLkJsb2IodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcblxuICAgICAgaWYgKGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmlsZW5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHZhbHVlKVxuICAgIH1cblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGhcbiAgICAvLyBuYW1lLCB2YWx1ZSwgYW5kIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIEFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHRoaXMuI3N0YXRlLnB1c2goZW50cnkpXG4gIH1cblxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyBUaGUgZGVsZXRlKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmVtb3ZlIGFsbCBlbnRyaWVzIHdob3NlIG5hbWVcbiAgICAvLyBpcyBuYW1lIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzLiNzdGF0ZSA9IHRoaXMuI3N0YXRlLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICB9XG5cbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuZ2V0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzLiNzdGF0ZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBmcm9tXG4gICAgLy8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGVbaWR4XS52YWx1ZVxuICB9XG5cbiAgZ2V0QWxsIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuZ2V0QWxsJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIGVtcHR5IGxpc3QuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGVudHJpZXMgd2hvc2UgbmFtZSBpcyBuYW1lLCBpbiBvcmRlcixcbiAgICAvLyBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlXG4gICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICAgIC5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSlcbiAgfVxuXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmhhcydcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIFRoZSBoYXMobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhbiBlbnRyeVxuICAgIC8vIHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpICE9PSAtMVxuICB9XG5cbiAgc2V0IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5zZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCB3ZWJpZGwuaXMuQmxvYih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWxlbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpXG4gICAgfVxuXG4gICAgLy8gVGhlIHNldChuYW1lLCB2YWx1ZSkgYW5kIHNldChuYW1lLCBibG9iVmFsdWUsIGZpbGVuYW1lKSBtZXRob2Qgc3RlcHNcbiAgICAvLyBhcmU6XG5cbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdmFsdWUgaWYgZ2l2ZW47IG90aGVyd2lzZSBibG9iVmFsdWUuXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoIG5hbWUsIHZhbHVlLCBhbmRcbiAgICAvLyBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgZW50cmllcyBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0IHdob3NlIG5hbWUgaXMgbmFtZSwgdGhlblxuICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IHN1Y2ggZW50cnkgd2l0aCBlbnRyeSBhbmQgcmVtb3ZlIHRoZSBvdGhlcnMuXG4gICAgY29uc3QgaWR4ID0gdGhpcy4jc3RhdGUuZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jc3RhdGUgPSBbXG4gICAgICAgIC4uLnRoaXMuI3N0YXRlLnNsaWNlKDAsIGlkeCksXG4gICAgICAgIGVudHJ5LFxuICAgICAgICAuLi50aGlzLiNzdGF0ZS5zbGljZShpZHggKyAxKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA0LiBPdGhlcndpc2UsIGFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgICAgdGhpcy4jc3RhdGUucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc3RhdGUucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICBpZiAoYVtiLm5hbWVdKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFbYi5uYW1lXSkpIHtcbiAgICAgICAgICBhW2IubmFtZV0ucHVzaChiLnZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFbYi5uYW1lXSA9IFthW2IubmFtZV0sIGIudmFsdWVdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFbYi5uYW1lXSA9IGIudmFsdWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFcbiAgICB9LCB7IF9fcHJvdG9fXzogbnVsbCB9KVxuXG4gICAgb3B0aW9ucy5kZXB0aCA/Pz0gZGVwdGhcbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgc3RhdGUpXG5cbiAgICAvLyByZW1vdmUgW09iamVjdCBudWxsIHByb3RvdHlwZV1cbiAgICByZXR1cm4gYEZvcm1EYXRhICR7b3V0cHV0LnNsaWNlKG91dHB1dC5pbmRleE9mKCddJykgKyAyKX1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGb3JtRGF0YX0gZm9ybURhdGFcbiAgICovXG4gIHN0YXRpYyBnZXRGb3JtRGF0YVN0YXRlIChmb3JtRGF0YSkge1xuICAgIHJldHVybiBmb3JtRGF0YS4jc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmb3JtRGF0YVxuICAgKiBAcGFyYW0ge2FueVtdfSBuZXdTdGF0ZVxuICAgKi9cbiAgc3RhdGljIHNldEZvcm1EYXRhU3RhdGUgKGZvcm1EYXRhLCBuZXdTdGF0ZSkge1xuICAgIGZvcm1EYXRhLiNzdGF0ZSA9IG5ld1N0YXRlXG4gIH1cbn1cblxuY29uc3QgeyBnZXRGb3JtRGF0YVN0YXRlLCBzZXRGb3JtRGF0YVN0YXRlIH0gPSBGb3JtRGF0YVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShGb3JtRGF0YSwgJ2dldEZvcm1EYXRhU3RhdGUnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShGb3JtRGF0YSwgJ3NldEZvcm1EYXRhU3RhdGUnKVxuXG5pdGVyYXRvck1peGluKCdGb3JtRGF0YScsIEZvcm1EYXRhLCBnZXRGb3JtRGF0YVN0YXRlLCAnbmFtZScsICd2YWx1ZScpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZvcm1EYXRhLnByb3RvdHlwZSwge1xuICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXRBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRm9ybURhdGEnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY3JlYXRlLWFuLWVudHJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8QmxvYn0gdmFsdWVcbiAqIEBwYXJhbSB7P3N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRyeSAobmFtZSwgdmFsdWUsIGZpbGVuYW1lKSB7XG4gIC8vIDEuIFNldCBuYW1lIHRvIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBuYW1lIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICAvLyBOb3RlOiBUaGlzIG9wZXJhdGlvbiB3YXMgZG9uZSBieSB0aGUgd2ViaWRsIGNvbnZlcnRlciBVU1ZTdHJpbmcuXG5cbiAgLy8gMi4gSWYgdmFsdWUgaXMgYSBzdHJpbmcsIHRoZW4gc2V0IHZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29udmVydGluZ1xuICAvLyAgICB2YWx1ZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBOb3RlOiBUaGlzIG9wZXJhdGlvbiB3YXMgZG9uZSBieSB0aGUgd2ViaWRsIGNvbnZlcnRlciBVU1ZTdHJpbmcuXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gSWYgdmFsdWUgaXMgbm90IGEgRmlsZSBvYmplY3QsIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgdmFsdWUgaXMgXCJibG9iXCJcbiAgICBpZiAoIXdlYmlkbC5pcy5GaWxlKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBuZXcgRmlsZShbdmFsdWVdLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgIH1cblxuICAgIC8vIDIuIElmIGZpbGVuYW1lIGlzIGdpdmVuLCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIGlzIGZpbGVuYW1lLlxuICAgIGlmIChmaWxlbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKiogQHR5cGUge0ZpbGVQcm9wZXJ0eUJhZ30gKi9cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgIGxhc3RNb2RpZmllZDogdmFsdWUubGFzdE1vZGlmaWVkXG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbmV3IEZpbGUoW3ZhbHVlXSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxud2ViaWRsLmlzLkZvcm1EYXRhID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oRm9ybURhdGEpXG5cbm1vZHVsZS5leHBvcnRzID0geyBGb3JtRGF0YSwgbWFrZUVudHJ5LCBzZXRGb3JtRGF0YVN0YXRlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0UsbUJBQW1CO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxnbG9iYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcywgaW5jcmVhc2UgdGhlIHZlcnNpb25cbi8vIG51bWJlciB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxPcmlnaW4gPSBTeW1ib2wuZm9yKCd1bmRpY2kuZ2xvYmFsT3JpZ2luLjEnKVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxPcmlnaW4gKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxPcmlnaW5dXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbE9yaWdpbiAobmV3T3JpZ2luKSB7XG4gIGlmIChuZXdPcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwobmV3T3JpZ2luKVxuXG4gIGlmIChwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgaHR0cCAmIGh0dHBzIHVybHMgYXJlIGFsbG93ZWQsIHJlY2VpdmVkICR7cGFyc2VkVVJMLnByb3RvY29sfWApXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgdmFsdWU6IHBhcnNlZFVSTCxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRHbG9iYWxPcmlnaW4sXG4gIHNldEdsb2JhbE9yaWdpblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\n/**\n * @param {number} code\n * @returns {code is (0x0a | 0x0d | 0x09 | 0x20)}\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x0a || code === 0x0d || code === 0x09 || code === 0x20\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n * @returns {string}\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\n/**\n * @param {Headers} headers\n * @param {Array|Object} object\n */\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (headers first item, headers second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key  value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n * @param {Headers} headers\n * @param {string} name\n * @param {string} value\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headerss guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headerss guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headerss guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headerss guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headerss header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headerss guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\n// https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n/**\n * @param {Headers} target\n */\nfunction headersListSortAndCombine (target) {\n  const headersList = getHeadersList(target)\n\n  if (!headersList) {\n    return []\n  }\n\n  if (headersList.sortedMap) {\n    return headersList.sortedMap\n  }\n\n  // 1. Let headers be an empty list of headers with the key being the name\n  //    and value the value.\n  const headers = []\n\n  // 2. Let names be the result of convert header names to a sorted-lowercase\n  //    set with all the names of the headers in list.\n  const names = headersList.toSortedArray()\n\n  const cookies = headersList.cookies\n\n  // fast-path\n  if (cookies === null || cookies.length === 1) {\n    // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n    return (headersList.sortedMap = names)\n  }\n\n  // 3. For each name of names:\n  for (let i = 0; i < names.length; ++i) {\n    const { 0: name, 1: value } = names[i]\n    // 1. If name is `set-cookie`, then:\n    if (name === 'set-cookie') {\n      // 1. Let values be a list of all values of headers in list whose name\n      //    is a byte-case-insensitive match for name, in order.\n\n      // 2. For each value of values:\n      // 1. Append (name, value) to headers.\n      for (let j = 0; j < cookies.length; ++j) {\n        headers.push([name, cookies[j]])\n      }\n    } else {\n      // 2. Otherwise:\n\n      // 1. Let value be the result of getting name from list.\n\n      // 2. Assert: value is non-null.\n      // Note: This operation was done by `HeadersList#toSortedArray`.\n\n      // 3. Append (name, value) to headers.\n      headers.push([name, value])\n    }\n  }\n\n  // 4. Return headers.\n  return (headersList.sortedMap = headers)\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  sortedMap\n  headersMap\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this.headersMap = new Map(init.headersMap)\n      this.sortedMap = init.sortedMap\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this.headersMap = new Map(init)\n      this.sortedMap = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this.headersMap.has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this.headersMap.clear()\n    this.sortedMap = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this.sortedMap = null\n\n    // 1. If list contains name, then set name to the first such\n    //    headers name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this.headersMap.get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this.headersMap.set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this.headersMap.set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this.sortedMap = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this.headersMap.set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this.sortedMap = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this.headersMap.delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this.headersMap) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this.headersMap.size !== 0) {\n      for (const { name, value } of this.headersMap.values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this.headersMap.values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this.headersMap.size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this.headersMap.size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this.headersMap[Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this.headersMap) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  /**\n   * @type {HeadersList}\n   */\n  #headersList\n\n  /**\n   * @param {HeadersInit|Symbol} [init]\n   * @returns\n   */\n  constructor (init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set thiss guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers constructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If thiss guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if thiss guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If thiss header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from thiss header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if thiss header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If thiss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if thiss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n    // 2. Return the values of all headers in thiss header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  /**\n   * @param {Headers} o\n   */\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  /**\n   * @param {Headers} target\n   * @param {HeadersList} list\n   */\n  static setHeadersList (target, list) {\n    target.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, headersListSortAndCombine, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDRCQUFXOztBQUVoQztBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkYsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsMkRBQTJEO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcaGVhZGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIGl0ZXJhdG9yTWl4aW4sXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2NvZGUgaXMgKDB4MGEgfCAweDBkIHwgMHgwOSB8IDB4MjApfVxuICovXG5mdW5jdGlvbiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDB4MGEgfHwgY29kZSA9PT0gMHgwZCB8fCBjb2RlID09PSAweDA5IHx8IGNvZGUgPT09IDB4MjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci12YWx1ZS1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGVhZGVyVmFsdWVOb3JtYWxpemUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vICBUbyBub3JtYWxpemUgYSBieXRlIHNlcXVlbmNlIHBvdGVudGlhbFZhbHVlLCByZW1vdmVcbiAgLy8gIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgYnl0ZXMgZnJvbVxuICAvLyAgcG90ZW50aWFsVmFsdWUuXG4gIGxldCBpID0gMDsgbGV0IGogPSBwb3RlbnRpYWxWYWx1ZS5sZW5ndGhcblxuICB3aGlsZSAoaiA+IGkgJiYgaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlKHBvdGVudGlhbFZhbHVlLmNoYXJDb2RlQXQoaiAtIDEpKSkgLS1qXG4gIHdoaWxlIChqID4gaSAmJiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUocG90ZW50aWFsVmFsdWUuY2hhckNvZGVBdChpKSkpICsraVxuXG4gIHJldHVybiBpID09PSAwICYmIGogPT09IHBvdGVudGlhbFZhbHVlLmxlbmd0aCA/IHBvdGVudGlhbFZhbHVlIDogcG90ZW50aWFsVmFsdWUuc3Vic3RyaW5nKGksIGopXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpbGwgKGhlYWRlcnMsIG9iamVjdCkge1xuICAvLyBUbyBmaWxsIGEgSGVhZGVycyBvYmplY3QgaGVhZGVycyB3aXRoIGEgZ2l2ZW4gb2JqZWN0IG9iamVjdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIElmIG9iamVjdCBpcyBhIHNlcXVlbmNlLCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBvYmplY3Q6XG4gIC8vIE5vdGU6IHdlYmlkbCBjb252ZXJzaW9uIHRvIGFycmF5IGhhcyBhbHJlYWR5IGJlZW4gZG9uZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSBvYmplY3RbaV1cbiAgICAgIC8vIDEuIElmIGhlYWRlciBkb2VzIG5vdCBjb250YWluIGV4YWN0bHkgdHdvIGl0ZW1zLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgICAgIG1lc3NhZ2U6IGBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kICR7aGVhZGVyLmxlbmd0aH0uYFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgKGhlYWRlcuKAmXMgZmlyc3QgaXRlbSwgaGVhZGVy4oCZcyBzZWNvbmQgaXRlbSkgdG8gaGVhZGVycy5cbiAgICAgIGFwcGVuZEhlYWRlcihoZWFkZXJzLCBoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgLy8gTm90ZTogbnVsbCBzaG91bGQgdGhyb3dcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgb2JqZWN0IGlzIGEgcmVjb3JkLCB0aGVuIGZvciBlYWNoIGtleSDihpIgdmFsdWUgaW4gb2JqZWN0LFxuICAgIC8vICAgIGFwcGVuZCAoa2V5LCB2YWx1ZSkgdG8gaGVhZGVyc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcHBlbmRIZWFkZXIoaGVhZGVycywga2V5c1tpXSwgb2JqZWN0W2tleXNbaV1dKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgdHlwZXM6IFsnc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+JywgJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVycy1hcHBlbmRcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhcHBlbmRIZWFkZXIgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICB2YWx1ZSxcbiAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIDQuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiOlxuICAvLyAgICBUT0RPXG4gIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICBpZiAoZ2V0SGVhZGVyc0d1YXJkKGhlYWRlcnMpID09PSAnaW1tdXRhYmxlJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuXG4gIC8vIDcuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICByZXR1cm4gZ2V0SGVhZGVyc0xpc3QoaGVhZGVycykuYXBwZW5kKG5hbWUsIHZhbHVlLCBmYWxzZSlcblxuICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gaGVhZGVyc1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGhlYWRlcnNMaXN0U29ydEFuZENvbWJpbmUgKHRhcmdldCkge1xuICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KHRhcmdldClcblxuICBpZiAoIWhlYWRlcnNMaXN0KSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBpZiAoaGVhZGVyc0xpc3Quc29ydGVkTWFwKSB7XG4gICAgcmV0dXJuIGhlYWRlcnNMaXN0LnNvcnRlZE1hcFxuICB9XG5cbiAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgYW4gZW1wdHkgbGlzdCBvZiBoZWFkZXJzIHdpdGggdGhlIGtleSBiZWluZyB0aGUgbmFtZVxuICAvLyAgICBhbmQgdmFsdWUgdGhlIHZhbHVlLlxuICBjb25zdCBoZWFkZXJzID0gW11cblxuICAvLyAyLiBMZXQgbmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0IGhlYWRlciBuYW1lcyB0byBhIHNvcnRlZC1sb3dlcmNhc2VcbiAgLy8gICAgc2V0IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyBpbiBsaXN0LlxuICBjb25zdCBuYW1lcyA9IGhlYWRlcnNMaXN0LnRvU29ydGVkQXJyYXkoKVxuXG4gIGNvbnN0IGNvb2tpZXMgPSBoZWFkZXJzTGlzdC5jb29raWVzXG5cbiAgLy8gZmFzdC1wYXRoXG4gIGlmIChjb29raWVzID09PSBudWxsIHx8IGNvb2tpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gTm90ZTogVGhlIG5vbi1udWxsIGFzc2VydGlvbiBvZiB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGRvbmUgYnkgYEhlYWRlcnNMaXN0I3RvU29ydGVkQXJyYXlgXG4gICAgcmV0dXJuIChoZWFkZXJzTGlzdC5zb3J0ZWRNYXAgPSBuYW1lcylcbiAgfVxuXG4gIC8vIDMuIEZvciBlYWNoIG5hbWUgb2YgbmFtZXM6XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB7IDA6IG5hbWUsIDE6IHZhbHVlIH0gPSBuYW1lc1tpXVxuICAgIC8vIDEuIElmIG5hbWUgaXMgYHNldC1jb29raWVgLCB0aGVuOlxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIC8vIDEuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgb2YgaGVhZGVycyBpbiBsaXN0IHdob3NlIG5hbWVcbiAgICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLCBpbiBvcmRlci5cblxuICAgICAgLy8gMi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICAgICAgLy8gMS4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29va2llcy5sZW5ndGg7ICsraikge1xuICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIGNvb2tpZXNbal1dKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAyLiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDEuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIGxpc3QuXG5cbiAgICAgIC8vIDIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAvLyBOb3RlOiBUaGlzIG9wZXJhdGlvbiB3YXMgZG9uZSBieSBgSGVhZGVyc0xpc3QjdG9Tb3J0ZWRBcnJheWAuXG5cbiAgICAgIC8vIDMuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnMuXG4gICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gaGVhZGVycy5cbiAgcmV0dXJuIChoZWFkZXJzTGlzdC5zb3J0ZWRNYXAgPSBoZWFkZXJzKVxufVxuXG5mdW5jdGlvbiBjb21wYXJlSGVhZGVyTmFtZSAoYSwgYikge1xuICByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IDFcbn1cblxuY2xhc3MgSGVhZGVyc0xpc3Qge1xuICAvKiogQHR5cGUge1tzdHJpbmcsIHN0cmluZ11bXXxudWxsfSAqL1xuICBjb29raWVzID0gbnVsbFxuXG4gIHNvcnRlZE1hcFxuICBoZWFkZXJzTWFwXG5cbiAgY29uc3RydWN0b3IgKGluaXQpIHtcbiAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnNMaXN0KSB7XG4gICAgICB0aGlzLmhlYWRlcnNNYXAgPSBuZXcgTWFwKGluaXQuaGVhZGVyc01hcClcbiAgICAgIHRoaXMuc29ydGVkTWFwID0gaW5pdC5zb3J0ZWRNYXBcbiAgICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llcyA9PT0gbnVsbCA/IG51bGwgOiBbLi4uaW5pdC5jb29raWVzXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNNYXAgPSBuZXcgTWFwKGluaXQpXG4gICAgICB0aGlzLnNvcnRlZE1hcCA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLWxpc3QtY29udGFpbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgY29udGFpbnMgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gQSBoZWFkZXIgbGlzdCBsaXN0IGNvbnRhaW5zIGEgaGVhZGVyIG5hbWUgbmFtZSBpZiBsaXN0XG4gICAgLy8gY29udGFpbnMgYSBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIG1hdGNoIGZvciBuYW1lLlxuXG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyc01hcC5oYXMoaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuaGVhZGVyc01hcC5jbGVhcigpXG4gICAgdGhpcy5zb3J0ZWRNYXAgPSBudWxsXG4gICAgdGhpcy5jb29raWVzID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtYXBwZW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBhcHBlbmQgKG5hbWUsIHZhbHVlLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXMuc29ydGVkTWFwID0gbnVsbFxuXG4gICAgLy8gMS4gSWYgbGlzdCBjb250YWlucyBuYW1lLCB0aGVuIHNldCBuYW1lIHRvIHRoZSBmaXJzdCBzdWNoXG4gICAgLy8gICAgaGVhZGVy4oCZcyBuYW1lLlxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBleGlzdHMgPSB0aGlzLmhlYWRlcnNNYXAuZ2V0KGxvd2VyY2FzZU5hbWUpXG5cbiAgICAvLyAyLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGxvd2VyY2FzZU5hbWUgPT09ICdjb29raWUnID8gJzsgJyA6ICcsICdcbiAgICAgIHRoaXMuaGVhZGVyc01hcC5zZXQobG93ZXJjYXNlTmFtZSwge1xuICAgICAgICBuYW1lOiBleGlzdHMubmFtZSxcbiAgICAgICAgdmFsdWU6IGAke2V4aXN0cy52YWx1ZX0ke2RlbGltaXRlcn0ke3ZhbHVlfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc01hcC5zZXQobG93ZXJjYXNlTmFtZSwgeyBuYW1lLCB2YWx1ZSB9KVxuICAgIH1cblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICh0aGlzLmNvb2tpZXMgPz89IFtdKS5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgc2V0IChuYW1lLCB2YWx1ZSwgaXNMb3dlckNhc2UpIHtcbiAgICB0aGlzLnNvcnRlZE1hcCA9IG51bGxcbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICB0aGlzLmNvb2tpZXMgPSBbdmFsdWVdXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgbGlzdCBjb250YWlucyBuYW1lLCB0aGVuIHNldCB0aGUgdmFsdWUgb2ZcbiAgICAvLyAgICB0aGUgZmlyc3Qgc3VjaCBoZWFkZXIgdG8gdmFsdWUgYW5kIHJlbW92ZSB0aGVcbiAgICAvLyAgICBvdGhlcnMuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBhcHBlbmQgaGVhZGVyIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICB0aGlzLmhlYWRlcnNNYXAuc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBkZWxldGUgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpcy5zb3J0ZWRNYXAgPSBudWxsXG4gICAgaWYgKCFpc0xvd2VyQ2FzZSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyc01hcC5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0IChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIC8vIDEuIElmIGxpc3QgZG9lcyBub3QgY29udGFpbiBuYW1lLCB0aGVuIHJldHVybiBudWxsLlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLFxuICAgIC8vICAgIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgMHgyQyAweDIwLCBpbiBvcmRlci5cbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzTWFwLmdldChpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKCkpPy52YWx1ZSA/PyBudWxsXG4gIH1cblxuICAqIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAvLyB1c2UgdGhlIGxvd2VyY2FzZWQgbmFtZVxuICAgIGZvciAoY29uc3QgeyAwOiBuYW1lLCAxOiB7IHZhbHVlIH0gfSBvZiB0aGlzLmhlYWRlcnNNYXApIHtcbiAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV1cbiAgICB9XG4gIH1cblxuICBnZXQgZW50cmllcyAoKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBpZiAodGhpcy5oZWFkZXJzTWFwLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIHRoaXMuaGVhZGVyc01hcC52YWx1ZXMoKSkge1xuICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgcmF3VmFsdWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzTWFwLnZhbHVlcygpXG4gIH1cblxuICBnZXQgZW50cmllc0xpc3QgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgaWYgKHRoaXMuaGVhZGVyc01hcC5zaXplICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgMDogbG93ZXJOYW1lLCAxOiB7IG5hbWUsIHZhbHVlIH0gfSBvZiB0aGlzLmhlYWRlcnNNYXApIHtcbiAgICAgICAgaWYgKGxvd2VyTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgdGhpcy5jb29raWVzKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIGNvb2tpZV0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgdmFsdWVdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb252ZXJ0LWhlYWRlci1uYW1lcy10by1hLXNvcnRlZC1sb3dlcmNhc2Utc2V0XG4gIHRvU29ydGVkQXJyYXkgKCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmhlYWRlcnNNYXAuc2l6ZVxuICAgIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHNpemUpXG4gICAgLy8gSW4gbW9zdCBjYXNlcywgeW91IHdpbGwgdXNlIHRoZSBmYXN0LXBhdGguXG4gICAgLy8gZmFzdC1wYXRoOiBVc2UgYmluYXJ5IGluc2VydGlvbiBzb3J0IGZvciBzbWFsbCBhcnJheXMuXG4gICAgaWYgKHNpemUgPD0gMzIpIHtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIC8vIElmIGVtcHR5LCBpdCBpcyBhbiBlbXB0eSBhcnJheS4gVG8gYXZvaWQgdGhlIGZpcnN0IGluZGV4IGFzc2lnbm1lbnQuXG4gICAgICAgIHJldHVybiBhcnJheVxuICAgICAgfVxuICAgICAgLy8gSW1wcm92ZSBwZXJmb3JtYW5jZSBieSB1bnJvbGxpbmcgbG9vcCBhbmQgYXZvaWRpbmcgZG91YmxlLWxvb3AuXG4gICAgICAvLyBEb3VibGUtbG9vcC1sZXNzIHZlcnNpb24gb2YgdGhlIGJpbmFyeSBpbnNlcnRpb24gc29ydC5cbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5oZWFkZXJzTWFwW1N5bWJvbC5pdGVyYXRvcl0oKVxuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgLy8gc2V0IFtuYW1lLCB2YWx1ZV0gdG8gZmlyc3QgaW5kZXguXG4gICAgICBhcnJheVswXSA9IFtmaXJzdFZhbHVlWzBdLCBmaXJzdFZhbHVlWzFdLnZhbHVlXVxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoZmlyc3RWYWx1ZVsxXS52YWx1ZSAhPT0gbnVsbClcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBpID0gMSwgaiA9IDAsIHJpZ2h0ID0gMCwgbGVmdCA9IDAsIHBpdm90ID0gMCwgeCwgdmFsdWU7XG4gICAgICAgIGkgPCBzaXplO1xuICAgICAgICArK2lcbiAgICAgICkge1xuICAgICAgICAvLyBnZXQgbmV4dCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBjdXJyZW50IGluZGV4LlxuICAgICAgICB4ID0gYXJyYXlbaV0gPSBbdmFsdWVbMF0sIHZhbHVlWzFdLnZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQoeFsxXSAhPT0gbnVsbClcbiAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgcmlnaHQgPSBpXG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgIC8vIG1pZGRsZSBpbmRleFxuICAgICAgICAgIHBpdm90ID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSA+PiAxKVxuICAgICAgICAgIC8vIGNvbXBhcmUgaGVhZGVyIG5hbWVcbiAgICAgICAgICBpZiAoYXJyYXlbcGl2b3RdWzBdIDw9IHhbMF0pIHtcbiAgICAgICAgICAgIGxlZnQgPSBwaXZvdCArIDFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBwaXZvdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcGl2b3QpIHtcbiAgICAgICAgICBqID0gaVxuICAgICAgICAgIHdoaWxlIChqID4gbGVmdCkge1xuICAgICAgICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdXG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5W2xlZnRdID0geFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCA0ICovXG4gICAgICBpZiAoIWl0ZXJhdG9yLm5leHQoKS5kb25lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBhbmQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVhY2hhYmxlJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNhc2Ugd291bGQgYmUgYSByYXJlIG9jY3VycmVuY2UuXG4gICAgICAvLyBzbG93LXBhdGg6IGZhbGxiYWNrXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoY29uc3QgeyAwOiBuYW1lLCAxOiB7IHZhbHVlIH0gfSBvZiB0aGlzLmhlYWRlcnNNYXApIHtcbiAgICAgICAgYXJyYXlbaSsrXSA9IFtuYW1lLCB2YWx1ZV1cbiAgICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICAgICAgICAvLyAzLjIuMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgICAgYXNzZXJ0KHZhbHVlICE9PSBudWxsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5LnNvcnQoY29tcGFyZUhlYWRlck5hbWUpXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXJzLWNsYXNzXG5jbGFzcyBIZWFkZXJzIHtcbiAgI2d1YXJkXG4gIC8qKlxuICAgKiBAdHlwZSB7SGVhZGVyc0xpc3R9XG4gICAqL1xuICAjaGVhZGVyc0xpc3RcblxuICAvKipcbiAgICogQHBhcmFtIHtIZWFkZXJzSW5pdHxTeW1ib2x9IFtpbml0XVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgaWYgKGluaXQgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuI2hlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnNMaXN0KClcblxuICAgIC8vIFRoZSBuZXcgSGVhZGVycyhpbml0KSBjb25zdHJ1Y3RvciBzdGVwcyBhcmU6XG5cbiAgICAvLyAxLiBTZXQgdGhpc+KAmXMgZ3VhcmQgdG8gXCJub25lXCIuXG4gICAgdGhpcy4jZ3VhcmQgPSAnbm9uZSdcblxuICAgIC8vIDIuIElmIGluaXQgaXMgZ2l2ZW4sIHRoZW4gZmlsbCB0aGlzIHdpdGggaW5pdC5cbiAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQoaW5pdCwgJ0hlYWRlcnMgY29uc3RydWN0b3InLCAnaW5pdCcpXG4gICAgICBmaWxsKHRoaXMsIGluaXQpXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWFwcGVuZFxuICBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ0hlYWRlcnMuYXBwZW5kJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmFwcGVuZCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcblxuICAgIHJldHVybiBhcHBlbmRIZWFkZXIodGhpcywgbmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmRlbGV0ZScpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5kZWxldGUnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5kZWxldGUnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgbmFtZVxuICAgIC8vICAgIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlciBuYW1lLCBhbmRcbiAgICAvLyAgICBuYW1lIGlzIG5vdCBhIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpc1xuICAgIC8vICAgIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA2LiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW5cbiAgICAvLyAgICByZXR1cm4uXG4gICAgaWYgKCF0aGlzLiNoZWFkZXJzTGlzdC5jb250YWlucyhuYW1lLCBmYWxzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDcuIERlbGV0ZSBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpcy5cbiAgICB0aGlzLiNoZWFkZXJzTGlzdC5kZWxldGUobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0XG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmdldCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5nZXQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXJcbiAgICAvLyAgICBsaXN0LlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdC5nZXQobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtaGFzXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmhhcycpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5oYXMnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBuYW1lO1xuICAgIC8vICAgIG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jaGVhZGVyc0xpc3QuY29udGFpbnMobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtc2V0XG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnSGVhZGVycy5zZXQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuc2V0J1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gICAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiIGFuZFxuICAgIC8vICAgIG5hbWUvdmFsdWUgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA3LiBTZXQgKG5hbWUsIHZhbHVlKSBpbiB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzXG4gICAgdGhpcy4jaGVhZGVyc0xpc3Quc2V0KG5hbWUsIHZhbHVlLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRzZXRjb29raWVcbiAgZ2V0U2V0Q29va2llICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgU2V0LUNvb2tpZWAsIHRoZW4gcmV0dXJuIMKrIMK7LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIHRoaXPigJlzIGhlYWRlciBsaXN0IHdob3NlIG5hbWUgaXNcbiAgICAvLyAgICBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYFNldC1Db29raWVgLCBpbiBvcmRlci5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNoZWFkZXJzTGlzdC5jb29raWVzXG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIFsuLi5saXN0XVxuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG5cbiAgICByZXR1cm4gYEhlYWRlcnMgJHt1dGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHRoaXMuI2hlYWRlcnNMaXN0LmVudHJpZXMpfWBcbiAgfVxuXG4gIHN0YXRpYyBnZXRIZWFkZXJzR3VhcmQgKG8pIHtcbiAgICByZXR1cm4gby4jZ3VhcmRcbiAgfVxuXG4gIHN0YXRpYyBzZXRIZWFkZXJzR3VhcmQgKG8sIGd1YXJkKSB7XG4gICAgby4jZ3VhcmQgPSBndWFyZFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SGVhZGVyc30gb1xuICAgKi9cbiAgc3RhdGljIGdldEhlYWRlcnNMaXN0IChvKSB7XG4gICAgcmV0dXJuIG8uI2hlYWRlcnNMaXN0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIZWFkZXJzfSB0YXJnZXRcbiAgICogQHBhcmFtIHtIZWFkZXJzTGlzdH0gbGlzdFxuICAgKi9cbiAgc3RhdGljIHNldEhlYWRlcnNMaXN0ICh0YXJnZXQsIGxpc3QpIHtcbiAgICB0YXJnZXQuI2hlYWRlcnNMaXN0ID0gbGlzdFxuICB9XG59XG5cbmNvbnN0IHsgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzR3VhcmQsIGdldEhlYWRlcnNMaXN0LCBzZXRIZWFkZXJzTGlzdCB9ID0gSGVhZGVyc1xuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnZ2V0SGVhZGVyc0d1YXJkJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ3NldEhlYWRlcnNHdWFyZCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdnZXRIZWFkZXJzTGlzdCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdzZXRIZWFkZXJzTGlzdCcpXG5cbml0ZXJhdG9yTWl4aW4oJ0hlYWRlcnMnLCBIZWFkZXJzLCBoZWFkZXJzTGlzdFNvcnRBbmRDb21iaW5lLCAwLCAxKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0U2V0Q29va2llOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnSGVhZGVycycsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXToge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH1cbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IHdlYmlkbC51dGlsLlR5cGVzLk9CSkVDVCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gUmVmbGVjdC5nZXQoViwgU3ltYm9sLml0ZXJhdG9yKVxuXG4gICAgLy8gQSB3b3JrLWFyb3VuZCB0byBlbnN1cmUgd2Ugc2VuZCB0aGUgcHJvcGVybHktY2FzZWQgSGVhZGVycyB3aGVuIFYgaXMgYSBIZWFkZXJzIG9iamVjdC5cbiAgICAvLyBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMzE1OSNpc3N1ZWNvbW1lbnQtMjA3NTUzNzIyNiBiZWZvcmUgdG91Y2hpbmcsIHBsZWFzZS5cbiAgICBpZiAoIXV0aWwudHlwZXMuaXNQcm94eShWKSAmJiBpdGVyYXRvciA9PT0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcykgeyAvLyBIZWFkZXJzIG9iamVjdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdldEhlYWRlcnNMaXN0KFYpLmVudHJpZXNMaXN0XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gZmFsbC10aHJvdWdoXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXShWLCBwcmVmaXgsIGFyZ3VtZW50LCBpdGVyYXRvci5iaW5kKFYpKVxuICAgIH1cblxuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10oViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbGwsXG4gIC8vIGZvciB0ZXN0LlxuICBjb21wYXJlSGVhZGVyTmFtZSxcbiAgSGVhZGVycyxcbiAgSGVhZGVyc0xpc3QsXG4gIGdldEhlYWRlcnNHdWFyZCxcbiAgc2V0SGVhZGVyc0d1YXJkLFxuICBzZXRIZWFkZXJzTGlzdCxcbiAgZ2V0SGVhZGVyc0xpc3Rcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse,\n  getResponseState\n} = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { Request, cloneRequest, getRequestDispatcher, getRequestState } = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst {\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType,\n  hasAuthenticationEntry,\n  includesCredentials,\n  isTraversableNavigable\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\nconst { Readable, pipeline, finished, isErrored, isReadable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { addAbortListener, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst { bytesMatch } = __webpack_require__(/*! ../subresource-integrity/subresource-integrity */ \"(rsc)/./node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js\")\nconst { createDeferredPromise } = __webpack_require__(/*! ../../util/promise */ \"(rsc)/./node_modules/undici/lib/util/promise.js\")\nconst { isomorphicEncode } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\n// Node.js v23.8.0+ and v22.15.0+ supports Zstandard\nconst hasZstd = runtimeFeatures.has('zstd')\n\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controllers state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controllers serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObjects request.\n  const request = getRequestState(requestObject)\n\n  // 4. If requestObjects signals aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObjects signals abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be requests clients global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // requests service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be thiss relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObjects signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObjects signals abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObjects signals abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If responses aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controllers serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: getRequestDispatcher(requestObject) // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If responses URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be responses URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be responses timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be responses cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If responses timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfos end time to the coarsened shared current time\n  // given globals relevant settings objects cross-origin isolated\n  // capability.\n  // TODO: given globals relevant settings objects cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState,\n    '', // bodyType\n    response.status\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If requests body is not null and is readable, then cancel requests\n  // body with error.\n  if (request.body?.stream != null && isReadable(request.body.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObjects response.\n  const response = getResponseState(responseObject)\n\n  // 5. If responses body is not null and is readable, then error responses\n  // body with error.\n  if (response.body?.stream != null && isReadable(response.body.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If requests client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to requests clients global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If requests body is a byte sequence, then set requests body to\n  //    requests body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If requests window is \"client\", then set requests window to requests\n  // client, if requests clients global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If requests origin is \"client\", then set requests origin to requests\n  // clients origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If requests policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If requests client is non-null, then set requests policy\n    // container to a clone of requests clients policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set requests policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If requests header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on requests destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to requests header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If requests header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // requests header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If requests priority is null, then use requests initiator and\n  // destination appropriately in setting requests priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams, false)\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive) {\n  try {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request\n\n    // 2. Let response be null.\n    let response = null\n\n    // 3. If requests local-URLs-only flag is set and requests current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n      response = makeNetworkError('local URLs only')\n    }\n\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === 'blocked') {\n      response = makeNetworkError('bad port')\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n\n    // 7. If requests referrer policy is the empty string, then set requests\n    // referrer policy to requests policy containers referrer policy.\n    if (request.referrerPolicy === '') {\n      request.referrerPolicy = request.policyContainer.referrerPolicy\n    }\n\n    // 8. If requests referrer is not \"no-referrer\", then set requests\n    // referrer to the result of invoking determine requests referrer.\n    if (request.referrer !== 'no-referrer') {\n      request.referrer = determineRequestsReferrer(request)\n    }\n\n    // 9. Set requests current URLs scheme to \"https\" if all of the following\n    // conditions are true:\n    // - requests current URLs scheme is \"http\"\n    // - requests current URLs host is a domain\n    // - Matching requests current URLs host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n      const currentURL = requestCurrentURL(request)\n      if (\n        // - requests current URLs origin is same origin with requests origin,\n        //   and requests response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // requests current URLs scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - requests mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set requests response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        response = await schemeFetch(fetchParams)\n\n      // requests mode is \"same-origin\"\n      } else if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        response = makeNetworkError('request mode cannot be \"same-origin\"')\n\n      // requests mode is \"no-cors\"\n      } else if (request.mode === 'no-cors') {\n        // 1. If requests redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          response = makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        } else {\n          // 2. Set requests response tainting to \"opaque\".\n          request.responseTainting = 'opaque'\n\n          // 3. Return the result of running scheme fetch given fetchParams.\n          response = await schemeFetch(fetchParams)\n        }\n      // requests current URLs scheme is not an HTTP(S) scheme\n      } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        response = makeNetworkError('URL scheme must be a HTTP(S) scheme')\n\n        // - requests use-CORS-preflight flag is set\n        // - requests unsafe-request flag is set and either requests method is\n        //   not a CORS-safelisted method or CORS-unsafe request-header names with\n        //   requests header list is not empty\n        //    1. Set requests response tainting to \"cors\".\n        //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n        //    given fetchParams and true.\n        //    3. If corsWithPreflightResponse is a network error, then clear cache\n        //    entries using request.\n        //    4. Return corsWithPreflightResponse.\n        // TODO\n\n      // Otherwise\n      } else {\n        //    1. Set requests response tainting to \"cors\".\n        request.responseTainting = 'cors'\n\n        //    2. Return the result of running HTTP fetch given fetchParams.\n        response = await httpFetch(fetchParams)\n      }\n    }\n\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n      return response\n    }\n\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n      // If requests response tainting is \"cors\", then:\n      if (request.responseTainting === 'cors') {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and responses header list.\n        // TODO\n        // 2. If requests credentials mode is not \"include\" and headerNames\n        // contains `*`, then set responses CORS-exposed header-name list to\n        // all unique header names in responses header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // responses CORS-exposed header-name list to headerNames.\n        // TODO\n      }\n\n      // Set response to the following filtered response with response as its\n      // internal response, depending on requests response tainting:\n      if (request.responseTainting === 'basic') {\n        response = filterResponse(response, 'basic')\n      } else if (request.responseTainting === 'cors') {\n        response = filterResponse(response, 'cors')\n      } else if (request.responseTainting === 'opaque') {\n        response = filterResponse(response, 'opaque')\n      } else {\n        assert(false)\n      }\n    }\n\n    // 14. Let internalResponse be response, if response is a network error,\n    // and responses internal response otherwise.\n    let internalResponse =\n      response.status === 0 ? response : response.internalResponse\n\n    // 15. If internalResponses URL list is empty, then set it to a clone of\n    // requests URL list.\n    if (internalResponse.urlList.length === 0) {\n      internalResponse.urlList.push(...request.urlList)\n    }\n\n    // 16. If requests timing allow failed flag is unset, then set\n    // internalResponses timing allow passed flag.\n    if (!request.timingAllowFailed) {\n      response.timingAllowPassed = true\n    }\n\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n\n    // 18. If responses type is \"opaque\", internalResponses status is 206,\n    // internalResponses range-requested flag is set, and requests header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (\n      response.type === 'opaque' &&\n      internalResponse.status === 206 &&\n      internalResponse.rangeRequested &&\n      !request.headers.contains('range', true)\n    ) {\n      response = internalResponse = makeNetworkError()\n    }\n\n    // 19. If response is not a network error and either requests method is\n    // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n    // set internalResponses body to null and disregard any enqueuing toward\n    // it (if any).\n    if (\n      response.status !== 0 &&\n      (request.method === 'HEAD' ||\n        request.method === 'CONNECT' ||\n        nullBodyStatus.includes(internalResponse.status))\n    ) {\n      internalResponse.body = null\n      fetchParams.controller.dump = true\n    }\n\n    // 20. If requests integrity metadata is not the empty string, then:\n    if (request.integrity) {\n      // 1. Let processBodyError be this step: run fetch finale given fetchParams\n      // and a network error.\n      const processBodyError = (reason) =>\n        fetchFinale(fetchParams, makeNetworkError(reason))\n\n      // 2. If requests response tainting is \"opaque\", or responses body is null,\n      // then run processBodyError and abort these steps.\n      if (request.responseTainting === 'opaque' || response.body == null) {\n        processBodyError(response.error)\n        return\n      }\n\n      // 3. Let processBody given bytes be these steps:\n      const processBody = (bytes) => {\n        // 1. If bytes do not match requests integrity metadata,\n        // then run processBodyError and abort these steps. [SRI]\n        if (!bytesMatch(bytes, request.integrity)) {\n          processBodyError('integrity mismatch')\n          return\n        }\n\n        // 2. Set responses body to bytes as a body.\n        response.body = safelyExtractBody(bytes)[0]\n\n        // 3. Run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response)\n      }\n\n      // 4. Fully read responses body given processBody and processBodyError.\n      fullyReadBody(response.body, processBody, processBodyError)\n    } else {\n      // 21. Otherwise, run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n  } catch (err) {\n    fetchParams.controller.terminate(err)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParamss request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on requests current URLs scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If requests current URLs path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL)\n      }\n\n      // 1. Let blobURLEntry be requests current URLs blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !webidl.is.Blob(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntrys object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blobs size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blobs type.\n      const type = blob.type\n\n      // 8. If requests header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set responses status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set responses body to bodyWithTypes body.\n        response.body = bodyWithType[0]\n\n        // 4. Set responses header list to  (`Content-Length`, serializedFullLength), (`Content-Type`, type) .\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set responses range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from requests header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength  rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd  1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength  1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd + 1, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set responses body to slicedBodyWithTypes body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlobs size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set responses status to 206.\n        response.status = 206\n\n        // 14. Set responses status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set responses header list to  (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) .\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on requests current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStructs MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is  (`Content-Type`, mimeType) ,\n      //    and body is dataURLStructs body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParamss requests done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParamss process response done is not null, then queue a fetch\n  // task to run fetchParamss process response done given response, with\n  // fetchParamss task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParamss timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParamss requests client is a secure context,\n  //    then set timingInfos server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from responses internal responses header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParamss requests destination is \"document\", then set fetchParamss controllers\n    //    full timing info to fetchParamss timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParamss controllers report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParamss requests URLs scheme is not an HTTP(S) scheme, then return.\n      if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {\n        return\n      }\n\n      // 2. Set timingInfos end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be responses cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be responses body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If responses timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParamss requests mode is not \"navigate\" or responses has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to responses status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from responses header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfos content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParamss requests initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParamss requests URL, fetchParamss requests initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParamss requests done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParamss process response end-of-body is non-null, then run fetchParamss process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParamss requests initiator type is non-null and fetchParamss requests clients\n      //    global object is fetchParamss task destination, then run fetchParamss controllers report\n      //    timing steps given fetchParamss requests clients global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParamss task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParamss process response is non-null, then queue a fetch task to run fetchParamss\n  //    process response given response, with fetchParamss task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise responses internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponses body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponses bodys stream to the result of internalResponses bodys stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If requests service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If requests redirect mode is \"follow\", then set requests\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If requests response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // requests timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either requests response tainting or responses type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // requests origin, requests client, requests destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponses status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponses status is not 303, requests body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on requests redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and responses internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponses location URL given requests current\n  // URLs fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If requests redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase requests redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If requests mode is \"cors\", locationURL includes credentials, and\n  // requests origin is not same origin with locationURLs origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If requests response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponses status is not 303, requests body is non-null,\n  // and requests bodys source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponses status is 301 or 302 and requests method is `POST`\n  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set requests method to `GET` and requests body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // requests header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If requests current URLs origin is not same origin with locationURLs\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from requests header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request's body is non-null, then set request's body to the first return\n  // value of safely extracting request's body's source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfos redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParamss cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfos redirect start time is 0, then set timingInfos\n  //  redirect start time to timingInfos start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to requests URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set requests referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If requests window is \"no-window\" and requests redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParamss request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequests bodys length, if httpRequests\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequests body is null and httpRequests method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequests header list.\n\n  //    10. If contentLength is non-null and httpRequests keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequests referrer is a URL, then append\n  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n  //     to httpRequests header list.\n  if (webidl.is.URL(httpRequest.referrer)) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequests header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequests header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent, true)\n  }\n\n  //    15. If httpRequests cache mode is \"default\" and httpRequests header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequests cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequests header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequests header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequests header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequests header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequests header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequests header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequests header list per HTTP. Do not append a given\n  //    header if httpRequests header list contains that headers name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    21. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    if (!httpRequest.headersList.contains('authorization', true)) {\n      // 1. Let authorizationValue be null.\n      let authorizationValue = null\n\n      // 2. If theres an authentication entry for httpRequest and either\n      //    httpRequests use-URL-credentials flag is unset or httpRequests\n      //    current URL does not include credentials, then set\n      //    authorizationValue to authentication entry.\n      if (hasAuthenticationEntry(httpRequest) && (\n        httpRequest.useURLCredentials === undefined || !includesCredentials(requestCurrentURL(httpRequest))\n      )) {\n        // TODO\n      } else if (includesCredentials(requestCurrentURL(httpRequest)) && isAuthenticationFetch) {\n        // 3. Otherwise, if httpRequests current URL does include credentials\n        //    and isAuthenticationFetch is true, set authorizationValue to\n        //    httpRequests current URL, converted to an `Authorization` value\n        const { username, password } = requestCurrentURL(httpRequest)\n        authorizationValue = `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`\n      }\n\n      // 4. If authorizationValue is non-null, then append (`Authorization`,\n      //    authorizationValue) to httpRequests header list.\n      if (authorizationValue !== null) {\n        httpRequest.headersList.append('Authorization', authorizationValue, false)\n      }\n    }\n  }\n\n  //    21. If theres a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequests cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequests method is unsafe and forwardResponses status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set responses URL list to a clone of httpRequests URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequests header list contains `Range`, then set responses\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set responses request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If responses status is 401, httpRequests response tainting is not \"cors\",\n  //     includeCredentials is true, and requests traversable for user prompts is\n  //     a traversable navigable:\n  if (response.status === 401 && httpRequest.responseTainting !== 'cors' && includeCredentials && isTraversableNavigable(request.traversableForUserPrompts)) {\n    // 2. If requests body is non-null, then:\n    if (request.body != null) {\n      // 1. If requests bodys source is null, then return a network error.\n      if (request.body.source == null) {\n        return makeNetworkError('expected non-null body source')\n      }\n\n      // 2. Set requests body to the body of the result of safely extracting\n      //    requests bodys source.\n      request.body = safelyExtractBody(request.body.source)[0]\n    }\n\n    // 3. If requests use-URL-credentials flag is unset or isAuthenticationFetch is\n    //    true, then:\n    if (request.useURLCredentials === undefined || isAuthenticationFetch) {\n      // 1. If fetchParams is canceled, then return the appropriate network error\n      //    for fetchParams.\n      if (isCancelled(fetchParams)) {\n        return makeAppropriateNetworkError(fetchParams)\n      }\n\n      // 2. Let username and password be the result of prompting the end user for a\n      //    username and password, respectively, in requests traversable for user prompts.\n      // TODO\n\n      // 3. Set the username given requests current URL and username.\n      // requestCurrentURL(request).username = TODO\n\n      // 4. Set the password given requests current URL and password.\n      // requestCurrentURL(request).password = TODO\n\n      // In browsers, the user will be prompted to enter a username/password before the request\n      // is re-sent. To prevent an infinite 401 loop, return the response for now.\n      // https://github.com/nodejs/undici/pull/4756\n      return response\n    }\n\n    // 4. Set response to the result of running HTTP-network-or-cache fetch given\n    //    fetchParams and true.\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(fetchParams, true)\n  }\n\n  // 15. If responses status is 407, then:\n  if (response.status === 407) {\n    // 1. If requests window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in requests window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // responses status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on requests mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfos final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connections\n  //    timing info, timingInfos post-redirect start time, and fetchParamss\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n  //    and requests bodys source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to requests header list.\n\n  //    4. Set timingInfos final network-request start time to the coarsened\n  //    shared current time given fetchParamss cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If requests body is non-null, and requests bodys source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of requests body in that buffer. If the user agent reads from\n  //        requests body beyond that buffers size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfos final network-response start time to the coarsened\n  //        shared current time given fetchParamss cross-origin isolated capability,\n  //        immediately after the user agents HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfos final network-response start time above.\n\n  //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If requests window is an environment settings object, make the\n  //        dialog available in requests window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit requests body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParamss process request end-of-body is\n  // non-null, then queue a fetch task given fetchParamss process request\n  // end-of-body and fetchParamss task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParamss process request body is non-null, then run\n      // fetchParamss process request body given bytess length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParamss process request end-of-body is non-null,\n      // then run fetchParamss process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParamss task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    return fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      pull: pullAlgorithm,\n      cancel: cancelAlgorithm,\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set responses body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and requests cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in responses header list, if any, and requests current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  if (!fetchParams.controller.resume) {\n    fetchParams.controller.on('terminated', onAborted)\n  }\n\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for responses message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfos decoded body size by bytess length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParamss controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesnt need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set responses aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParamss\n      //    controllers serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfos final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connections timing info, timingInfos post-redirect start\n          // time, and fetchParamss cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfos final network-request start time to the coarsened shared current time given\n          // fetchParamss cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfos final network-response start time to the coarsened shared current\n          // time given fetchParamss cross-origin isolated capability, immediately after the\n          // user agents HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return false\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          const decoders = []\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            const contentEncoding = headersList.get('content-encoding', true)\n            // \"All content-coding values are case-insensitive...\"\n            /** @type {string[]} */\n            const codings = contentEncoding ? contentEncoding.toLowerCase().split(',') : []\n\n            // Limit the number of content-encodings to prevent resource exhaustion.\n            // CVE fix similar to urllib3 (GHSA-gm62-xv2j-4w53) and curl (CVE-2022-32206).\n            const maxContentEncodings = 5\n            if (codings.length > maxContentEncodings) {\n              reject(new Error(`too many content-encodings in response: ${codings.length}, maximum allowed is ${maxContentEncodings}`))\n              return true\n            }\n\n            for (let i = codings.length - 1; i >= 0; --i) {\n              const coding = codings[i].trim()\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate({\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress({\n                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n                }))\n              } else if (coding === 'zstd' && hasZstd) {\n                decoders.push(zlib.createZstdDecompress({\n                  flush: zlib.constants.ZSTD_e_continue,\n                  finishFlush: zlib.constants.ZSTD_e_end\n                }))\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          const onError = this.onError.bind(this)\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, (err) => {\n                if (err) {\n                  this.onError(err)\n                }\n              }).on('error', onError)\n              : this.body.on('error', onError)\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from responses\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and responses header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfos encoded body size by bytess length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          // We need to support 200 for websocket over h2 as per RFC-8441\n          // Absence of session means H1\n          if ((socket.session != null && status !== 200) || (socket.session == null && status !== 101)) {\n            return false\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN4QixRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzNDLFFBQVEsK0RBQStELEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUM1RixhQUFhLG1CQUFPLENBQUMsNEJBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QixXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsUUFBUSxzREFBc0QsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3JGLFFBQVEsaURBQWlELEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDcEYsUUFBUSxrRUFBa0UsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQ2hHLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUN0RCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDNUMsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywwSUFBZ0Q7QUFDL0UsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUM5RCxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsb0VBQVU7QUFDL0MsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDZGQUE2Qjs7QUFFakU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQ0FBbUM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUJBQXVCO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTs7QUFFcEIsVUFBVSxtQkFBbUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQXVDO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFdBQVc7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBdUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGdCQUFnQjs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxzQ0FBc0MsZUFBZSxTQUFTLEdBQUcsU0FBUyxzQkFBc0I7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7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RUEscUNBQXFDLGNBQWM7O0FBRW5EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGVBQWUsdUJBQXVCLG9CQUFvQjtBQUNwSTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIG1ha2VSZXNwb25zZSxcbiAgZnJvbUlubmVyUmVzcG9uc2UsXG4gIGdldFJlc3BvbnNlU3RhdGVcbn0gPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbmNvbnN0IHsgSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IFJlcXVlc3QsIGNsb25lUmVxdWVzdCwgZ2V0UmVxdWVzdERpc3BhdGNoZXIsIGdldFJlcXVlc3RTdGF0ZSB9ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3Qge1xuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgcmVxdWVzdEJhZFBvcnQsXG4gIFRBT0NoZWNrLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCxcbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBjb3JzQ2hlY2ssXG4gIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcixcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIHNhbWVPcmlnaW4sXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgdXJsSGFzSHR0cHNTY2hlbWUsXG4gIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlLFxuICBoYXNBdXRoZW50aWNhdGlvbkVudHJ5LFxuICBpbmNsdWRlc0NyZWRlbnRpYWxzLFxuICBpc1RyYXZlcnNhYmxlTmF2aWdhYmxlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgc2FmZWx5RXh0cmFjdEJvZHksIGV4dHJhY3RCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzU2V0LFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgc3VicmVzb3VyY2VTZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHsgUmVhZGFibGUsIHBpcGVsaW5lLCBmaW5pc2hlZCwgaXNFcnJvcmVkLCBpc1JlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIsIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGRhdGFVUkxQcm9jZXNzb3IsIHNlcmlhbGl6ZUFNaW1lVHlwZSwgbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2dsb2JhbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgU1RBVFVTX0NPREVTIH0gPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3QgeyBieXRlc01hdGNoIH0gPSByZXF1aXJlKCcuLi9zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvc3VicmVzb3VyY2UtaW50ZWdyaXR5JylcbmNvbnN0IHsgY3JlYXRlRGVmZXJyZWRQcm9taXNlIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL3Byb21pc2UnKVxuY29uc3QgeyBpc29tb3JwaGljRW5jb2RlIH0gPSByZXF1aXJlKCcuLi9pbmZyYScpXG5jb25zdCB7IHJ1bnRpbWVGZWF0dXJlcyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ydW50aW1lLWZlYXR1cmVzJylcblxuLy8gTm9kZS5qcyB2MjMuOC4wKyBhbmQgdjIyLjE1LjArIHN1cHBvcnRzIFpzdGFuZGFyZFxuY29uc3QgaGFzWnN0ZCA9IHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ3pzdGQnKVxuXG5jb25zdCBHRVRfT1JfSEVBRCA9IFsnR0VUJywgJ0hFQUQnXVxuXG5jb25zdCBkZWZhdWx0VXNlckFnZW50ID0gdHlwZW9mIF9fVU5ESUNJX0lTX05PREVfXyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVzYnVpbGREZXRlY3Rpb24gIT09ICd1bmRlZmluZWQnXG4gID8gJ25vZGUnXG4gIDogJ3VuZGljaSdcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2J1ZmZlcicpLnJlc29sdmVPYmplY3RVUkx9ICovXG5sZXQgcmVzb2x2ZU9iamVjdFVSTFxuXG5jbGFzcyBGZXRjaCBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoZXIpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyXG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuZHVtcCA9IGZhbHNlXG4gICAgdGhpcy5zdGF0ZSA9ICdvbmdvaW5nJ1xuICB9XG5cbiAgdGVybWluYXRlIChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KHJlYXNvbilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCByZWFzb24pXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtY29udHJvbGxlci1hYm9ydFxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAxLiBTZXQgY29udHJvbGxlcuKAmXMgc3RhdGUgdG8gXCJhYm9ydGVkXCIuXG4gICAgdGhpcy5zdGF0ZSA9ICdhYm9ydGVkJ1xuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrRXJyb3IgYmUgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIC8vIDMuIFNldCBlcnJvciB0byBmYWxsYmFja0Vycm9yIGlmIGl0IGlzIG5vdCBnaXZlbi5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIExldCBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShlcnJvcikuXG4gICAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIGNhdGNoIGl0LCBhbmQgbGV0XG4gICAgLy8gICAgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZmFsbGJhY2tFcnJvcikuXG5cbiAgICAvLyA1LiBTZXQgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gdG8gc2VyaWFsaXplZEVycm9yLlxuICAgIHRoaXMuc2VyaWFsaXplZEFib3J0UmVhc29uID0gZXJyb3JcblxuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShlcnJvcilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCBlcnJvcilcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGZXRjaERvbmUgKHJlc3BvbnNlKSB7XG4gIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCAnZmV0Y2gnKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtbWV0aG9kXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2xvYmFsVGhpcy5mZXRjaCcpXG5cbiAgLy8gMS4gTGV0IHAgYmUgYSBuZXcgcHJvbWlzZS5cbiAgbGV0IHAgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDIuIExldCByZXF1ZXN0T2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAgLy8gUmVxdWVzdCBhcyBjb25zdHJ1Y3RvciB3aXRoIGlucHV0IGFuZCBpbml0IGFzIGFyZ3VtZW50cy4gSWYgdGhpcyB0aHJvd3NcbiAgLy8gYW4gZXhjZXB0aW9uLCByZWplY3QgcCB3aXRoIGl0IGFuZCByZXR1cm4gcC5cbiAgbGV0IHJlcXVlc3RPYmplY3RcblxuICB0cnkge1xuICAgIHJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHAucmVqZWN0KGUpXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gMy4gTGV0IHJlcXVlc3QgYmUgcmVxdWVzdE9iamVjdOKAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGdldFJlcXVlc3RTdGF0ZShyZXF1ZXN0T2JqZWN0KVxuXG4gIC8vIDQuIElmIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgaWYgKHJlcXVlc3RPYmplY3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAvLyAxLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgbnVsbCwgYW5kXG4gICAgLy8gICAgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCBudWxsLCByZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAvLyAyLiBSZXR1cm4gcC5cbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyA1LiBMZXQgZ2xvYmFsT2JqZWN0IGJlIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgY29uc3QgZ2xvYmFsT2JqZWN0ID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgLy8gNi4gSWYgZ2xvYmFsT2JqZWN0IGlzIGEgU2VydmljZVdvcmtlckdsb2JhbFNjb3BlIG9iamVjdCwgdGhlbiBzZXRcbiAgLy8gcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gIGlmIChnbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnU2VydmljZVdvcmtlckdsb2JhbFNjb3BlJykge1xuICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgfVxuXG4gIC8vIDcuIExldCByZXNwb25zZU9iamVjdCBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2VPYmplY3QgPSBudWxsXG5cbiAgLy8gOC4gTGV0IHJlbGV2YW50UmVhbG0gYmUgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG5cbiAgLy8gOS4gTGV0IGxvY2FsbHlBYm9ydGVkIGJlIGZhbHNlLlxuICBsZXQgbG9jYWxseUFib3J0ZWQgPSBmYWxzZVxuXG4gIC8vIDEwLiBMZXQgY29udHJvbGxlciBiZSBudWxsLlxuICBsZXQgY29udHJvbGxlciA9IG51bGxcblxuICAvLyAxMS4gQWRkIHRoZSBmb2xsb3dpbmcgYWJvcnQgc3RlcHMgdG8gcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFsOlxuICBhZGRBYm9ydExpc3RlbmVyKFxuICAgIHJlcXVlc3RPYmplY3Quc2lnbmFsLFxuICAgICgpID0+IHtcbiAgICAgIC8vIDEuIFNldCBsb2NhbGx5QWJvcnRlZCB0byB0cnVlLlxuICAgICAgbG9jYWxseUFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIEFzc2VydDogY29udHJvbGxlciBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChjb250cm9sbGVyICE9IG51bGwpXG5cbiAgICAgIC8vIDMuIEFib3J0IGNvbnRyb2xsZXIgd2l0aCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQocmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgICBjb25zdCByZWFsUmVzcG9uc2UgPSByZXNwb25zZU9iamVjdD8uZGVyZWYoKVxuXG4gICAgICAvLyA0LiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsXG4gICAgICAvLyAgICBhbmQgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlYWxSZXNwb25zZSwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuICAgIH1cbiAgKVxuXG4gIC8vIDEyLiBMZXQgaGFuZGxlRmV0Y2hEb25lIGdpdmVuIHJlc3BvbnNlIHJlc3BvbnNlIGJlIHRvIGZpbmFsaXplIGFuZFxuICAvLyByZXBvcnQgdGltaW5nIHdpdGggcmVzcG9uc2UsIGdsb2JhbE9iamVjdCwgYW5kIFwiZmV0Y2hcIi5cbiAgLy8gc2VlIGZ1bmN0aW9uIGhhbmRsZUZldGNoRG9uZVxuXG4gIC8vIDEzLiBTZXQgY29udHJvbGxlciB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZmV0Y2ggZ2l2ZW4gcmVxdWVzdCxcbiAgLy8gd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIGhhbmRsZUZldGNoRG9uZSwgYW5kIHByb2Nlc3NSZXNwb25zZVxuICAvLyBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdWJzdGVwczpcblxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAvLyAxLiBJZiBsb2NhbGx5QWJvcnRlZCBpcyB0cnVlLCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKGxvY2FsbHlBYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBJZiByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgLy8gMS4gTGV0IGRlc2VyaWFsaXplZEVycm9yIGJlIHRoZSByZXN1bHQgb2YgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkXG4gICAgICAvLyAgICBhYm9ydCByZWFzb24gZ2l2ZW4gY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kXG4gICAgICAvLyAgICByZWxldmFudFJlYWxtLlxuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGFuZFxuICAgICAgLy8gICAgZGVzZXJpYWxpemVkRXJyb3IuXG5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlamVjdCBwIHdpdGggYSBUeXBlRXJyb3JcbiAgICAvLyBhbmQgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBwLnJlamVjdChuZXcgVHlwZUVycm9yKCdmZXRjaCBmYWlsZWQnLCB7IGNhdXNlOiByZXNwb25zZS5lcnJvciB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZU9iamVjdCB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgcmVsZXZhbnRSZWFsbS5cbiAgICByZXNwb25zZU9iamVjdCA9IG5ldyBXZWFrUmVmKGZyb21Jbm5lclJlc3BvbnNlKHJlc3BvbnNlLCAnaW1tdXRhYmxlJykpXG5cbiAgICAvLyA1LiBSZXNvbHZlIHAgd2l0aCByZXNwb25zZU9iamVjdC5cbiAgICBwLnJlc29sdmUocmVzcG9uc2VPYmplY3QuZGVyZWYoKSlcbiAgICBwID0gbnVsbFxuICB9XG5cbiAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBkaXNwYXRjaGVyOiBnZXRSZXF1ZXN0RGlzcGF0Y2hlcihyZXF1ZXN0T2JqZWN0KSAvLyB1bmRpY2lcbiAgfSlcblxuICAvLyAxNC4gUmV0dXJuIHAuXG4gIHJldHVybiBwLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLWFuZC1yZXBvcnQtdGltaW5nXG5mdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyAocmVzcG9uc2UsIGluaXRpYXRvclR5cGUgPSAnb3RoZXInKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmIHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBudWxsIG9yIGVtcHR5LCB0aGVuIHJldHVybi5cbiAgaWYgKCFyZXNwb25zZS51cmxMaXN0Py5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDMuIExldCBvcmlnaW5hbFVSTCBiZSByZXNwb25zZeKAmXMgVVJMIGxpc3RbMF0uXG4gIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXVxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvXG5cbiAgLy8gNS4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAvLyA2LiBJZiBvcmlnaW5hbFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUob3JpZ2luYWxVUkwpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA3LiBJZiB0aW1pbmdJbmZvIGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gOC4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuOlxuICBpZiAoIXJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkKSB7XG4gICAgLy8gIDEuIFNldCB0aW1pbmdJbmZvIHRvIGEgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBvcGFxdWUgdGltaW5nIGluZm8gZm9yIHRpbWluZ0luZm8uXG4gICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgc3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICAgIH0pXG5cbiAgICAvLyAgMi4gU2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICBjYWNoZVN0YXRlID0gJydcbiAgfVxuXG4gIC8vIDkuIFNldCB0aW1pbmdJbmZv4oCZcyBlbmQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWVcbiAgLy8gZ2l2ZW4gZ2xvYmFs4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5LlxuICAvLyBUT0RPOiBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHk/XG4gIHRpbWluZ0luZm8uZW5kVGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKClcblxuICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aW1pbmdJbmZvLlxuICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mb1xuXG4gIC8vIDExLiBNYXJrIHJlc291cmNlIHRpbWluZyBmb3IgdGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsXG4gIC8vIGdsb2JhbCwgYW5kIGNhY2hlU3RhdGUuXG4gIG1hcmtSZXNvdXJjZVRpbWluZyhcbiAgICB0aW1pbmdJbmZvLFxuICAgIG9yaWdpbmFsVVJMLmhyZWYsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGUsXG4gICAgJycsIC8vIGJvZHlUeXBlXG4gICAgcmVzcG9uc2Uuc3RhdHVzXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3Jlc291cmNlLXRpbWluZy8jZGZuLW1hcmstcmVzb3VyY2UtdGltaW5nXG5jb25zdCBtYXJrUmVzb3VyY2VUaW1pbmcgPSBwZXJmb3JtYW5jZS5tYXJrUmVzb3VyY2VUaW1pbmdcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0LWZldGNoXG5mdW5jdGlvbiBhYm9ydEZldGNoIChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgZXJyb3IpIHtcbiAgLy8gMS4gUmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgaWYgKHApIHtcbiAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgcmVzb2x2ZWQgdGhlIHByb21pc2UgYXQgdGhpcyBzdGFnZVxuICAgIHAucmVqZWN0KGVycm9yKVxuICB9XG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gY2FuY2VsIHJlcXVlc3TigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlcXVlc3QuYm9keT8uc3RyZWFtICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXF1ZXN0LmJvZHkuc3RyZWFtKSkge1xuICAgIHJlcXVlc3QuYm9keS5zdHJlYW0uY2FuY2VsKGVycm9yKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9TVEFURScpIHtcbiAgICAgICAgLy8gTm9kZSBidWc/XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHJlc3BvbnNlT2JqZWN0IGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAocmVzcG9uc2VPYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZS5cbiAgY29uc3QgcmVzcG9uc2UgPSBnZXRSZXNwb25zZVN0YXRlKHJlc3BvbnNlT2JqZWN0KVxuXG4gIC8vIDUuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciByZXNwb25zZeKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVzcG9uc2UuYm9keT8uc3RyZWFtICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXNwb25zZS5ib2R5LnN0cmVhbSkpIHtcbiAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaGluZ1xuZnVuY3Rpb24gZmV0Y2hpbmcgKHtcbiAgcmVxdWVzdCxcbiAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2UsXG4gIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgZGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXIoKSAvLyB1bmRpY2lcbn0pIHtcbiAgLy8gRW5zdXJlIHRoYXQgdGhlIGRpc3BhdGNoZXIgaXMgc2V0IGFjY29yZGluZ2x5XG4gIGFzc2VydChkaXNwYXRjaGVyKVxuXG4gIC8vIDEuIExldCB0YXNrRGVzdGluYXRpb24gYmUgbnVsbC5cbiAgbGV0IHRhc2tEZXN0aW5hdGlvbiA9IG51bGxcblxuICAvLyAyLiBMZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgYmUgZmFsc2UuXG4gIGxldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSA9IGZhbHNlXG5cbiAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuOlxuICBpZiAocmVxdWVzdC5jbGllbnQgIT0gbnVsbCkge1xuICAgIC8vIDEuIFNldCB0YXNrRGVzdGluYXRpb24gdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICAgIHRhc2tEZXN0aW5hdGlvbiA9IHJlcXVlc3QuY2xpZW50Lmdsb2JhbE9iamVjdFxuXG4gICAgLy8gMi4gU2V0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IHRvIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgY3Jvc3Mtb3JpZ2luXG4gICAgLy8gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSA9XG4gICAgICByZXF1ZXN0LmNsaWVudC5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNC4gSWYgdXNlUGFyYWxsZWxRdWV1ZSBpcyB0cnVlLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cbiAgLy8gVE9ET1xuXG4gIC8vIDUuIExldCB0aW1pbmdJbmZvIGJlIGEgbmV3IGZldGNoIHRpbWluZyBpbmZvIHdob3NlIHN0YXJ0IHRpbWUgYW5kXG4gIC8vIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSBhcmUgdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuXG4gIC8vIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBjdXJyZW50VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICBjb25zdCB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZVxuICB9KVxuXG4gIC8vIDYuIExldCBmZXRjaFBhcmFtcyBiZSBhIG5ldyBmZXRjaCBwYXJhbXMgd2hvc2VcbiAgLy8gcmVxdWVzdCBpcyByZXF1ZXN0LFxuICAvLyB0aW1pbmcgaW5mbyBpcyB0aW1pbmdJbmZvLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgYm9keSBjaHVuayBsZW5ndGggaXMgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBpcyBwcm9jZXNzUmVzcG9uc2UsXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgLy8gdGFzayBkZXN0aW5hdGlvbiBpcyB0YXNrRGVzdGluYXRpb24sXG4gIC8vIGFuZCBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSBpcyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEZldGNoKGRpc3BhdGNoZXIpLFxuICAgIHJlcXVlc3QsXG4gICAgdGltaW5nSW5mbyxcbiAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgIHRhc2tEZXN0aW5hdGlvbixcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG9cbiAgLy8gICAgcmVxdWVzdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gIC8vIE5PVEU6IFNpbmNlIGZldGNoaW5nIGlzIG9ubHkgY2FsbGVkIGZyb20gZmV0Y2gsIGJvZHkgc2hvdWxkIGFscmVhZHkgYmVcbiAgLy8gZXh0cmFjdGVkLlxuICBhc3NlcnQoIXJlcXVlc3QuYm9keSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyB3aW5kb3cgdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW50LCBpZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QgaXMgYSBXaW5kb3cgb2JqZWN0OyBvdGhlcndpc2VcbiAgLy8gXCJuby13aW5kb3dcIi5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnY2xpZW50Jykge1xuICAgIC8vIFRPRE86IFdoYXQgaWYgcmVxdWVzdC5jbGllbnQgaXMgbnVsbD9cbiAgICByZXF1ZXN0LndpbmRvdyA9XG4gICAgICByZXF1ZXN0LmNsaWVudD8uZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1dpbmRvdydcbiAgICAgICAgPyByZXF1ZXN0LmNsaWVudFxuICAgICAgICA6ICduby13aW5kb3cnXG4gIH1cblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudOKAmXMgb3JpZ2luLlxuICBpZiAocmVxdWVzdC5vcmlnaW4gPT09ICdjbGllbnQnKSB7XG4gICAgcmVxdWVzdC5vcmlnaW4gPSByZXF1ZXN0LmNsaWVudC5vcmlnaW5cbiAgfVxuXG4gIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXIgaXMgXCJjbGllbnRcIiwgdGhlbjpcbiAgaWYgKHJlcXVlc3QucG9saWN5Q29udGFpbmVyID09PSAnY2xpZW50Jykge1xuICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIGNsaWVudCBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcG9saWN5XG4gICAgLy8gY29udGFpbmVyIHRvIGEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBwb2xpY3kgY29udGFpbmVyLiBbSFRNTF1cbiAgICBpZiAocmVxdWVzdC5jbGllbnQgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5wb2xpY3lDb250YWluZXIgPSBjbG9uZVBvbGljeUNvbnRhaW5lcihcbiAgICAgICAgcmVxdWVzdC5jbGllbnQucG9saWN5Q29udGFpbmVyXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDIuIE90aGVyd2lzZSwgc2V0IHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXIgdG8gYSBuZXcgcG9saWN5XG4gICAgICAvLyBjb250YWluZXIuXG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IG1ha2VQb2xpY3lDb250YWluZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBY2NlcHRgLCB0aGVuOlxuICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdCcsIHRydWUpKSB7XG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIGAqLypgLlxuICAgIGNvbnN0IHZhbHVlID0gJyovKidcblxuICAgIC8vIDIuIEEgdXNlciBhZ2VudCBzaG91bGQgc2V0IHZhbHVlIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBzdGF0ZW1lbnQsIGlmXG4gICAgLy8gYW55LCBzd2l0Y2hpbmcgb24gcmVxdWVzdOKAmXMgZGVzdGluYXRpb246XG4gICAgLy8gXCJkb2N1bWVudFwiXG4gICAgLy8gXCJmcmFtZVwiXG4gICAgLy8gXCJpZnJhbWVcIlxuICAgIC8vIGB0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSwqLyo7cT0wLjhgXG4gICAgLy8gXCJpbWFnZVwiXG4gICAgLy8gYGltYWdlL3BuZyxpbWFnZS9zdmcreG1sLGltYWdlLyo7cT0wLjgsKi8qO3E9MC41YFxuICAgIC8vIFwic3R5bGVcIlxuICAgIC8vIGB0ZXh0L2NzcywqLyo7cT0wLjFgXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMy4gQXBwZW5kIGBBY2NlcHRgL3ZhbHVlIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQnLCB2YWx1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBY2NlcHQtTGFuZ3VhZ2VgLCB0aGVuXG4gIC8vIHVzZXIgYWdlbnRzIHNob3VsZCBhcHBlbmQgYEFjY2VwdC1MYW5ndWFnZWAvYW4gYXBwcm9wcmlhdGUgdmFsdWUgdG9cbiAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0LWxhbmd1YWdlJywgdHJ1ZSkpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWxhbmd1YWdlJywgJyonLCB0cnVlKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIHByaW9yaXR5IGlzIG51bGwsIHRoZW4gdXNlIHJlcXVlc3TigJlzIGluaXRpYXRvciBhbmRcbiAgLy8gZGVzdGluYXRpb24gYXBwcm9wcmlhdGVseSBpbiBzZXR0aW5nIHJlcXVlc3TigJlzIHByaW9yaXR5IHRvIGFcbiAgLy8gdXNlci1hZ2VudC1kZWZpbmVkIG9iamVjdC5cbiAgaWYgKHJlcXVlc3QucHJpb3JpdHkgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxNS4gSWYgcmVxdWVzdCBpcyBhIHN1YnJlc291cmNlIHJlcXVlc3QsIHRoZW46XG4gIGlmIChzdWJyZXNvdXJjZVNldC5oYXMocmVxdWVzdC5kZXN0aW5hdGlvbikpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxNi4gUnVuIG1haW4gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gIG1haW5GZXRjaChmZXRjaFBhcmFtcywgZmFsc2UpXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUpIHtcbiAgdHJ5IHtcbiAgICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gICAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gICAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gICAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgbG9jYWwtVVJMcy1vbmx5IGZsYWcgaXMgc2V0IGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTCBpc1xuICAgIC8vIG5vdCBsb2NhbCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2xvY2FsIFVSTHMgb25seScpXG4gICAgfVxuXG4gICAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDUuIFVwZ3JhZGUgcmVxdWVzdCB0byBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgaWYgYXBwcm9wcmlhdGUuXG4gICAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgICAvLyA2LiBJZiBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBhIGJhZCBwb3J0LCBzaG91bGQgZmV0Y2hpbmcgcmVxdWVzdFxuICAgIC8vIGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudCwgb3Igc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50XG4gICAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChyZXF1ZXN0QmFkUG9ydChyZXF1ZXN0KSA9PT0gJ2Jsb2NrZWQnKSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2JhZCBwb3J0JylcbiAgICB9XG4gICAgLy8gVE9ETzogc2hvdWxkIGZldGNoaW5nIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50P1xuICAgIC8vIFRPRE86IHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3k/XG5cbiAgICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgICAvLyByZWZlcnJlciBwb2xpY3kgdG8gcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lcuKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgIGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gICAgfVxuXG4gICAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICBpZiAocmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdClcbiAgICB9XG5cbiAgICAvLyA5LiBTZXQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSB0byBcImh0dHBzXCIgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAgIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAgIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgaXMgYSBkb21haW5cbiAgICAvLyAtIE1hdGNoaW5nIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IHBlciBLbm93biBIU1RTIEhvc3QgRG9tYWluIE5hbWVcbiAgICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAgIC8vICAgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlIG9yIGEgY29uZ3J1ZW50IG1hdGNoICh3aXRoIG9yIHdpdGhvdXQgYW5cbiAgICAvLyAgIGFzc2VydGVkIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSkuIFtIU1RTXVxuICAgIC8vIFRPRE9cblxuICAgIC8vIDEwLiBJZiByZWN1cnNpdmUgaXMgZmFsc2UsIHRoZW4gcnVuIHRoZSByZW1haW5pbmcgc3RlcHMgaW4gcGFyYWxsZWwuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgIC8vIHRoZSBzdGVwcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBzdGF0ZW1lbnQ6XG4gICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAgIGlmIChcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgb3JpZ2luLFxuICAgICAgICAvLyAgIGFuZCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImJhc2ljXCJcbiAgICAgICAgKHNhbWVPcmlnaW4oY3VycmVudFVSTCwgcmVxdWVzdC51cmwpICYmIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykgfHxcbiAgICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIlxuICAgICAgICAoY3VycmVudFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgfHxcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICAgIChyZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JylcbiAgICAgICkge1xuICAgICAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJiYXNpY1wiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnYmFzaWMnXG5cbiAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJzYW1lLW9yaWdpblwiXG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgICAvLyAxLiBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ3JlcXVlc3QgbW9kZSBjYW5ub3QgYmUgXCJzYW1lLW9yaWdpblwiJylcblxuICAgICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIlxuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIG5vdCBcImZvbGxvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnZm9sbG93Jykge1xuICAgICAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAyLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJvcGFxdWVcIi5cbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnb3BhcXVlJ1xuXG4gICAgICAgICAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgICAgfVxuICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWVcbiAgICAgIH0gZWxzZSBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJylcblxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIHVuc2FmZS1yZXF1ZXN0IGZsYWcgaXMgc2V0IGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gICAgICAgIC8vICAgbm90IGEgQ09SUy1zYWZlbGlzdGVkIG1ldGhvZCBvciBDT1JTLXVuc2FmZSByZXF1ZXN0LWhlYWRlciBuYW1lcyB3aXRoXG4gICAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAgIC8vICAgIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImNvcnNcIi5cbiAgICAgICAgLy8gICAgMi4gTGV0IGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2hcbiAgICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAgIC8vICAgIDMuIElmIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIGNsZWFyIGNhY2hlXG4gICAgICAgIC8vICAgIGVudHJpZXMgdXNpbmcgcmVxdWVzdC5cbiAgICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAgIC8vIFRPRE9cblxuICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdjb3JzJ1xuXG4gICAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTIuIElmIHJlY3Vyc2l2ZSBpcyB0cnVlLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9XG5cbiAgICAvLyAxMy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWRcbiAgICAvLyByZXNwb25zZSwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmICFyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgICAvLyBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiwgdGhlbjpcbiAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgICAvLyAxLiBMZXQgaGVhZGVyTmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgICAvLyBnaXZlbiBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZSBpcyBub3QgXCJpbmNsdWRlXCIgYW5kIGhlYWRlck5hbWVzXG4gICAgICAgIC8vIGNvbnRhaW5zIGAqYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvXG4gICAgICAgIC8vIGFsbCB1bmlxdWUgaGVhZGVyIG5hbWVzIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIGhlYWRlck5hbWVzIGlzIG5vdCBudWxsIG9yIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgICAgIC8vIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0byBoZWFkZXJOYW1lcy5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAgICAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2Jhc2ljJylcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2NvcnMnKVxuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdvcGFxdWUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDE0LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLFxuICAgIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICAgIGxldCBpbnRlcm5hbFJlc3BvbnNlID1cbiAgICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gMCA/IHJlc3BvbnNlIDogcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuXG4gICAgLy8gMTUuIElmIGludGVybmFsUmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LCB0aGVuIHNldCBpdCB0byBhIGNsb25lIG9mXG4gICAgLy8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gICAgaWYgKGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5wdXNoKC4uLnJlcXVlc3QudXJsTGlzdClcbiAgICB9XG5cbiAgICAvLyAxNi4gSWYgcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnIGlzIHVuc2V0LCB0aGVuIHNldFxuICAgIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZy5cbiAgICBpZiAoIXJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQpIHtcbiAgICAgIHJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDE3LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBhbnkgb2YgdGhlIGZvbGxvd2luZyByZXR1cm5zXG4gICAgLy8gYmxvY2tlZFxuICAgIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnRcbiAgICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeVxuICAgIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBpdHMgTUlNRSB0eXBlXG4gICAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIG5vc25pZmZcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAxOC4gSWYgcmVzcG9uc2XigJlzIHR5cGUgaXMgXCJvcGFxdWVcIiwgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDIwNixcbiAgICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZyBpcyBzZXQsIGFuZCByZXF1ZXN04oCZcyBoZWFkZXJcbiAgICAvLyBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2UgYW5kIGludGVybmFsUmVzcG9uc2VcbiAgICAvLyB0byBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKFxuICAgICAgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScgJiZcbiAgICAgIGludGVybmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgJiZcbiAgICAgIGludGVybmFsUmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgJiZcbiAgICAgICFyZXF1ZXN0LmhlYWRlcnMuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICAgIH1cblxuICAgIC8vIDE5LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gICAgLy8gYEhFQURgIG9yIGBDT05ORUNUYCwgb3IgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cyxcbiAgICAvLyBzZXQgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keSB0byBudWxsIGFuZCBkaXNyZWdhcmQgYW55IGVucXVldWluZyB0b3dhcmRcbiAgICAvLyBpdCAoaWYgYW55KS5cbiAgICBpZiAoXG4gICAgICByZXNwb25zZS5zdGF0dXMgIT09IDAgJiZcbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgICAgbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMpKVxuICAgICkge1xuICAgICAgaW50ZXJuYWxSZXNwb25zZS5ib2R5ID0gbnVsbFxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kdW1wID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDIwLiBJZiByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QuaW50ZWdyaXR5KSB7XG4gICAgICAvLyAxLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXNcbiAgICAgIC8vIGFuZCBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKHJlYXNvbikgPT5cbiAgICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIG1ha2VOZXR3b3JrRXJyb3IocmVhc29uKSlcblxuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJvcGFxdWVcIiwgb3IgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCxcbiAgICAgIC8vIHRoZW4gcnVuIHByb2Nlc3NCb2R5RXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgICBjb25zdCBwcm9jZXNzQm9keSA9IChieXRlcykgPT4ge1xuICAgICAgICAvLyAxLiBJZiBieXRlcyBkbyBub3QgbWF0Y2ggcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLFxuICAgICAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy4gW1NSSV1cbiAgICAgICAgaWYgKCFieXRlc01hdGNoKGJ5dGVzLCByZXF1ZXN0LmludGVncml0eSkpIHtcbiAgICAgICAgICBwcm9jZXNzQm9keUVycm9yKCdpbnRlZ3JpdHkgbWlzbWF0Y2gnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJ5dGVzIGFzIGEgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXVxuXG4gICAgICAgIC8vIDMuIFJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIEZ1bGx5IHJlYWQgcmVzcG9uc2XigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHkgYW5kIHByb2Nlc3NCb2R5RXJyb3IuXG4gICAgICBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAyMS4gT3RoZXJ3aXNlLCBydW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycilcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1zY2hlbWUtZmV0Y2hcbi8vIGdpdmVuIGEgZmV0Y2ggcGFyYW1zIGZldGNoUGFyYW1zXG5mdW5jdGlvbiBzY2hlbWVGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gTm90ZTogc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgZGVzdHJveWVkIG9uIHJlZGlyZWN0LCB3aGljaCBzZXRzIGZldGNoUGFyYW1zIHRvIGFcbiAgLy8gY2FuY2VsbGVkIHN0YXRlLCB3ZSBkbyBub3Qgd2FudCB0aGlzIGNvbmRpdGlvbiB0byB0cmlnZ2VyICp1bmxlc3MqIHRoZXJlIGhhdmUgYmVlblxuICAvLyBubyByZWRpcmVjdHMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTc3NlxuICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpICYmIGZldGNoUGFyYW1zLnJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKSlcbiAgfVxuXG4gIC8vIDIuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCB7IHJlcXVlc3QgfSA9IGZldGNoUGFyYW1zXG5cbiAgY29uc3QgeyBwcm90b2NvbDogc2NoZW1lIH0gPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGFuZCBydW4gdGhlIGFzc29jaWF0ZWQgc3RlcHM6XG4gIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgY2FzZSAnYWJvdXQ6Jzoge1xuICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHBhdGggaXMgdGhlIHN0cmluZyBcImJsYW5rXCIsIHRoZW4gcmV0dXJuIGEgbmV3IHJlc3BvbnNlXG4gICAgICAvLyB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLCBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIGB0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOGApIMK7LFxuICAgICAgLy8gYW5kIGJvZHkgaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UgYXMgYSBib2R5LlxuXG4gICAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Fib3V0IHNjaGVtZSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuICAgIGNhc2UgJ2Jsb2I6Jzoge1xuICAgICAgaWYgKCFyZXNvbHZlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJlc29sdmVPYmplY3RVUkwgPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLnJlc29sdmVPYmplY3RVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMS4gTGV0IGJsb2JVUkxFbnRyeSBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgYmxvYiBVUkwgZW50cnkuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnkgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9ibG9iLzdiMGViYWNjYzYyYjU2NmExOTY1Mzk2ZTViZTdiYjJiYzA2Zjg0MWYvRmlsZUFQSS91cmwvcmVzb3VyY2VzL2ZldGNoLXRlc3RzLmpzI0w1Mi1MNTZcbiAgICAgIC8vIEJ1ZmZlci5yZXNvbHZlT2JqZWN0VVJMIGRvZXMgbm90IGlnbm9yZSBVUkwgcXVlcmllcy5cbiAgICAgIGlmIChibG9iVVJMRW50cnkuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2IgPSByZXNvbHZlT2JqZWN0VVJMKGJsb2JVUkxFbnRyeS50b1N0cmluZygpKVxuXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgLCBibG9iVVJMRW50cnkgaXMgbnVsbCwgb3IgYmxvYlVSTEVudHJ54oCZc1xuICAgICAgLy8gICAgb2JqZWN0IGlzIG5vdCBhIEJsb2Igb2JqZWN0LCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnIHx8ICF3ZWJpZGwuaXMuQmxvYihibG9iKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ludmFsaWQgbWV0aG9kJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBibG9iIGJlIGJsb2JVUkxFbnRyeeKAmXMgb2JqZWN0LlxuICAgICAgLy8gTm90ZTogZG9uZSBhYm92ZVxuXG4gICAgICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgYSBuZXcgcmVzcG9uc2UuXG4gICAgICBjb25zdCByZXNwb25zZSA9IG1ha2VSZXNwb25zZSgpXG5cbiAgICAgIC8vIDUuIExldCBmdWxsTGVuZ3RoIGJlIGJsb2LigJlzIHNpemUuXG4gICAgICBjb25zdCBmdWxsTGVuZ3RoID0gYmxvYi5zaXplXG5cbiAgICAgIC8vIDYuIExldCBzZXJpYWxpemVkRnVsbExlbmd0aCBiZSBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICBjb25zdCBzZXJpYWxpemVkRnVsbExlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7ZnVsbExlbmd0aH1gKVxuXG4gICAgICAvLyA3LiBMZXQgdHlwZSBiZSBibG9i4oCZcyB0eXBlLlxuICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZVxuXG4gICAgICAvLyA4LiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWA6XG4gICAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICAgICAgLy8gMS4gTGV0IGJvZHlXaXRoVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHNhZmVseSBleHRyYWN0aW5nIGJsb2IuXG4gICAgICAgIC8vIE5vdGU6IGluIHRoZSBGaWxlQVBJIGEgYmxvYiBcIm9iamVjdFwiIGlzIGEgQmxvYiAqb3IqIGEgTWVkaWFTb3VyY2UuXG4gICAgICAgIC8vIEluIG5vZGUsIHRoaXMgY2FuIG9ubHkgZXZlciBiZSBhIEJsb2IuIFRoZXJlZm9yZSB3ZSBjYW4gc2FmZWx5XG4gICAgICAgIC8vIHVzZSBleHRyYWN0Qm9keSBkaXJlY3RseS5cbiAgICAgICAgY29uc3QgYm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoYmxvYilcblxuICAgICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBPS2AuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSAnT0snXG5cbiAgICAgICAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDQuIFNldCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgdG8gwqsgKGBDb250ZW50LUxlbmd0aGAsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoKSwgKGBDb250ZW50LVR5cGVgLCB0eXBlKSDCuy5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LWxlbmd0aCcsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtdHlwZScsIHR5cGUsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICAgICAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcblxuICAgICAgICAvLyAyLiBMZXQgcmFuZ2VIZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGBSYW5nZWAgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldCgncmFuZ2UnLCB0cnVlKVxuXG4gICAgICAgIC8vIDMuIExldCByYW5nZVZhbHVlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIHNpbmdsZSByYW5nZSBoZWFkZXIgdmFsdWUgZ2l2ZW4gcmFuZ2VIZWFkZXIgYW5kIHRydWUuXG4gICAgICAgIGNvbnN0IHJhbmdlVmFsdWUgPSBzaW1wbGVSYW5nZUhlYWRlclZhbHVlKHJhbmdlSGVhZGVyLCB0cnVlKVxuXG4gICAgICAgIC8vIDQuIElmIHJhbmdlVmFsdWUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICBpZiAocmFuZ2VWYWx1ZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBMZXQgKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSBiZSByYW5nZVZhbHVlLlxuICAgICAgICBsZXQgeyByYW5nZVN0YXJ0VmFsdWU6IHJhbmdlU3RhcnQsIHJhbmdlRW5kVmFsdWU6IHJhbmdlRW5kIH0gPSByYW5nZVZhbHVlXG5cbiAgICAgICAgLy8gNi4gSWYgcmFuZ2VTdGFydCBpcyBudWxsOlxuICAgICAgICAvLyA3LiBPdGhlcndpc2U6XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gMS4gU2V0IHJhbmdlU3RhcnQgdG8gZnVsbExlbmd0aCDiiJIgcmFuZ2VFbmQuXG4gICAgICAgICAgcmFuZ2VTdGFydCA9IGZ1bGxMZW5ndGggLSByYW5nZUVuZFxuXG4gICAgICAgICAgLy8gMi4gU2V0IHJhbmdlRW5kIHRvIHJhbmdlU3RhcnQgKyByYW5nZUVuZCDiiJIgMS5cbiAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyByYW5nZUVuZCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAxLiBJZiByYW5nZVN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBmdWxsTGVuZ3RoLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPj0gZnVsbExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdSYW5nZSBzdGFydCBpcyBncmVhdGVyIHRoYW4gdGhlIGJsb2JcXCdzIHNpemUuJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMi4gSWYgcmFuZ2VFbmQgaXMgbnVsbCBvciByYW5nZUVuZCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZnVsbExlbmd0aCwgdGhlbiBzZXRcbiAgICAgICAgICAvLyAgICByYW5nZUVuZCB0byBmdWxsTGVuZ3RoIOKIkiAxLlxuICAgICAgICAgIGlmIChyYW5nZUVuZCA9PT0gbnVsbCB8fCByYW5nZUVuZCA+PSBmdWxsTGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZUVuZCA9IGZ1bGxMZW5ndGggLSAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gTGV0IHNsaWNlZEJsb2IgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyBzbGljZSBibG9iIGdpdmVuIGJsb2IsIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgIHJhbmdlRW5kICsgMSwgYW5kIHR5cGUuXG4gICAgICAgIGNvbnN0IHNsaWNlZEJsb2IgPSBibG9iLnNsaWNlKHJhbmdlU3RhcnQsIHJhbmdlRW5kICsgMSwgdHlwZSlcblxuICAgICAgICAvLyA5LiBMZXQgc2xpY2VkQm9keVdpdGhUeXBlIGJlIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3Rpbmcgc2xpY2VkQmxvYi5cbiAgICAgICAgLy8gTm90ZTogc2FtZSByZWFzb24gYXMgbWVudGlvbmVkIGFib3ZlIGFzIHRvIHdoeSB3ZSB1c2UgZXh0cmFjdEJvZHlcbiAgICAgICAgY29uc3Qgc2xpY2VkQm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoc2xpY2VkQmxvYilcblxuICAgICAgICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIHNsaWNlZEJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNsaWNlZEJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDExLiBMZXQgc2VyaWFsaXplZFNsaWNlZExlbmd0aCBiZSBzbGljZWRCbG9i4oCZcyBzaXplLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRTbGljZWRMZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke3NsaWNlZEJsb2Iuc2l6ZX1gKVxuXG4gICAgICAgIC8vIDEyLiBMZXQgY29udGVudFJhbmdlIGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgYnVpbGQgYSBjb250ZW50IHJhbmdlIGdpdmVuIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgICByYW5nZUVuZCwgYW5kIGZ1bGxMZW5ndGguXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IGJ1aWxkQ29udGVudFJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKVxuXG4gICAgICAgIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyB0byAyMDYuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IDIwNlxuXG4gICAgICAgIC8vIDE0LiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBQYXJ0aWFsIENvbnRlbnRgLlxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gJ1BhcnRpYWwgQ29udGVudCdcblxuICAgICAgICAvLyAxNS4gU2V0IHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCB0byDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgc2VyaWFsaXplZFNsaWNlZExlbmd0aCksXG4gICAgICAgIC8vICAgICAoYENvbnRlbnQtVHlwZWAsIHR5cGUpLCAoYENvbnRlbnQtUmFuZ2VgLCBjb250ZW50UmFuZ2UpIMK7LlxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtbGVuZ3RoJywgc2VyaWFsaXplZFNsaWNlZExlbmd0aCwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXR5cGUnLCB0eXBlLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtcmFuZ2UnLCBjb250ZW50UmFuZ2UsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDEwLiBSZXR1cm4gcmVzcG9uc2UuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgIH1cbiAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgIC8vIDEuIExldCBkYXRhVVJMU3RydWN0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGVcbiAgICAgIC8vICAgIGRhdGE6IFVSTCBwcm9jZXNzb3Igb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAgIGNvbnN0IGRhdGFVUkxTdHJ1Y3QgPSBkYXRhVVJMUHJvY2Vzc29yKGN1cnJlbnRVUkwpXG5cbiAgICAgIC8vIDIuIElmIGRhdGFVUkxTdHJ1Y3QgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYVxuICAgICAgLy8gICAgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChkYXRhVVJMU3RydWN0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBtaW1lVHlwZSBiZSBkYXRhVVJMU3RydWN04oCZcyBNSU1FIHR5cGUsIHNlcmlhbGl6ZWQuXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShkYXRhVVJMU3RydWN0Lm1pbWVUeXBlKVxuXG4gICAgICAvLyA0LiBSZXR1cm4gYSByZXNwb25zZSB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLFxuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBtaW1lVHlwZSkgwrssXG4gICAgICAvLyAgICBhbmQgYm9keSBpcyBkYXRhVVJMU3RydWN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtdHlwZScsIHsgbmFtZTogJ0NvbnRlbnQtVHlwZScsIHZhbHVlOiBtaW1lVHlwZSB9XVxuICAgICAgICBdLFxuICAgICAgICBib2R5OiBzYWZlbHlFeHRyYWN0Qm9keShkYXRhVVJMU3RydWN0LmJvZHkpWzBdXG4gICAgICB9KSlcbiAgICB9XG4gICAgY2FzZSAnZmlsZTonOiB7XG4gICAgICAvLyBGb3Igbm93LCB1bmZvcnR1bmF0ZSBhcyBpdCBpcywgZmlsZSBVUkxzIGFyZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICAgICAgLy8gV2hlbiBpbiBkb3VidCwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignbm90IGltcGxlbWVudGVkLi4uIHlldC4uLicpKVxuICAgIH1cbiAgICBjYXNlICdodHRwOic6XG4gICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuXG4gICAgICByZXR1cm4gaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3Vua25vd24gc2NoZW1lJykpXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmaW5hbGl6ZS1yZXNwb25zZVxuZnVuY3Rpb24gZmluYWxpemVSZXNwb25zZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgLy8gMiwgSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBpcyBub3QgbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoXG4gIC8vIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgZ2l2ZW4gcmVzcG9uc2UsIHdpdGhcbiAgLy8gZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lKHJlc3BvbnNlKSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtZmluYWxlXG5mdW5jdGlvbiBmZXRjaEZpbmFsZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudCBpcyBhIHNlY3VyZSBjb250ZXh0LFxuICAvLyAgICB0aGVuIHNldCB0aW1pbmdJbmZv4oCZcyBzZXJ2ZXItdGltaW5nIGhlYWRlcnMgdG8gdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZ1xuICAvLyAgICBgU2VydmVyLVRpbWluZ2AgZnJvbSByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gMy4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgLy8gMS4gTGV0IHVuc2FmZUVuZFRpbWUgYmUgdGhlIHVuc2FmZSBzaGFyZWQgY3VycmVudCB0aW1lLlxuICAgIGNvbnN0IHVuc2FmZUVuZFRpbWUgPSBEYXRlLm5vdygpIC8vID9cblxuICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbiBpcyBcImRvY3VtZW50XCIsIHRoZW4gc2V0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZc1xuICAgIC8vICAgIGZ1bGwgdGltaW5nIGluZm8gdG8gZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmZ1bGxUaW1pbmdJbmZvID0gdGltaW5nSW5mb1xuICAgIH1cblxuICAgIC8vIDMuIFNldCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXMgcmVwb3J0IHRpbWluZyBzdGVwcyB0byB0aGUgZm9sbG93aW5nIHN0ZXBzIGdpdmVuIGEgZ2xvYmFsIG9iamVjdCBnbG9iYWw6XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXBvcnRUaW1pbmdTdGVwcyA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuLlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBlbmQgdGltZSB0byB0aGUgcmVsYXRpdmUgaGlnaCByZXNvbHV0aW9uIHRpbWUgZ2l2ZW4gdW5zYWZlRW5kVGltZSBhbmQgZ2xvYmFsLlxuICAgICAgdGltaW5nSW5mby5lbmRUaW1lID0gdW5zYWZlRW5kVGltZVxuXG4gICAgICAvLyAzLiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gICAgICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAgICAgLy8gNC4gTGV0IGJvZHlJbmZvIGJlIHJlc3BvbnNl4oCZcyBib2R5IGluZm8uXG4gICAgICBjb25zdCBib2R5SW5mbyA9IHJlc3BvbnNlLmJvZHlJbmZvXG5cbiAgICAgIC8vIDUuIElmIHJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcgaXMgbm90IHNldCwgdGhlbiBzZXQgdGltaW5nSW5mbyB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuXG4gICAgICAvLyAgICBvcGFxdWUgdGltaW5nIGluZm8gZm9yIHRpbWluZ0luZm8gYW5kIHNldCBjYWNoZVN0YXRlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICBpZiAoIXJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkKSB7XG4gICAgICAgIHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHRpbWluZ0luZm8pXG5cbiAgICAgICAgY2FjaGVTdGF0ZSA9ICcnXG4gICAgICB9XG5cbiAgICAgIC8vIDYuIExldCByZXNwb25zZVN0YXR1cyBiZSAwLlxuICAgICAgbGV0IHJlc3BvbnNlU3RhdHVzID0gMFxuXG4gICAgICAvLyA3LiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBub3QgXCJuYXZpZ2F0ZVwiIG9yIHJlc3BvbnNl4oCZcyBoYXMtY3Jvc3Mtb3JpZ2luLXJlZGlyZWN0cyBpcyBmYWxzZTpcbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0Lm1vZGUgIT09ICduYXZpZ2F0b3InIHx8ICFyZXNwb25zZS5oYXNDcm9zc09yaWdpblJlZGlyZWN0cykge1xuICAgICAgICAvLyAxLiBTZXQgcmVzcG9uc2VTdGF0dXMgdG8gcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgICAgICAgcmVzcG9uc2VTdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcblxuICAgICAgICAvLyAyLiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGEgTUlNRSB0eXBlIGZyb20gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGV4dHJhY3RNaW1lVHlwZShyZXNwb25zZS5oZWFkZXJzTGlzdClcblxuICAgICAgICAvLyAzLiBJZiBtaW1lVHlwZSBpcyBub3QgZmFpbHVyZSwgdGhlbiBzZXQgYm9keUluZm/igJlzIGNvbnRlbnQgdHlwZSB0byB0aGUgcmVzdWx0IG9mIG1pbmltaXppbmcgYSBzdXBwb3J0ZWQgTUlNRSB0eXBlIGdpdmVuIG1pbWVUeXBlLlxuICAgICAgICBpZiAobWltZVR5cGUgIT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIGJvZHlJbmZvLmNvbnRlbnRUeXBlID0gbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZShtaW1lVHlwZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA4LiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIHR5cGUgaXMgbm9uLW51bGwsIHRoZW4gbWFyayByZXNvdXJjZSB0aW1pbmcgZ2l2ZW4gdGltaW5nSW5mbyxcbiAgICAgIC8vICAgIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkwsIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSwgZ2xvYmFsLCBjYWNoZVN0YXRlLCBib2R5SW5mbyxcbiAgICAgIC8vICAgIGFuZCByZXNwb25zZVN0YXR1cy5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICBtYXJrUmVzb3VyY2VUaW1pbmcodGltaW5nSW5mbywgZmV0Y2hQYXJhbXMucmVxdWVzdC51cmwuaHJlZiwgZmV0Y2hQYXJhbXMucmVxdWVzdC5pbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzLCBjYWNoZVN0YXRlLCBib2R5SW5mbywgcmVzcG9uc2VTdGF0dXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgYmUgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrID0gKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gICAgICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIG5vbi1udWxsLCB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2Vzc1xuICAgICAgLy8gICAgcmVzcG9uc2UgZW5kLW9mLWJvZHkgZ2l2ZW4gcmVzcG9uc2UuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ICE9IG51bGwpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KHJlc3BvbnNlKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlIGlzIG5vbi1udWxsIGFuZCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW504oCZc1xuICAgICAgLy8gICAgZ2xvYmFsIG9iamVjdCBpcyBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbiwgdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXLigJlzIHJlcG9ydFxuICAgICAgLy8gICAgdGltaW5nIHN0ZXBzIGdpdmVuIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC5pbml0aWF0b3JUeXBlICE9IG51bGwpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXBvcnRUaW1pbmdTdGVwcygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb25cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrKCkpXG4gIH1cblxuICAvLyA0LiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBpcyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBwcm9jZXNzIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlLCB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgPSBudWxsXG4gICAgfSlcbiAgfVxuXG4gIC8vIDUuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3I7IG90aGVyd2lzZSByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGNvbnN0IGludGVybmFsUmVzcG9uc2UgPSByZXNwb25zZS50eXBlID09PSAnZXJyb3InID8gcmVzcG9uc2UgOiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSA/PyByZXNwb25zZSlcblxuICAvLyA2LiBJZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgLy8gNy4gT3RoZXJ3aXNlOlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICB9IGVsc2Uge1xuICAgIC8vIG1jb2xsaW5hOiBhbGwgdGhlIGZvbGxvd2luZyBzdGVwcyBvZiB0aGUgc3BlY3MgYXJlIHNraXBwZWQuXG4gICAgLy8gVGhlIGludGVybmFsIHRyYW5zZm9ybSBzdHJlYW0gaXMgbm90IG5lZWRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8zMDkzI2lzc3VlY29tbWVudC0yMDUwMTk4NTQxXG5cbiAgICAvLyAxLiBMZXQgdHJhbnNmb3JtU3RyZWFtIGJlIGEgbmV3IFRyYW5zZm9ybVN0cmVhbS5cbiAgICAvLyAyLiBMZXQgaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHdoaWNoLCBnaXZlbiBjaHVuaywgZW5xdWV1ZXMgY2h1bmsgaW4gdHJhbnNmb3JtU3RyZWFtLlxuICAgIC8vIDMuIFNldCB1cCB0cmFuc2Zvcm1TdHJlYW0gd2l0aCB0cmFuc2Zvcm1BbGdvcml0aG0gc2V0IHRvIGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGFuZCBmbHVzaEFsZ29yaXRobVxuICAgIC8vICAgIHNldCB0byBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gICAgLy8gNC4gU2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHnigJlzIHN0cmVhbSB0byB0aGUgcmVzdWx0IG9mIGludGVybmFsUmVzcG9uc2XigJlzIGJvZHnigJlzIHN0cmVhbSBwaXBlZCB0aHJvdWdoIHRyYW5zZm9ybVN0cmVhbS5cblxuICAgIGZpbmlzaGVkKGludGVybmFsUmVzcG9uc2UuYm9keS5zdHJlYW0sICgpID0+IHtcbiAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSgpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cEZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBhY3R1YWxSZXNwb25zZSBiZSBudWxsLlxuICBsZXQgYWN0dWFsUmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDUuIElmIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwiYWxsXCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID09PSAnYWxsJykge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDYuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIC8vIDEuIElmIG1ha2VDT1JTUHJlZmxpZ2h0IGlzIHRydWUgYW5kIG9uZSBvZiB0aGVzZSBjb25kaXRpb25zIGlzIHRydWU6XG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBcImZvbGxvd1wiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAgIC8vIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICAgIH1cblxuICAgIC8vIDMuIFNldCByZXNwb25zZSBhbmQgYWN0dWFsUmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgLy8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcylcblxuICAgIC8vIDQuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBhIENPUlMgY2hlY2tcbiAgICAvLyBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAgIGNvcnNDaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2NvcnMgZmFpbHVyZScpXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgdGhlIFRBTyBjaGVjayBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHNldFxuICAgIC8vIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZy5cbiAgICBpZiAoVEFPQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgZWl0aGVyIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIG9yIHJlc3BvbnNl4oCZcyB0eXBlXG4gIC8vIGlzIFwib3BhcXVlXCIsIGFuZCB0aGUgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHBvbGljeSBjaGVjayB3aXRoXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiwgcmVxdWVzdOKAmXMgY2xpZW50LCByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbixcbiAgLy8gYW5kIGFjdHVhbFJlc3BvbnNlIHJldHVybnMgYmxvY2tlZCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScpICYmXG4gICAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrKFxuICAgICAgcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0LmNsaWVudCxcbiAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24sXG4gICAgICBhY3R1YWxSZXNwb25zZVxuICAgICkgPT09ICdibG9ja2VkJ1xuICApIHtcbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignYmxvY2tlZCcpXG4gIH1cblxuICAvLyA4LiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuOlxuICBpZiAocmVkaXJlY3RTdGF0dXNTZXQuaGFzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAvLyAxLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gYW5kIHRoZSBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHVzZXIgYWdlbnRzIG1heSwgYW5kIGFyZSBldmVuXG4gICAgLy8gZW5jb3VyYWdlZCB0bywgdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODhcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KHVuZGVmaW5lZCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gMi4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGU6XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ3VuZXhwZWN0ZWQgcmVkaXJlY3QnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ21hbnVhbCcpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWxcbiAgICAgIC8vIHJlc3BvbnNlIGlzIGFjdHVhbFJlc3BvbnNlLlxuICAgICAgLy8gTk9URShzcGVjKTogT24gdGhlIHdlYiB0aGlzIHdvdWxkIHJldHVybiBhbiBgb3BhcXVlcmVkaXJlY3RgIHJlc3BvbnNlLFxuICAgICAgLy8gYnV0IHRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIHNlcnZlciBzaWRlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMTkzLlxuICAgICAgcmVzcG9uc2UgPSBhY3R1YWxSZXNwb25zZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1yZWRpcmVjdCBmZXRjaCBnaXZlblxuICAgICAgLy8gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwUmVkaXJlY3RGZXRjaChmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyA5LiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXJlZGlyZWN0LWZldGNoXG5mdW5jdGlvbiBodHRwUmVkaXJlY3RGZXRjaCAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBhY3R1YWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWQgcmVzcG9uc2UsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBjb25zdCBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA/IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA6IHJlc3BvbnNlXG5cbiAgLy8gMy4gTGV0IGxvY2F0aW9uVVJMIGJlIGFjdHVhbFJlc3BvbnNl4oCZcyBsb2NhdGlvbiBVUkwgZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudFxuICAvLyBVUkzigJlzIGZyYWdtZW50LlxuICBsZXQgbG9jYXRpb25VUkxcblxuICB0cnkge1xuICAgIGxvY2F0aW9uVVJMID0gcmVzcG9uc2VMb2NhdGlvblVSTChcbiAgICAgIGFjdHVhbFJlc3BvbnNlLFxuICAgICAgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkuaGFzaFxuICAgIClcblxuICAgIC8vIDQuIElmIGxvY2F0aW9uVVJMIGlzIG51bGwsIHRoZW4gcmV0dXJuIHJlc3BvbnNlLlxuICAgIGlmIChsb2NhdGlvblVSTCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDUuIElmIGxvY2F0aW9uVVJMIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgfVxuXG4gIC8vIDYuIElmIGxvY2F0aW9uVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gZXJyb3IuXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUobG9jYXRpb25VUkwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZScpKVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgY291bnQgaXMgMjAsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMjApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3JlZGlyZWN0IGNvdW50IGV4Y2VlZGVkJykpXG4gIH1cblxuICAvLyA4LiBJbmNyZWFzZSByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBieSAxLlxuICByZXF1ZXN0LnJlZGlyZWN0Q291bnQgKz0gMVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJjb3JzXCIsIGxvY2F0aW9uVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCBhbmRcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZcyBvcmlnaW4sIHRoZW4gcmV0dXJuXG4gIC8vICBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0Lm1vZGUgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZCkgJiZcbiAgICAhc2FtZU9yaWdpbihyZXF1ZXN0LCBsb2NhdGlvblVSTClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpKVxuICB9XG5cbiAgLy8gMTAuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBsb2NhdGlvblVSTCBpbmNsdWRlc1xuICAvLyBjcmVkZW50aWFscywgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICdVUkwgY2Fubm90IGNvbnRhaW4gY3JlZGVudGlhbHMgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIidcbiAgICApKVxuICB9XG5cbiAgLy8gMTEuIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IDMwMywgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICBhY3R1YWxSZXNwb25zZS5zdGF0dXMgIT09IDMwMyAmJlxuICAgIHJlcXVlc3QuYm9keSAhPSBudWxsICYmXG4gICAgcmVxdWVzdC5ib2R5LnNvdXJjZSA9PSBudWxsXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigpKVxuICB9XG5cbiAgLy8gMTIuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMSBvciAzMDIgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGBcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMyBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBgR0VUYCBvciBgSEVBRGBcbiAgaWYgKFxuICAgIChbMzAxLCAzMDJdLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykgfHxcbiAgICAoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzID09PSAzMDMgJiZcbiAgICAgICFHRVRfT1JfSEVBRC5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpXG4gICkge1xuICAgIC8vIHRoZW46XG4gICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBgR0VUYCBhbmQgcmVxdWVzdOKAmXMgYm9keSB0byBudWxsLlxuICAgIHJlcXVlc3QubWV0aG9kID0gJ0dFVCdcbiAgICByZXF1ZXN0LmJvZHkgPSBudWxsXG5cbiAgICAvLyAyLiBGb3IgZWFjaCBoZWFkZXJOYW1lIG9mIHJlcXVlc3QtYm9keS1oZWFkZXIgbmFtZSwgZGVsZXRlIGhlYWRlck5hbWUgZnJvbVxuICAgIC8vIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiByZXF1ZXN0Qm9keUhlYWRlcikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoaGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMy4gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBsb2NhdGlvblVSTOKAmXNcbiAgLy8gICAgIG9yaWdpbiwgdGhlbiBmb3IgZWFjaCBoZWFkZXJOYW1lIG9mIENPUlMgbm9uLXdpbGRjYXJkIHJlcXVlc3QtaGVhZGVyIG5hbWUsXG4gIC8vICAgICBkZWxldGUgaGVhZGVyTmFtZSBmcm9tIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCksIGxvY2F0aW9uVVJMKSkge1xuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb3JzLW5vbi13aWxkY2FyZC1yZXF1ZXN0LWhlYWRlci1uYW1lXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2F1dGhvcml6YXRpb24nLCB0cnVlKVxuXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2F1dGhlbnRpY2F0aW9uLWVudHJpZXNcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgncHJveHktYXV0aG9yaXphdGlvbicsIHRydWUpXG5cbiAgICAvLyBcIkNvb2tpZVwiIGFuZCBcIkhvc3RcIiBhcmUgZm9yYmlkZGVuIHJlcXVlc3QtaGVhZGVycywgd2hpY2ggdW5kaWNpIGRvZXNuJ3QgaW1wbGVtZW50LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdjb29raWUnLCB0cnVlKVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JywgdHJ1ZSlcbiAgfVxuXG4gIC8vIDE0LiBJZiByZXF1ZXN0J3MgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdCdzIGJvZHkgdG8gdGhlIGZpcnN0IHJldHVyblxuICAvLyB2YWx1ZSBvZiBzYWZlbHkgZXh0cmFjdGluZyByZXF1ZXN0J3MgYm9keSdzIHNvdXJjZS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgICByZXF1ZXN0LmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShyZXF1ZXN0LmJvZHkuc291cmNlKVswXVxuICB9XG5cbiAgLy8gMTUuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAxNi4gU2V0IHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IGVuZCB0aW1lIGFuZCBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGhlXG4gIC8vIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgdGltaW5nSW5mby5yZWRpcmVjdEVuZFRpbWUgPSB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSA9XG4gICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgLy8gMTcuIElmIHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IHN0YXJ0IHRpbWUgaXMgMCwgdGhlbiBzZXQgdGltaW5nSW5mb+KAmXNcbiAgLy8gIHJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGltaW5nSW5mb+KAmXMgc3RhcnQgdGltZS5cbiAgaWYgKHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPT09IDApIHtcbiAgICB0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID0gdGltaW5nSW5mby5zdGFydFRpbWVcbiAgfVxuXG4gIC8vIDE4LiBBcHBlbmQgbG9jYXRpb25VUkwgdG8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlcXVlc3QudXJsTGlzdC5wdXNoKGxvY2F0aW9uVVJMKVxuXG4gIC8vIDE5LiBJbnZva2Ugc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBvbiByZWRpcmVjdCBvbiByZXF1ZXN0IGFuZFxuICAvLyBhY3R1YWxSZXNwb25zZS5cbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0LCBhY3R1YWxSZXNwb25zZSlcblxuICAvLyAyMC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICByZXR1cm4gbWFpbkZldGNoKGZldGNoUGFyYW1zLCB0cnVlKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLW9yLWNhY2hlLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya09yQ2FjaGVGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggPSBmYWxzZSxcbiAgaXNOZXdDb25uZWN0aW9uRmV0Y2ggPSBmYWxzZVxuKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBodHRwRmV0Y2hQYXJhbXMgYmUgbnVsbC5cbiAgbGV0IGh0dHBGZXRjaFBhcmFtcyA9IG51bGxcblxuICAvLyAzLiBMZXQgaHR0cFJlcXVlc3QgYmUgbnVsbC5cbiAgbGV0IGh0dHBSZXF1ZXN0ID0gbnVsbFxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0b3JlZFJlc3BvbnNlIGJlIG51bGwuXG4gIC8vIFRPRE86IGNhY2hlXG5cbiAgLy8gNi4gTGV0IGh0dHBDYWNoZSBiZSBudWxsLlxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNy4gTGV0IHRoZSByZXZhbGlkYXRpbmdGbGFnIGJlIHVuc2V0LlxuICBjb25zdCByZXZhbGlkYXRpbmdGbGFnID0gZmFsc2VcblxuICAvLyA4LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIgYW5kIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXNcbiAgLy8gICAgXCJlcnJvclwiLCB0aGVuIHNldCBodHRwRmV0Y2hQYXJhbXMgdG8gZmV0Y2hQYXJhbXMgYW5kIGh0dHBSZXF1ZXN0IHRvXG4gIC8vICAgIHJlcXVlc3QuXG4gIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycgJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgIGh0dHBGZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zXG4gICAgaHR0cFJlcXVlc3QgPSByZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gU2V0IGh0dHBSZXF1ZXN0IHRvIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgICBodHRwUmVxdWVzdCA9IGNsb25lUmVxdWVzdChyZXF1ZXN0KVxuXG4gICAgLy8gMi4gU2V0IGh0dHBGZXRjaFBhcmFtcyB0byBhIGNvcHkgb2YgZmV0Y2hQYXJhbXMuXG4gICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9XG5cbiAgICAvLyAzLiBTZXQgaHR0cEZldGNoUGFyYW1z4oCZcyByZXF1ZXN0IHRvIGh0dHBSZXF1ZXN0LlxuICAgIGh0dHBGZXRjaFBhcmFtcy5yZXF1ZXN0ID0gaHR0cFJlcXVlc3RcbiAgfVxuXG4gIC8vICAgIDMuIExldCBpbmNsdWRlQ3JlZGVudGlhbHMgYmUgdHJ1ZSBpZiBvbmUgb2ZcbiAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID1cbiAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScgfHxcbiAgICAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ3NhbWUtb3JpZ2luJyAmJlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKVxuXG4gIC8vICAgIDQuIExldCBjb250ZW50TGVuZ3RoIGJlIGh0dHBSZXF1ZXN04oCZcyBib2R54oCZcyBsZW5ndGgsIGlmIGh0dHBSZXF1ZXN04oCZc1xuICAvLyAgICBib2R5IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGxcblxuICAvLyAgICA1LiBMZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGJlIG51bGwuXG4gIGxldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBudWxsXG5cbiAgLy8gICAgNi4gSWYgaHR0cFJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGAgb3JcbiAgLy8gICAgYFBVVGAsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBgMGAuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiZcbiAgICBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKVxuICApIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSAnMCdcbiAgfVxuXG4gIC8vICAgIDcuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0b1xuICAvLyAgICBjb250ZW50TGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKGAke2NvbnRlbnRMZW5ndGh9YClcbiAgfVxuXG4gIC8vICAgIDguIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENvbnRlbnQtTGVuZ3RoYC9jb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudExlbmd0aEhlYWRlclZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgOS4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtTGVuZ3RoYCxcbiAgLy8gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgMTAuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBrZWVwYWxpdmUgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBodHRwUmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAvLyBOT1RFOiBrZWVwYWxpdmUgaXMgYSBub29wIG91dHNpZGUgb2YgYnJvd3NlciBjb250ZXh0LlxuICB9XG5cbiAgLy8gICAgMTEuIElmIGh0dHBSZXF1ZXN04oCZcyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYFJlZmVyZXJgL2h0dHBSZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLFxuICAvLyAgICAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAod2ViaWRsLmlzLlVSTChodHRwUmVxdWVzdC5yZWZlcnJlcikpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3JlZmVyZXInLCBpc29tb3JwaGljRW5jb2RlKGh0dHBSZXF1ZXN0LnJlZmVycmVyLmhyZWYpLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTIuIEFwcGVuZCBhIHJlcXVlc3QgYE9yaWdpbmAgaGVhZGVyIGZvciBodHRwUmVxdWVzdC5cbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihodHRwUmVxdWVzdClcblxuICAvLyAgICAxMy4gQXBwZW5kIHRoZSBGZXRjaCBtZXRhZGF0YSBoZWFkZXJzIGZvciBodHRwUmVxdWVzdC4gW0ZFVENILU1FVEFEQVRBXVxuICBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDE0LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgVXNlci1BZ2VudGAsIHRoZW5cbiAgLy8gICAgdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgVXNlci1BZ2VudGAvZGVmYXVsdCBgVXNlci1BZ2VudGAgdmFsdWUgdG9cbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd1c2VyLWFnZW50JywgdHJ1ZSkpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3VzZXItYWdlbnQnLCBkZWZhdWx0VXNlckFnZW50LCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTUuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwiZGVmYXVsdFwiIGFuZCBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QgY29udGFpbnMgYElmLU1vZGlmaWVkLVNpbmNlYCwgYElmLU5vbmUtTWF0Y2hgLFxuICAvLyAgICBgSWYtVW5tb2RpZmllZC1TaW5jZWAsIGBJZi1NYXRjaGAsIG9yIGBJZi1SYW5nZWAsIHRoZW4gc2V0XG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnZGVmYXVsdCcgJiZcbiAgICAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1ub25lLW1hdGNoJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi11bm1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tYXRjaCcsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtcmFuZ2UnLCB0cnVlKSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAxNi4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1jYWNoZVwiLCBodHRwUmVxdWVzdOKAmXMgcHJldmVudFxuICAvLyAgICBuby1jYWNoZSBjYWNoZS1jb250cm9sIGhlYWRlciBtb2RpZmljYXRpb24gZmxhZyBpcyB1bnNldCwgYW5kXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENhY2hlLUNvbnRyb2xgL2BtYXgtYWdlPTBgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tY2FjaGUnICYmXG4gICAgIWh0dHBSZXF1ZXN0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uICYmXG4gICAgIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJywgdHJ1ZSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ21heC1hZ2U9MCcsIHRydWUpXG4gIH1cblxuICAvLyAgICAxNy4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1zdG9yZVwiIG9yIFwicmVsb2FkXCIsIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ3JlbG9hZCcpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUHJhZ21hYCwgdGhlbiBhcHBlbmRcbiAgICAvLyBgUHJhZ21hYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdwcmFnbWEnLCB0cnVlKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdwcmFnbWEnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cblxuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCxcbiAgICAvLyB0aGVuIGFwcGVuZCBgQ2FjaGUtQ29udHJvbGAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcsIHRydWUpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDE4LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYEFjY2VwdC1FbmNvZGluZ2AvYGlkZW50aXR5YCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5JywgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDE5LiBNb2RpZnkgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IHBlciBIVFRQLiBEbyBub3QgYXBwZW5kIGEgZ2l2ZW5cbiAgLy8gICAgaGVhZGVyIGlmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyB0aGF0IGhlYWRlcuKAmXMgbmFtZS5cbiAgLy8gICAgVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4NSNpc3N1ZWNvbW1lbnQtODk2NTYwMTI5XG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1lbmNvZGluZycsIHRydWUpKSB7XG4gICAgaWYgKHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2JyLCBnemlwLCBkZWZsYXRlJywgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JywgdHJ1ZSlcblxuICAvLyAgICAyMS4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIHRoZW46XG4gIGlmIChpbmNsdWRlQ3JlZGVudGlhbHMpIHtcbiAgICAvLyAxLiBJZiB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZCB0byBibG9jayBjb29raWVzIGZvciBodHRwUmVxdWVzdFxuICAgIC8vIChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcblxuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBdXRob3JpemF0aW9uYCwgdGhlbjpcbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhdXRob3JpemF0aW9uJywgdHJ1ZSkpIHtcbiAgICAgIC8vIDEuIExldCBhdXRob3JpemF0aW9uVmFsdWUgYmUgbnVsbC5cbiAgICAgIGxldCBhdXRob3JpemF0aW9uVmFsdWUgPSBudWxsXG5cbiAgICAgIC8vIDIuIElmIHRoZXJl4oCZcyBhbiBhdXRoZW50aWNhdGlvbiBlbnRyeSBmb3IgaHR0cFJlcXVlc3QgYW5kIGVpdGhlclxuICAgICAgLy8gICAgaHR0cFJlcXVlc3TigJlzIHVzZS1VUkwtY3JlZGVudGlhbHMgZmxhZyBpcyB1bnNldCBvciBodHRwUmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGRvZXMgbm90IGluY2x1ZGUgY3JlZGVudGlhbHMsIHRoZW4gc2V0XG4gICAgICAvLyAgICBhdXRob3JpemF0aW9uVmFsdWUgdG8gYXV0aGVudGljYXRpb24gZW50cnkuXG4gICAgICBpZiAoaGFzQXV0aGVudGljYXRpb25FbnRyeShodHRwUmVxdWVzdCkgJiYgKFxuICAgICAgICBodHRwUmVxdWVzdC51c2VVUkxDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkIHx8ICFpbmNsdWRlc0NyZWRlbnRpYWxzKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSlcbiAgICAgICkpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSkgJiYgaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgaHR0cFJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGRvZXMgaW5jbHVkZSBjcmVkZW50aWFsc1xuICAgICAgICAvLyAgICBhbmQgaXNBdXRoZW50aWNhdGlvbkZldGNoIGlzIHRydWUsIHNldCBhdXRob3JpemF0aW9uVmFsdWUgdG9cbiAgICAgICAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLCBjb252ZXJ0ZWQgdG8gYW4gYEF1dGhvcml6YXRpb25gIHZhbHVlXG4gICAgICAgIGNvbnN0IHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSByZXF1ZXN0Q3VycmVudFVSTChodHRwUmVxdWVzdClcbiAgICAgICAgYXV0aG9yaXphdGlvblZhbHVlID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWBcbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgYXV0aG9yaXphdGlvblZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYEF1dGhvcml6YXRpb25gLFxuICAgICAgLy8gICAgYXV0aG9yaXphdGlvblZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICBpZiAoYXV0aG9yaXphdGlvblZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnQXV0aG9yaXphdGlvbicsIGF1dGhvcml6YXRpb25WYWx1ZSwgZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gICAgMjEuIElmIHRoZXJl4oCZcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LCB1c2UgaXQgYXMgYXBwcm9wcmlhdGUuXG4gIC8vICAgIFRPRE86IHByb3h5LWF1dGhlbnRpY2F0aW9uXG5cbiAgLy8gICAgMjIuIFNldCBodHRwQ2FjaGUgdG8gdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZVxuICAvLyAgICBwYXJ0aXRpb24sIGdpdmVuIGh0dHBSZXF1ZXN0LlxuICAvLyAgICBUT0RPOiBjYWNoZVxuXG4gIC8vICAgIDIzLiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG9cbiAgLy8gICAgXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vICAgIDI0LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBuZWl0aGVyIFwibm8tc3RvcmVcIiBub3IgXCJyZWxvYWRcIixcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlICE9PSAnbm8tc3RvcmUnICYmIGh0dHBSZXF1ZXN0LmNhY2hlICE9PSAncmVsb2FkJykge1xuICAgIC8vIFRPRE86IGNhY2hlXG4gIH1cblxuICAvLyA5LiBJZiBhYm9ydGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIsIHRoZW4gcmV0dXJuIGFcbiAgICAvLyBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ29ubHkgaWYgY2FjaGVkJylcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgZm9yd2FyZFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmsgZmV0Y2hcbiAgICAvLyBnaXZlbiBodHRwRmV0Y2hQYXJhbXMsIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGlzTmV3Q29ubmVjdGlvbkZldGNoLlxuICAgIGNvbnN0IGZvcndhcmRSZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrRmV0Y2goXG4gICAgICBodHRwRmV0Y2hQYXJhbXMsXG4gICAgICBpbmNsdWRlQ3JlZGVudGlhbHMsXG4gICAgICBpc05ld0Nvbm5lY3Rpb25GZXRjaFxuICAgIClcblxuICAgIC8vIDMuIElmIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgdW5zYWZlIGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpc1xuICAgIC8vIGluIHRoZSByYW5nZSAyMDAgdG8gMzk5LCBpbmNsdXNpdmUsIGludmFsaWRhdGUgYXBwcm9wcmlhdGUgc3RvcmVkXG4gICAgLy8gcmVzcG9uc2VzIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZSBcIkludmFsaWRhdGlvblwiIGNoYXB0ZXIgb2YgSFRUUFxuICAgIC8vIENhY2hpbmcsIGFuZCBzZXQgc3RvcmVkUmVzcG9uc2UgdG8gbnVsbC4gW0hUVFAtQ0FDSElOR11cbiAgICBpZiAoXG4gICAgICAhc2FmZU1ldGhvZHNTZXQuaGFzKGh0dHBSZXF1ZXN0Lm1ldGhvZCkgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzIDw9IDM5OVxuICAgICkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB0aGUgcmV2YWxpZGF0aW5nRmxhZyBpcyBzZXQgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwNCxcbiAgICAvLyB0aGVuOlxuICAgIGlmIChyZXZhbGlkYXRpbmdGbGFnICYmIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA1LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2UgdG8gZm9yd2FyZFJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBmb3J3YXJkUmVzcG9uc2VcblxuICAgICAgLy8gMi4gU3RvcmUgaHR0cFJlcXVlc3QgYW5kIGZvcndhcmRSZXNwb25zZSBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGVcbiAgICAgIC8vIFwiU3RvcmluZyBSZXNwb25zZXMgaW4gQ2FjaGVzXCIgY2hhcHRlciBvZiBIVFRQIENhY2hpbmcuIFtIVFRQLUNBQ0hJTkddXG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cbiAgfVxuXG4gIC8vIDExLiBTZXQgcmVzcG9uc2XigJlzIFVSTCBsaXN0IHRvIGEgY2xvbmUgb2YgaHR0cFJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXNwb25zZS51cmxMaXN0ID0gWy4uLmh0dHBSZXF1ZXN0LnVybExpc3RdXG5cbiAgLy8gMTIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZeKAmXNcbiAgLy8gcmFuZ2UtcmVxdWVzdGVkIGZsYWcuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgcmVxdWVzdC1pbmNsdWRlcy1jcmVkZW50aWFscyB0byBpbmNsdWRlQ3JlZGVudGlhbHMuXG4gIHJlc3BvbnNlLnJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzXG5cbiAgLy8gMTQuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDAxLCBodHRwUmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgbm90IFwiY29yc1wiLFxuICAvLyAgICAgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIGFuZCByZXF1ZXN04oCZcyB0cmF2ZXJzYWJsZSBmb3IgdXNlciBwcm9tcHRzIGlzXG4gIC8vICAgICBhIHRyYXZlcnNhYmxlIG5hdmlnYWJsZTpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIGh0dHBSZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgIT09ICdjb3JzJyAmJiBpbmNsdWRlQ3JlZGVudGlhbHMgJiYgaXNUcmF2ZXJzYWJsZU5hdmlnYWJsZShyZXF1ZXN0LnRyYXZlcnNhYmxlRm9yVXNlclByb21wdHMpKSB7XG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5ib2R5LnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdleHBlY3RlZCBub24tbnVsbCBib2R5IHNvdXJjZScpXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCByZXF1ZXN04oCZcyBib2R5IHRvIHRoZSBib2R5IG9mIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3RpbmdcbiAgICAgIC8vICAgIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZS5cbiAgICAgIHJlcXVlc3QuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KHJlcXVlc3QuYm9keS5zb3VyY2UpWzBdXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgdXNlLVVSTC1jcmVkZW50aWFscyBmbGFnIGlzIHVuc2V0IG9yIGlzQXV0aGVudGljYXRpb25GZXRjaCBpc1xuICAgIC8vICAgIHRydWUsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QudXNlVVJMQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZCB8fCBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gpIHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvclxuICAgICAgLy8gICAgZm9yIGZldGNoUGFyYW1zLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBMZXQgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGJlIHRoZSByZXN1bHQgb2YgcHJvbXB0aW5nIHRoZSBlbmQgdXNlciBmb3IgYVxuICAgICAgLy8gICAgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLCByZXNwZWN0aXZlbHksIGluIHJlcXVlc3TigJlzIHRyYXZlcnNhYmxlIGZvciB1c2VyIHByb21wdHMuXG4gICAgICAvLyBUT0RPXG5cbiAgICAgIC8vIDMuIFNldCB0aGUgdXNlcm5hbWUgZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgYW5kIHVzZXJuYW1lLlxuICAgICAgLy8gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkudXNlcm5hbWUgPSBUT0RPXG5cbiAgICAgIC8vIDQuIFNldCB0aGUgcGFzc3dvcmQgZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgYW5kIHBhc3N3b3JkLlxuICAgICAgLy8gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkucGFzc3dvcmQgPSBUT0RPXG5cbiAgICAgIC8vIEluIGJyb3dzZXJzLCB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIHRvIGVudGVyIGEgdXNlcm5hbWUvcGFzc3dvcmQgYmVmb3JlIHRoZSByZXF1ZXN0XG4gICAgICAvLyBpcyByZS1zZW50LiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIDQwMSBsb29wLCByZXR1cm4gdGhlIHJlc3BvbnNlIGZvciBub3cuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzQ3NTZcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuXG4gICAgLy8gICAgZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSlcbiAgfVxuXG4gIC8vIDE1LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwNywgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA3KSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gMi4gPz8/XG5cbiAgICAvLyAzLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gNC4gUHJvbXB0IHRoZSBlbmQgdXNlciBhcyBhcHByb3ByaWF0ZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cgYW5kIHN0b3JlXG4gICAgLy8gdGhlIHJlc3VsdCBhcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LiBbSFRUUC1BVVRIXVxuICAgIC8vIFRPRE86IEludm9rZSBzb21lIGtpbmQgb2YgY2FsbGJhY2s/XG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlblxuICAgIC8vIGZldGNoUGFyYW1zLlxuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncHJveHkgYXV0aGVudGljYXRpb24gcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gMTYuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gIGlmIChcbiAgICAvLyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQyMVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIxICYmXG4gICAgLy8gaXNOZXdDb25uZWN0aW9uRmV0Y2ggaXMgZmFsc2VcbiAgICAhaXNOZXdDb25uZWN0aW9uRmV0Y2ggJiZcbiAgICAvLyByZXF1ZXN04oCZcyBib2R5IGlzIG51bGwsIG9yIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBub24tbnVsbFxuICAgIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCB8fCByZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICkge1xuICAgIC8vIHRoZW46XG5cbiAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGVcbiAgICAvLyBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcywgaXNBdXRoZW50aWNhdGlvbkZldGNoLCBhbmQgdHJ1ZS5cblxuICAgIC8vIFRPRE8gKHNwZWMpOiBUaGUgc3BlYyBkb2Vzbid0IHNwZWNpZnkgdGhpcyBidXQgd2UgbmVlZCB0byBjYW5jZWxcbiAgICAvLyB0aGUgYWN0aXZlIHJlc3BvbnNlIGJlZm9yZSB3ZSBjYW4gc3RhcnQgYSBuZXcgb25lLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyOTNcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKFxuICAgICAgZmV0Y2hQYXJhbXMsXG4gICAgICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsXG4gICAgICB0cnVlXG4gICAgKVxuICB9XG5cbiAgLy8gMTcuIElmIGlzQXV0aGVudGljYXRpb25GZXRjaCBpcyB0cnVlLCB0aGVuIGNyZWF0ZSBhbiBhdXRoZW50aWNhdGlvbiBlbnRyeVxuICBpZiAoaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTguIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaW5jbHVkZUNyZWRlbnRpYWxzID0gZmFsc2UsXG4gIGZvcmNlTmV3Q29ubmVjdGlvbiA9IGZhbHNlXG4pIHtcbiAgYXNzZXJ0KCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3llZClcblxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gPSB7XG4gICAgYWJvcnQ6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICBkZXN0cm95IChlcnIsIGFib3J0ID0gdHJ1ZSkge1xuICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgICAgaWYgKGFib3J0KSB7XG4gICAgICAgICAgdGhpcy5hYm9ydD8uKGVyciA/PyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA0LiBMZXQgaHR0cENhY2hlIGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGUgcGFydGl0aW9uLFxuICAvLyBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPOiBjYWNoZVxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNS4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICByZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gNi4gTGV0IG5ldHdvcmtQYXJ0aXRpb25LZXkgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgbmV0d29ya1xuICAvLyBwYXJ0aXRpb24ga2V5IGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA3LiBMZXQgbmV3Q29ubmVjdGlvbiBiZSBcInllc1wiIGlmIGZvcmNlTmV3Q29ubmVjdGlvbiBpcyB0cnVlOyBvdGhlcndpc2VcbiAgLy8gXCJub1wiLlxuICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gJ3llcycgOiAnbm8nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyA4LiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgbW9kZTpcbiAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLFxuICAgIC8vIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIGNvbm5lY3Rpb24sIGdpdmVuXG4gICAgLy8gbmV0d29ya1BhcnRpdGlvbktleSwgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbixcbiAgICAvLyBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBmb3JjZU5ld0Nvbm5lY3Rpb24uXG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gOS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIGNvbm5lY3Rpb24gaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlbiBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXNcbiAgLy8gICAgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cblxuICAvLyAgICAzLiBJZiBjb25uZWN0aW9uIGlzIG5vdCBhbiBIVFRQLzIgY29ubmVjdGlvbiwgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gICAgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIGFwcGVuZCAoYFRyYW5zZmVyLUVuY29kaW5nYCxcbiAgLy8gICAgYGNodW5rZWRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICA0LiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gICAgY2FwYWJpbGl0eS5cblxuICAvLyAgICA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBtYWtpbmcgYW4gSFRUUCByZXF1ZXN0IG92ZXIgY29ubmVjdGlvblxuICAvLyAgICB1c2luZyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBjYXZlYXRzOlxuXG4gIC8vICAgICAgICAtIEZvbGxvdyB0aGUgcmVsZXZhbnQgcmVxdWlyZW1lbnRzIGZyb20gSFRUUC4gW0hUVFBdIFtIVFRQLVNFTUFOVElDU11cbiAgLy8gICAgICAgIFtIVFRQLUNPTkRdIFtIVFRQLUNBQ0hJTkddIFtIVFRQLUFVVEhdXG5cbiAgLy8gICAgICAgIC0gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLFxuICAvLyAgICAgICAgdGhlbiB0aGUgdXNlciBhZ2VudCBtYXkgaGF2ZSBhIGJ1ZmZlciBvZiB1cCB0byA2NCBraWJpYnl0ZXMgYW5kIHN0b3JlXG4gIC8vICAgICAgICBhIHBhcnQgb2YgcmVxdWVzdOKAmXMgYm9keSBpbiB0aGF0IGJ1ZmZlci4gSWYgdGhlIHVzZXIgYWdlbnQgcmVhZHMgZnJvbVxuICAvLyAgICAgICAgcmVxdWVzdOKAmXMgYm9keSBiZXlvbmQgdGhhdCBidWZmZXLigJlzIHNpemUgYW5kIHRoZSB1c2VyIGFnZW50IG5lZWRzIHRvXG4gIC8vICAgICAgICByZXNlbmQgcmVxdWVzdCwgdGhlbiBpbnN0ZWFkIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgICAgIC0gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgICAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSxcbiAgLy8gICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZVxuICAvLyAgICAgICAgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXIgYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXNcbiAgLy8gICAgICAgIGxpbmUgZm9yIEhUVFAvMS54KS5cblxuICAvLyAgICAgICAgLSBXYWl0IHVudGlsIGFsbCB0aGUgaGVhZGVycyBhcmUgdHJhbnNtaXR0ZWQuXG5cbiAgLy8gICAgICAgIC0gQW55IHJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIDEwMCB0byAxOTksIGluY2x1c2l2ZSxcbiAgLy8gICAgICAgIGFuZCBpcyBub3QgMTAxLCBhcmUgdG8gYmUgaWdub3JlZCwgZXhjZXB0IGZvciB0aGUgcHVycG9zZXMgb2Ygc2V0dGluZ1xuICAvLyAgICAgICAgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIGFib3ZlLlxuXG4gIC8vICAgIC0gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFRyYW5zZmVyLUVuY29kaW5nYC9gY2h1bmtlZGAgYW5kXG4gIC8vICAgIHJlc3BvbnNlIGlzIHRyYW5zZmVycmVkIHZpYSBIVFRQLzEuMCBvciBvbGRlciwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vICAgIGVycm9yLlxuXG4gIC8vICAgIC0gSWYgdGhlIEhUVFAgcmVxdWVzdCByZXN1bHRzIGluIGEgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZSBkaWFsb2csIHRoZW46XG5cbiAgLy8gICAgICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QsIG1ha2UgdGhlXG4gIC8vICAgICAgICBkaWFsb2cgYXZhaWxhYmxlIGluIHJlcXVlc3TigJlzIHdpbmRvdy5cblxuICAvLyAgICAgICAgMi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vIFRvIHRyYW5zbWl0IHJlcXVlc3TigJlzIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuICBsZXQgcmVxdWVzdEJvZHkgPSBudWxsXG4gIC8vIDEuIElmIGJvZHkgaXMgbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpc1xuICAvLyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdFxuICAvLyBlbmQtb2YtYm9keSBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJvZHkgaXMgbm9uLW51bGw6XG5cbiAgICAvLyAgICAxLiBMZXQgcHJvY2Vzc0JvZHlDaHVuayBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gYXN5bmMgZnVuY3Rpb24gKiAoYnl0ZXMpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOiB0cmFuc21pdCBieXRlcy5cbiAgICAgIHlpZWxkIGJ5dGVzXG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW5cbiAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBnaXZlbiBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg/LihieXRlcy5ieXRlTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBwcm9jZXNzRW5kT2ZCb2R5IGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsXG4gICAgICAvLyB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBnaXZlbiBlIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBlIGlzIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbiwgdGhlbiBhYm9ydCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSW5jcmVtZW50YWxseSByZWFkIHJlcXVlc3TigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHlDaHVuaywgcHJvY2Vzc0VuZE9mQm9keSxcbiAgICAvLyBwcm9jZXNzQm9keUVycm9yLCBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgcmVxdWVzdEJvZHkgPSAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QuYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHByb2Nlc3NCb2R5Q2h1bmsoYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0VuZE9mQm9keSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzb2NrZXQgaXMgb25seSBwcm92aWRlZCBmb3Igd2Vic29ja2V0c1xuICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0gPSBhd2FpdCBkaXNwYXRjaCh7IGJvZHk6IHJlcXVlc3RCb2R5IH0pXG5cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCA9ICgpID0+IGl0ZXJhdG9yLm5leHQoKVxuXG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDEwLiBJZiBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAvLyAxLiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICAgIC8vIDIuIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLCBlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKVxuICB9XG5cbiAgLy8gMTEuIExldCBwdWxsQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHJlc3VtZXMgdGhlIG9uZ29pbmcgZmV0Y2hcbiAgLy8gaWYgaXQgaXMgc3VzcGVuZGVkLlxuICBjb25zdCBwdWxsQWxnb3JpdGhtID0gKCkgPT4ge1xuICAgIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSgpXG4gIH1cblxuICAvLyAxMi4gTGV0IGNhbmNlbEFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhYm9ydHMgZmV0Y2hQYXJhbXPigJlzXG4gIC8vIGNvbnRyb2xsZXIgd2l0aCByZWFzb24sIGdpdmVuIHJlYXNvbi5cbiAgY29uc3QgY2FuY2VsQWxnb3JpdGhtID0gKHJlYXNvbikgPT4ge1xuICAgIC8vIElmIHRoZSBhYm9ydGVkIGZldGNoIHdhcyBhbHJlYWR5IHRlcm1pbmF0ZWQsIHRoZW4gd2UgZG8gbm90XG4gICAgLy8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICBpZiAoIWlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydChyZWFzb24pXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIExldCBoaWdoV2F0ZXJNYXJrIGJlIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOIG51bWJlciwgY2hvc2VuIGJ5XG4gIC8vIHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTQuIExldCBzaXplQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFjY2VwdHMgYSBjaHVuayBvYmplY3RcbiAgLy8gYW5kIHJldHVybnMgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4sIG5vbi1pbmZpbml0ZSBudW1iZXIsIGNob3NlbiBieSB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBMZXQgc3RyZWFtIGJlIGEgbmV3IFJlYWRhYmxlU3RyZWFtLlxuICAvLyAxNi4gU2V0IHVwIHN0cmVhbSB3aXRoIGJ5dGUgcmVhZGluZyBzdXBwb3J0IHdpdGggcHVsbEFsZ29yaXRobSBzZXQgdG8gcHVsbEFsZ29yaXRobSxcbiAgLy8gICAgIGNhbmNlbEFsZ29yaXRobSBzZXQgdG8gY2FuY2VsQWxnb3JpdGhtLlxuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyID0gY29udHJvbGxlclxuICAgICAgfSxcbiAgICAgIHB1bGw6IHB1bGxBbGdvcml0aG0sXG4gICAgICBjYW5jZWw6IGNhbmNlbEFsZ29yaXRobSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9XG4gIClcblxuICAvLyAxNy4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBhIG5ldyBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0uXG4gIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbSwgc291cmNlOiBudWxsLCBsZW5ndGg6IG51bGwgfVxuXG4gIC8vICAgIDIuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXNcbiAgLy8gICAgbm90IFwibm8tc3RvcmVcIiwgdGhlbiB1cGRhdGUgcmVzcG9uc2UgaW4gaHR0cENhY2hlIGZvciByZXF1ZXN0LlxuICAvLyAgICBUT0RPXG5cbiAgLy8gICAgMy4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkXG4gIC8vICAgIHRvIGJsb2NrIGNvb2tpZXMgZm9yIHJlcXVlc3QgKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbiBydW4gdGhlXG4gIC8vICAgIFwic2V0LWNvb2tpZS1zdHJpbmdcIiBwYXJzaW5nIGFsZ29yaXRobSAoc2VlIHNlY3Rpb24gNS4yIG9mIFtDT09LSUVTXSkgb25cbiAgLy8gICAgdGhlIHZhbHVlIG9mIGVhY2ggaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gIC8vICAgIGBTZXQtQ29va2llYCBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QsIGlmIGFueSwgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAvLyAgICBUT0RPXG5cbiAgLy8gMTguIElmIGFib3J0ZWQsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxOS4gUnVuIHRoZXNlIHN0ZXBzIGluIHBhcmFsbGVsOlxuXG4gIC8vICAgIDEuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQ6XG4gIGlmICghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUpIHtcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKCd0ZXJtaW5hdGVkJywgb25BYm9ydGVkKVxuICB9XG5cbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gMS4gV2hpbGUgdHJ1ZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyAxLTMuIFNlZSBvbkRhdGEuLi5cblxuICAgICAgLy8gNC4gU2V0IGJ5dGVzIHRvIHRoZSByZXN1bHQgb2YgaGFuZGxpbmcgY29udGVudCBjb2RpbmdzIGdpdmVuXG4gICAgICAvLyBjb2RpbmdzIGFuZCBieXRlcy5cbiAgICAgIGxldCBieXRlc1xuICAgICAgbGV0IGlzRmFpbHVyZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0KClcblxuICAgICAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBieXRlcyA9IGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkICYmICF0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSkge1xuICAgICAgICAgIC8vIHpsaWIgZG9lc24ndCBsaWtlIGVtcHR5IHN0cmVhbXMuXG4gICAgICAgICAgYnl0ZXMgPSB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlcyA9IGVyclxuXG4gICAgICAgICAgLy8gZXJyIG1heSBiZSBwcm9wYWdhdGVkIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHJlYWRhYmxlc3RyZWFtLmNhbmNlbCxcbiAgICAgICAgICAvLyB3aGljaCBtaWdodCBub3QgYmUgYW4gZXJyb3IuIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDA5XG4gICAgICAgICAgaXNGYWlsdXJlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgdGhlIGJ5dGVzIHRyYW5zbWlzc2lvbiBmb3IgcmVzcG9uc2XigJlzIG1lc3NhZ2VcbiAgICAgICAgLy8gYm9keSBpcyBkb25lIG5vcm1hbGx5IGFuZCBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gY2xvc2VcbiAgICAgICAgLy8gc3RyZWFtLCBmaW5hbGl6ZSByZXNwb25zZSBmb3IgZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLCBhbmRcbiAgICAgICAgLy8gYWJvcnQgdGhlc2UgaW4tcGFyYWxsZWwgc3RlcHMuXG4gICAgICAgIHJlYWRhYmxlU3RyZWFtQ2xvc2UoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyKVxuXG4gICAgICAgIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBkZWNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgdGltaW5nSW5mby5kZWNvZGVkQm9keVNpemUgKz0gYnl0ZXM/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgICAvLyA2LiBJZiBieXRlcyBpcyBmYWlsdXJlLCB0aGVuIHRlcm1pbmF0ZSBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChpc0ZhaWx1cmUpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoYnl0ZXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA3LiBFbnF1ZXVlIGEgVWludDhBcnJheSB3cmFwcGluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGJ5dGVzXG4gICAgICAvLyBpbnRvIHN0cmVhbS5cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKVxuICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgLy8gOC4gSWYgc3RyZWFtIGlzIGVycm9yZWQsIHRoZW4gdGVybWluYXRlIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDkuIElmIHN0cmVhbSBkb2VzbuKAmXQgbmVlZCBtb3JlIGRhdGEgYXNrIHRoZSB1c2VyIGFnZW50IHRvIHN1c3BlbmRcbiAgICAgIC8vIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDIuIElmIGFib3J0ZWQsIHRoZW46XG4gIGZ1bmN0aW9uIG9uQWJvcnRlZCAocmVhc29uKSB7XG4gICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZCwgdGhlbjpcbiAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyBhYm9ydGVkIGZsYWcuXG4gICAgICByZXNwb25zZS5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBJZiBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gZXJyb3Igc3RyZWFtIHdpdGggdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gICAgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBnaXZlbiBmZXRjaFBhcmFtc+KAmXNcbiAgICAgIC8vICAgIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZCBhblxuICAgICAgLy8gICAgaW1wbGVtZW50YXRpb24tZGVmaW5lZCByZWFsbS5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBzdHJlYW0gaXMgcmVhZGFibGUsIGVycm9yIHN0cmVhbSB3aXRoIGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IobmV3IFR5cGVFcnJvcigndGVybWluYXRlZCcsIHtcbiAgICAgICAgICBjYXVzZTogaXNFcnJvckxpa2UocmVhc29uKSA/IHJlYXNvbiA6IHVuZGVmaW5lZFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCB0aGUgdXNlciBhZ2VudCBzaG91bGQgY2xvc2UgY29ubmVjdGlvbiB1bmxlc3MgaXQgd291bGQgYmUgYmFkIGZvciBwZXJmb3JtYW5jZSB0byBkbyBzby5cbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG4gIH1cblxuICAvLyAyMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2VcblxuICBmdW5jdGlvbiBkaXNwYXRjaCAoeyBib2R5IH0pIHtcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi8uLicpLkFnZW50fSAqL1xuICAgIGNvbnN0IGFnZW50ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kaXNwYXRjaGVyXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWdlbnQuZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIHBhdGg6IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsXG4gICAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgYm9keTogYWdlbnQuaXNNb2NrQWN0aXZlID8gcmVxdWVzdC5ib2R5ICYmIChyZXF1ZXN0LmJvZHkuc291cmNlIHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pIDogYm9keSxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzTGlzdC5lbnRyaWVzLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnM6IDAsXG4gICAgICAgIHVwZ3JhZGU6IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcgPyAnd2Vic29ja2V0JyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgYWJvcnQ6IG51bGwsXG5cbiAgICAgICAgb25Db25uZWN0IChhYm9ydCkge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgY29ubmVjdGlvbiBoZXJlP1xuICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxuXG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGNsYW1wIGFuZCBjb2Fyc2VuXG4gICAgICAgICAgLy8gY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB3aXRoIGNvbm5lY3Rpb27igJlzIHRpbWluZyBpbmZvLCB0aW1pbmdJbmZv4oCZcyBwb3N0LXJlZGlyZWN0IHN0YXJ0XG4gICAgICAgICAgLy8gdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY29ubmVjdGlvbiB0aW1pbmdcbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8gPSBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyh1bmRlZmluZWQsIHRpbWluZ0luZm8ucG9zdFJlZGlyZWN0U3RhcnRUaW1lLCBmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcblxuICAgICAgICAgIGlmIChjb25uZWN0aW9uLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgYWJvcnQobmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKCd0ZXJtaW5hdGVkJywgYWJvcnQpXG4gICAgICAgICAgICB0aGlzLmFib3J0ID0gY29ubmVjdGlvbi5hYm9ydCA9IGFib3J0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVxdWVzdCBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlblxuICAgICAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsTmV0d29ya1JlcXVlc3RTdGFydFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc3BvbnNlU3RhcnRlZCAoKSB7XG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50XG4gICAgICAgICAgLy8gdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHksIGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgICAgICAgIC8vIHVzZXIgYWdlbnTigJlzIEhUVFAgcGFyc2VyIHJlY2VpdmVzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZSAoZS5nLiwgZnJhbWUgaGVhZGVyXG4gICAgICAgICAgLy8gYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXMgbGluZSBmb3IgSFRUUC8xLngpLlxuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgICAgICAgfSxcblxuICAgICAgICBvbkhlYWRlcnMgKHN0YXR1cywgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA8IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnNMaXN0LmdldCgnbG9jYXRpb24nLCB0cnVlKVxuXG4gICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVhZDogcmVzdW1lIH0pXG5cbiAgICAgICAgICBjb25zdCB3aWxsRm9sbG93ID0gbG9jYXRpb24gJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycgJiZcbiAgICAgICAgICAgIHJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpXG5cbiAgICAgICAgICBjb25zdCBkZWNvZGVycyA9IFtdXG5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1FbmNvZGluZ1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnQ09OTkVDVCcgJiYgIW51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykgJiYgIXdpbGxGb2xsb3cpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gaGVhZGVyc0xpc3QuZ2V0KCdjb250ZW50LWVuY29kaW5nJywgdHJ1ZSlcbiAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgICAgICAgY29uc3QgY29kaW5ncyA9IGNvbnRlbnRFbmNvZGluZyA/IGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykgOiBbXVxuXG4gICAgICAgICAgICAvLyBMaW1pdCB0aGUgbnVtYmVyIG9mIGNvbnRlbnQtZW5jb2RpbmdzIHRvIHByZXZlbnQgcmVzb3VyY2UgZXhoYXVzdGlvbi5cbiAgICAgICAgICAgIC8vIENWRSBmaXggc2ltaWxhciB0byB1cmxsaWIzIChHSFNBLWdtNjIteHYyai00dzUzKSBhbmQgY3VybCAoQ1ZFLTIwMjItMzIyMDYpLlxuICAgICAgICAgICAgY29uc3QgbWF4Q29udGVudEVuY29kaW5ncyA9IDVcbiAgICAgICAgICAgIGlmIChjb2RpbmdzLmxlbmd0aCA+IG1heENvbnRlbnRFbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgdG9vIG1hbnkgY29udGVudC1lbmNvZGluZ3MgaW4gcmVzcG9uc2U6ICR7Y29kaW5ncy5sZW5ndGh9LCBtYXhpbXVtIGFsbG93ZWQgaXMgJHttYXhDb250ZW50RW5jb2RpbmdzfWApKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29kaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICBjb25zdCBjb2RpbmcgPSBjb2RpbmdzW2ldLnRyaW0oKVxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMi5odG1sI3NlY3Rpb24tNy4yXG4gICAgICAgICAgICAgIGlmIChjb2RpbmcgPT09ICd4LWd6aXAnIHx8IGNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUd1bnppcCh7XG4gICAgICAgICAgICAgICAgICAvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAgIC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgLy8gYnkgY29tbW9uIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKGNyZWF0ZUluZmxhdGUoe1xuICAgICAgICAgICAgICAgICAgZmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyh7XG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnenN0ZCcgJiYgaGFzWnN0ZCkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVac3RkRGVjb21wcmVzcyh7XG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuWlNURF9lX2NvbnRpbnVlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLlpTVERfZV9lbmRcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyc0xpc3QsXG4gICAgICAgICAgICBib2R5OiBkZWNvZGVycy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBwaXBlbGluZSh0aGlzLmJvZHksIC4uLmRlY29kZXJzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgICAgIDogdGhpcy5ib2R5Lm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhIChjaHVuaykge1xuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIElmIG9uZSBvciBtb3JlIGJ5dGVzIGhhdmUgYmVlbiB0cmFuc21pdHRlZCBmcm9tIHJlc3BvbnNl4oCZc1xuICAgICAgICAgIC8vIG1lc3NhZ2UgYm9keSwgdGhlbjpcblxuICAgICAgICAgIC8vICAxLiBMZXQgYnl0ZXMgYmUgdGhlIHRyYW5zbWl0dGVkIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gY2h1bmtcblxuICAgICAgICAgIC8vICAyLiBMZXQgY29kaW5ncyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAgICAgLy8gIGdpdmVuIGBDb250ZW50LUVuY29kaW5nYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICAgIC8vICBTZWUgcHVsbEFsZ29yaXRobS5cblxuICAgICAgICAgIC8vICAzLiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBlbmNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgICAgICAgIC8vICA0LiBTZWUgcHVsbEFsZ29yaXRobS4uLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tcGxldGUgKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCA9IHRydWVcblxuICAgICAgICAgIHRoaXMuYm9keS5wdXNoKG51bGwpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keT8uZGVzdHJveShlcnJvcilcblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycm9yKVxuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uVXBncmFkZSAoc3RhdHVzLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHN1cHBvcnQgMjAwIGZvciB3ZWJzb2NrZXQgb3ZlciBoMiBhcyBwZXIgUkZDLTg0NDFcbiAgICAgICAgICAvLyBBYnNlbmNlIG9mIHNlc3Npb24gbWVhbnMgSDFcbiAgICAgICAgICBpZiAoKHNvY2tldC5zZXNzaW9uICE9IG51bGwgJiYgc3RhdHVzICE9PSAyMDApIHx8IChzb2NrZXQuc2Vzc2lvbiA9PSBudWxsICYmIHN0YXR1cyAhPT0gMTAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogU1RBVFVTX0NPREVTW3N0YXR1c10sXG4gICAgICAgICAgICBoZWFkZXJzTGlzdCxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { getMaxListeners, setMaxListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nlet abortSignalHasEventHandlerLeakWarning\n\ntry {\n  abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0\n} catch {\n  abortSignalHasEventHandlerLeakWarning = false\n}\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  /** @type {AbortSignal} */\n  #signal\n\n  /** @type {import('../../dispatcher/dispatcher')} */\n  #dispatcher\n\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input)\n    init = webidl.converters.RequestInit(init)\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be thiss relevant settings objects API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this.#dispatcher = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(webidl.is.Request(input))\n\n      // 8. Set request to inputs request.\n      request = input.#state\n\n      // 9. Set signal to inputs signal.\n      signal = input.#signal\n\n      this.#dispatcher = init.dispatcher || input.#dispatcher\n    }\n\n    // 7. Let origin be thiss relevant settings objects origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If requests window is an environment settings object and its origin\n    // is same origin with origin, then set window to requests window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL requests URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method requests method.\n      method: request.method,\n      // header list A copy of requests header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client Thiss relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority requests priority.\n      priority: request.priority,\n      // origin requests origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer requests referrer.\n      referrer: request.referrer,\n      // referrer policy requests referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode requests mode.\n      mode: request.mode,\n      // credentials mode requests credentials mode.\n      credentials: request.credentials,\n      // cache mode requests cache mode.\n      cache: request.cache,\n      // redirect mode requests redirect mode.\n      redirect: request.redirect,\n      // integrity metadata requests integrity metadata.\n      integrity: request.integrity,\n      // keepalive requests keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag requests reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag requests history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of requests URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset requests reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset requests history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set requests origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set requests referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set requests referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set requests URL to requests current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set requests URL list to  requests URL .\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrers origin is not same origin with origin\n        // then set requests referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set requests referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set requests mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set requests credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set requests method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set thiss request to request.\n    this.#state = request\n\n    // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this.#signal = ac.signal\n\n    // 29. If signal is not null, then make thiss signal follow signal.\n    if (signal != null) {\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // If the max amount of listeners is equal to the default, increase it\n        if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {\n          setMaxListeners(1500, signal)\n        }\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is requests header list and guard is\n    // \"request\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersList(this.#headers, request.headersList)\n    setHeadersGuard(this.#headers, 'request')\n\n    // 31. If thiss requests mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If thiss requests method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set thiss headerss guard to \"request-no-cors\".\n      setHeadersGuard(this.#headers, 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this.#headers)\n      // 1. Let headers be a copy of thiss headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty thiss headerss header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append headers name/headers value to thiss headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill thiss headers with headers.\n        fillHeaders(this.#headers, headers)\n      }\n    }\n\n    // 33. Let inputBody be inputs requests body if input is a Request\n    // object; otherwise null.\n    const inputBody = webidl.is.Request(input) ? input.#state.body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and requests method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to requests keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and thiss headerss header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // thiss headers.\n      if (contentType && !getHeadersList(this.#headers).contains('content-type', true)) {\n        this.#headers.append('content-type', contentType, true)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set thiss requests use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (bodyUnusable(input.#state)) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set thiss requests body to finalBody.\n    this.#state.body = finalBody\n  }\n\n  // Returns requests HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return thiss requests method.\n    return this.#state.method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return thiss requests URL, serialized.\n    return URLSerializer(this.#state.url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return thiss headers.\n    return this.#headers\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return thiss requests destination.\n    return this.#state.destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the globals default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If thiss requests referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this.#state.referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If thiss requests referrer is \"client\", then return\n    // \"about:client\".\n    if (this.#state.referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return thiss requests referrer, serialized.\n    return this.#state.referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the requests\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return thiss requests referrer policy.\n    return this.#state.referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return thiss requests mode.\n    return this.#state.mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    webidl.brandCheck(this, Request)\n\n    // The credentials getter steps are to return thiss requests credentials mode.\n    return this.#state.credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browsers cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return thiss requests cache mode.\n    return this.#state.cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return thiss requests redirect mode.\n    return this.#state.redirect\n  }\n\n  // Returns requests subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return thiss requests integrity\n    // metadata.\n    return this.#state.integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return thiss requests keepalive.\n    return this.#state.keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if thiss\n    // requests reload-navigation flag is set; otherwise false.\n    return this.#state.reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if thiss requests\n    // history-navigation flag is set; otherwise false.\n    return this.#state.historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return thiss signal.\n    return this.#signal\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning thiss request.\n    const clonedRequest = cloneRequest(this.#state)\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n    // 4. Make clonedRequestObjects signal follow thiss signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Request} request\n   * @param {AbortSignal} newSignal\n   */\n  static setRequestSignal (request, newSignal) {\n    request.#signal = newSignal\n    return request\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestDispatcher (request) {\n    return request.#dispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {import('../../dispatcher/dispatcher')} newDispatcher\n   */\n  static setRequestDispatcher (request, newDispatcher) {\n    request.#dispatcher = newDispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {Headers} newHeaders\n   */\n  static setRequestHeaders (request, newHeaders) {\n    request.#headers = newHeaders\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestState (request) {\n    return request.#state\n  }\n\n  /**\n   * @param {Request} request\n   * @param {any} newState\n   */\n  static setRequestState (request, newState) {\n    request.#state = newState\n  }\n}\n\nconst { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request\nReflect.deleteProperty(Request, 'setRequestSignal')\nReflect.deleteProperty(Request, 'getRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestHeaders')\nReflect.deleteProperty(Request, 'getRequestState')\nReflect.deleteProperty(Request, 'setRequestState')\n\nmixinBody(Request, getRequestState)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    useURLCredentials: init.useURLCredentials ?? undefined,\n    traversableForUserPrompts: init.traversableForUserPrompts ?? 'client',\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If requests body is non-null, set newRequests body to the\n  // result of cloning requests body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {import('../../dispatcher/agent')} dispatcher\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, dispatcher, signal, guard) {\n  const request = new Request(kConstruct)\n  setRequestState(request, innerRequest)\n  setRequestDispatcher(request, dispatcher)\n  setRequestSignal(request, signal)\n  const headers = new Headers(kConstruct)\n  setRequestHeaders(request, headers)\n  setHeadersList(headers, innerRequest.headersList)\n  setHeadersGuard(headers, guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.is.Request = webidl.util.MakeTypeAssertion(Request)\n\n/**\n * @param {*} V\n * @returns {import('../../../types/fetch').Request|string}\n *\n * @see https://fetch.spec.whatwg.org/#requestinfo\n */\nwebidl.converters.RequestInfo = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (webidl.is.Request(V)) {\n    return V\n  }\n\n  return webidl.converters.USVString(V)\n}\n\n/**\n * @param {*} V\n * @returns {import('../../../types/fetch').RequestInit}\n * @see https://fetch.spec.whatwg.org/#requestinit\n */\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal'\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  },\n  {\n    key: 'priority',\n    converter: webidl.converters.DOMString,\n    allowedValues: ['high', 'low', 'auto'],\n    defaultValue: () => 'auto'\n  }\n])\n\nmodule.exports = {\n  Request,\n  makeRequest,\n  fromInnerRequest,\n  cloneRequest,\n  getRequestDispatcher,\n  getRequestState\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGtEQUFrRCxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDNUUsUUFBUSw0R0FBNEcsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ3pJLGFBQWEsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsNEJBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QixRQUFRLDRFQUE0RTtBQUNwRixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUM5QyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx3REFBd0QsRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUV2Rjs7QUFFQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOztBQUVBLGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG1FQUFtRSxZQUFZO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJDQUEyQyxTQUFTLDBCQUEwQixZQUFZO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBZ0Q7QUFDdEU7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsb0hBQW9IO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyx3QkFBd0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsbUVBQW1FO0FBQzlFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBBYm9ydENvbnRyb2xsZXIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZXh0cmFjdEJvZHksIG1peGluQm9keSwgY2xvbmVCb2R5LCBib2R5VW51c2FibGUgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB7IEhlYWRlcnMsIGZpbGw6IGZpbGxIZWFkZXJzLCBIZWFkZXJzTGlzdCwgc2V0SGVhZGVyc0d1YXJkLCBnZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNMaXN0LCBnZXRIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlcXVlc3REdXBsZXhcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgfSA9IHV0aWxcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZ2V0TWF4TGlzdGVuZXJzLCBzZXRNYXhMaXN0ZW5lcnMsIGRlZmF1bHRNYXhMaXN0ZW5lcnMgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY29uc3Qga0Fib3J0Q29udHJvbGxlciA9IFN5bWJvbCgnYWJvcnRDb250cm9sbGVyJylcblxuY29uc3QgcmVxdWVzdEZpbmFsaXplciA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBzaWduYWwsIGFib3J0IH0pID0+IHtcbiAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpXG59KVxuXG5jb25zdCBkZXBlbmRlbnRDb250cm9sbGVyTWFwID0gbmV3IFdlYWtNYXAoKVxuXG5sZXQgYWJvcnRTaWduYWxIYXNFdmVudEhhbmRsZXJMZWFrV2FybmluZ1xuXG50cnkge1xuICBhYm9ydFNpZ25hbEhhc0V2ZW50SGFuZGxlckxlYWtXYXJuaW5nID0gZ2V0TWF4TGlzdGVuZXJzKG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpID4gMFxufSBjYXRjaCB7XG4gIGFib3J0U2lnbmFsSGFzRXZlbnRIYW5kbGVyTGVha1dhcm5pbmcgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBidWlsZEFib3J0IChhY1JlZikge1xuICByZXR1cm4gYWJvcnRcblxuICBmdW5jdGlvbiBhYm9ydCAoKSB7XG4gICAgY29uc3QgYWMgPSBhY1JlZi5kZXJlZigpXG4gICAgaWYgKGFjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEN1cnJlbnRseSwgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggRmluYWxpemF0aW9uUmVnaXN0cnkuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ3NzQ4XG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhYm9ydCwgdGhlIGZpcnN0IHN0ZXAgaXMgdG8gdW5yZWdpc3RlciBmcm9tIGl0LlxuICAgICAgLy8gSWYgdGhlIGNvbnRyb2xsZXIgY2FuIHJlZmVyIHRvIGl0LCBpdCBpcyBzdGlsbCByZWdpc3RlcmVkLlxuICAgICAgLy8gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICByZXF1ZXN0RmluYWxpemVyLnVucmVnaXN0ZXIoYWJvcnQpXG5cbiAgICAgIC8vIFVuc3Vic2NyaWJlIGEgbGlzdGVuZXIuXG4gICAgICAvLyBGaW5hbGl6YXRpb25SZWdpc3RyeSB3aWxsIG5vIGxvbmdlciBiZSBjYWxsZWQsIHNvIHRoaXMgbXVzdCBiZSBkb25lLlxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KVxuXG4gICAgICBhYy5hYm9ydCh0aGlzLnJlYXNvbilcblxuICAgICAgY29uc3QgY29udHJvbGxlckxpc3QgPSBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmdldChhYy5zaWduYWwpXG5cbiAgICAgIGlmIChjb250cm9sbGVyTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyTGlzdC5zaXplICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgY29udHJvbGxlckxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0cmwgPSByZWYuZGVyZWYoKVxuICAgICAgICAgICAgaWYgKGN0cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjdHJsLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyTGlzdC5jbGVhcigpXG4gICAgICAgIH1cbiAgICAgICAgZGVwZW5kZW50Q29udHJvbGxlck1hcC5kZWxldGUoYWMuc2lnbmFsKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5sZXQgcGF0Y2hNZXRob2RXYXJuaW5nID0gZmFsc2VcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY2xhc3NcbmNsYXNzIFJlcXVlc3Qge1xuICAvKiogQHR5cGUge0Fib3J0U2lnbmFsfSAqL1xuICAjc2lnbmFsXG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpfSAqL1xuICAjZGlzcGF0Y2hlclxuXG4gIC8qKiBAdHlwZSB7SGVhZGVyc30gKi9cbiAgI2hlYWRlcnNcblxuICAjc3RhdGVcblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3RcbiAgY29uc3RydWN0b3IgKGlucHV0LCBpbml0ID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIGlmIChpbnB1dCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1JlcXVlc3QgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0KVxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdChpbml0KVxuXG4gICAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgbnVsbC5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuIExldCBmYWxsYmFja01vZGUgYmUgbnVsbC5cbiAgICBsZXQgZmFsbGJhY2tNb2RlID0gbnVsbFxuXG4gICAgLy8gMy4gTGV0IGJhc2VVUkwgYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVybCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hlciA9IGluaXQuZGlzcGF0Y2hlclxuXG4gICAgICAvLyAxLiBMZXQgcGFyc2VkVVJMIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBpbnB1dCB3aXRoIGJhc2VVUkwuXG4gICAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGxldCBwYXJzZWRVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQsIGJhc2VVcmwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICcgKyBpbnB1dCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHBhcnNlZFVSTCBpbmNsdWRlcyBjcmVkZW50aWFscywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgfHwgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1JlcXVlc3QgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBVUkwgdGhhdCBpbmNsdWRlcyBjcmVkZW50aWFsczogJyArXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2hvc2UgVVJMIGlzIHBhcnNlZFVSTC5cbiAgICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IHVybExpc3Q6IFtwYXJzZWRVUkxdIH0pXG5cbiAgICAgIC8vIDUuIFNldCBmYWxsYmFja01vZGUgdG8gXCJjb3JzXCIuXG4gICAgICBmYWxsYmFja01vZGUgPSAnY29ycydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNi4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA3LiBBc3NlcnQ6IGlucHV0IGlzIGEgUmVxdWVzdCBvYmplY3QuXG4gICAgICBhc3NlcnQod2ViaWRsLmlzLlJlcXVlc3QoaW5wdXQpKVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdCB0byBpbnB1dOKAmXMgcmVxdWVzdC5cbiAgICAgIHJlcXVlc3QgPSBpbnB1dC4jc3RhdGVcblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXQuI3NpZ25hbFxuXG4gICAgICB0aGlzLiNkaXNwYXRjaGVyID0gaW5pdC5kaXNwYXRjaGVyIHx8IGlucHV0LiNkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IG9yaWdpbiBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIG9yaWdpbi5cbiAgICBjb25zdCBvcmlnaW4gPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0Lm9yaWdpblxuXG4gICAgLy8gOC4gTGV0IHdpbmRvdyBiZSBcImNsaWVudFwiLlxuICAgIGxldCB3aW5kb3cgPSAnY2xpZW50J1xuXG4gICAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCBhbmQgaXRzIG9yaWdpblxuICAgIC8vIGlzIHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luLCB0aGVuIHNldCB3aW5kb3cgdG8gcmVxdWVzdOKAmXMgd2luZG93LlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3Qud2luZG93Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vudmlyb25tZW50U2V0dGluZ3NPYmplY3QnICYmXG4gICAgICBzYW1lT3JpZ2luKHJlcXVlc3Qud2luZG93LCBvcmlnaW4pXG4gICAgKSB7XG4gICAgICB3aW5kb3cgPSByZXF1ZXN0LndpbmRvd1xuICAgIH1cblxuICAgIC8vIDEwLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHt3aW5kb3d9JyBtdXN0IGJlIG51bGxgKVxuICAgIH1cblxuICAgIC8vIDExLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cywgdGhlbiBzZXQgd2luZG93IHRvIFwibm8td2luZG93XCIuXG4gICAgaWYgKCd3aW5kb3cnIGluIGluaXQpIHtcbiAgICAgIHdpbmRvdyA9ICduby13aW5kb3cnXG4gICAgfVxuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICAgIC8vIFVSTCByZXF1ZXN04oCZcyBVUkwuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBpcyBzZXQgYXMgdGhlIGZpcnN0IGl0ZW0gaW4gcmVxdWVzdCdzIHVybExpc3QgaW4gbWFrZVJlcXVlc3RcbiAgICAgIC8vIG1ldGhvZCByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgLy8gaGVhZGVyIGxpc3QgQSBjb3B5IG9mIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IGhlYWRlcnNMaXN0IGlzIGNsb25lZCBpbiBtYWtlUmVxdWVzdFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QuaGVhZGVyc0xpc3QsXG4gICAgICAvLyB1bnNhZmUtcmVxdWVzdCBmbGFnIFNldC5cbiAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QudW5zYWZlUmVxdWVzdCxcbiAgICAgIC8vIGNsaWVudCBUaGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgICBjbGllbnQ6IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QsXG4gICAgICAvLyB3aW5kb3cgd2luZG93LlxuICAgICAgd2luZG93LFxuICAgICAgLy8gcHJpb3JpdHkgcmVxdWVzdOKAmXMgcHJpb3JpdHkuXG4gICAgICBwcmlvcml0eTogcmVxdWVzdC5wcmlvcml0eSxcbiAgICAgIC8vIG9yaWdpbiByZXF1ZXN04oCZcyBvcmlnaW4uIFRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgb3JpZ2luIGlzIG9ubHkgc2lnbmlmaWNhbnQgZm9yIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAgICAgIC8vIGJlaW5nIGhhbmRsZWQgYnkgYSBzZXJ2aWNlIHdvcmtlci4gSW4gdGhpcyBzY2VuYXJpbyBhIHJlcXVlc3QgY2FuIGhhdmUgYW4gb3JpZ2luIHRoYXQgaXMgZGlmZmVyZW50XG4gICAgICAvLyBmcm9tIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICAvLyByZWZlcnJlciByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICAgIHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgLy8gcmVmZXJyZXIgcG9saWN5IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgLy8gbW9kZSByZXF1ZXN04oCZcyBtb2RlLlxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgLy8gY3JlZGVudGlhbHMgbW9kZSByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICAvLyBjYWNoZSBtb2RlIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIC8vIHJlZGlyZWN0IG1vZGUgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgLy8gaW50ZWdyaXR5IG1ldGFkYXRhIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YS5cbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICAvLyBrZWVwYWxpdmUgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAga2VlcGFsaXZlOiByZXF1ZXN0LmtlZXBhbGl2ZSxcbiAgICAgIC8vIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAvLyBVUkwgbGlzdCBBIGNsb25lIG9mIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QudXJsTGlzdF1cbiAgICB9KVxuXG4gICAgY29uc3QgaW5pdEhhc0tleSA9IE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCAhPT0gMFxuXG4gICAgLy8gMTMuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChpbml0SGFzS2V5KSB7XG4gICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiBzZXQgaXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICByZXF1ZXN0Lm1vZGUgPSAnc2FtZS1vcmlnaW4nXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFVuc2V0IHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyAzLiBVbnNldCByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIFwiY2xpZW50XCIuXG4gICAgICByZXF1ZXN0Lm9yaWdpbiA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDUuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiXG4gICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcblxuICAgICAgLy8gNi4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9ICcnXG5cbiAgICAgIC8vIDcuIFNldCByZXF1ZXN04oCZcyBVUkwgdG8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3TigJlzIFVSTCBsaXN0IHRvIMKrIHJlcXVlc3TigJlzIFVSTCDCuy5cbiAgICAgIHJlcXVlc3QudXJsTGlzdCA9IFtyZXF1ZXN0LnVybF1cbiAgICB9XG5cbiAgICAvLyAxNC4gSWYgaW5pdFtcInJlZmVycmVyXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVmZXJyZXIgYmUgaW5pdFtcInJlZmVycmVyXCJdLlxuICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyXG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwibm8tcmVmZXJyZXJcIi5cbiAgICAgIGlmIChyZWZlcnJlciA9PT0gJycpIHtcbiAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICduby1yZWZlcnJlcidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBwYXJzZWRSZWZlcnJlciBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgcmVmZXJyZXIgd2l0aFxuICAgICAgICAvLyBiYXNlVVJMLlxuICAgICAgICAvLyAyLiBJZiBwYXJzZWRSZWZlcnJlciBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBsZXQgcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIsIGJhc2VVcmwpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlZmVycmVyIFwiJHtyZWZlcnJlcn1cIiBpcyBub3QgYSB2YWxpZCBVUkwuYCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIHNjaGVtZSBpcyBcImFib3V0XCIgYW5kIHBhdGggaXMgdGhlIHN0cmluZyBcImNsaWVudFwiXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW5cbiAgICAgICAgLy8gdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJzZWRSZWZlcnJlci5wcm90b2NvbCA9PT0gJ2Fib3V0OicgJiYgcGFyc2VkUmVmZXJyZXIuaG9zdG5hbWUgPT09ICdjbGllbnQnKSB8fFxuICAgICAgICAgIChvcmlnaW4gJiYgIXNhbWVPcmlnaW4ocGFyc2VkUmVmZXJyZXIsIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDQuIE90aGVyd2lzZSwgc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIHBhcnNlZFJlZmVycmVyLlxuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBwYXJzZWRSZWZlcnJlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTUuIElmIGluaXRbXCJyZWZlcnJlclBvbGljeVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZmVycmVyUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5XG4gICAgfVxuXG4gICAgLy8gMTYuIExldCBtb2RlIGJlIGluaXRbXCJtb2RlXCJdIGlmIGl0IGV4aXN0cywgYW5kIGZhbGxiYWNrTW9kZSBvdGhlcndpc2UuXG4gICAgbGV0IG1vZGVcbiAgICBpZiAoaW5pdC5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vZGUgPSBpbml0Lm1vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZSA9IGZhbGxiYWNrTW9kZVxuICAgIH1cblxuICAgIC8vIDE3LiBJZiBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAobW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXF1ZXN0IGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgcmVxdWVzdCBtb2RlIG5hdmlnYXRlLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMTguIElmIG1vZGUgaXMgbm9uLW51bGwsIHNldCByZXF1ZXN04oCZcyBtb2RlIHRvIG1vZGUuXG4gICAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5tb2RlID0gbW9kZVxuICAgIH1cblxuICAgIC8vIDE5LiBJZiBpbml0W1wiY3JlZGVudGlhbHNcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlXG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgaW5pdFtcImNhY2hlXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5jYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNhY2hlID0gaW5pdC5jYWNoZVxuICAgIH1cblxuICAgIC8vIDIxLiBJZiByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiBhbmQgcmVxdWVzdOKAmXMgbW9kZSBpc1xuICAgIC8vIG5vdCBcInNhbWUtb3JpZ2luXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHJlcXVlc3QuY2FjaGUgPT09ICdvbmx5LWlmLWNhY2hlZCcgJiYgcmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidvbmx5LWlmLWNhY2hlZCcgY2FuIGJlIHNldCBvbmx5IHdpdGggJ3NhbWUtb3JpZ2luJyBtb2RlXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyAyMi4gSWYgaW5pdFtcInJlZGlyZWN0XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdFxuICAgIH1cblxuICAgIC8vIDIzLiBJZiBpbml0W1wiaW50ZWdyaXR5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIHRvIGl0LlxuICAgIGlmIChpbml0LmludGVncml0eSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LmludGVncml0eSA9IFN0cmluZyhpbml0LmludGVncml0eSlcbiAgICB9XG5cbiAgICAvLyAyNC4gSWYgaW5pdFtcImtlZXBhbGl2ZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGtlZXBhbGl2ZSB0byBpdC5cbiAgICBpZiAoaW5pdC5rZWVwYWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5rZWVwYWxpdmUgPSBCb29sZWFuKGluaXQua2VlcGFsaXZlKVxuICAgIH1cblxuICAgIC8vIDI1LiBJZiBpbml0W1wibWV0aG9kXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IG1ldGhvZCBiZSBpbml0W1wibWV0aG9kXCJdLlxuICAgICAgbGV0IG1ldGhvZCA9IGluaXQubWV0aG9kXG5cbiAgICAgIGNvbnN0IG1heUJlTm9ybWFsaXplZCA9IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF1cblxuICAgICAgaWYgKG1heUJlTm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdGU6IEJ5cGFzcyB2YWxpZGF0aW9uIERFTEVURSwgR0VULCBIRUFELCBPUFRJT05TLCBQT1NULCBQVVQsIFBBVENIIGFuZCB0aGVzZSBsb3dlcmNhc2Ugb25lc1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1heUJlTm9ybWFsaXplZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4gSWYgbWV0aG9kIGlzIG5vdCBhIG1ldGhvZCBvciBtZXRob2QgaXMgYSBmb3JiaWRkZW4gbWV0aG9kLCB0aGVuXG4gICAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCcke21ldGhvZH0nIGlzIG5vdCBhIHZhbGlkIEhUVFAgbWV0aG9kLmApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cHBlckNhc2UgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuXG4gICAgICAgIGlmIChmb3JiaWRkZW5NZXRob2RzU2V0Lmhhcyh1cHBlckNhc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgSFRUUCBtZXRob2QgaXMgdW5zdXBwb3J0ZWQuYClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIE5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAgICAgICAgLy8gTm90ZTogbXVzdCBiZSBpbiB1cHBlcmNhc2VcbiAgICAgICAgbWV0aG9kID0gbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlW3VwcGVyQ2FzZV0gPz8gbWV0aG9kXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBtZXRob2QuXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gbWV0aG9kXG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0Y2hNZXRob2RXYXJuaW5nICYmIHJlcXVlc3QubWV0aG9kID09PSAncGF0Y2gnKSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1VzaW5nIGBwYXRjaGAgaXMgaGlnaGx5IGxpa2VseSB0byByZXN1bHQgaW4gYSBgNDA1IE1ldGhvZCBOb3QgQWxsb3dlZGAuIGBQQVRDSGAgaXMgbXVjaCBtb3JlIGxpa2VseSB0byBzdWNjZWVkLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUZFVENILXBhdGNoJ1xuICAgICAgICB9KVxuXG4gICAgICAgIHBhdGNoTWV0aG9kV2FybmluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyNi4gSWYgaW5pdFtcInNpZ25hbFwiXSBleGlzdHMsIHRoZW4gc2V0IHNpZ25hbCB0byBpdC5cbiAgICBpZiAoaW5pdC5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWxcbiAgICB9XG5cbiAgICAvLyAyNy4gU2V0IHRoaXPigJlzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzLiNzdGF0ZSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXMuI3NpZ25hbCA9IGFjLnNpZ25hbFxuXG4gICAgLy8gMjkuIElmIHNpZ25hbCBpcyBub3QgbnVsbCwgdGhlbiBtYWtlIHRoaXPigJlzIHNpZ25hbCBmb2xsb3cgc2lnbmFsLlxuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHNpZ25hbC5yZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGEgc3Ryb25nIHJlZiB0byBhYyB3aGlsZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAvLyBpcyBhbGl2ZS4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgLy8gZnJvbSBiZWluZyBwcmVtYXR1cmVseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTkyNi5cbiAgICAgICAgdGhpc1trQWJvcnRDb250cm9sbGVyXSA9IGFjXG5cbiAgICAgICAgY29uc3QgYWNSZWYgPSBuZXcgV2Vha1JlZihhYylcbiAgICAgICAgY29uc3QgYWJvcnQgPSBidWlsZEFib3J0KGFjUmVmKVxuXG4gICAgICAgIC8vIElmIHRoZSBtYXggYW1vdW50IG9mIGxpc3RlbmVycyBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCwgaW5jcmVhc2UgaXRcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsSGFzRXZlbnRIYW5kbGVyTGVha1dhcm5pbmcgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTUwMCwgc2lnbmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgYWJvcnQpXG4gICAgICAgIC8vIFRoZSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgcmVnaXN0cnkga2V5IHRvIGJlIHVucmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2l0aG91dCBpdCwgeW91IGNhbm5vdCB1bnJlZ2lzdGVyLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyBhYm9ydCBpcyB1c2VkIGFzIHRoZSB1bnJlZ2lzdGVyIGtleS4gKGJlY2F1c2UgaXQgaXMgdW5pcXVlKVxuICAgICAgICByZXF1ZXN0RmluYWxpemVyLnJlZ2lzdGVyKGFjLCB7IHNpZ25hbCwgYWJvcnQgfSwgYWJvcnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzAuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkIGlzXG4gICAgLy8gXCJyZXF1ZXN0XCIuXG4gICAgdGhpcy4jaGVhZGVycyA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gICAgc2V0SGVhZGVyc0xpc3QodGhpcy4jaGVhZGVycywgcmVxdWVzdC5oZWFkZXJzTGlzdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpcy4jaGVhZGVycywgJ3JlcXVlc3QnKVxuXG4gICAgLy8gMzEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCIsIHRoZW46XG4gICAgaWYgKG1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2QsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQuaGFzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnJHtyZXF1ZXN0Lm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQgdG8gXCJyZXF1ZXN0LW5vLWNvcnNcIi5cbiAgICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzLiNoZWFkZXJzLCAncmVxdWVzdC1uby1jb3JzJylcbiAgICB9XG5cbiAgICAvLyAzMi4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8qKiBAdHlwZSB7SGVhZGVyc0xpc3R9ICovXG4gICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KHRoaXMuI2hlYWRlcnMpXG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgY29uc3QgaGVhZGVycyA9IGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkID8gaW5pdC5oZWFkZXJzIDogbmV3IEhlYWRlcnNMaXN0KGhlYWRlcnNMaXN0KVxuXG4gICAgICAvLyAzLiBFbXB0eSB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIGhlYWRlcnNMaXN0LmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgaGVhZGVycy5yYXdWYWx1ZXMoKSkge1xuICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChuYW1lLCB2YWx1ZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogQ29weSB0aGUgYHNldC1jb29raWVgIG1ldGEtZGF0YS5cbiAgICAgICAgaGVhZGVyc0xpc3QuY29va2llcyA9IGhlYWRlcnMuY29va2llc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzLiNoZWFkZXJzLCBoZWFkZXJzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMzLiBMZXQgaW5wdXRCb2R5IGJlIGlucHV04oCZcyByZXF1ZXN04oCZcyBib2R5IGlmIGlucHV0IGlzIGEgUmVxdWVzdFxuICAgIC8vIG9iamVjdDsgb3RoZXJ3aXNlIG51bGwuXG4gICAgY29uc3QgaW5wdXRCb2R5ID0gd2ViaWRsLmlzLlJlcXVlc3QoaW5wdXQpID8gaW5wdXQuI3N0YXRlLmJvZHkgOiBudWxsXG5cbiAgICAvLyAzNC4gSWYgZWl0aGVyIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwgb3IgaW5wdXRCb2R5IGlzXG4gICAgLy8gbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYEdFVGAgb3IgYEhFQURgLCB0aGVuIHRocm93IGFcbiAgICAvLyBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgKGluaXQuYm9keSAhPSBudWxsIHx8IGlucHV0Qm9keSAhPSBudWxsKSAmJlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5LicpXG4gICAgfVxuXG4gICAgLy8gMzUuIExldCBpbml0Qm9keSBiZSBudWxsLlxuICAgIGxldCBpbml0Qm9keSA9IG51bGxcblxuICAgIC8vIDM2LiBJZiBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0LmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gTGV0IENvbnRlbnQtVHlwZSBiZSBudWxsLlxuICAgICAgLy8gMi4gU2V0IGluaXRCb2R5IGFuZCBDb250ZW50LVR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nXG4gICAgICAvLyBpbml0W1wiYm9keVwiXSwgd2l0aCBrZWVwYWxpdmUgc2V0IHRvIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShcbiAgICAgICAgaW5pdC5ib2R5LFxuICAgICAgICByZXF1ZXN0LmtlZXBhbGl2ZVxuICAgICAgKVxuICAgICAgaW5pdEJvZHkgPSBleHRyYWN0ZWRCb2R5XG5cbiAgICAgIC8vIDMsIElmIENvbnRlbnQtVHlwZSBpcyBub24tbnVsbCBhbmQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QgZG9lc1xuICAgICAgLy8gbm90IGNvbnRhaW4gYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIGBDb250ZW50LVR5cGVgL0NvbnRlbnQtVHlwZSB0b1xuICAgICAgLy8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhZ2V0SGVhZGVyc0xpc3QodGhpcy4jaGVhZGVycykuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzNy4gTGV0IGlucHV0T3JJbml0Qm9keSBiZSBpbml0Qm9keSBpZiBpdCBpcyBub24tbnVsbDsgb3RoZXJ3aXNlXG4gICAgLy8gaW5wdXRCb2R5LlxuICAgIGNvbnN0IGlucHV0T3JJbml0Qm9keSA9IGluaXRCb2R5ID8/IGlucHV0Qm9keVxuXG4gICAgLy8gMzguIElmIGlucHV0T3JJbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5wdXRPckluaXRCb2R54oCZcyBzb3VyY2UgaXNcbiAgICAvLyBudWxsLCB0aGVuOlxuICAgIGlmIChpbnB1dE9ySW5pdEJvZHkgIT0gbnVsbCAmJiBpbnB1dE9ySW5pdEJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbml0W1wiZHVwbGV4XCJdIGRvZXMgbm90IGV4aXN0LFxuICAgICAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpbml0Qm9keSAhPSBudWxsICYmIGluaXQuZHVwbGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdEluaXQ6IGR1cGxleCBvcHRpb24gaXMgcmVxdWlyZWQgd2hlbiBzZW5kaW5nIGEgYm9keS4nKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5laXRoZXIgXCJzYW1lLW9yaWdpblwiIG5vciBcImNvcnNcIixcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nICYmIHJlcXVlc3QubW9kZSAhPT0gJ2NvcnMnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0lmIHJlcXVlc3QgaXMgbWFkZSBmcm9tIFJlYWRhYmxlU3RyZWFtLCBtb2RlIHNob3VsZCBiZSBcInNhbWUtb3JpZ2luXCIgb3IgXCJjb3JzXCInXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMy4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnLlxuICAgICAgcmVxdWVzdC51c2VDT1JTUHJlZmxpZ2h0RmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyAzOS4gTGV0IGZpbmFsQm9keSBiZSBpbnB1dE9ySW5pdEJvZHkuXG4gICAgbGV0IGZpbmFsQm9keSA9IGlucHV0T3JJbml0Qm9keVxuXG4gICAgLy8gNDAuIElmIGluaXRCb2R5IGlzIG51bGwgYW5kIGlucHV0Qm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdEJvZHkgPT0gbnVsbCAmJiBpbnB1dEJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5wdXQgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoYm9keVVudXNhYmxlKGlucHV0LiNzdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnN0cnVjdCBhIFJlcXVlc3Qgd2l0aCBhIFJlcXVlc3Qgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkLidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgZmluYWxCb2R5IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwcm94eSBmb3IgaW5wdXRCb2R5LlxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpcy4jc3RhdGUuYm9keSA9IGZpbmFsQm9keVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBIVFRQIG1ldGhvZCwgd2hpY2ggaXMgXCJHRVRcIiBieSBkZWZhdWx0LlxuICBnZXQgbWV0aG9kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1ldGhvZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLm1ldGhvZFxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgVVJMIG9mIHJlcXVlc3QgYXMgYSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIFVSTCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzLiNzdGF0ZS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBraW5kIG9mIHJlc291cmNlIHJlcXVlc3RlZCBieSByZXF1ZXN0LCBlLmcuLCBcImRvY3VtZW50XCJcbiAgLy8gb3IgXCJzY3JpcHRcIi5cbiAgZ2V0IGRlc3RpbmF0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIGdldHRlciBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5kZXN0aW5hdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgb2YgcmVxdWVzdC4gSXRzIHZhbHVlIGNhbiBiZSBhIHNhbWUtb3JpZ2luIFVSTCBpZlxuICAvLyBleHBsaWNpdGx5IHNldCBpbiBpbml0LCB0aGUgZW1wdHkgc3RyaW5nIHRvIGluZGljYXRlIG5vIHJlZmVycmVyLCBhbmRcbiAgLy8gXCJhYm91dDpjbGllbnRcIiB3aGVuIGRlZmF1bHRpbmcgdG8gdGhlIGdsb2JhbOKAmXMgZGVmYXVsdC4gVGhpcyBpcyB1c2VkXG4gIC8vIGR1cmluZyBmZXRjaGluZyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBgUmVmZXJlcmAgaGVhZGVyIG9mIHRoZVxuICAvLyByZXF1ZXN0IGJlaW5nIG1hZGUuXG4gIGdldCByZWZlcnJlciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgdGhlbiByZXR1cm4gdGhlXG4gICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgIGlmICh0aGlzLiNzdGF0ZS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzLiNzdGF0ZS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAgIHJldHVybiAnYWJvdXQ6Y2xpZW50J1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVmZXJyZXIudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgcG9saWN5IGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHVzZWQgZHVyaW5nIGZldGNoaW5nIHRvIGNvbXB1dGUgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlci5cbiAgZ2V0IHJlZmVycmVyUG9saWN5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZmVycmVyUG9saWN5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5tb2RlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjcmVkZW50aWFscyBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHdoZXRoZXIgY3JlZGVudGlhbHMgd2lsbCBiZSBzZW50IHdpdGggdGhlXG4gIC8vIHJlcXVlc3QgYWx3YXlzLCBuZXZlciwgb3Igb25seSB3aGVuIHNlbnQgdG8gYSBzYW1lLW9yaWdpbiBVUkwuXG4gIGdldCBjcmVkZW50aWFscyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5jcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY2FjaGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgdGhlIHJlcXVlc3Qgd2lsbFxuICAvLyBpbnRlcmFjdCB3aXRoIHRoZSBicm93c2Vy4oCZcyBjYWNoZSB3aGVuIGZldGNoaW5nLlxuICBnZXQgY2FjaGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgY2FjaGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuY2FjaGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZGlyZWN0IG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHJlZGlyZWN0cyBmb3IgdGhlXG4gIC8vIHJlcXVlc3Qgd2lsbCBiZSBoYW5kbGVkIGR1cmluZyBmZXRjaGluZy4gQSByZXF1ZXN0XG4gIC8vIHdpbGwgZm9sbG93IHJlZGlyZWN0cyBieSBkZWZhdWx0LlxuICBnZXQgcmVkaXJlY3QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLmludGVncml0eVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGNhbiBvdXRsaXZlIHRoZVxuICAvLyBnbG9iYWwgaW4gd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gIGdldCBrZWVwYWxpdmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUga2VlcGFsaXZlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUua2VlcGFsaXZlXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgcmVsb2FkXG4gIC8vIG5hdmlnYXRpb24uXG4gIGdldCBpc1JlbG9hZE5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNSZWxvYWROYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXNcbiAgICAvLyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3J3YXJkIG5hdmlnYXRpb24pLlxuICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc0hpc3RvcnlOYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVxdWVzdOKAmXNcbiAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuaGlzdG9yeU5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHNpZ25hbCBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYW4gQWJvcnRTaWduYWxcbiAgLy8gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBhbmQgaXRzXG4gIC8vIGFib3J0IGV2ZW50IGhhbmRsZXIuXG4gIGdldCBzaWduYWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgc2lnbmFsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHNpZ25hbC5cbiAgICByZXR1cm4gdGhpcy4jc2lnbmFsXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5ib2R5ID8gdGhpcy4jc3RhdGUuYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gISF0aGlzLiNzdGF0ZS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpcy4jc3RhdGUuYm9keS5zdHJlYW0pXG4gIH1cblxuICBnZXQgZHVwbGV4ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICdoYWxmJ1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlcXVlc3QuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoYm9keVVudXNhYmxlKHRoaXMuI3N0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpcy4jc3RhdGUpXG5cbiAgICAvLyAzLiBMZXQgY2xvbmVkUmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVxdWVzdCBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gY2xvbmVkUmVxdWVzdCwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICAvLyA0LiBNYWtlIGNsb25lZFJlcXVlc3RPYmplY3TigJlzIHNpZ25hbCBmb2xsb3cgdGhpc+KAmXMgc2lnbmFsLlxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxpc3QgPSBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmdldCh0aGlzLnNpZ25hbClcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGlzdCA9IG5ldyBTZXQoKVxuICAgICAgICBkZXBlbmRlbnRDb250cm9sbGVyTWFwLnNldCh0aGlzLnNpZ25hbCwgbGlzdClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjUmVmID0gbmV3IFdlYWtSZWYoYWMpXG4gICAgICBsaXN0LmFkZChhY1JlZilcbiAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihcbiAgICAgICAgYWMuc2lnbmFsLFxuICAgICAgICBidWlsZEFib3J0KGFjUmVmKVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiBjbG9uZWRSZXF1ZXN0T2JqZWN0LlxuICAgIHJldHVybiBmcm9tSW5uZXJSZXF1ZXN0KGNsb25lZFJlcXVlc3QsIHRoaXMuI2Rpc3BhdGNoZXIsIGFjLnNpZ25hbCwgZ2V0SGVhZGVyc0d1YXJkKHRoaXMuI2hlYWRlcnMpKVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kZXB0aCA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5kZXB0aCA9IDJcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sXG4gICAgICByZWZlcnJlcjogdGhpcy5yZWZlcnJlcixcbiAgICAgIHJlZmVycmVyUG9saWN5OiB0aGlzLnJlZmVycmVyUG9saWN5LFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsXG4gICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0LFxuICAgICAgaW50ZWdyaXR5OiB0aGlzLmludGVncml0eSxcbiAgICAgIGtlZXBhbGl2ZTogdGhpcy5rZWVwYWxpdmUsXG4gICAgICBpc1JlbG9hZE5hdmlnYXRpb246IHRoaXMuaXNSZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgaXNIaXN0b3J5TmF2aWdhdGlvbjogdGhpcy5pc0hpc3RvcnlOYXZpZ2F0aW9uLFxuICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbFxuICAgIH1cblxuICAgIHJldHVybiBgUmVxdWVzdCAke25vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHByb3BlcnRpZXMpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gbmV3U2lnbmFsXG4gICAqL1xuICBzdGF0aWMgc2V0UmVxdWVzdFNpZ25hbCAocmVxdWVzdCwgbmV3U2lnbmFsKSB7XG4gICAgcmVxdWVzdC4jc2lnbmFsID0gbmV3U2lnbmFsXG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIHN0YXRpYyBnZXRSZXF1ZXN0RGlzcGF0Y2hlciAocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LiNkaXNwYXRjaGVyXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKX0gbmV3RGlzcGF0Y2hlclxuICAgKi9cbiAgc3RhdGljIHNldFJlcXVlc3REaXNwYXRjaGVyIChyZXF1ZXN0LCBuZXdEaXNwYXRjaGVyKSB7XG4gICAgcmVxdWVzdC4jZGlzcGF0Y2hlciA9IG5ld0Rpc3BhdGNoZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtIZWFkZXJzfSBuZXdIZWFkZXJzXG4gICAqL1xuICBzdGF0aWMgc2V0UmVxdWVzdEhlYWRlcnMgKHJlcXVlc3QsIG5ld0hlYWRlcnMpIHtcbiAgICByZXF1ZXN0LiNoZWFkZXJzID0gbmV3SGVhZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgc3RhdGljIGdldFJlcXVlc3RTdGF0ZSAocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LiNzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueX0gbmV3U3RhdGVcbiAgICovXG4gIHN0YXRpYyBzZXRSZXF1ZXN0U3RhdGUgKHJlcXVlc3QsIG5ld1N0YXRlKSB7XG4gICAgcmVxdWVzdC4jc3RhdGUgPSBuZXdTdGF0ZVxuICB9XG59XG5cbmNvbnN0IHsgc2V0UmVxdWVzdFNpZ25hbCwgZ2V0UmVxdWVzdERpc3BhdGNoZXIsIHNldFJlcXVlc3REaXNwYXRjaGVyLCBzZXRSZXF1ZXN0SGVhZGVycywgZ2V0UmVxdWVzdFN0YXRlLCBzZXRSZXF1ZXN0U3RhdGUgfSA9IFJlcXVlc3RcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVxdWVzdCwgJ3NldFJlcXVlc3RTaWduYWwnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnZ2V0UmVxdWVzdERpc3BhdGNoZXInKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnc2V0UmVxdWVzdERpc3BhdGNoZXInKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnc2V0UmVxdWVzdEhlYWRlcnMnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnZ2V0UmVxdWVzdFN0YXRlJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVxdWVzdCwgJ3NldFJlcXVlc3RTdGF0ZScpXG5cbm1peGluQm9keShSZXF1ZXN0LCBnZXRSZXF1ZXN0U3RhdGUpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0c1xuZnVuY3Rpb24gbWFrZVJlcXVlc3QgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IGluaXQubWV0aG9kID8/ICdHRVQnLFxuICAgIGxvY2FsVVJMc09ubHk6IGluaXQubG9jYWxVUkxzT25seSA/PyBmYWxzZSxcbiAgICB1bnNhZmVSZXF1ZXN0OiBpbml0LnVuc2FmZVJlcXVlc3QgPz8gZmFsc2UsXG4gICAgYm9keTogaW5pdC5ib2R5ID8/IG51bGwsXG4gICAgY2xpZW50OiBpbml0LmNsaWVudCA/PyBudWxsLFxuICAgIHJlc2VydmVkQ2xpZW50OiBpbml0LnJlc2VydmVkQ2xpZW50ID8/IG51bGwsXG4gICAgcmVwbGFjZXNDbGllbnRJZDogaW5pdC5yZXBsYWNlc0NsaWVudElkID8/ICcnLFxuICAgIHdpbmRvdzogaW5pdC53aW5kb3cgPz8gJ2NsaWVudCcsXG4gICAga2VlcGFsaXZlOiBpbml0LmtlZXBhbGl2ZSA/PyBmYWxzZSxcbiAgICBzZXJ2aWNlV29ya2VyczogaW5pdC5zZXJ2aWNlV29ya2VycyA/PyAnYWxsJyxcbiAgICBpbml0aWF0b3I6IGluaXQuaW5pdGlhdG9yID8/ICcnLFxuICAgIGRlc3RpbmF0aW9uOiBpbml0LmRlc3RpbmF0aW9uID8/ICcnLFxuICAgIHByaW9yaXR5OiBpbml0LnByaW9yaXR5ID8/IG51bGwsXG4gICAgb3JpZ2luOiBpbml0Lm9yaWdpbiA/PyAnY2xpZW50JyxcbiAgICBwb2xpY3lDb250YWluZXI6IGluaXQucG9saWN5Q29udGFpbmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyOiBpbml0LnJlZmVycmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyUG9saWN5OiBpbml0LnJlZmVycmVyUG9saWN5ID8/ICcnLFxuICAgIG1vZGU6IGluaXQubW9kZSA/PyAnbm8tY29ycycsXG4gICAgdXNlQ09SU1ByZWZsaWdodEZsYWc6IGluaXQudXNlQ09SU1ByZWZsaWdodEZsYWcgPz8gZmFsc2UsXG4gICAgY3JlZGVudGlhbHM6IGluaXQuY3JlZGVudGlhbHMgPz8gJ3NhbWUtb3JpZ2luJyxcbiAgICB1c2VDcmVkZW50aWFsczogaW5pdC51c2VDcmVkZW50aWFscyA/PyBmYWxzZSxcbiAgICBjYWNoZTogaW5pdC5jYWNoZSA/PyAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgPz8gJ2ZvbGxvdycsXG4gICAgaW50ZWdyaXR5OiBpbml0LmludGVncml0eSA/PyAnJyxcbiAgICBjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6IGluaXQuY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhID8/ICcnLFxuICAgIHBhcnNlck1ldGFkYXRhOiBpbml0LnBhcnNlck1ldGFkYXRhID8/ICcnLFxuICAgIHJlbG9hZE5hdmlnYXRpb246IGluaXQucmVsb2FkTmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICBoaXN0b3J5TmF2aWdhdGlvbjogaW5pdC5oaXN0b3J5TmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICB1c2VyQWN0aXZhdGlvbjogaW5pdC51c2VyQWN0aXZhdGlvbiA/PyBmYWxzZSxcbiAgICB0YWludGVkT3JpZ2luOiBpbml0LnRhaW50ZWRPcmlnaW4gPz8gZmFsc2UsXG4gICAgcmVkaXJlY3RDb3VudDogaW5pdC5yZWRpcmVjdENvdW50ID8/IDAsXG4gICAgcmVzcG9uc2VUYWludGluZzogaW5pdC5yZXNwb25zZVRhaW50aW5nID8/ICdiYXNpYycsXG4gICAgcHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246IGluaXQucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gPz8gZmFsc2UsXG4gICAgZG9uZTogaW5pdC5kb25lID8/IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93RmFpbGVkOiBpbml0LnRpbWluZ0FsbG93RmFpbGVkID8/IGZhbHNlLFxuICAgIHVzZVVSTENyZWRlbnRpYWxzOiBpbml0LnVzZVVSTENyZWRlbnRpYWxzID8/IHVuZGVmaW5lZCxcbiAgICB0cmF2ZXJzYWJsZUZvclVzZXJQcm9tcHRzOiBpbml0LnRyYXZlcnNhYmxlRm9yVXNlclByb21wdHMgPz8gJ2NsaWVudCcsXG4gICAgdXJsTGlzdDogaW5pdC51cmxMaXN0LFxuICAgIHVybDogaW5pdC51cmxMaXN0WzBdLFxuICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVxdWVzdCAocmVxdWVzdCkge1xuICAvLyBUbyBjbG9uZSBhIHJlcXVlc3QgcmVxdWVzdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIExldCBuZXdSZXF1ZXN0IGJlIGEgY29weSBvZiByZXF1ZXN0LCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyAuLi5yZXF1ZXN0LCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgc2V0IG5ld1JlcXVlc3TigJlzIGJvZHkgdG8gdGhlXG4gIC8vIHJlc3VsdCBvZiBjbG9uaW5nIHJlcXVlc3TigJlzIGJvZHkuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1JlcXVlc3QuYm9keSA9IGNsb25lQm9keShyZXF1ZXN0LmJvZHkpXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gbmV3UmVxdWVzdC5cbiAgcmV0dXJuIG5ld1JlcXVlc3Rcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNyZWF0ZVxuICogQHBhcmFtIHthbnl9IGlubmVyUmVxdWVzdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2Rpc3BhdGNoZXIvYWdlbnQnKX0gZGlzcGF0Y2hlclxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXG4gKiBAcGFyYW0geydyZXF1ZXN0JyB8ICdpbW11dGFibGUnIHwgJ3JlcXVlc3Qtbm8tY29ycycgfCAncmVzcG9uc2UnIHwgJ25vbmUnfSBndWFyZFxuICogQHJldHVybnMge1JlcXVlc3R9XG4gKi9cbmZ1bmN0aW9uIGZyb21Jbm5lclJlcXVlc3QgKGlubmVyUmVxdWVzdCwgZGlzcGF0Y2hlciwgc2lnbmFsLCBndWFyZCkge1xuICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoa0NvbnN0cnVjdClcbiAgc2V0UmVxdWVzdFN0YXRlKHJlcXVlc3QsIGlubmVyUmVxdWVzdClcbiAgc2V0UmVxdWVzdERpc3BhdGNoZXIocmVxdWVzdCwgZGlzcGF0Y2hlcilcbiAgc2V0UmVxdWVzdFNpZ25hbChyZXF1ZXN0LCBzaWduYWwpXG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICBzZXRSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0LCBoZWFkZXJzKVxuICBzZXRIZWFkZXJzTGlzdChoZWFkZXJzLCBpbm5lclJlcXVlc3QuaGVhZGVyc0xpc3QpXG4gIHNldEhlYWRlcnNHdWFyZChoZWFkZXJzLCBndWFyZClcbiAgcmV0dXJuIHJlcXVlc3Rcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgbWV0aG9kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2lnbmFsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkdXBsZXg6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlc3RpbmF0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5VXNlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNIaXN0b3J5TmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNSZWxvYWROYXZpZ2F0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZWVwYWxpdmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGludGVncml0eToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2FjaGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNyZWRlbnRpYWxzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhdHRyaWJ1dGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZmVycmVyUG9saWN5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbW9kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1JlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG53ZWJpZGwuaXMuUmVxdWVzdCA9IHdlYmlkbC51dGlsLk1ha2VUeXBlQXNzZXJ0aW9uKFJlcXVlc3QpXG5cbi8qKlxuICogQHBhcmFtIHsqfSBWXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy9mZXRjaCcpLlJlcXVlc3R8c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RpbmZvXG4gKi9cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmICh3ZWJpZGwuaXMuUmVxdWVzdChWKSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBWXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy9mZXRjaCcpLlJlcXVlc3RJbml0fVxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluaXRcbiAqL1xud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgJ1JlcXVlc3RJbml0JyxcbiAgICAgICAgJ3NpZ25hbCdcbiAgICAgIClcbiAgICApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd3aW5kb3cnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkdXBsZXgnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3REdXBsZXhcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgc3BlY2lmaWMgb3B0aW9uXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfSxcbiAge1xuICAgIGtleTogJ3ByaW9yaXR5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBhbGxvd2VkVmFsdWVzOiBbJ2hpZ2gnLCAnbG93JywgJ2F1dG8nXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICdhdXRvJ1xuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVxdWVzdCxcbiAgbWFrZVJlcXVlc3QsXG4gIGZyb21Jbm5lclJlcXVlc3QsXG4gIGNsb25lUmVxdWVzdCxcbiAgZ2V0UmVxdWVzdERpc3BhdGNoZXIsXG4gIGdldFJlcXVlc3RTdGF0ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody, streamRegistry, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  environmentSettingsObject: relevantRealm\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isomorphicEncode, serializeJavascriptValueToJSONString } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\n\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and thiss\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = undefined) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and thiss relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // objects API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and thiss relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObjects responses status to status.\n    responseObject.#state.status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObjects responses header list.\n    responseObject.#state.headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body, 'Response', 'body')\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set thiss response to a new response.\n    this.#state = makeResponse({})\n\n    // 2. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is thiss responses header list and guard\n    // is \"response\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersGuard(this.#headers, 'response')\n    setHeadersList(this.#headers, this.#state.headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns responses type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return thiss responses type.\n    return this.#state.type\n  }\n\n  // Returns responses URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this.#state.urlList\n\n    // The url getter steps are to return the empty string if thiss\n    // responses URL is null; otherwise thiss responses URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if thiss responses URL\n    // list has more than one item; otherwise false.\n    return this.#state.urlList.length > 1\n  }\n\n  // Returns responses status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return thiss responses status.\n    return this.#state.status\n  }\n\n  // Returns whether responses status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if thiss responses status is an\n    // ok status; otherwise false.\n    return this.#state.status >= 200 && this.#state.status <= 299\n  }\n\n  // Returns responses status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return thiss responses status\n    // message.\n    return this.#state.statusText\n  }\n\n  // Returns responses headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return thiss headers.\n    return this.#headers\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning thiss response.\n    const clonedResponse = cloneResponse(this.#state)\n\n    // Note: To re-register because of a new stream.\n    if (this.#state.body?.stream) {\n      streamRegistry.register(this, new WeakRef(this.#state.body.stream))\n    }\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseHeaders (response) {\n    return response.#headers\n  }\n\n  /**\n   * @param {Response} response\n   * @param {Headers} newHeaders\n   */\n  static setResponseHeaders (response, newHeaders) {\n    response.#headers = newHeaders\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseState (response) {\n    return response.#state\n  }\n\n  /**\n   * @param {Response} response\n   * @param {any} newState\n   */\n  static setResponseState (response, newState) {\n    response.#state = newState\n  }\n}\n\nconst { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response\nReflect.deleteProperty(Response, 'getResponseHeaders')\nReflect.deleteProperty(Response, 'setResponseHeaders')\nReflect.deleteProperty(Response, 'getResponseState')\nReflect.deleteProperty(Response, 'setResponseState')\n\nmixinBody(Response, getResponseState)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of responses\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If responses body is non-null, then set newResponses body to the\n  // result of cloning responses body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on requests response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal responses header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal responses header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal responses CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set responses responses status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    getResponseState(response).status = init.status\n  }\n\n  // 4. Set responses responses status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    getResponseState(response).statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(getResponseHeaders(response), init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    getResponseState(response).body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !getResponseState(response).headersList.contains('content-type', true)) {\n      getResponseState(response).headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  setResponseState(response, innerResponse)\n  const headers = new Headers(kConstruct)\n  setResponseHeaders(response, headers)\n  setHeadersList(headers, innerResponse.headersList)\n  setHeadersGuard(headers, guard)\n\n  // Note: If innerResponse's urlList contains a URL, it is a fetch response.\n  if (innerResponse.urlList.length !== 0 && innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    streamRegistry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (webidl.is.Blob(V)) {\n    return V\n  }\n\n  if (webidl.is.BufferSource(V)) {\n    return V\n  }\n\n  if (webidl.is.FormData(V)) {\n    return V\n  }\n\n  if (webidl.is.URLSearchParams(V)) {\n    return V\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (webidl.is.ReadableStream(V)) {\n    return V\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nwebidl.is.Response = webidl.util.MakeTypeAssertion(Response)\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse,\n  getResponseState\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSwrRUFBK0UsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzVHLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUM1RixhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzlDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHlEQUF5RCxFQUFFLG1CQUFPLENBQUMsb0VBQVU7O0FBRXJGOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0EsK0NBQStDLHlDQUF5Qzs7QUFFeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxJQUFJLEtBQUssWUFBWTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnREFBZ0Q7QUFDdkU7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsNkVBQTZFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMseUJBQXlCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFlBQVk7QUFDakgsbUZBQW1GLFlBQVk7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakUsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLG1FQUFtRTtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxccmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSGVhZGVycywgSGVhZGVyc0xpc3QsIGZpbGwsIGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgZXh0cmFjdEJvZHksIGNsb25lQm9keSwgbWl4aW5Cb2R5LCBzdHJlYW1SZWdpc3RyeSwgYm9keVVudXNhYmxlIH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWxcbmNvbnN0IHtcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNFcnJvckxpa2UsXG4gIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Q6IHJlbGV2YW50UmVhbG1cbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXNcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzb21vcnBoaWNFbmNvZGUsIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyB9ID0gcmVxdWlyZSgnLi4vaW5mcmEnKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2UtY2xhc3NcbmNsYXNzIFJlc3BvbnNlIHtcbiAgLyoqIEB0eXBlIHtIZWFkZXJzfSAqL1xuICAjaGVhZGVyc1xuXG4gICNzdGF0ZVxuXG4gIC8vIENyZWF0ZXMgbmV0d29yayBlcnJvciBSZXNwb25zZS5cbiAgc3RhdGljIGVycm9yICgpIHtcbiAgICAvLyBUaGUgc3RhdGljIGVycm9yKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhXG4gICAgLy8gUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyBuZXR3b3JrIGVycm9yLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXNcbiAgICAvLyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VOZXR3b3JrRXJyb3IoKSwgJ2ltbXV0YWJsZScpXG5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVzcG9uc2UtanNvblxuICBzdGF0aWMganNvbiAoZGF0YSwgaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ1Jlc3BvbnNlLmpzb24nKVxuXG4gICAgaWYgKGluaXQgIT09IG51bGwpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNlcmlhbGl6ZSBhIEphdmFTY3JpcHQgdmFsdWUgdG8gSlNPTiBieXRlcyBvbiBkYXRhLlxuICAgIGNvbnN0IGJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgKVxuXG4gICAgLy8gMi4gTGV0IGJvZHkgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJ5dGVzLlxuICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcylcblxuICAgIC8vIDMuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyByZXNwb25zZSxcbiAgICAvLyAgICBcInJlc3BvbnNlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VSZXNwb25zZSh7fSksICdyZXNwb25zZScpXG5cbiAgICAvLyA0LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiByZXNwb25zZU9iamVjdCwgaW5pdCwgYW5kIChib2R5LCBcImFwcGxpY2F0aW9uL2pzb25cIikuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlT2JqZWN0LCBpbml0LCB7IGJvZHk6IGJvZHlbMF0sIHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHJlZGlyZWN0IFJlc3BvbnNlIHRoYXQgcmVkaXJlY3RzIHRvIHVybCB3aXRoIHN0YXR1cyBzdGF0dXMuXG4gIHN0YXRpYyByZWRpcmVjdCAodXJsLCBzdGF0dXMgPSAzMDIpIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdSZXNwb25zZS5yZWRpcmVjdCcpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKHN0YXR1cylcblxuICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHVybCB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAvLyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyBUT0RPOiBiYXNlLVVSTD9cbiAgICBsZXQgcGFyc2VkVVJMXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsLCByZWxldmFudFJlYWxtLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJHt1cmx9YCwgeyBjYXVzZTogZXJyIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gICAgaWYgKCFyZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc3RhdHVzIGNvZGUgJHtzdGF0dXN9YClcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiBhIG5ldyByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZVJlc3BvbnNlKHt9KSwgJ2ltbXV0YWJsZScpXG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gc3RhdHVzLlxuICAgIHJlc3BvbnNlT2JqZWN0LiNzdGF0ZS5zdGF0dXMgPSBzdGF0dXNcblxuICAgIC8vIDYuIExldCB2YWx1ZSBiZSBwYXJzZWRVUkwsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICBjb25zdCB2YWx1ZSA9IGlzb21vcnBoaWNFbmNvZGUoVVJMU2VyaWFsaXplcihwYXJzZWRVUkwpKVxuXG4gICAgLy8gNy4gQXBwZW5kIGBMb2NhdGlvbmAvdmFsdWUgdG8gcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXNwb25zZU9iamVjdC4jc3RhdGUuaGVhZGVyc0xpc3QuYXBwZW5kKCdsb2NhdGlvbicsIHZhbHVlLCB0cnVlKVxuXG4gICAgLy8gOC4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZVxuICBjb25zdHJ1Y3RvciAoYm9keSA9IG51bGwsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgaWYgKGJvZHkgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5ICE9PSBudWxsKSB7XG4gICAgICBib2R5ID0gd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQoYm9keSwgJ1Jlc3BvbnNlJywgJ2JvZHknKVxuICAgIH1cblxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyByZXNwb25zZSB0byBhIG5ldyByZXNwb25zZS5cbiAgICB0aGlzLiNzdGF0ZSA9IG1ha2VSZXNwb25zZSh7fSlcblxuICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgdGhpc+KAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZFxuICAgIC8vIGlzIFwicmVzcG9uc2VcIi5cbiAgICB0aGlzLiNoZWFkZXJzID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpcy4jaGVhZGVycywgJ3Jlc3BvbnNlJylcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzLiNoZWFkZXJzLCB0aGlzLiNzdGF0ZS5oZWFkZXJzTGlzdClcblxuICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgbnVsbC5cbiAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgYm9keVdpdGhUeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBib2R5V2l0aFR5cGUgPSB7IGJvZHk6IGV4dHJhY3RlZEJvZHksIHR5cGUgfVxuICAgIH1cblxuICAgIC8vIDUuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHRoaXMsIGluaXQsIGFuZCBib2R5V2l0aFR5cGUuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHR5cGUsIGUuZy4sIFwiY29yc1wiLlxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgdHlwZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgdHlwZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUudHlwZVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgVVJMLCBpZiBpdCBoYXMgb25lOyBvdGhlcndpc2UgdGhlIGVtcHR5IHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICBjb25zdCB1cmxMaXN0ID0gdGhpcy4jc3RhdGUudXJsTGlzdFxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoaXPigJlzXG4gICAgLy8gcmVzcG9uc2XigJlzIFVSTCBpcyBudWxsOyBvdGhlcndpc2UgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTCxcbiAgICAvLyBzZXJpYWxpemVkIHdpdGggZXhjbHVkZSBmcmFnbWVudCBzZXQgdG8gdHJ1ZS5cbiAgICBjb25zdCB1cmwgPSB1cmxMaXN0W3VybExpc3QubGVuZ3RoIC0gMV0gPz8gbnVsbFxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodXJsLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNlIHdhcyBvYnRhaW5lZCB0aHJvdWdoIGEgcmVkaXJlY3QuXG4gIGdldCByZWRpcmVjdGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSByZWRpcmVjdGVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTFxuICAgIC8vIGxpc3QgaGFzIG1vcmUgdGhhbiBvbmUgaXRlbTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS51cmxMaXN0Lmxlbmd0aCA+IDFcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgZ2V0IHN0YXR1cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLnN0YXR1c1xuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW4gb2sgc3RhdHVzLlxuICBnZXQgb2sgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIG9rIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhblxuICAgIC8vIG9rIHN0YXR1czsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5zdGF0dXMgPj0gMjAwICYmIHRoaXMuI3N0YXRlLnN0YXR1cyA8PSAyOTlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlLlxuICBnZXQgc3RhdHVzVGV4dCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzVGV4dCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzXG4gICAgLy8gbWVzc2FnZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgaGVhZGVycyBhcyBIZWFkZXJzLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuYm9keSA/IHRoaXMuI3N0YXRlLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiAhIXRoaXMuI3N0YXRlLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLiNzdGF0ZS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXNwb25zZS5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoYm9keVVudXNhYmxlKHRoaXMuI3N0YXRlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZS5jbG9uZScsXG4gICAgICAgIG1lc3NhZ2U6ICdCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzLiNzdGF0ZSlcblxuICAgIC8vIE5vdGU6IFRvIHJlLXJlZ2lzdGVyIGJlY2F1c2Ugb2YgYSBuZXcgc3RyZWFtLlxuICAgIGlmICh0aGlzLiNzdGF0ZS5ib2R5Py5zdHJlYW0pIHtcbiAgICAgIHN0cmVhbVJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIG5ldyBXZWFrUmVmKHRoaXMuI3N0YXRlLmJvZHkuc3RyZWFtKSlcbiAgICB9XG5cbiAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW5cbiAgICAvLyBjbG9uZWRSZXNwb25zZSwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICByZXR1cm4gZnJvbUlubmVyUmVzcG9uc2UoY2xvbmVkUmVzcG9uc2UsIGdldEhlYWRlcnNHdWFyZCh0aGlzLiNoZWFkZXJzKSlcbiAgfVxuXG4gIFtub2RlVXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGVwdGggPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZGVwdGggPSAyXG4gICAgfVxuXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5LFxuICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICBvazogdGhpcy5vayxcbiAgICAgIHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9XG5cbiAgICByZXR1cm4gYFJlc3BvbnNlICR7bm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgcHJvcGVydGllcyl9YFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgZ2V0UmVzcG9uc2VIZWFkZXJzIChyZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZS4jaGVhZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7SGVhZGVyc30gbmV3SGVhZGVyc1xuICAgKi9cbiAgc3RhdGljIHNldFJlc3BvbnNlSGVhZGVycyAocmVzcG9uc2UsIG5ld0hlYWRlcnMpIHtcbiAgICByZXNwb25zZS4jaGVhZGVycyA9IG5ld0hlYWRlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgc3RhdGljIGdldFJlc3BvbnNlU3RhdGUgKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLiNzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7YW55fSBuZXdTdGF0ZVxuICAgKi9cbiAgc3RhdGljIHNldFJlc3BvbnNlU3RhdGUgKHJlc3BvbnNlLCBuZXdTdGF0ZSkge1xuICAgIHJlc3BvbnNlLiNzdGF0ZSA9IG5ld1N0YXRlXG4gIH1cbn1cblxuY29uc3QgeyBnZXRSZXNwb25zZUhlYWRlcnMsIHNldFJlc3BvbnNlSGVhZGVycywgZ2V0UmVzcG9uc2VTdGF0ZSwgc2V0UmVzcG9uc2VTdGF0ZSB9ID0gUmVzcG9uc2VcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVzcG9uc2UsICdnZXRSZXNwb25zZUhlYWRlcnMnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXNwb25zZSwgJ3NldFJlc3BvbnNlSGVhZGVycycpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KFJlc3BvbnNlLCAnZ2V0UmVzcG9uc2VTdGF0ZScpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KFJlc3BvbnNlLCAnc2V0UmVzcG9uc2VTdGF0ZScpXG5cbm1peGluQm9keShSZXNwb25zZSwgZ2V0UmVzcG9uc2VTdGF0ZSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG4gIHR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvazoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3RlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHlVc2VkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnUmVzcG9uc2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZSwge1xuICBqc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlc3BvbnNlLWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlc3BvbnNlIChyZXNwb25zZSkge1xuICAvLyBUbyBjbG9uZSBhIHJlc3BvbnNlIHJlc3BvbnNlLCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSwgdGhlbiByZXR1cm4gYSBuZXcgaWRlbnRpY2FsXG4gIC8vIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsIHJlc3BvbnNlIGlzIGEgY2xvbmUgb2YgcmVzcG9uc2XigJlzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLlxuICBpZiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIHJldHVybiBmaWx0ZXJSZXNwb25zZShcbiAgICAgIGNsb25lUmVzcG9uc2UocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSksXG4gICAgICByZXNwb25zZS50eXBlXG4gICAgKVxuICB9XG5cbiAgLy8gMi4gTGV0IG5ld1Jlc3BvbnNlIGJlIGEgY29weSBvZiByZXNwb25zZSwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyAuLi5yZXNwb25zZSwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBuZXdSZXNwb25zZeKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVzcG9uc2XigJlzIGJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXNwb25zZS5ib2R5ID0gY2xvbmVCb2R5KHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0Py5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdD8uaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQ/LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbi8vIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IgKHJlc3BvbnNlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBuZXR3b3JrIGVycm9yIGlzIGEgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImVycm9yXCIsXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyAmJlxuICAgIC8vIHN0YXR1cyBpcyAwXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwXG4gIClcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogW10sXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIGdldFJlc3BvbnNlU3RhdGUocmVzcG9uc2UpLnN0YXR1cyA9IGluaXQuc3RhdHVzXG4gIH1cblxuICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBpbml0W1wic3RhdHVzVGV4dFwiXS5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gNS4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIGZpbGwgcmVzcG9uc2XigJlzIGhlYWRlcnMgd2l0aCBpbml0W1wiaGVhZGVyc1wiXS5cbiAgaWYgKCdoZWFkZXJzJyBpbiBpbml0ICYmIGluaXQuaGVhZGVycyAhPSBudWxsKSB7XG4gICAgZmlsbChnZXRSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuYm9keSA9IGJvZHkuYm9keVxuXG4gICAgLy8gMy4gSWYgYm9keSdzIHR5cGUgaXMgbm9uLW51bGwgYW5kIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpblxuICAgIC8vICAgIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtVHlwZWAsIGJvZHkncyB0eXBlKSB0byByZXNwb25zZSdzIGhlYWRlciBsaXN0LlxuICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICBnZXRSZXNwb25zZVN0YXRlKHJlc3BvbnNlKS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSwgdHJ1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlc3BvbnNlXG4gKiBAcGFyYW0geydyZXF1ZXN0JyB8ICdpbW11dGFibGUnIHwgJ3JlcXVlc3Qtbm8tY29ycycgfCAncmVzcG9uc2UnIHwgJ25vbmUnfSBndWFyZFxuICogQHJldHVybnMge1Jlc3BvbnNlfVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXNwb25zZSAoaW5uZXJSZXNwb25zZSwgZ3VhcmQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoa0NvbnN0cnVjdClcbiAgc2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSwgaW5uZXJSZXNwb25zZSlcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSwgaGVhZGVycylcbiAgc2V0SGVhZGVyc0xpc3QoaGVhZGVycywgaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdClcbiAgc2V0SGVhZGVyc0d1YXJkKGhlYWRlcnMsIGd1YXJkKVxuXG4gIC8vIE5vdGU6IElmIGlubmVyUmVzcG9uc2UncyB1cmxMaXN0IGNvbnRhaW5zIGEgVVJMLCBpdCBpcyBhIGZldGNoIHJlc3BvbnNlLlxuICBpZiAoaW5uZXJSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCAhPT0gMCAmJiBpbm5lclJlc3BvbnNlLmJvZHk/LnN0cmVhbSkge1xuICAgIC8vIElmIHRoZSB0YXJnZXQgKHJlc3BvbnNlKSBpcyByZWNsYWltZWQsIHRoZSBjbGVhbnVwIGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCB3aXRoXG4gICAgLy8gdGhlIGhlbGQgdmFsdWUgcHJvdmlkZWQgZm9yIGl0IChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKS4gVGhlIGhlbGQgdmFsdWUgY2FuIGJlIGFueSB2YWx1ZTpcbiAgICAvLyBhIHByaW1pdGl2ZSBvciBhbiBvYmplY3QsIGV2ZW4gdW5kZWZpbmVkLiBJZiB0aGUgaGVsZCB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZSByZWdpc3RyeSBrZWVwc1xuICAgIC8vIGEgc3Ryb25nIHJlZmVyZW5jZSB0byBpdCAoc28gaXQgY2FuIHBhc3MgaXQgdG8gdGhlIGNsZWFudXAgY2FsbGJhY2sgbGF0ZXIpLiBSZXdvcmRlZCBmcm9tXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICBzdHJlYW1SZWdpc3RyeS5yZWdpc3RlcihyZXNwb25zZSwgbmV3IFdlYWtSZWYoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkpXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgaWYgKHdlYmlkbC5pcy5CbG9iKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIGlmICh3ZWJpZGwuaXMuQnVmZmVyU291cmNlKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIGlmICh3ZWJpZGwuaXMuRm9ybURhdGEoVikpIHtcbiAgICByZXR1cm4gVlxuICB9XG5cbiAgaWYgKHdlYmlkbC5pcy5VUkxTZWFyY2hQYXJhbXMoVikpIHtcbiAgICByZXR1cm4gVlxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWLCBwcmVmaXgsIG5hbWUpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLmlzLlJlYWRhYmxlU3RyZWFtKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIC8vIE5vdGU6IHRoZSBzcGVjIGRvZXNuJ3QgaW5jbHVkZSBhc3luYyBpdGVyYWJsZXMsXG4gIC8vIHRoaXMgaXMgYW4gdW5kaWNpIGV4dGVuc2lvbi5cbiAgaWYgKFY/LltTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gVlxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQoViwgcHJlZml4LCBhcmd1bWVudClcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnc3RhdHVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMjAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzdGF0dXNUZXh0JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9XG5dKVxuXG53ZWJpZGwuaXMuUmVzcG9uc2UgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihSZXNwb25zZSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzTmV0d29ya0Vycm9yLFxuICBtYWtlTmV0d29ya0Vycm9yLFxuICBtYWtlUmVzcG9uc2UsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIFJlc3BvbnNlLFxuICBjbG9uZVJlc3BvbnNlLFxuICBmcm9tSW5uZXJSZXNwb25zZSxcbiAgZ2V0UmVzcG9uc2VTdGF0ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { redirectStatusSet, referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\nconst { collectAnHTTPQuotedString, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\")\nconst { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { isomorphicEncode, collectASequenceOfCodePoints, removeChars } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in responses URL list and null if responses URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If responses status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and responses header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with responses URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set locations\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be requests current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n/**\n * Parse a referrer policy from a Referrer-Policy header\n * @see https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n */\nfunction parseReferrerPolicy (actualResponse) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n  const policyHeader = (actualResponse.headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // 2. Let policy be the empty string.\n  let policy = ''\n\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  if (policyHeader.length) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 4. Return policy.\n  return policy\n}\n\n/**\n * Given a request request and a response actualResponse, this algorithm\n * updates requests referrer policy according to the Referrer-Policy\n * header (if any) in actualResponse.\n * @see https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\n * @param {import('./request').Request} request\n * @param {import('./response').Response} actualResponse\n */\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  const policy = parseReferrerPolicy(actualResponse)\n\n  // 2. If policy is not the empty string, then set requests referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: rs url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set headers value to rs mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to requests header list.\n  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on requests referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If requests origin is a tuple origin, its scheme is \"https\", and\n        // requests current URLs scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If requests origin is not same origin with requests current URLs\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to requests header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n/**\n * Determine requests Referrer\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\n */\nfunction determineRequestsReferrer (request) {\n  // Given a request request, we can determine the correct referrer information\n  // to send by examining its referrer policy as detailed in the following\n  // steps, which return either no referrer or a URL:\n\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be requests client.\n\n  let referrerSource = null\n\n  // 3. Switch on requests referrer:\n\n  // \"client\"\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // Note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  // a URL\n  } else if (webidl.is.URL(request.referrer)) {\n    // Let referrerSource be requests referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let requests referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point\n  // to enforce arbitrary policy considerations in the interests of minimizing\n  // data leakage. For example, the user agent could strip the URL down to an\n  // origin, modify its host, replace it with an empty string, etc.\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'no-referrer':\n      // Return no referrer\n      return 'no-referrer'\n    case 'origin':\n      // Return referrerOrigin\n      if (referrerOrigin != null) {\n        return referrerOrigin\n      }\n      return stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url':\n      // Return referrerURL.\n      return referrerURL\n    case 'strict-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerOrigin\n      return referrerOrigin\n    }\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of requests current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of requests current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return no referrer.\n      return 'no-referrer'\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of requests current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return referrerOrigin.\n      return referrerOrigin\n    case 'no-referrer-when-downgrade': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerURL.\n      return referrerURL\n    }\n  }\n}\n\n/**\n * Certain portions of URLs must not be included when sending a URL as the\n * value of a `Referer` header: a URLs fragment, username, and password\n * components must be stripped from the URL before its sent out. This\n * algorithm accepts a origin-only flag, which defaults to false. If set to\n * true, the algorithm will additionally remove the URLs path and query\n * components, leaving only the scheme, host, and port.\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean} [originOnly=false]\n */\nfunction stripURLForReferrer (url, originOnly = false) {\n  // 1. Assert: url is a URL.\n  assert(webidl.is.URL(url))\n\n  // Note: Create a new URL instance to avoid mutating the original URL.\n  url = new URL(url)\n\n  // 2. If urls scheme is a local scheme, then return no referrer.\n  if (urlIsLocal(url)) {\n    return 'no-referrer'\n  }\n\n  // 3. Set urls username to the empty string.\n  url.username = ''\n\n  // 4. Set urls password to the empty string.\n  url.password = ''\n\n  // 5. Set urls fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly === true) {\n    // 1. Set urls path to  the empty string .\n    url.pathname = ''\n\n    // 2. Set urls query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nconst isPotentialleTrustworthyIPv4 = RegExp.prototype.test\n  .bind(/^127\\.(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.){2}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)$/)\n\nconst isPotentiallyTrustworthyIPv6 = RegExp.prototype.test\n  .bind(/^(?:(?:0{1,4}:){7}|(?:0{1,4}:){1,6}:|::)0{0,3}1$/)\n\n/**\n * Check if host matches one of the CIDR notations 127.0.0.0/8 or ::1/128.\n *\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginIPPotentiallyTrustworthy (origin) {\n  // IPv6\n  if (origin.includes(':')) {\n    // Remove brackets from IPv6 addresses\n    if (origin[0] === '[' && origin[origin.length - 1] === ']') {\n      origin = origin.slice(1, -1)\n    }\n    return isPotentiallyTrustworthyIPv6(origin)\n  }\n\n  // IPv4\n  return isPotentialleTrustworthyIPv4(origin)\n}\n\n/**\n * A potentially trustworthy origin is one which a user agent can generally\n * trust as delivering data securely.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginPotentiallyTrustworthy (origin) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  if (origin == null || origin === 'null') {\n    return false\n  }\n\n  // 2. Assert: origin is a tuple origin.\n  origin = new URL(origin)\n\n  // 3. If origins scheme is either \"https\" or \"wss\",\n  //    return \"Potentially Trustworthy\".\n  if (origin.protocol === 'https:' || origin.protocol === 'wss:') {\n    return true\n  }\n\n  // 4. If origins host matches one of the CIDR notations 127.0.0.0/8 or\n  // ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n  if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {\n    return true\n  }\n\n  // 5. If the user agent conforms to the name resolution rules in\n  //    [let-localhost-be-localhost] and one of the following is true:\n\n  //    origins host is \"localhost\" or \"localhost.\"\n  if (origin.hostname === 'localhost' || origin.hostname === 'localhost.') {\n    return true\n  }\n\n  //    origins host ends with \".localhost\" or \".localhost.\"\n  if (origin.hostname.endsWith('.localhost') || origin.hostname.endsWith('.localhost.')) {\n    return true\n  }\n\n  // 6. If origins scheme is \"file\", return \"Potentially Trustworthy\".\n  if (origin.protocol === 'file:') {\n    return true\n  }\n\n  // 7. If origins scheme component is one which the user agent considers to\n  // be authenticated, return \"Potentially Trustworthy\".\n\n  // 8. If origin has been configured as a trustworthy origin, return\n  //    \"Potentially Trustworthy\".\n\n  // 9. Return \"Not Trustworthy\".\n  return false\n}\n\n/**\n * A potentially trustworthy URL is one which either inherits context from its\n * creator (about:blank, about:srcdoc, data) or one whose origin is a\n * potentially trustworthy origin.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://www.w3.org/TR/secure-contexts/#is-url-trustworthy\n * @param {URL} url\n * @returns {boolean}\n */\nfunction isURLPotentiallyTrustworthy (url) {\n  // Given a URL record (url), the following algorithm returns \"Potentially\n  // Trustworthy\" or \"Not Trustworthy\" as appropriate:\n  if (!webidl.is.URL(url)) {\n    return false\n  }\n\n  // 1. If url is \"about:blank\" or \"about:srcdoc\",\n  //    return \"Potentially Trustworthy\".\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // 2. If urls scheme is \"data\", return \"Potentially Trustworthy\".\n  if (url.protocol === 'data:') return true\n\n  // Note: The origin of blob: URLs is the origin of the context in which they\n  // were created. Therefore, blobs created in a trustworthy origin will\n  // themselves be potentially trustworthy.\n  if (url.protocol === 'blob:') return true\n\n  // 3. Return the result of executing  3.1 Is origin potentially trustworthy?\n  // on urls origin.\n  return isOriginPotentiallyTrustworthy(url.origin)\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {((target: any) => any)} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be objects index.\n      // 7. Let kind be objects kind.\n      // 8. Let values be objects target's value pairs to iterate over.\n      const index = this.#index\n      const values = kInternalIterator(this.#target)\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set objects index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pairs key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pairs value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pairs key.\n          // 2. Let idlValue be pairs value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {(target: any) => any} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @param {import('./body').ExtractBodyResult} body\n * @param {(bytes: Uint8Array) => void} processBody\n * @param {(error: Error) => void} processBodyError\n * @returns {void}\n *\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  try {\n  // 4. Let reader be the result of getting a reader for bodys stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n    const reader = body.stream.getReader()\n\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    readAllBytes(reader, successSteps, errorSteps)\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStream<Uint8Array<ArrayBuffer>>} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n * @returns {Promise<void>}\n */\nasync function readAllBytes (reader, successSteps, failureSteps) {\n  try {\n    const bytes = []\n    let byteLength = 0\n\n    do {\n      const { done, value: chunk } = await reader.read()\n\n      if (done) {\n        // 1. Call successSteps with bytes.\n        successSteps(Buffer.concat(bytes, byteLength))\n        return\n      }\n\n      // 1. If chunk is not a Uint8Array object, call failureSteps\n      //    with a TypeError and abort these steps.\n      if (!isUint8Array(chunk)) {\n        failureSteps(new TypeError('Received non-Uint8Array chunk'))\n        return\n      }\n\n      // 2. Append the bytes represented by chunk to bytes.\n      bytes.push(chunk)\n      byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    } while (true)\n  } catch (e) {\n    // 1. Call failureSteps with e.\n    failureSteps(e)\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n * @returns {boolean}\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  // A URL is local if its scheme is a local scheme.\n  // A local scheme is \"about\", \"blob\", or \"data\".\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @typedef {Object} RangeHeaderValue\n * @property {number|null} rangeStartValue\n * @property {number|null} rangeEndValue\n */\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n * @return {RangeHeaderValue|'failure'}\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  #zlibOptions\n\n  /** @param {zlib.ZlibOptions} [zlibOptions] */\n  constructor (zlibOptions) {\n    super()\n    this.#zlibOptions = zlibOptions\n  }\n\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate(this.#zlibOptions)\n        : zlib.createInflateRaw(this.#zlibOptions)\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\n/**\n * @param {zlib.ZlibOptions} [zlibOptions]\n * @returns {InflateStream}\n */\nfunction createInflate (zlibOptions) {\n  return new InflateStream(zlibOptions)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeTypes essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeTypes parameters[\"charset\"] exists, then set charset to\n      //        mimeTypes parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeTypes essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeTypes parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeTypes parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nfunction hasAuthenticationEntry (request) {\n  return false\n}\n\n/**\n * @see https://url.spec.whatwg.org/#include-credentials\n * @param {URL} url\n */\nfunction includesCredentials (url) {\n  // A URL includes credentials if its username or password is not the empty string.\n  return !!(url.username && url.password)\n}\n\n/**\n * @see https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable\n * @param {object|string} navigable\n */\nfunction isTraversableNavigable (navigable) {\n  // TODO\n  return true\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  environmentSettingsObject,\n  isOriginIPPotentiallyTrustworthy,\n  hasAuthenticationEntry,\n  includesCredentials,\n  isTraversableNavigable\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxRQUFRLHVEQUF1RCxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDdEYsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQzlDLFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN6RSxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNqRCxRQUFRLG9FQUFvRSxFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3ZHLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNsRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsOERBQThELEVBQUUsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3QgeyByZWRpcmVjdFN0YXR1c1NldCwgcmVmZXJyZXJQb2xpY3lUb2tlbnMsIGJhZFBvcnRzU2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLCBwYXJzZU1JTUVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUoJ25vZGU6cGVyZl9ob29rcycpXG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtRnJvbSwgaXNWYWxpZEhUVFBUb2tlbiwgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBpc1VpbnQ4QXJyYXkgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbC90eXBlcycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgaXNvbW9ycGhpY0VuY29kZSwgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cywgcmVtb3ZlQ2hhcnMgfSA9IHJlcXVpcmUoJy4uL2luZnJhJylcblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDIuIExldCBsb2NhdGlvbiBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuXG4gIC8vIGBMb2NhdGlvbmAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgLy8gMy4gSWYgbG9jYXRpb24gaXMgYSBoZWFkZXIgdmFsdWUsIHRoZW4gc2V0IGxvY2F0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgcGFyc2luZyBsb2NhdGlvbiB3aXRoIHJlc3BvbnNl4oCZcyBVUkwuXG4gIGlmIChsb2NhdGlvbiAhPT0gbnVsbCAmJiBpc1ZhbGlkSGVhZGVyVmFsdWUobG9jYXRpb24pKSB7XG4gICAgaWYgKCFpc1ZhbGlkRW5jb2RlZFVSTChsb2NhdGlvbikpIHtcbiAgICAgIC8vIFNvbWUgd2Vic2l0ZXMgcmVzcG9uZCBsb2NhdGlvbiBoZWFkZXIgaW4gVVRGLTggZm9ybSB3aXRob3V0IGVuY29kaW5nIHRoZW0gYXMgQVNDSUlcbiAgICAgIC8vIGFuZCBtYWpvciBicm93c2VycyByZWRpcmVjdCB0aGVtIHRvIGNvcnJlY3RseSBVVEYtOCBlbmNvZGVkIGFkZHJlc3Nlcy5cbiAgICAgIC8vIEhlcmUsIHdlIGhhbmRsZSB0aGF0IGJlaGF2aW9yIGluIHRoZSBzYW1lIHdheS5cbiAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4KGxvY2F0aW9uKVxuICAgIH1cbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMTczOCNzZWN0aW9uLTIuMlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbmNvZGVkVVJMICh1cmwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmwubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gdXJsLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIE5vbi1VUy1BU0NJSSArIERFTFxuICAgICAgY29kZSA8IDB4MjAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIE5VTCAtIFVTXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBJZiBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzc3VtZXMgaXQncyBVVEYtOCBlbmNvZGVkIGFuZCBkZWNvZGVzIGl0LlxuICogU2luY2UgVVRGLTggaXMgYSBzdXBlcnNldCBvZiBBU0NJSSwgdGhpcyB3aWxsIHdvcmsgZm9yIEFTQ0lJIHN0cmluZ3MgYXMgd2VsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4ICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdiaW5hcnknKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gaXNWYWxpZEhUVFBUb2tlblxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgcmV0dXJuIChcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJ1xcdCcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJyAnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcXHQnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICcgJyB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXG4nKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXHInKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXDAnKVxuICApID09PSBmYWxzZVxufVxuXG4vKipcbiAqIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNwYXJzZS1yZWZlcnJlci1wb2xpY3ktZnJvbS1oZWFkZXJcbiAqL1xuZnVuY3Rpb24gcGFyc2VSZWZlcnJlclBvbGljeSAoYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoYWN0dWFsUmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knLCB0cnVlKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIDIuIExldCBwb2xpY3kgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHBvbGljeSA9ICcnXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gaW4gcG9saWN5LXRva2VucywgaWYgdG9rZW4gaXMgYSByZWZlcnJlciBwb2xpY3kgYW5kIHRva2VuIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCBwb2xpY3kgdG8gdG9rZW4uXG5cbiAgLy8gTm90ZTogQXMgdGhlIHJlZmVycmVyLXBvbGljeSBjYW4gY29udGFpbiBtdWx0aXBsZSBwb2xpY2llc1xuICAvLyBzZXBhcmF0ZWQgYnkgY29tbWEsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGFsbCBvZiB0aGVtXG4gIC8vIGFuZCBwaWNrIHRoZSBmaXJzdCB2YWxpZCBvbmUuXG4gIC8vIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JlZmVycmVyLVBvbGljeSNzcGVjaWZ5X2FfZmFsbGJhY2tfcG9saWN5XG4gIGlmIChwb2xpY3lIZWFkZXIubGVuZ3RoKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5oYXModG9rZW4pKSB7XG4gICAgICAgIHBvbGljeSA9IHRva2VuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIHBvbGljeS5cbiAgcmV0dXJuIHBvbGljeVxufVxuXG4vKipcbiAqIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICogdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAqIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3NldC1yZXF1ZXN0cy1yZWZlcnJlci1wb2xpY3ktb24tcmVkaXJlY3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3JlcXVlc3QnKS5SZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9yZXNwb25zZScpLlJlc3BvbnNlfSBhY3R1YWxSZXNwb25zZVxuICovXG5mdW5jdGlvbiBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0IChyZXF1ZXN0LCBhY3R1YWxSZXNwb25zZSkge1xuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cbiAgY29uc3QgcG9saWN5ID0gcGFyc2VSZWZlcnJlclBvbGljeShhY3R1YWxSZXNwb25zZSlcblxuICAvLyAyLiBJZiBwb2xpY3kgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byBwb2xpY3kuXG4gIGlmIChwb2xpY3kgIT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHBvbGljeVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjcm9zcy1vcmlnaW4tcmVzb3VyY2UtcG9saWN5LWNoZWNrXG5mdW5jdGlvbiBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnYWxsb3dlZCdcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY29ycy1jaGVja1xuZnVuY3Rpb24gY29yc0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXRhby1jaGVja1xuZnVuY3Rpb24gVEFPQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuZnVuY3Rpb24gYXBwZW5kRmV0Y2hNZXRhZGF0YSAoaHR0cFJlcXVlc3QpIHtcbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1kZXN0LWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtbW9kZS1oZWFkZXJcblxuICAvLyAgMS4gQXNzZXJ0OiBy4oCZcyB1cmwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwuXG4gIC8vICBUT0RPXG5cbiAgLy8gIDIuIExldCBoZWFkZXIgYmUgYSBTdHJ1Y3R1cmVkIEhlYWRlciB3aG9zZSB2YWx1ZSBpcyBhIHRva2VuLlxuICBsZXQgaGVhZGVyID0gbnVsbFxuXG4gIC8vICAzLiBTZXQgaGVhZGVy4oCZcyB2YWx1ZSB0byBy4oCZcyBtb2RlLlxuICBoZWFkZXIgPSBodHRwUmVxdWVzdC5tb2RlXG5cbiAgLy8gIDQuIFNldCBhIHN0cnVjdHVyZWQgZmllbGQgdmFsdWUgYFNlYy1GZXRjaC1Nb2RlYC9oZWFkZXIgaW4gcuKAmXMgaGVhZGVyIGxpc3QuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnc2VjLWZldGNoLW1vZGUnLCBoZWFkZXIsIHRydWUpXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1zaXRlLWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtdXNlci1oZWFkZXJcbiAgLy8gIFRPRE9cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcGVuZC1hLXJlcXVlc3Qtb3JpZ2luLWhlYWRlclxuZnVuY3Rpb24gYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgc2VyaWFsaXplZE9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIGJ5dGUtc2VyaWFsaXppbmcgYSByZXF1ZXN0IG9yaWdpblxuICAvLyAgICB3aXRoIHJlcXVlc3QuXG4gIC8vIFRPRE86IGltcGxlbWVudCBcImJ5dGUtc2VyaWFsaXppbmcgYSByZXF1ZXN0IG9yaWdpblwiXG4gIGxldCBzZXJpYWxpemVkT3JpZ2luID0gcmVxdWVzdC5vcmlnaW5cblxuICAvLyAtIFwiJ2NsaWVudCcgaXMgY2hhbmdlZCB0byBhbiBvcmlnaW4gZHVyaW5nIGZldGNoaW5nLlwiXG4gIC8vICAgVGhpcyBkb2Vzbid0IGhhcHBlbiBpbiB1bmRpY2kgKGluIG1vc3QgY2FzZXMpIGJlY2F1c2UgdW5kaWNpLCBieSBkZWZhdWx0LFxuICAvLyAgIGhhcyBubyBjb25jZXB0IG9mIG9yaWdpbi5cbiAgLy8gLSByZXF1ZXN0Lm9yaWdpbiBjYW4gYWxzbyBiZSBzZXQgdG8gcmVxdWVzdC5jbGllbnQub3JpZ2luIChjbGllbnQgYmVpbmdcbiAgLy8gICBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QpLCB3aGljaCBpcyB1bmRlZmluZWQgd2l0aG91dCB1c2luZ1xuICAvLyAgIHNldEdsb2JhbE9yaWdpbi5cbiAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4gPT09ICdjbGllbnQnIHx8IHNlcmlhbGl6ZWRPcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgb3IgcmVxdWVzdOKAmXMgbW9kZSBpcyBcIndlYnNvY2tldFwiLFxuICAvLyAgICB0aGVuIGFwcGVuZCAoYE9yaWdpbmAsIHNlcmlhbGl6ZWRPcmlnaW4pIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyAzLiBPdGhlcndpc2UsIGlmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBuZWl0aGVyIGBHRVRgIG5vciBgSEVBRGAsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4sIHRydWUpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAvLyAxLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5OlxuICAgIHN3aXRjaCAocmVxdWVzdC5yZWZlcnJlclBvbGljeSkge1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXInOlxuICAgICAgICAvLyBTZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4sIGl0cyBzY2hlbWUgaXMgXCJodHRwc1wiLCBhbmRcbiAgICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgXCJodHRwc1wiLCB0aGVuIHNldFxuICAgICAgICAvLyBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKHJlcXVlc3Qub3JpZ2luICYmIHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3Qub3JpZ2luKSAmJiAhdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzXG4gICAgICAgIC8vIG9yaWdpbiwgdGhlbiBzZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0LCByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH1cblxuICAgIC8vIDIuIEFwcGVuZCAoYE9yaWdpbmAsIHNlcmlhbGl6ZWRPcmlnaW4pIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luLCB0cnVlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9oci10aW1lLyNkZm4tY29hcnNlbi10aW1lXG5mdW5jdGlvbiBjb2Fyc2VuVGltZSAodGltZXN0YW1wLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICAvLyBUT0RPXG4gIHJldHVybiB0aW1lc3RhbXBcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NsYW1wLWFuZC1jb2Fyc2VuLWNvbm5lY3Rpb24tdGltaW5nLWluZm9cbmZ1bmN0aW9uIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvIChjb25uZWN0aW9uVGltaW5nSW5mbywgZGVmYXVsdFN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgaWYgKCFjb25uZWN0aW9uVGltaW5nSW5mbz8uc3RhcnRUaW1lIHx8IGNvbm5lY3Rpb25UaW1pbmdJbmZvLnN0YXJ0VGltZSA8IGRlZmF1bHRTdGFydFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZG9tYWluTG9va3VwU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgZG9tYWluTG9va3VwRW5kVGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBjb25uZWN0aW9uRW5kVGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIHNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBBTFBOTmVnb3RpYXRlZFByb3RvY29sOiBjb25uZWN0aW9uVGltaW5nSW5mbz8uQUxQTk5lZ290aWF0ZWRQcm90b2NvbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZG9tYWluTG9va3VwU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5kb21haW5Mb29rdXBTdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBkb21haW5Mb29rdXBFbmRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5kb21haW5Mb29rdXBFbmRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgY29ubmVjdGlvblN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uY29ubmVjdGlvblN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGNvbm5lY3Rpb25FbmRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5jb25uZWN0aW9uRW5kVGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIHNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLnNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBBTFBOTmVnb3RpYXRlZFByb3RvY29sOiBjb25uZWN0aW9uVGltaW5nSW5mby5BTFBOTmVnb3RpYXRlZFByb3RvY29sXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2hyLXRpbWUvI2Rmbi1jb2Fyc2VuZWQtc2hhcmVkLWN1cnJlbnQtdGltZVxuZnVuY3Rpb24gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUgKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIHJldHVybiBjb2Fyc2VuVGltZShwZXJmb3JtYW5jZS5ub3coKSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjcmVhdGUtYW4tb3BhcXVlLXRpbWluZy1pbmZvXG5mdW5jdGlvbiBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvICh0aW1pbmdJbmZvKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIHJlZGlyZWN0U3RhcnRUaW1lOiAwLFxuICAgIHJlZGlyZWN0RW5kVGltZTogMCxcbiAgICBwb3N0UmVkaXJlY3RTdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lID8/IDAsXG4gICAgZmluYWxTZXJ2aWNlV29ya2VyU3RhcnRUaW1lOiAwLFxuICAgIGZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lOiAwLFxuICAgIGZpbmFsTmV0d29ya1JlcXVlc3RTdGFydFRpbWU6IDAsXG4gICAgZW5kVGltZTogMCxcbiAgICBlbmNvZGVkQm9keVNpemU6IDAsXG4gICAgZGVjb2RlZEJvZHlTaXplOiAwLFxuICAgIGZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm86IG51bGxcbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNwb2xpY3ktY29udGFpbmVyXG5mdW5jdGlvbiBtYWtlUG9saWN5Q29udGFpbmVyICgpIHtcbiAgLy8gTm90ZTogdGhlIGZldGNoIHNwZWMgZG9lc24ndCBtYWtlIHVzZSBvZiBlbWJlZGRlciBwb2xpY3kgb3IgQ1NQIGxpc3RcbiAgcmV0dXJuIHtcbiAgICByZWZlcnJlclBvbGljeTogJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjY2xvbmUtYS1wb2xpY3ktY29udGFpbmVyXG5mdW5jdGlvbiBjbG9uZVBvbGljeUNvbnRhaW5lciAocG9saWN5Q29udGFpbmVyKSB7XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6IHBvbGljeUNvbnRhaW5lci5yZWZlcnJlclBvbGljeVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHJlcXVlc3TigJlzIFJlZmVycmVyXG4gKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIgKHJlcXVlc3QpIHtcbiAgLy8gR2l2ZW4gYSByZXF1ZXN0IHJlcXVlc3QsIHdlIGNhbiBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcmVmZXJyZXIgaW5mb3JtYXRpb25cbiAgLy8gdG8gc2VuZCBieSBleGFtaW5pbmcgaXRzIHJlZmVycmVyIHBvbGljeSBhcyBkZXRhaWxlZCBpbiB0aGUgZm9sbG93aW5nXG4gIC8vIHN0ZXBzLCB3aGljaCByZXR1cm4gZWl0aGVyIG5vIHJlZmVycmVyIG9yIGEgVVJMOlxuXG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuXG4gIC8vIFwiY2xpZW50XCJcbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gTm90ZTogbm9kZSBpc24ndCBhIGJyb3dzZXIgYW5kIGRvZXNuJ3QgaW1wbGVtZW50IGRvY3VtZW50L2lmcmFtZXMsXG4gICAgLy8gc28gd2UgYnlwYXNzIHRoaXMgc3RlcCBhbmQgcmVwbGFjZSBpdCB3aXRoIG91ciBvd24uXG5cbiAgICBjb25zdCBnbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW4oKVxuXG4gICAgaWYgKCFnbG9iYWxPcmlnaW4gfHwgZ2xvYmFsT3JpZ2luLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHdlIG5lZWQgdG8gY2xvbmUgaXQgYXMgaXQncyBtdXRhdGVkXG4gICAgcmVmZXJyZXJTb3VyY2UgPSBuZXcgVVJMKGdsb2JhbE9yaWdpbilcbiAgLy8gYSBVUkxcbiAgfSBlbHNlIGlmICh3ZWJpZGwuaXMuVVJMKHJlcXVlc3QucmVmZXJyZXIpKSB7XG4gICAgLy8gTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgIHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlclxuICB9XG5cbiAgLy8gNC4gTGV0IHJlcXVlc3TigJlzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvclxuICAvLyAgICB1c2UgYXMgYSByZWZlcnJlci5cbiAgbGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSlcblxuICAvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhc1xuICAvLyAgICBhIHJlZmVycmVyLCB3aXRoIHRoZSBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuICBjb25zdCByZWZlcnJlck9yaWdpbiA9IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG5cbiAgLy8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXNcbiAgLy8gICAgZ3JlYXRlciB0aGFuIDQwOTYsIHNldCByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cbiAgaWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuICAgIHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW5cbiAgfVxuXG4gIC8vIDcuIFRoZSB1c2VyIGFnZW50IE1BWSBhbHRlciByZWZlcnJlclVSTCBvciByZWZlcnJlck9yaWdpbiBhdCB0aGlzIHBvaW50XG4gIC8vIHRvIGVuZm9yY2UgYXJiaXRyYXJ5IHBvbGljeSBjb25zaWRlcmF0aW9ucyBpbiB0aGUgaW50ZXJlc3RzIG9mIG1pbmltaXppbmdcbiAgLy8gZGF0YSBsZWFrYWdlLiBGb3IgZXhhbXBsZSwgdGhlIHVzZXIgYWdlbnQgY291bGQgc3RyaXAgdGhlIFVSTCBkb3duIHRvIGFuXG4gIC8vIG9yaWdpbiwgbW9kaWZ5IGl0cyBob3N0LCByZXBsYWNlIGl0IHdpdGggYW4gZW1wdHkgc3RyaW5nLCBldGMuXG5cbiAgLy8gOC4gRXhlY3V0ZSB0aGUgc3dpdGNoIHN0YXRlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGUgdmFsdWUgb2YgcG9saWN5OlxuICBzd2l0Y2ggKHBvbGljeSkge1xuICAgIGNhc2UgJ25vLXJlZmVycmVyJzpcbiAgICAgIC8vIFJldHVybiBubyByZWZlcnJlclxuICAgICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4nOlxuICAgICAgLy8gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICBpZiAocmVmZXJyZXJPcmlnaW4gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlLCB0cnVlKVxuICAgIGNhc2UgJ3Vuc2FmZS11cmwnOlxuICAgICAgLy8gUmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuICAgICAgLy8gMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgLy8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN04oCZcyBjdXJyZW50XG4gICAgICAvLyBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuIHJldHVybiByZWZlcnJlclVSTC5cbiAgICAgIGlmIChzYW1lT3JpZ2luKHJlcXVlc3QsIHJlZmVycmVyVVJMKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICAgIH1cbiAgICAgIC8vIDIuIFJldHVybiBubyByZWZlcnJlci5cbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgY2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgIC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdOKAmXMgY3VycmVudFxuICAgICAgLy8gVVJMIGFyZSB0aGUgc2FtZSwgdGhlbiByZXR1cm4gcmVmZXJyZXJVUkwuXG4gICAgICBpZiAoc2FtZU9yaWdpbihyZXF1ZXN0LCByZWZlcnJlclVSTCkpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgICB9XG4gICAgICAvLyAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICBjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuICAgICAgLy8gMi4gUmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2VydGFpbiBwb3J0aW9ucyBvZiBVUkxzIG11c3Qgbm90IGJlIGluY2x1ZGVkIHdoZW4gc2VuZGluZyBhIFVSTCBhcyB0aGVcbiAqIHZhbHVlIG9mIGEgYFJlZmVyZXJgIGhlYWRlcjogYSBVUkxzIGZyYWdtZW50LCB1c2VybmFtZSwgYW5kIHBhc3N3b3JkXG4gKiBjb21wb25lbnRzIG11c3QgYmUgc3RyaXBwZWQgZnJvbSB0aGUgVVJMIGJlZm9yZSBpdOKAmXMgc2VudCBvdXQuIFRoaXNcbiAqIGFsZ29yaXRobSBhY2NlcHRzIGEgb3JpZ2luLW9ubHkgZmxhZywgd2hpY2ggZGVmYXVsdHMgdG8gZmFsc2UuIElmIHNldCB0b1xuICogdHJ1ZSwgdGhlIGFsZ29yaXRobSB3aWxsIGFkZGl0aW9uYWxseSByZW1vdmUgdGhlIFVSTOKAmXMgcGF0aCBhbmQgcXVlcnlcbiAqIGNvbXBvbmVudHMsIGxlYXZpbmcgb25seSB0aGUgc2NoZW1lLCBob3N0LCBhbmQgcG9ydC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29yaWdpbk9ubHk9ZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0cmlwVVJMRm9yUmVmZXJyZXIgKHVybCwgb3JpZ2luT25seSA9IGZhbHNlKSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQod2ViaWRsLmlzLlVSTCh1cmwpKVxuXG4gIC8vIE5vdGU6IENyZWF0ZSBhIG5ldyBVUkwgaW5zdGFuY2UgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIFVSTC5cbiAgdXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgLy8gMi4gSWYgdXJs4oCZcyBzY2hlbWUgaXMgYSBsb2NhbCBzY2hlbWUsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuICBpZiAodXJsSXNMb2NhbCh1cmwpKSB7XG4gICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgfVxuXG4gIC8vIDMuIFNldCB1cmzigJlzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHVybC51c2VybmFtZSA9ICcnXG5cbiAgLy8gNC4gU2V0IHVybOKAmXMgcGFzc3dvcmQgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnBhc3N3b3JkID0gJydcblxuICAvLyA1LiBTZXQgdXJs4oCZcyBmcmFnbWVudCB0byBudWxsLlxuICB1cmwuaGFzaCA9ICcnXG5cbiAgLy8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKG9yaWdpbk9ubHkgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgdXJs4oCZcyBwYXRoIHRvIMKrIHRoZSBlbXB0eSBzdHJpbmcgwrsuXG4gICAgdXJsLnBhdGhuYW1lID0gJydcblxuICAgIC8vIDIuIFNldCB1cmzigJlzIHF1ZXJ5IHRvIG51bGwuXG4gICAgdXJsLnNlYXJjaCA9ICcnXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdXJsLlxuICByZXR1cm4gdXJsXG59XG5cbmNvbnN0IGlzUG90ZW50aWFsbGVUcnVzdHdvcnRoeUlQdjQgPSBSZWdFeHAucHJvdG90eXBlLnRlc3RcbiAgLmJpbmQoL14xMjdcXC4oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZClcXC4pezJ9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpJC8pXG5cbmNvbnN0IGlzUG90ZW50aWFsbHlUcnVzdHdvcnRoeUlQdjYgPSBSZWdFeHAucHJvdG90eXBlLnRlc3RcbiAgLmJpbmQoL14oPzooPzowezEsNH06KXs3fXwoPzowezEsNH06KXsxLDZ9Onw6OikwezAsM30xJC8pXG5cbi8qKlxuICogQ2hlY2sgaWYgaG9zdCBtYXRjaGVzIG9uZSBvZiB0aGUgQ0lEUiBub3RhdGlvbnMgMTI3LjAuMC4wLzggb3IgOjoxLzEyOC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPcmlnaW5JUFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkgKG9yaWdpbikge1xuICAvLyBJUHY2XG4gIGlmIChvcmlnaW4uaW5jbHVkZXMoJzonKSkge1xuICAgIC8vIFJlbW92ZSBicmFja2V0cyBmcm9tIElQdjYgYWRkcmVzc2VzXG4gICAgaWYgKG9yaWdpblswXSA9PT0gJ1snICYmIG9yaWdpbltvcmlnaW4ubGVuZ3RoIC0gMV0gPT09ICddJykge1xuICAgICAgb3JpZ2luID0gb3JpZ2luLnNsaWNlKDEsIC0xKVxuICAgIH1cbiAgICByZXR1cm4gaXNQb3RlbnRpYWxseVRydXN0d29ydGh5SVB2NihvcmlnaW4pXG4gIH1cblxuICAvLyBJUHY0XG4gIHJldHVybiBpc1BvdGVudGlhbGxlVHJ1c3R3b3J0aHlJUHY0KG9yaWdpbilcbn1cblxuLyoqXG4gKiBBIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IG9yaWdpbiBpcyBvbmUgd2hpY2ggYSB1c2VyIGFnZW50IGNhbiBnZW5lcmFsbHlcbiAqIHRydXN0IGFzIGRlbGl2ZXJpbmcgZGF0YSBzZWN1cmVseS5cbiAqXG4gKiBSZXR1cm4gdmFsdWUgYHRydWVgIG1lYW5zIGBQb3RlbnRpYWxseSBUcnVzdHdvcnRoeWAuXG4gKiBSZXR1cm4gdmFsdWUgYGZhbHNlYCBtZWFucyBgTm90IFRydXN0d29ydGh5YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy1vcmlnaW4tdHJ1c3R3b3J0aHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkgKG9yaWdpbikge1xuICAvLyAxLiBJZiBvcmlnaW4gaXMgYW4gb3BhcXVlIG9yaWdpbiwgcmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG4gIGlmIChvcmlnaW4gPT0gbnVsbCB8fCBvcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gMi4gQXNzZXJ0OiBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4uXG4gIG9yaWdpbiA9IG5ldyBVUkwob3JpZ2luKVxuXG4gIC8vIDMuIElmIG9yaWdpbuKAmXMgc2NoZW1lIGlzIGVpdGhlciBcImh0dHBzXCIgb3IgXCJ3c3NcIixcbiAgLy8gICAgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKG9yaWdpbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgb3JpZ2luLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNC4gSWYgb3JpZ2lu4oCZcyBob3N0IG1hdGNoZXMgb25lIG9mIHRoZSBDSURSIG5vdGF0aW9ucyAxMjcuMC4wLjAvOCBvclxuICAvLyA6OjEvMTI4IFtSRkM0NjMyXSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKGlzT3JpZ2luSVBQb3RlbnRpYWxseVRydXN0d29ydGh5KG9yaWdpbi5ob3N0bmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNS4gSWYgdGhlIHVzZXIgYWdlbnQgY29uZm9ybXMgdG8gdGhlIG5hbWUgcmVzb2x1dGlvbiBydWxlcyBpblxuICAvLyAgICBbbGV0LWxvY2FsaG9zdC1iZS1sb2NhbGhvc3RdIGFuZCBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuXG4gIC8vICAgIG9yaWdpbuKAmXMgaG9zdCBpcyBcImxvY2FsaG9zdFwiIG9yIFwibG9jYWxob3N0LlwiXG4gIGlmIChvcmlnaW4uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IG9yaWdpbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdC4nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vICAgIG9yaWdpbuKAmXMgaG9zdCBlbmRzIHdpdGggXCIubG9jYWxob3N0XCIgb3IgXCIubG9jYWxob3N0LlwiXG4gIGlmIChvcmlnaW4uaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSB8fCBvcmlnaW4uaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QuJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNi4gSWYgb3JpZ2lu4oCZcyBzY2hlbWUgaXMgXCJmaWxlXCIsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG4gIGlmIChvcmlnaW4ucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNy4gSWYgb3JpZ2lu4oCZcyBzY2hlbWUgY29tcG9uZW50IGlzIG9uZSB3aGljaCB0aGUgdXNlciBhZ2VudCBjb25zaWRlcnMgdG9cbiAgLy8gYmUgYXV0aGVudGljYXRlZCwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblxuICAvLyA4LiBJZiBvcmlnaW4gaGFzIGJlZW4gY29uZmlndXJlZCBhcyBhIHRydXN0d29ydGh5IG9yaWdpbiwgcmV0dXJuXG4gIC8vICAgIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblxuICAvLyA5LiBSZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgaXMgb25lIHdoaWNoIGVpdGhlciBpbmhlcml0cyBjb250ZXh0IGZyb20gaXRzXG4gKiBjcmVhdG9yIChhYm91dDpibGFuaywgYWJvdXQ6c3JjZG9jLCBkYXRhKSBvciBvbmUgd2hvc2Ugb3JpZ2luIGlzIGFcbiAqIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IG9yaWdpbi5cbiAqXG4gKiBSZXR1cm4gdmFsdWUgYHRydWVgIG1lYW5zIGBQb3RlbnRpYWxseSBUcnVzdHdvcnRoeWAuXG4gKiBSZXR1cm4gdmFsdWUgYGZhbHNlYCBtZWFucyBgTm90IFRydXN0d29ydGh5YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWN1cmUtY29udGV4dHMvI2lzLXVybC10cnVzdHdvcnRoeVxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAodXJsKSB7XG4gIC8vIEdpdmVuIGEgVVJMIHJlY29yZCAodXJsKSwgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0gcmV0dXJucyBcIlBvdGVudGlhbGx5XG4gIC8vIFRydXN0d29ydGh5XCIgb3IgXCJOb3QgVHJ1c3R3b3J0aHlcIiBhcyBhcHByb3ByaWF0ZTpcbiAgaWYgKCF3ZWJpZGwuaXMuVVJMKHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIDEuIElmIHVybCBpcyBcImFib3V0OmJsYW5rXCIgb3IgXCJhYm91dDpzcmNkb2NcIixcbiAgLy8gICAgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKHVybC5ocmVmID09PSAnYWJvdXQ6YmxhbmsnIHx8IHVybC5ocmVmID09PSAnYWJvdXQ6c3JjZG9jJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBcImRhdGFcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgcmV0dXJuIHRydWVcblxuICAvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IFVSTHMgaXMgdGhlIG9yaWdpbiBvZiB0aGUgY29udGV4dCBpbiB3aGljaCB0aGV5XG4gIC8vIHdlcmUgY3JlYXRlZC4gVGhlcmVmb3JlLCBibG9icyBjcmVhdGVkIGluIGEgdHJ1c3R3b3J0aHkgb3JpZ2luIHdpbGxcbiAgLy8gdGhlbXNlbHZlcyBiZSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeS5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2Jsb2I6JykgcmV0dXJuIHRydWVcblxuICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgwqcgMy4xIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT9cbiAgLy8gb24gdXJs4oCZcyBvcmlnaW4uXG4gIHJldHVybiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsLm9yaWdpbilcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaXNBYm9ydGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2Qtbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZCAobWV0aG9kKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2VbbWV0aG9kLnRvTG93ZXJDYXNlKCldID8/IG1ldGhvZFxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSUyNWl0ZXJhdG9ycHJvdG90eXBlJTI1LW9iamVjdFxuY29uc3QgZXNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0geygodGFyZ2V0OiBhbnkpID0+IGFueSl9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvciAobmFtZSwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4ID0gMCwgdmFsdWVJbmRleCA9IDEpIHtcbiAgY2xhc3MgRmFzdEl0ZXJhYmxlSXRlcmF0b3Ige1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICN0YXJnZXRcbiAgICAvKiogQHR5cGUgeydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSAqL1xuICAgICNraW5kXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgI2luZGV4XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWRlZmF1bHQtaXRlcmF0b3Itb2JqZWN0XG4gICAgICogQHBhcmFtIHt1bmtub3dufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHRhcmdldCwga2luZCkge1xuICAgICAgdGhpcy4jdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICB0aGlzLiNraW5kID0ga2luZFxuICAgICAgdGhpcy4jaW5kZXggPSAwXG4gICAgfVxuXG4gICAgbmV4dCAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW50ZXJmYWNlIGJlIHRoZSBpbnRlcmZhY2UgZm9yIHdoaWNoIHRoZSBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGV4aXN0cy5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQgb2JqZWN0IGJlID8gVG9PYmplY3QodGhpc1ZhbHVlKS5cbiAgICAgIC8vIDQuIElmIG9iamVjdCBpcyBhIHBsYXRmb3JtIG9iamVjdCwgdGhlbiBwZXJmb3JtIGEgc2VjdXJpdHlcbiAgICAgIC8vICAgIGNoZWNrLCBwYXNzaW5nOlxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JyB8fCB0aGlzID09PSBudWxsIHx8ICEoI3RhcmdldCBpbiB0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNpbmRleFxuICAgICAgY29uc3QgdmFsdWVzID0ga0ludGVybmFsSXRlcmF0b3IodGhpcy4jdGFyZ2V0KVxuXG4gICAgICAvLyA5LiBMZXQgbGVuIGJlIHRoZSBsZW5ndGggb2YgdmFsdWVzLlxuICAgICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyAxMC4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGxlbiwgdGhlbiByZXR1cm5cbiAgICAgIC8vICAgICBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSkuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMTEuIExldCBwYWlyIGJlIHRoZSBlbnRyeSBpbiB2YWx1ZXMgYXQgaW5kZXggaW5kZXguXG4gICAgICBjb25zdCB7IFtrZXlJbmRleF06IGtleSwgW3ZhbHVlSW5kZXhdOiB2YWx1ZSB9ID0gdmFsdWVzW2luZGV4XVxuXG4gICAgICAvLyAxMi4gU2V0IG9iamVjdOKAmXMgaW5kZXggdG8gaW5kZXggKyAxLlxuICAgICAgdGhpcy4jaW5kZXggPSBpbmRleCArIDFcblxuICAgICAgLy8gMTMuIFJldHVybiB0aGUgaXRlcmF0b3IgcmVzdWx0IGZvciBwYWlyIGFuZCBraW5kLlxuXG4gICAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2l0ZXJhdG9yLXJlc3VsdFxuXG4gICAgICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgICAgIGxldCByZXN1bHRcbiAgICAgIHN3aXRjaCAodGhpcy4ja2luZCkge1xuICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxLZXkgYmUgcGFpcuKAmXMga2V5LlxuICAgICAgICAgIC8vIDIuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gcmVzdWx0IGlzIGtleS5cbiAgICAgICAgICByZXN1bHQgPSBrZXlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDMuIHJlc3VsdCBpcyB2YWx1ZS5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2tleSt2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAgICAgLy8gMi4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDMuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNC4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxWYWx1ZSB0b1xuICAgICAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAgICAgLy8gNi4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIwXCIsIGtleSkuXG4gICAgICAgICAgLy8gNy4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIxXCIsIHZhbHVlKS5cbiAgICAgICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICAgICAgcmVzdWx0ID0gW2tleSwgdmFsdWVdXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gUmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBmYWxzZSkuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAgLy8gQHRzLWlnbm9yZVxuICBkZWxldGUgRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZSwgZXNJdGVyYXRvclByb3RvdHlwZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUsIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYCR7bmFtZX0gSXRlcmF0b3JgXG4gICAgfSxcbiAgICBuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuICB9KVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHRhcmdldFxuICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuICAgIHJldHVybiBuZXcgRmFzdEl0ZXJhYmxlSXRlcmF0b3IodGFyZ2V0LCBraW5kKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IG9iamVjdCBjbGFzc1xuICogQHBhcmFtIHsodGFyZ2V0OiBhbnkpID0+IGFueX0ga0ludGVybmFsSXRlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBba2V5SW5kZXhdXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW3ZhbHVlSW5kZXhdXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdG9yTWl4aW4gKG5hbWUsIG9iamVjdCwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4ID0gMCwgdmFsdWVJbmRleCA9IDEpIHtcbiAgY29uc3QgbWFrZUl0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3IobmFtZSwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4LCB2YWx1ZUluZGV4KVxuXG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAga2V5czoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMgKCkge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpcywgJ2tleScpXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMgKCkge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpcywgJ3ZhbHVlJylcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudHJpZXM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRyaWVzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9yRWFjaDoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2ggKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSBnbG9iYWxUaGlzKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBgJHtuYW1lfS5mb3JFYWNoYClcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja2ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZm9yRWFjaCcgb24gJyR7bmFtZX0nOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRnVuY3Rpb24nLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB7IDA6IGtleSwgMTogdmFsdWUgfSBvZiBtYWtlSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpKSB7XG4gICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LnByb3RvdHlwZSwge1xuICAgIC4uLnByb3BlcnRpZXMsXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcHJvcGVydGllcy5lbnRyaWVzLnZhbHVlXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2JvZHknKS5FeHRyYWN0Qm9keVJlc3VsdH0gYm9keVxuICogQHBhcmFtIHsoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IHZvaWR9IHByb2Nlc3NCb2R5XG4gKiBAcGFyYW0geyhlcnJvcjogRXJyb3IpID0+IHZvaWR9IHByb2Nlc3NCb2R5RXJyb3JcbiAqIEByZXR1cm5zIHt2b2lkfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktZnVsbHktcmVhZFxuICovXG5mdW5jdGlvbiBmdWxseVJlYWRCb2R5IChib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcikge1xuICAvLyAxLiBJZiB0YXNrRGVzdGluYXRpb24gaXMgbnVsbCwgdGhlbiBzZXQgdGFza0Rlc3RpbmF0aW9uIHRvXG4gIC8vICAgIHRoZSByZXN1bHQgb2Ygc3RhcnRpbmcgYSBuZXcgcGFyYWxsZWwgcXVldWUuXG5cbiAgLy8gMi4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXMgYmUgdG8gcXVldWUgYVxuICAvLyAgICBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzQm9keSBnaXZlbiBieXRlcywgd2l0aCB0YXNrRGVzdGluYXRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IHByb2Nlc3NCb2R5XG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgYmUgdG8gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzQm9keUVycm9yLFxuICAvLyAgICB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IHByb2Nlc3NCb2R5RXJyb3JcblxuICB0cnkge1xuICAvLyA0LiBMZXQgcmVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIHJlYWRlciBmb3IgYm9keeKAmXMgc3RyZWFtLlxuICAvLyAgICBJZiB0aGF0IHRocmV3IGFuIGV4Y2VwdGlvbiwgdGhlbiBydW4gZXJyb3JTdGVwcyB3aXRoIHRoYXRcbiAgLy8gICAgZXhjZXB0aW9uIGFuZCByZXR1cm4uXG4gICAgY29uc3QgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcblxuICAgIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gICAgcmVhZEFsbEJ5dGVzKHJlYWRlciwgc3VjY2Vzc1N0ZXBzLCBlcnJvclN0ZXBzKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8VWludDhBcnJheT59IGNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1DbG9zZSAoY29udHJvbGxlcikge1xuICB0cnkge1xuICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgIGNvbnRyb2xsZXIuYnlvYlJlcXVlc3Q/LnJlc3BvbmQoMClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVE9ETzogYWRkIGNvbW1lbnQgZXhwbGFpbmluZyB3aHkgdGhpcyBlcnJvciBvY2N1cnMuXG4gICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnQ29udHJvbGxlciBpcyBhbHJlYWR5IGNsb3NlZCcpICYmICFlcnIubWVzc2FnZS5pbmNsdWRlcygnUmVhZGFibGVTdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQnKSkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbWRlZmF1bHRyZWFkZXItcmVhZC1hbGwtYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZC1sb29wXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk8QXJyYXlCdWZmZXI+Pn0gcmVhZGVyXG4gKiBAcGFyYW0geyhieXRlczogVWludDhBcnJheSkgPT4gdm9pZH0gc3VjY2Vzc1N0ZXBzXG4gKiBAcGFyYW0geyhlcnJvcjogRXJyb3IpID0+IHZvaWR9IGZhaWx1cmVTdGVwc1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyAocmVhZGVyLCBzdWNjZXNzU3RlcHMsIGZhaWx1cmVTdGVwcykge1xuICB0cnkge1xuICAgIGNvbnN0IGJ5dGVzID0gW11cbiAgICBsZXQgYnl0ZUxlbmd0aCA9IDBcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWU6IGNodW5rIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIC8vIDEuIENhbGwgc3VjY2Vzc1N0ZXBzIHdpdGggYnl0ZXMuXG4gICAgICAgIHN1Y2Nlc3NTdGVwcyhCdWZmZXIuY29uY2F0KGJ5dGVzLCBieXRlTGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDEuIElmIGNodW5rIGlzIG5vdCBhIFVpbnQ4QXJyYXkgb2JqZWN0LCBjYWxsIGZhaWx1cmVTdGVwc1xuICAgICAgLy8gICAgd2l0aCBhIFR5cGVFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgICAgZmFpbHVyZVN0ZXBzKG5ldyBUeXBlRXJyb3IoJ1JlY2VpdmVkIG5vbi1VaW50OEFycmF5IGNodW5rJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgdGhlIGJ5dGVzIHJlcHJlc2VudGVkIGJ5IGNodW5rIHRvIGJ5dGVzLlxuICAgICAgYnl0ZXMucHVzaChjaHVuaylcbiAgICAgIGJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICAvLyAzLiBSZWFkLWxvb3AgZ2l2ZW4gcmVhZGVyLCBieXRlcywgc3VjY2Vzc1N0ZXBzLCBhbmQgZmFpbHVyZVN0ZXBzLlxuICAgIH0gd2hpbGUgKHRydWUpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAxLiBDYWxsIGZhaWx1cmVTdGVwcyB3aXRoIGUuXG4gICAgZmFpbHVyZVN0ZXBzKGUpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNpcy1sb2NhbFxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybElzTG9jYWwgKHVybCkge1xuICBhc3NlcnQoJ3Byb3RvY29sJyBpbiB1cmwpIC8vIGVuc3VyZSBpdCdzIGEgdXJsIG9iamVjdFxuXG4gIGNvbnN0IHByb3RvY29sID0gdXJsLnByb3RvY29sXG5cbiAgLy8gQSBVUkwgaXMgbG9jYWwgaWYgaXRzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZS5cbiAgLy8gQSBsb2NhbCBzY2hlbWUgaXMgXCJhYm91dFwiLCBcImJsb2JcIiwgb3IgXCJkYXRhXCIuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2Fib3V0OicgfHwgcHJvdG9jb2wgPT09ICdibG9iOicgfHwgcHJvdG9jb2wgPT09ICdkYXRhOidcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEhhc0h0dHBzU2NoZW1lICh1cmwpIHtcbiAgcmV0dXJuIChcbiAgICAoXG4gICAgICB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgdXJsWzVdID09PSAnOicgJiZcbiAgICAgIHVybFswXSA9PT0gJ2gnICYmXG4gICAgICB1cmxbMV0gPT09ICd0JyAmJlxuICAgICAgdXJsWzJdID09PSAndCcgJiZcbiAgICAgIHVybFszXSA9PT0gJ3AnICYmXG4gICAgICB1cmxbNF0gPT09ICdzJ1xuICAgICkgfHxcbiAgICB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG4gIClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXNjaGVtZVxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0h0dHBIdHRwc1NjaGVtZSAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgfHwgcHJvdG9jb2wgPT09ICdodHRwczonXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmFuZ2VIZWFkZXJWYWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gcmFuZ2VTdGFydFZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcnxudWxsfSByYW5nZUVuZFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNzaW1wbGUtcmFuZ2UtaGVhZGVyLXZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dXaGl0ZXNwYWNlXG4gKiBAcmV0dXJuIHtSYW5nZUhlYWRlclZhbHVlfCdmYWlsdXJlJ31cbiAqL1xuZnVuY3Rpb24gc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSAodmFsdWUsIGFsbG93V2hpdGVzcGFjZSkge1xuICAvLyAxLiBMZXQgZGF0YSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGluZyBvZiB2YWx1ZS5cbiAgLy8gTm90ZTogaXNvbW9ycGhpYyBkZWNvZGluZyB0YWtlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIChpZS4gYSBVaW50OEFycmF5KSBhbmQgdHVybnMgaXQgaW50byBhIHN0cmluZyxcbiAgLy8gbm90aGluZyBtb3JlLiBXZSBvYnZpb3VzbHkgZG9uJ3QgbmVlZCB0byBkbyB0aGF0IGlmIHZhbHVlIGlzIGEgc3RyaW5nIGFscmVhZHkuXG4gIGNvbnN0IGRhdGEgPSB2YWx1ZVxuXG4gIC8vIDIuIElmIGRhdGEgZG9lcyBub3Qgc3RhcnQgd2l0aCBcImJ5dGVzXCIsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMy4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGRhdGEsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgNXRoIGNvZGUgcG9pbnQgb2YgZGF0YS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiA1IH1cblxuICAvLyA0LiBJZiBhbGxvd1doaXRlc3BhY2UgaXMgdHJ1ZSwgY29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDUuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwM0QgKD0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgzRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsIGZyb21cbiAgLy8gICAgZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gOC4gTGV0IHJhbmdlU3RhcnQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgQVNDSUkgZGlnaXRzLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHJhbmdlU3RhcnQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA5LiBMZXQgcmFuZ2VTdGFydFZhbHVlIGJlIHJhbmdlU3RhcnQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZVN0YXJ0IGlzIG5vdCB0aGVcbiAgLy8gICAgZW1wdHkgc3RyaW5nOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgcmFuZ2VTdGFydFZhbHVlID0gcmFuZ2VTdGFydC5sZW5ndGggPyBOdW1iZXIocmFuZ2VTdGFydCkgOiBudWxsXG5cbiAgLy8gMTAuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDExLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gZGF0YSBpcyBub3QgVSswMDJEICgtKSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGEuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgIT09IDB4MkQpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gMTMuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWJcbiAgLy8gICAgIG9yIHNwYWNlLCBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IGl0cyB0aGUgc2FtZSBzdGVwIGFzIGluICM4IGFnYWluIGxvbFxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyAxNC4gTGV0IHJhbmdlRW5kIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlXG4gIC8vICAgICBBU0NJSSBkaWdpdHMsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogeW91IHdvdWxkbid0IGd1ZXNzIGl0LCBidXQgdGhpcyBpcyBhbHNvIHRoZSBzYW1lIHN0ZXAgYXMgIzhcbiAgY29uc3QgcmFuZ2VFbmQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyAxNS4gTGV0IHJhbmdlRW5kVmFsdWUgYmUgcmFuZ2VFbmQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZUVuZFxuICAvLyAgICAgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiBUSEUgU0FNRSBTVEVQLCBBR0FJTiEhIVxuICAvLyBOb3RlOiB3aHkgaW50ZXJwcmV0IGFzIGEgZGVjaW1hbCBpZiB3ZSBvbmx5IGNvbGxlY3QgYXNjaWkgZGlnaXRzP1xuICBjb25zdCByYW5nZUVuZFZhbHVlID0gcmFuZ2VFbmQubGVuZ3RoID8gTnVtYmVyKHJhbmdlRW5kKSA6IG51bGxcblxuICAvLyAxNi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBkYXRhLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE3LiBJZiByYW5nZUVuZFZhbHVlIGFuZCByYW5nZVN0YXJ0VmFsdWUgYXJlIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChyYW5nZUVuZFZhbHVlID09PSBudWxsICYmIHJhbmdlU3RhcnRWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE4LiBJZiByYW5nZVN0YXJ0VmFsdWUgYW5kIHJhbmdlRW5kVmFsdWUgYXJlIG51bWJlcnMsIGFuZCByYW5nZVN0YXJ0VmFsdWUgaXNcbiAgLy8gICAgIGdyZWF0ZXIgdGhhbiByYW5nZUVuZFZhbHVlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBOb3RlOiAuLi4gd2hlbiBjYW4gdGhleSBub3QgYmUgbnVtYmVycz9cbiAgaWYgKHJhbmdlU3RhcnRWYWx1ZSA+IHJhbmdlRW5kVmFsdWUpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxOS4gUmV0dXJuIChyYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUpLlxuICByZXR1cm4geyByYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2J1aWxkLWEtY29udGVudC1yYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZFxuICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb250ZW50UmFuZ2UgKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKSB7XG4gIC8vIDEuIExldCBjb250ZW50UmFuZ2UgYmUgYGJ5dGVzIGAuXG4gIGxldCBjb250ZW50UmFuZ2UgPSAnYnl0ZXMgJ1xuXG4gIC8vIDIuIEFwcGVuZCByYW5nZVN0YXJ0LCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VTdGFydH1gKVxuXG4gIC8vIDMuIEFwcGVuZCAweDJEICgtKSB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSAnLSdcblxuICAvLyA0LiBBcHBlbmQgcmFuZ2VFbmQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke3JhbmdlRW5kfWApXG5cbiAgLy8gNS4gQXBwZW5kIDB4MkYgKC8pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICcvJ1xuXG4gIC8vIDYuIEFwcGVuZCBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtmdWxsTGVuZ3RofWApXG5cbiAgLy8gNy4gUmV0dXJuIGNvbnRlbnRSYW5nZS5cbiAgcmV0dXJuIGNvbnRlbnRSYW5nZVxufVxuXG4vLyBBIFN0cmVhbSwgd2hpY2ggcGlwZXMgdGhlIHJlc3BvbnNlIHRvIHpsaWIuY3JlYXRlSW5mbGF0ZSgpIG9yXG4vLyB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSBkZXBlbmRpbmcgb24gdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJ1ZmZlci5cbi8vIElmIHRoZSBsb3dlciBieXRlIG9mIHRoZSBmaXJzdCBieXRlIGlzIDB4MDgsIHRoZW4gdGhlIHN0cmVhbSBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYSB6bGliIHN0cmVhbSwgb3RoZXJ3aXNlIGl0J3MgaW50ZXJwcmV0ZWQgYXMgYVxuLy8gcmF3IGRlZmxhdGUgc3RyZWFtLlxuY2xhc3MgSW5mbGF0ZVN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICN6bGliT3B0aW9uc1xuXG4gIC8qKiBAcGFyYW0ge3psaWIuWmxpYk9wdGlvbnN9IFt6bGliT3B0aW9uc10gKi9cbiAgY29uc3RydWN0b3IgKHpsaWJPcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuI3psaWJPcHRpb25zID0gemxpYk9wdGlvbnNcbiAgfVxuXG4gIF90cmFuc2Zvcm0gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2luZmxhdGVTdHJlYW0pIHtcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0gPSAoY2h1bmtbMF0gJiAweDBGKSA9PT0gMHgwOFxuICAgICAgICA/IHpsaWIuY3JlYXRlSW5mbGF0ZSh0aGlzLiN6bGliT3B0aW9ucylcbiAgICAgICAgOiB6bGliLmNyZWF0ZUluZmxhdGVSYXcodGhpcy4jemxpYk9wdGlvbnMpXG5cbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2RhdGEnLCB0aGlzLnB1c2guYmluZCh0aGlzKSlcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2VuZCcsICgpID0+IHRoaXMucHVzaChudWxsKSlcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5kZXN0cm95KGVycikpXG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVN0cmVhbS53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICB9XG5cbiAgX2ZpbmFsIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLmVuZCgpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtID0gbnVsbFxuICAgIH1cbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3psaWIuWmxpYk9wdGlvbnN9IFt6bGliT3B0aW9uc11cbiAqIEByZXR1cm5zIHtJbmZsYXRlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmZsYXRlICh6bGliT3B0aW9ucykge1xuICByZXR1cm4gbmV3IEluZmxhdGVTdHJlYW0oemxpYk9wdGlvbnMpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItZXh0cmFjdC1taW1lLXR5cGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2hlYWRlcnMnKS5IZWFkZXJzTGlzdH0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBleHRyYWN0TWltZVR5cGUgKGhlYWRlcnMpIHtcbiAgLy8gMS4gTGV0IGNoYXJzZXQgYmUgbnVsbC5cbiAgbGV0IGNoYXJzZXQgPSBudWxsXG5cbiAgLy8gMi4gTGV0IGVzc2VuY2UgYmUgbnVsbC5cbiAgbGV0IGVzc2VuY2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IG1pbWVUeXBlIGJlIG51bGwuXG4gIGxldCBtaW1lVHlwZSA9IG51bGxcblxuICAvLyA0LiBMZXQgdmFsdWVzIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZywgZGVjb2RpbmcsIGFuZCBzcGxpdHRpbmcgYENvbnRlbnQtVHlwZWAgZnJvbSBoZWFkZXJzLlxuICBjb25zdCB2YWx1ZXMgPSBnZXREZWNvZGVTcGxpdCgnY29udGVudC10eXBlJywgaGVhZGVycylcblxuICAvLyA1LiBJZiB2YWx1ZXMgaXMgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEZvciBlYWNoIHZhbHVlIG9mIHZhbHVlczpcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAvLyA2LjEuIExldCB0ZW1wb3JhcnlNaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdmFsdWUuXG4gICAgY29uc3QgdGVtcG9yYXJ5TWltZVR5cGUgPSBwYXJzZU1JTUVUeXBlKHZhbHVlKVxuXG4gICAgLy8gNi4yLiBJZiB0ZW1wb3JhcnlNaW1lVHlwZSBpcyBmYWlsdXJlIG9yIGl0cyBlc3NlbmNlIGlzIFwiKi8qXCIsIHRoZW4gY29udGludWUuXG4gICAgaWYgKHRlbXBvcmFyeU1pbWVUeXBlID09PSAnZmFpbHVyZScgfHwgdGVtcG9yYXJ5TWltZVR5cGUuZXNzZW5jZSA9PT0gJyovKicpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNi4zLiBTZXQgbWltZVR5cGUgdG8gdGVtcG9yYXJ5TWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSB0ZW1wb3JhcnlNaW1lVHlwZVxuXG4gICAgLy8gNi40LiBJZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBub3QgZXNzZW5jZSwgdGhlbjpcbiAgICBpZiAobWltZVR5cGUuZXNzZW5jZSAhPT0gZXNzZW5jZSkge1xuICAgICAgLy8gNi40LjEuIFNldCBjaGFyc2V0IHRvIG51bGwuXG4gICAgICBjaGFyc2V0ID0gbnVsbFxuXG4gICAgICAvLyA2LjQuMi4gSWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIGV4aXN0cywgdGhlbiBzZXQgY2hhcnNldCB0b1xuICAgICAgLy8gICAgICAgIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXS5cbiAgICAgIGlmIChtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcygnY2hhcnNldCcpKSB7XG4gICAgICAgIGNoYXJzZXQgPSBtaW1lVHlwZS5wYXJhbWV0ZXJzLmdldCgnY2hhcnNldCcpXG4gICAgICB9XG5cbiAgICAgIC8vIDYuNC4zLiBTZXQgZXNzZW5jZSB0byBtaW1lVHlwZeKAmXMgZXNzZW5jZS5cbiAgICAgIGVzc2VuY2UgPSBtaW1lVHlwZS5lc3NlbmNlXG4gICAgfSBlbHNlIGlmICghbWltZVR5cGUucGFyYW1ldGVycy5oYXMoJ2NoYXJzZXQnKSAmJiBjaGFyc2V0ICE9PSBudWxsKSB7XG4gICAgICAvLyA2LjUuIE90aGVyd2lzZSwgaWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIGRvZXMgbm90IGV4aXN0LCBhbmRcbiAgICAgIC8vICAgICAgY2hhcnNldCBpcyBub24tbnVsbCwgc2V0IG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSB0byBjaGFyc2V0LlxuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQoJ2NoYXJzZXQnLCBjaGFyc2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIElmIG1pbWVUeXBlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItdmFsdWUtZ2V0LWRlY29kZS1hbmQtc3BsaXRcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldHRpbmdEZWNvZGluZ1NwbGl0dGluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IGlucHV0IGJlIHRoZSByZXN1bHQgb2YgaXNvbW9ycGhpYyBkZWNvZGluZyB2YWx1ZS5cbiAgY29uc3QgaW5wdXQgPSB2YWx1ZVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdmFsdWVzIGJlIGEgbGlzdCBvZiBzdHJpbmdzLCBpbml0aWFsbHkgZW1wdHkuXG4gIGNvbnN0IHZhbHVlcyA9IFtdXG5cbiAgLy8gNC4gTGV0IHRlbXBvcmFyeVZhbHVlIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCB0ZW1wb3JhcnlWYWx1ZSA9ICcnXG5cbiAgLy8gNS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gNS4xLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpXG4gICAgLy8gICAgICBvciBVKzAwMkMgKCwpIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLCB0byB0ZW1wb3JhcnlWYWx1ZS5cbiAgICB0ZW1wb3JhcnlWYWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICdcIicgJiYgY2hhciAhPT0gJywnLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDUuMi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbjpcbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIC8vIDUuMi4xLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXMgVSswMDIyIChcIiksIHRoZW46XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgPT09IDB4MjIpIHtcbiAgICAgICAgLy8gNS4yLjEuMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhbiBIVFRQIHF1b3RlZCBzdHJpbmcgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24sIHRvIHRlbXBvcmFyeVZhbHVlLlxuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSArPSBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyA1LjIuMS4yLiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGNvbnRpbnVlLlxuICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA1LjIuMi4gT3RoZXJ3aXNlOlxuXG4gICAgICAgIC8vIDUuMi4yLjEuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzIFUrMDAyQyAoLCkuXG4gICAgICAgIGFzc2VydChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSA9PT0gMHgyQylcblxuICAgICAgICAvLyA1LjIuMi4yLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjMuIFJlbW92ZSBhbGwgSFRUUCB0YWIgb3Igc3BhY2UgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0ZW1wb3JhcnlWYWx1ZS5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9IHJlbW92ZUNoYXJzKHRlbXBvcmFyeVZhbHVlLCB0cnVlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAvLyA1LjQuIEFwcGVuZCB0ZW1wb3JhcnlWYWx1ZSB0byB2YWx1ZXMuXG4gICAgdmFsdWVzLnB1c2godGVtcG9yYXJ5VmFsdWUpXG5cbiAgICAvLyA1LjYuIFNldCB0ZW1wb3JhcnlWYWx1ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIHRlbXBvcmFyeVZhbHVlID0gJydcbiAgfVxuXG4gIC8vIDYuIFJldHVybiB2YWx1ZXMuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldC1kZWNvZGUtc3BsaXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGxvd2VyY2FzZSBoZWFkZXIgbmFtZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSBsaXN0XG4gKi9cbmZ1bmN0aW9uIGdldERlY29kZVNwbGl0IChuYW1lLCBsaXN0KSB7XG4gIC8vIDEuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIGxpc3QuXG4gIGNvbnN0IHZhbHVlID0gbGlzdC5nZXQobmFtZSwgdHJ1ZSlcblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBudWxsLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZ2V0dGluZywgZGVjb2RpbmcsIGFuZCBzcGxpdHRpbmcgdmFsdWUuXG4gIHJldHVybiBnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGhhc0F1dGhlbnRpY2F0aW9uRW50cnkgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2luY2x1ZGUtY3JlZGVudGlhbHNcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXNDcmVkZW50aWFscyAodXJsKSB7XG4gIC8vIEEgVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzIGlmIGl0cyB1c2VybmFtZSBvciBwYXNzd29yZCBpcyBub3QgdGhlIGVtcHR5IHN0cmluZy5cbiAgcmV0dXJuICEhKHVybC51c2VybmFtZSAmJiB1cmwucGFzc3dvcmQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb2N1bWVudC1zZXF1ZW5jZXMuaHRtbCN0cmF2ZXJzYWJsZS1uYXZpZ2FibGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gbmF2aWdhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzVHJhdmVyc2FibGVOYXZpZ2FibGUgKG5hdmlnYWJsZSkge1xuICAvLyBUT0RPXG4gIHJldHVybiB0cnVlXG59XG5cbmNsYXNzIEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlIHtcbiAgZ2V0IGJhc2VVcmwgKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWxPcmlnaW4oKVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVybD8ub3JpZ2luXG4gIH1cblxuICBwb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKClcbn1cblxuY2xhc3MgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB7XG4gIHNldHRpbmdzT2JqZWN0ID0gbmV3IEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlKClcbn1cblxuY29uc3QgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCA9IG5ldyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0KClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQWJvcnRlZCxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzVmFsaWRFbmNvZGVkVVJMLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8sXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgVEFPQ2hlY2ssXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHJlc3BvbnNlVVJMLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgaXRlcmF0b3JNaXhpbixcbiAgY3JlYXRlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxIYXNIdHRwc1NjaGVtZSxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHJlYWRBbGxCeXRlcyxcbiAgc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSxcbiAgYnVpbGRDb250ZW50UmFuZ2UsXG4gIGNyZWF0ZUluZmxhdGUsXG4gIGV4dHJhY3RNaW1lVHlwZSxcbiAgZ2V0RGVjb2RlU3BsaXQsXG4gIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QsXG4gIGlzT3JpZ2luSVBQb3RlbnRpYWxseVRydXN0d29ydGh5LFxuICBoYXNBdXRoZW50aWNhdGlvbkVudHJ5LFxuICBpbmNsdWRlc0NyZWRlbnRpYWxzLFxuICBpc1RyYXZlcnNhYmxlTmF2aWdhYmxlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/infra/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/infra/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ../../encoding */ \"(rsc)/./node_modules/undici/lib/encoding/index.js\")\n\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n * @returns {string}\n *\n * @see https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesnt point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n * @returns {string}\n *\n * @see https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line no-control-regex\n\n/**\n * @param {string} data\n * @returns {Uint8Array | 'failure'}\n *\n * @see https://infra.spec.whatwg.org/#forgiving-base64-decode\n */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')\n\n  let dataLength = data.length\n  // 2. If datas code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If datas code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n/**\n * @param {number} char\n * @returns {boolean}\n *\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n */\nfunction isASCIIWhitespace (char) {\n  return (\n    char === 0x09 || // \\t\n    char === 0x0a || // \\n\n    char === 0x0c || // \\f\n    char === 0x0d || // \\r\n    char === 0x20    // space\n  )\n}\n\n/**\n * @param {Uint8Array} input\n * @returns {string}\n *\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to inputs length and whose code points have the same values\n  //    as the values of inputs bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''\n  let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line no-control-regex\n\n/**\n * @param {string} input\n * @returns {string}\n *\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to inputs code\n  //    point length and whose bytes have the same values as the\n  //    values of inputs code points, in the same order\n  return input\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n * @returns {string}\n *\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {string}\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\nmodule.exports = {\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  forgivingBase64,\n  isASCIIWhitespace,\n  isomorphicDecode,\n  isomorphicEncode,\n  parseJSONFromBytes,\n  removeASCIIWhitespace,\n  removeChars,\n  serializeJavascriptValueToJSONString\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvaW5mcmEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBZ0I7O0FBRXBEO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcaW5mcmFcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHV0ZjhEZWNvZGVCeXRlcyB9ID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcnKVxuXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IHN0cmluZykgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYS1zZXF1ZW5jZS1vZi1jb2RlLXBvaW50c1xuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCByZXN1bHQgPSAnJ1xuXG4gIC8vIDIuIFdoaWxlIHBvc2l0aW9uIGRvZXNu4oCZdCBwb2ludCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQgYW5kIHRoZVxuICAvLyBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBtZWV0cyB0aGUgY29uZGl0aW9uIGNvbmRpdGlvbjpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0pKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoYXQgY29kZSBwb2ludCB0byB0aGUgZW5kIG9mIHJlc3VsdC5cbiAgICByZXN1bHQgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEEgZmFzdGVyIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgdGhhdCBvbmx5IHdvcmtzIHdoZW4gY29tcGFyaW5nIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYS1zZXF1ZW5jZS1vZi1jb2RlLXBvaW50c1xuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCAoY2hhciwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGlkeCA9IGlucHV0LmluZGV4T2YoY2hhciwgcG9zaXRpb24ucG9zaXRpb24pXG4gIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uID0gaW5wdXQubGVuZ3RoXG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0KVxuICB9XG5cbiAgcG9zaXRpb24ucG9zaXRpb24gPSBpZHhcbiAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuY29uc3QgQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYID0gL1tcXHUwMDA5XFx1MDAwQVxcdTAwMENcXHUwMDBEXFx1MDAyMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCAnZmFpbHVyZSd9XG4gKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jZm9yZ2l2aW5nLWJhc2U2NC1kZWNvZGVcbiAqL1xuZnVuY3Rpb24gZm9yZ2l2aW5nQmFzZTY0IChkYXRhKSB7XG4gIC8vIDEuIFJlbW92ZSBhbGwgQVNDSUkgd2hpdGVzcGFjZSBmcm9tIGRhdGEuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYLCAnJylcblxuICBsZXQgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIC8vIDIuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIG5vIHJlbWFpbmRlciwgdGhlbjpcbiAgaWYgKGRhdGFMZW5ndGggJSA0ID09PSAwKSB7XG4gICAgLy8gMS4gSWYgZGF0YSBlbmRzIHdpdGggb25lIG9yIHR3byBVKzAwM0QgKD0pIGNvZGUgcG9pbnRzLFxuICAgIC8vIHRoZW4gcmVtb3ZlIHRoZW0gZnJvbSBkYXRhLlxuICAgIGlmIChkYXRhLmNoYXJDb2RlQXQoZGF0YUxlbmd0aCAtIDEpID09PSAweDAwM0QpIHtcbiAgICAgIC0tZGF0YUxlbmd0aFxuICAgICAgaWYgKGRhdGEuY2hhckNvZGVBdChkYXRhTGVuZ3RoIC0gMSkgPT09IDB4MDAzRCkge1xuICAgICAgICAtLWRhdGFMZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAzLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBhIHJlbWFpbmRlciBvZiAxLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YUxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA0LiBJZiBkYXRhIGNvbnRhaW5zIGEgY29kZSBwb2ludCB0aGF0IGlzIG5vdCBvbmUgb2ZcbiAgLy8gIFUrMDAyQiAoKylcbiAgLy8gIFUrMDAyRiAoLylcbiAgLy8gIEFTQ0lJIGFscGhhbnVtZXJpY1xuICAvLyB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoL1teKy8wLTlBLVphLXpdLy50ZXN0KGRhdGEubGVuZ3RoID09PSBkYXRhTGVuZ3RoID8gZGF0YSA6IGRhdGEuc3Vic3RyaW5nKDAsIGRhdGFMZW5ndGgpKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUlXaGl0ZXNwYWNlIChjaGFyKSB7XG4gIHJldHVybiAoXG4gICAgY2hhciA9PT0gMHgwOSB8fCAvLyBcXHRcbiAgICBjaGFyID09PSAweDBhIHx8IC8vIFxcblxuICAgIGNoYXIgPT09IDB4MGMgfHwgLy8gXFxmXG4gICAgY2hhciA9PT0gMHgwZCB8fCAvLyBcXHJcbiAgICBjaGFyID09PSAweDIwICAgIC8vIHNwYWNlXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2lzb21vcnBoaWMtZGVjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNEZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIFRvIGlzb21vcnBoaWMgZGVjb2RlIGEgYnl0ZSBzZXF1ZW5jZSBpbnB1dCwgcmV0dXJuIGEgc3RyaW5nIHdob3NlIGNvZGUgcG9pbnRcbiAgLy8gICAgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBsZW5ndGggYW5kIHdob3NlIGNvZGUgcG9pbnRzIGhhdmUgdGhlIHNhbWUgdmFsdWVzXG4gIC8vICAgIGFzIHRoZSB2YWx1ZXMgb2YgaW5wdXTigJlzIGJ5dGVzLCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gIGlmICgoMiA8PCAxNSkgLSAxID4gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQpXG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnXG4gIGxldCBpID0gMFxuICBsZXQgYWRkaXRpb24gPSAoMiA8PCAxNSkgLSAxXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKGkgKyBhZGRpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgYWRkaXRpb24gPSBsZW5ndGggLSBpXG4gICAgfVxuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKz0gYWRkaXRpb24pKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuY29uc3QgaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4ID0gL1teXFx4MDAtXFx4RkZdLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1lbmNvZGVcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0VuY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gQXNzZXJ0OiBpbnB1dCBjb250YWlucyBubyBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVSswMEZGLlxuICBhc3NlcnQoIWludmFsaWRJc29tb3JwaGljRW5jb2RlVmFsdWVSZWdleC50ZXN0KGlucHV0KSlcblxuICAvLyAyLiBSZXR1cm4gYSBieXRlIHNlcXVlbmNlIHdob3NlIGxlbmd0aCBpcyBlcXVhbCB0byBpbnB1dOKAmXMgY29kZVxuICAvLyAgICBwb2ludCBsZW5ndGggYW5kIHdob3NlIGJ5dGVzIGhhdmUgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAvLyAgICB2YWx1ZXMgb2YgaW5wdXTigJlzIGNvZGUgcG9pbnRzLCBpbiB0aGUgc2FtZSBvcmRlclxuICByZXR1cm4gaW5wdXRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1qc29uLWJ5dGVzLXRvLWEtamF2YXNjcmlwdC12YWx1ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gcm9tQnl0ZXMgKGJ5dGVzKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVCeXRlcyhieXRlcykpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBbbGVhZGluZz10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbdHJhaWxpbmc9dHJ1ZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtbGVhZGluZy1hbmQtdHJhaWxpbmctYXNjaWktd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiByZW1vdmVBU0NJSVdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICByZXR1cm4gcmVtb3ZlQ2hhcnMoc3RyLCBsZWFkaW5nLCB0cmFpbGluZywgaXNBU0NJSVdoaXRlc3BhY2UpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBsZWFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiBAcGFyYW0geyhjaGFyQ29kZTogbnVtYmVyKSA9PiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoYXJzIChzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBwcmVkaWNhdGUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IHN0ci5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICB3aGlsZSAobGVhZCA8IHN0ci5sZW5ndGggJiYgcHJlZGljYXRlKHN0ci5jaGFyQ29kZUF0KGxlYWQpKSkgbGVhZCsrXG4gIH1cblxuICBpZiAodHJhaWxpbmcpIHtcbiAgICB3aGlsZSAodHJhaWwgPiAwICYmIHByZWRpY2F0ZShzdHIuY2hhckNvZGVBdCh0cmFpbCkpKSB0cmFpbC0tXG4gIH1cblxuICByZXR1cm4gbGVhZCA9PT0gMCAmJiB0cmFpbCA9PT0gc3RyLmxlbmd0aCAtIDEgPyBzdHIgOiBzdHIuc2xpY2UobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtamF2YXNjcmlwdC12YWx1ZS10by1hLWpzb24tc3RyaW5nXG5mdW5jdGlvbiBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcgKHZhbHVlKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgPyBDYWxsKCVKU09OLnN0cmluZ2lmeSUsIHVuZGVmaW5lZCwgwqsgdmFsdWUgwrspLlxuICBjb25zdCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcblxuICAvLyAyLiBJZiByZXN1bHQgaXMgdW5kZWZpbmVkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKVxuICB9XG5cbiAgLy8gMy4gQXNzZXJ0OiByZXN1bHQgaXMgYSBzdHJpbmcuXG4gIGFzc2VydCh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJylcblxuICAvLyA0LiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLFxuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCxcbiAgZm9yZ2l2aW5nQmFzZTY0LFxuICBpc0FTQ0lJV2hpdGVzcGFjZSxcbiAgaXNvbW9ycGhpY0RlY29kZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgcGFyc2VKU09ORnJvbUJ5dGVzLFxuICByZW1vdmVBU0NJSVdoaXRlc3BhY2UsXG4gIHJlbW92ZUNoYXJzLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/infra/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js":
/*!************************************************************************************!*\
  !*** ./node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features.js */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\n/**\n * @typedef {object} Metadata\n * @property {SRIHashAlgorithm} alg - The algorithm used for the hash.\n * @property {string} val - The base64-encoded hash value.\n */\n\n/**\n * @typedef {Metadata[]} MetadataList\n */\n\n/**\n * @typedef {('sha256' | 'sha384' | 'sha512')} SRIHashAlgorithm\n */\n\n/**\n * @type {Map<SRIHashAlgorithm, number>}\n *\n * The valid SRI hash algorithm token set is the ordered set  \"sha256\",\n * \"sha384\", \"sha512\"  (corresponding to SHA-256, SHA-384, and SHA-512\n * respectively). The ordering of this set is meaningful, with stronger\n * algorithms appearing later in the set.\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#valid-sri-hash-algorithm-token-set\n */\nconst validSRIHashAlgorithmTokenSet = new Map([['sha256', 0], ['sha384', 1], ['sha512', 2]])\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('node:crypto')} */\nlet crypto\n\nif (runtimeFeatures.has('crypto')) {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  const cryptoHashes = crypto.getHashes()\n\n  // If no hashes are available, we cannot support SRI.\n  if (cryptoHashes.length === 0) {\n    validSRIHashAlgorithmTokenSet.clear()\n  }\n\n  for (const algorithm of validSRIHashAlgorithmTokenSet.keys()) {\n    // If the algorithm is not supported, remove it from the list.\n    if (cryptoHashes.includes(algorithm) === false) {\n      validSRIHashAlgorithmTokenSet.delete(algorithm)\n    }\n  }\n} else {\n  // If crypto is not available, we cannot support SRI.\n  validSRIHashAlgorithmTokenSet.clear()\n}\n\n/**\n * @typedef GetSRIHashAlgorithmIndex\n * @type {(algorithm: SRIHashAlgorithm) => number}\n * @param {SRIHashAlgorithm} algorithm\n * @returns {number} The index of the algorithm in the valid SRI hash algorithm\n * token set.\n */\n\nconst getSRIHashAlgorithmIndex = /** @type {GetSRIHashAlgorithmIndex} */ (Map.prototype.get.bind(\n  validSRIHashAlgorithmTokenSet))\n\n/**\n * @typedef IsValidSRIHashAlgorithm\n * @type {(algorithm: string) => algorithm is SRIHashAlgorithm}\n * @param {*} algorithm\n * @returns {algorithm is SRIHashAlgorithm}\n */\n\nconst isValidSRIHashAlgorithm = /** @type {IsValidSRIHashAlgorithm} */ (\n  Map.prototype.has.bind(validSRIHashAlgorithmTokenSet)\n)\n\n/**\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n * @returns {boolean}\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n */\nconst bytesMatch = runtimeFeatures.has('crypto') === false || validSRIHashAlgorithmTokenSet.size === 0\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  ? () => true\n  : (bytes, metadataList) => {\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n      const parsedMetadata = parseMetadata(metadataList)\n\n      // 2. If parsedMetadata is empty set, return true.\n      if (parsedMetadata.length === 0) {\n        return true\n      }\n\n      // 3. Let metadata be the result of getting the strongest\n      //    metadata from parsedMetadata.\n      const metadata = getStrongestMetadata(parsedMetadata)\n\n      // 4. For each item in metadata:\n      for (const item of metadata) {\n      // 1. Let algorithm be the item[\"alg\"].\n        const algorithm = item.alg\n\n        // 2. Let expectedValue be the item[\"val\"].\n        const expectedValue = item.val\n\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n        // 3. Let actualValue be the result of applying algorithm to bytes .\n        const actualValue = applyAlgorithmToBytes(algorithm, bytes)\n\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (caseSensitiveMatch(actualValue, expectedValue)) {\n          return true\n        }\n      }\n\n      // 5. Return false.\n      return false\n    }\n\n/**\n * @param {MetadataList} metadataList\n * @returns {MetadataList} The strongest hash algorithm from the metadata list.\n */\nfunction getStrongestMetadata (metadataList) {\n  // 1. Let result be the empty set and strongest be the empty string.\n  const result = []\n  /** @type {Metadata|null} */\n  let strongest = null\n\n  // 2. For each item in set:\n  for (const item of metadataList) {\n    // 1. Assert: item[\"alg\"] is a valid SRI hash algorithm token.\n    assert(isValidSRIHashAlgorithm(item.alg), 'Invalid SRI hash algorithm token')\n\n    // 2. If result is the empty set, then:\n    if (result.length === 0) {\n      // 1. Append item to result.\n      result.push(item)\n\n      // 2. Set strongest to item.\n      strongest = item\n\n      // 3. Continue.\n      continue\n    }\n\n    // 3. Let currentAlgorithm be strongest[\"alg\"], and currentAlgorithmIndex be\n    // the index of currentAlgorithm in the valid SRI hash algorithm token set.\n    const currentAlgorithm = /** @type {Metadata} */ (strongest).alg\n    const currentAlgorithmIndex = getSRIHashAlgorithmIndex(currentAlgorithm)\n\n    // 4. Let newAlgorithm be the item[\"alg\"], and newAlgorithmIndex be the\n    // index of newAlgorithm in the valid SRI hash algorithm token set.\n    const newAlgorithm = item.alg\n    const newAlgorithmIndex = getSRIHashAlgorithmIndex(newAlgorithm)\n\n    // 5. If newAlgorithmIndex is less than currentAlgorithmIndex, then continue.\n    if (newAlgorithmIndex < currentAlgorithmIndex) {\n      continue\n\n    // 6. Otherwise, if newAlgorithmIndex is greater than\n    // currentAlgorithmIndex:\n    } else if (newAlgorithmIndex > currentAlgorithmIndex) {\n      // 1. Set strongest to item.\n      strongest = item\n\n      // 2. Set result to  item .\n      result[0] = item\n      result.length = 1\n\n    // 7. Otherwise, newAlgorithmIndex and currentAlgorithmIndex are the same\n    // value. Append item to result.\n    } else {\n      result.push(item)\n    }\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * @param {string} metadata\n * @returns {MetadataList}\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {MetadataList} */\n  const result = []\n\n  // 2. For each item returned by splitting metadata on spaces:\n  for (const item of metadata.split(' ')) {\n    // 1. Let expression-and-options be the result of splitting item on U+003F (?).\n    const expressionAndOptions = item.split('?', 1)\n\n    // 2. Let algorithm-expression be expression-and-options[0].\n    const algorithmExpression = expressionAndOptions[0]\n\n    // 3. Let base64-value be the empty string.\n    let base64Value = ''\n\n    // 4. Let algorithm-and-value be the result of splitting algorithm-expression on U+002D (-).\n    const algorithmAndValue = [algorithmExpression.slice(0, 6), algorithmExpression.slice(7)]\n\n    // 5. Let algorithm be algorithm-and-value[0].\n    const algorithm = algorithmAndValue[0]\n\n    // 6. If algorithm is not a valid SRI hash algorithm token, then continue.\n    if (!isValidSRIHashAlgorithm(algorithm)) {\n      continue\n    }\n\n    // 7. If algorithm-and-value[1] exists, set base64-value to\n    // algorithm-and-value[1].\n    if (algorithmAndValue[1]) {\n      base64Value = algorithmAndValue[1]\n    }\n\n    // 8. Let metadata be the ordered map\n    // [\"alg\"  algorithm, \"val\"  base64-value].\n    const metadata = {\n      alg: algorithm,\n      val: base64Value\n    }\n\n    // 9. Append metadata to result.\n    result.push(metadata)\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * Applies the specified hash algorithm to the given bytes\n *\n * @typedef {(algorithm: SRIHashAlgorithm, bytes: Uint8Array) => string} ApplyAlgorithmToBytes\n * @param {SRIHashAlgorithm} algorithm\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nconst applyAlgorithmToBytes = (algorithm, bytes) => {\n  return crypto.hash(algorithm, bytes, 'base64')\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n * @param {string} actualValue base64 encoded string\n * @param {string} expectedValue base64 or base64url encoded string\n * @returns {boolean}\n */\nfunction caseSensitiveMatch (actualValue, expectedValue) {\n  // Ignore padding characters from the end of the strings by\n  // decreasing the length by 1 or 2 if the last characters are `=`.\n  let actualValueLength = actualValue.length\n  if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === '=') {\n    actualValueLength -= 1\n  }\n  if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === '=') {\n    actualValueLength -= 1\n  }\n  let expectedValueLength = expectedValue.length\n  if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === '=') {\n    expectedValueLength -= 1\n  }\n  if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === '=') {\n    expectedValueLength -= 1\n  }\n\n  if (actualValueLength !== expectedValueLength) {\n    return false\n  }\n\n  for (let i = 0; i < actualValueLength; ++i) {\n    if (\n      actualValue[i] === expectedValue[i] ||\n      (actualValue[i] === '+' && expectedValue[i] === '-') ||\n      (actualValue[i] === '/' && expectedValue[i] === '_')\n    ) {\n      continue\n    }\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = {\n  applyAlgorithmToBytes,\n  bytesMatch,\n  caseSensitiveMatch,\n  isValidSRIHashAlgorithm,\n  getStrongestMetadata,\n  parseMetadata\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvc3VicmVzb3VyY2UtaW50ZWdyaXR5L3N1YnJlc291cmNlLWludGVncml0eS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGdHQUFnQzs7QUFFcEU7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7O0FBRUE7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBLDRDQUE0QywwQkFBMEI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7O0FBRUEsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekUsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxzdWJyZXNvdXJjZS1pbnRlZ3JpdHlcXHN1YnJlc291cmNlLWludGVncml0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBydW50aW1lRmVhdHVyZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcnVudGltZS1mZWF0dXJlcy5qcycpXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YWRhdGFcbiAqIEBwcm9wZXJ0eSB7U1JJSGFzaEFsZ29yaXRobX0gYWxnIC0gVGhlIGFsZ29yaXRobSB1c2VkIGZvciB0aGUgaGFzaC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWwgLSBUaGUgYmFzZTY0LWVuY29kZWQgaGFzaCB2YWx1ZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtNZXRhZGF0YVtdfSBNZXRhZGF0YUxpc3RcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoJ3NoYTI1NicgfCAnc2hhMzg0JyB8ICdzaGE1MTInKX0gU1JJSGFzaEFsZ29yaXRobVxuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxTUklIYXNoQWxnb3JpdGhtLCBudW1iZXI+fVxuICpcbiAqIFRoZSB2YWxpZCBTUkkgaGFzaCBhbGdvcml0aG0gdG9rZW4gc2V0IGlzIHRoZSBvcmRlcmVkIHNldCDCqyBcInNoYTI1NlwiLFxuICogXCJzaGEzODRcIiwgXCJzaGE1MTJcIiDCuyAoY29ycmVzcG9uZGluZyB0byBTSEEtMjU2LCBTSEEtMzg0LCBhbmQgU0hBLTUxMlxuICogcmVzcGVjdGl2ZWx5KS4gVGhlIG9yZGVyaW5nIG9mIHRoaXMgc2V0IGlzIG1lYW5pbmdmdWwsIHdpdGggc3Ryb25nZXJcbiAqIGFsZ29yaXRobXMgYXBwZWFyaW5nIGxhdGVyIGluIHRoZSBzZXQuXG4gKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXN1YnJlc291cmNlLWludGVncml0eS8jdmFsaWQtc3JpLWhhc2gtYWxnb3JpdGhtLXRva2VuLXNldFxuICovXG5jb25zdCB2YWxpZFNSSUhhc2hBbGdvcml0aG1Ub2tlblNldCA9IG5ldyBNYXAoW1snc2hhMjU2JywgMF0sIFsnc2hhMzg0JywgMV0sIFsnc2hhNTEyJywgMl1dKVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2RldGVybWluaW5nLWlmLWNyeXB0by1zdXBwb3J0LWlzLXVuYXZhaWxhYmxlXG4vKiogQHR5cGUge2ltcG9ydCgnbm9kZTpjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cblxuaWYgKHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ2NyeXB0bycpKSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbiAgY29uc3QgY3J5cHRvSGFzaGVzID0gY3J5cHRvLmdldEhhc2hlcygpXG5cbiAgLy8gSWYgbm8gaGFzaGVzIGFyZSBhdmFpbGFibGUsIHdlIGNhbm5vdCBzdXBwb3J0IFNSSS5cbiAgaWYgKGNyeXB0b0hhc2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB2YWxpZFNSSUhhc2hBbGdvcml0aG1Ub2tlblNldC5jbGVhcigpXG4gIH1cblxuICBmb3IgKGNvbnN0IGFsZ29yaXRobSBvZiB2YWxpZFNSSUhhc2hBbGdvcml0aG1Ub2tlblNldC5rZXlzKCkpIHtcbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIG5vdCBzdXBwb3J0ZWQsIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0LlxuICAgIGlmIChjcnlwdG9IYXNoZXMuaW5jbHVkZXMoYWxnb3JpdGhtKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhbGlkU1JJSGFzaEFsZ29yaXRobVRva2VuU2V0LmRlbGV0ZShhbGdvcml0aG0pXG4gICAgfVxuICB9XG59IGVsc2Uge1xuICAvLyBJZiBjcnlwdG8gaXMgbm90IGF2YWlsYWJsZSwgd2UgY2Fubm90IHN1cHBvcnQgU1JJLlxuICB2YWxpZFNSSUhhc2hBbGdvcml0aG1Ub2tlblNldC5jbGVhcigpXG59XG5cbi8qKlxuICogQHR5cGVkZWYgR2V0U1JJSGFzaEFsZ29yaXRobUluZGV4XG4gKiBAdHlwZSB7KGFsZ29yaXRobTogU1JJSGFzaEFsZ29yaXRobSkgPT4gbnVtYmVyfVxuICogQHBhcmFtIHtTUklIYXNoQWxnb3JpdGhtfSBhbGdvcml0aG1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgYWxnb3JpdGhtIGluIHRoZSB2YWxpZCBTUkkgaGFzaCBhbGdvcml0aG1cbiAqIHRva2VuIHNldC5cbiAqL1xuXG5jb25zdCBnZXRTUklIYXNoQWxnb3JpdGhtSW5kZXggPSAvKiogQHR5cGUge0dldFNSSUhhc2hBbGdvcml0aG1JbmRleH0gKi8gKE1hcC5wcm90b3R5cGUuZ2V0LmJpbmQoXG4gIHZhbGlkU1JJSGFzaEFsZ29yaXRobVRva2VuU2V0KSlcblxuLyoqXG4gKiBAdHlwZWRlZiBJc1ZhbGlkU1JJSGFzaEFsZ29yaXRobVxuICogQHR5cGUgeyhhbGdvcml0aG06IHN0cmluZykgPT4gYWxnb3JpdGhtIGlzIFNSSUhhc2hBbGdvcml0aG19XG4gKiBAcGFyYW0geyp9IGFsZ29yaXRobVxuICogQHJldHVybnMge2FsZ29yaXRobSBpcyBTUklIYXNoQWxnb3JpdGhtfVxuICovXG5cbmNvbnN0IGlzVmFsaWRTUklIYXNoQWxnb3JpdGhtID0gLyoqIEB0eXBlIHtJc1ZhbGlkU1JJSGFzaEFsZ29yaXRobX0gKi8gKFxuICBNYXAucHJvdG90eXBlLmhhcy5iaW5kKHZhbGlkU1JJSGFzaEFsZ29yaXRobVRva2VuU2V0KVxuKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRhZGF0YUxpc3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICpcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKi9cbmNvbnN0IGJ5dGVzTWF0Y2ggPSBydW50aW1lRmVhdHVyZXMuaGFzKCdjcnlwdG8nKSA9PT0gZmFsc2UgfHwgdmFsaWRTUklIYXNoQWxnb3JpdGhtVG9rZW5TZXQuc2l6ZSA9PT0gMFxuICAvLyBJZiBub2RlIGlzIG5vdCBidWlsdCB3aXRoIE9wZW5TU0wgc3VwcG9ydCwgd2UgY2Fubm90IGNoZWNrXG4gIC8vIGEgcmVxdWVzdCdzIGludGVncml0eSwgc28gYWxsb3cgaXQgYnkgZGVmYXVsdCAodGhlIHNwZWMgd2lsbFxuICAvLyBhbGxvdyByZXF1ZXN0cyBpZiBhbiBpbnZhbGlkIGhhc2ggaXMgZ2l2ZW4sIGFzIHByZWNlZGVuY2UpLlxuICA/ICgpID0+IHRydWVcbiAgOiAoYnl0ZXMsIG1ldGFkYXRhTGlzdCkgPT4ge1xuICAgIC8vIDEuIExldCBwYXJzZWRNZXRhZGF0YSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgbWV0YWRhdGFMaXN0LlxuICAgICAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAgICAgLy8gMi4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgICAgIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IG1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyB0aGUgc3Ryb25nZXN0XG4gICAgICAvLyAgICBtZXRhZGF0YSBmcm9tIHBhcnNlZE1ldGFkYXRhLlxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdHJvbmdlc3RNZXRhZGF0YShwYXJzZWRNZXRhZGF0YSlcblxuICAgICAgLy8gNC4gRm9yIGVhY2ggaXRlbSBpbiBtZXRhZGF0YTpcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtZXRhZGF0YSkge1xuICAgICAgLy8gMS4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaXRlbVtcImFsZ1wiXS5cbiAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdcblxuICAgICAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgaXRlbVtcInZhbFwiXS5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IGl0ZW0udmFsXG5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcGxhdGZvcm0tdGVzdHMvd3B0L2NvbW1pdC9lNGM1Y2M3YTVlNDgwOTMyMjA1MjhkZmRkMWM0MDEyZGMzODM3YTBlXG4gICAgICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICAgICAgLy8gMy4gTGV0IGFjdHVhbFZhbHVlIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxnb3JpdGhtIHRvIGJ5dGVzIC5cbiAgICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBhcHBseUFsZ29yaXRobVRvQnl0ZXMoYWxnb3JpdGhtLCBieXRlcylcblxuICAgICAgICAvLyA0LiBJZiBhY3R1YWxWYWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciBleHBlY3RlZFZhbHVlLFxuICAgICAgICAvLyAgICByZXR1cm4gdHJ1ZS5cbiAgICAgICAgaWYgKGNhc2VTZW5zaXRpdmVNYXRjaChhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDUuIFJldHVybiBmYWxzZS5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuLyoqXG4gKiBAcGFyYW0ge01ldGFkYXRhTGlzdH0gbWV0YWRhdGFMaXN0XG4gKiBAcmV0dXJucyB7TWV0YWRhdGFMaXN0fSBUaGUgc3Ryb25nZXN0IGhhc2ggYWxnb3JpdGhtIGZyb20gdGhlIG1ldGFkYXRhIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cm9uZ2VzdE1ldGFkYXRhIChtZXRhZGF0YUxpc3QpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0IGFuZCBzdHJvbmdlc3QgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgLyoqIEB0eXBlIHtNZXRhZGF0YXxudWxsfSAqL1xuICBsZXQgc3Ryb25nZXN0ID0gbnVsbFxuXG4gIC8vIDIuIEZvciBlYWNoIGl0ZW0gaW4gc2V0OlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGFMaXN0KSB7XG4gICAgLy8gMS4gQXNzZXJ0OiBpdGVtW1wiYWxnXCJdIGlzIGEgdmFsaWQgU1JJIGhhc2ggYWxnb3JpdGhtIHRva2VuLlxuICAgIGFzc2VydChpc1ZhbGlkU1JJSGFzaEFsZ29yaXRobShpdGVtLmFsZyksICdJbnZhbGlkIFNSSSBoYXNoIGFsZ29yaXRobSB0b2tlbicpXG5cbiAgICAvLyAyLiBJZiByZXN1bHQgaXMgdGhlIGVtcHR5IHNldCwgdGhlbjpcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gMS4gQXBwZW5kIGl0ZW0gdG8gcmVzdWx0LlxuICAgICAgcmVzdWx0LnB1c2goaXRlbSlcblxuICAgICAgLy8gMi4gU2V0IHN0cm9uZ2VzdCB0byBpdGVtLlxuICAgICAgc3Ryb25nZXN0ID0gaXRlbVxuXG4gICAgICAvLyAzLiBDb250aW51ZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGN1cnJlbnRBbGdvcml0aG0gYmUgc3Ryb25nZXN0W1wiYWxnXCJdLCBhbmQgY3VycmVudEFsZ29yaXRobUluZGV4IGJlXG4gICAgLy8gdGhlIGluZGV4IG9mIGN1cnJlbnRBbGdvcml0aG0gaW4gdGhlIHZhbGlkIFNSSSBoYXNoIGFsZ29yaXRobSB0b2tlbiBzZXQuXG4gICAgY29uc3QgY3VycmVudEFsZ29yaXRobSA9IC8qKiBAdHlwZSB7TWV0YWRhdGF9ICovIChzdHJvbmdlc3QpLmFsZ1xuICAgIGNvbnN0IGN1cnJlbnRBbGdvcml0aG1JbmRleCA9IGdldFNSSUhhc2hBbGdvcml0aG1JbmRleChjdXJyZW50QWxnb3JpdGhtKVxuXG4gICAgLy8gNC4gTGV0IG5ld0FsZ29yaXRobSBiZSB0aGUgaXRlbVtcImFsZ1wiXSwgYW5kIG5ld0FsZ29yaXRobUluZGV4IGJlIHRoZVxuICAgIC8vIGluZGV4IG9mIG5ld0FsZ29yaXRobSBpbiB0aGUgdmFsaWQgU1JJIGhhc2ggYWxnb3JpdGhtIHRva2VuIHNldC5cbiAgICBjb25zdCBuZXdBbGdvcml0aG0gPSBpdGVtLmFsZ1xuICAgIGNvbnN0IG5ld0FsZ29yaXRobUluZGV4ID0gZ2V0U1JJSGFzaEFsZ29yaXRobUluZGV4KG5ld0FsZ29yaXRobSlcblxuICAgIC8vIDUuIElmIG5ld0FsZ29yaXRobUluZGV4IGlzIGxlc3MgdGhhbiBjdXJyZW50QWxnb3JpdGhtSW5kZXgsIHRoZW4gY29udGludWUuXG4gICAgaWYgKG5ld0FsZ29yaXRobUluZGV4IDwgY3VycmVudEFsZ29yaXRobUluZGV4KSB7XG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiBuZXdBbGdvcml0aG1JbmRleCBpcyBncmVhdGVyIHRoYW5cbiAgICAvLyBjdXJyZW50QWxnb3JpdGhtSW5kZXg6XG4gICAgfSBlbHNlIGlmIChuZXdBbGdvcml0aG1JbmRleCA+IGN1cnJlbnRBbGdvcml0aG1JbmRleCkge1xuICAgICAgLy8gMS4gU2V0IHN0cm9uZ2VzdCB0byBpdGVtLlxuICAgICAgc3Ryb25nZXN0ID0gaXRlbVxuXG4gICAgICAvLyAyLiBTZXQgcmVzdWx0IHRvIMKrIGl0ZW0gwrsuXG4gICAgICByZXN1bHRbMF0gPSBpdGVtXG4gICAgICByZXN1bHQubGVuZ3RoID0gMVxuXG4gICAgLy8gNy4gT3RoZXJ3aXNlLCBuZXdBbGdvcml0aG1JbmRleCBhbmQgY3VycmVudEFsZ29yaXRobUluZGV4IGFyZSB0aGUgc2FtZVxuICAgIC8vIHZhbHVlLiBBcHBlbmQgaXRlbSB0byByZXN1bHQuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRhZGF0YVxuICogQHJldHVybnMge01ldGFkYXRhTGlzdH1cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNwYXJzZS1tZXRhZGF0YVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGFkYXRhIChtZXRhZGF0YSkge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlIHRoZSBlbXB0eSBzZXQuXG4gIC8qKiBAdHlwZSB7TWV0YWRhdGFMaXN0fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIEZvciBlYWNoIGl0ZW0gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCBpdGVtIG9mIG1ldGFkYXRhLnNwbGl0KCcgJykpIHtcbiAgICAvLyAxLiBMZXQgZXhwcmVzc2lvbi1hbmQtb3B0aW9ucyBiZSB0aGUgcmVzdWx0IG9mIHNwbGl0dGluZyBpdGVtIG9uIFUrMDAzRiAoPykuXG4gICAgY29uc3QgZXhwcmVzc2lvbkFuZE9wdGlvbnMgPSBpdGVtLnNwbGl0KCc/JywgMSlcblxuICAgIC8vIDIuIExldCBhbGdvcml0aG0tZXhwcmVzc2lvbiBiZSBleHByZXNzaW9uLWFuZC1vcHRpb25zWzBdLlxuICAgIGNvbnN0IGFsZ29yaXRobUV4cHJlc3Npb24gPSBleHByZXNzaW9uQW5kT3B0aW9uc1swXVxuXG4gICAgLy8gMy4gTGV0IGJhc2U2NC12YWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGxldCBiYXNlNjRWYWx1ZSA9ICcnXG5cbiAgICAvLyA0LiBMZXQgYWxnb3JpdGhtLWFuZC12YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIHNwbGl0dGluZyBhbGdvcml0aG0tZXhwcmVzc2lvbiBvbiBVKzAwMkQgKC0pLlxuICAgIGNvbnN0IGFsZ29yaXRobUFuZFZhbHVlID0gW2FsZ29yaXRobUV4cHJlc3Npb24uc2xpY2UoMCwgNiksIGFsZ29yaXRobUV4cHJlc3Npb24uc2xpY2UoNyldXG5cbiAgICAvLyA1LiBMZXQgYWxnb3JpdGhtIGJlIGFsZ29yaXRobS1hbmQtdmFsdWVbMF0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gYWxnb3JpdGhtQW5kVmFsdWVbMF1cblxuICAgIC8vIDYuIElmIGFsZ29yaXRobSBpcyBub3QgYSB2YWxpZCBTUkkgaGFzaCBhbGdvcml0aG0gdG9rZW4sIHRoZW4gY29udGludWUuXG4gICAgaWYgKCFpc1ZhbGlkU1JJSGFzaEFsZ29yaXRobShhbGdvcml0aG0pKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDcuIElmIGFsZ29yaXRobS1hbmQtdmFsdWVbMV0gZXhpc3RzLCBzZXQgYmFzZTY0LXZhbHVlIHRvXG4gICAgLy8gYWxnb3JpdGhtLWFuZC12YWx1ZVsxXS5cbiAgICBpZiAoYWxnb3JpdGhtQW5kVmFsdWVbMV0pIHtcbiAgICAgIGJhc2U2NFZhbHVlID0gYWxnb3JpdGhtQW5kVmFsdWVbMV1cbiAgICB9XG5cbiAgICAvLyA4LiBMZXQgbWV0YWRhdGEgYmUgdGhlIG9yZGVyZWQgbWFwXG4gICAgLy8gwqtbXCJhbGdcIiDihpIgYWxnb3JpdGhtLCBcInZhbFwiIOKGkiBiYXNlNjQtdmFsdWVdwrsuXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICBhbGc6IGFsZ29yaXRobSxcbiAgICAgIHZhbDogYmFzZTY0VmFsdWVcbiAgICB9XG5cbiAgICAvLyA5LiBBcHBlbmQgbWV0YWRhdGEgdG8gcmVzdWx0LlxuICAgIHJlc3VsdC5wdXNoKG1ldGFkYXRhKVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHNwZWNpZmllZCBoYXNoIGFsZ29yaXRobSB0byB0aGUgZ2l2ZW4gYnl0ZXNcbiAqXG4gKiBAdHlwZWRlZiB7KGFsZ29yaXRobTogU1JJSGFzaEFsZ29yaXRobSwgYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IHN0cmluZ30gQXBwbHlBbGdvcml0aG1Ub0J5dGVzXG4gKiBAcGFyYW0ge1NSSUhhc2hBbGdvcml0aG19IGFsZ29yaXRobVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgYXBwbHlBbGdvcml0aG1Ub0J5dGVzID0gKGFsZ29yaXRobSwgYnl0ZXMpID0+IHtcbiAgcmV0dXJuIGNyeXB0by5oYXNoKGFsZ29yaXRobSwgYnl0ZXMsICdiYXNlNjQnKVxufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBiYXNlNjQgc3RyaW5ncywgYWxsb3dpbmcgZm9yIGJhc2U2NHVybFxuICogaW4gdGhlIHNlY29uZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFZhbHVlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkVmFsdWUgYmFzZTY0IG9yIGJhc2U2NHVybCBlbmNvZGVkIHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNhc2VTZW5zaXRpdmVNYXRjaCAoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpIHtcbiAgLy8gSWdub3JlIHBhZGRpbmcgY2hhcmFjdGVycyBmcm9tIHRoZSBlbmQgb2YgdGhlIHN0cmluZ3MgYnlcbiAgLy8gZGVjcmVhc2luZyB0aGUgbGVuZ3RoIGJ5IDEgb3IgMiBpZiB0aGUgbGFzdCBjaGFyYWN0ZXJzIGFyZSBgPWAuXG4gIGxldCBhY3R1YWxWYWx1ZUxlbmd0aCA9IGFjdHVhbFZhbHVlLmxlbmd0aFxuICBpZiAoYWN0dWFsVmFsdWVMZW5ndGggIT09IDAgJiYgYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWVMZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgYWN0dWFsVmFsdWVMZW5ndGggLT0gMVxuICB9XG4gIGlmIChhY3R1YWxWYWx1ZUxlbmd0aCAhPT0gMCAmJiBhY3R1YWxWYWx1ZVthY3R1YWxWYWx1ZUxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICBhY3R1YWxWYWx1ZUxlbmd0aCAtPSAxXG4gIH1cbiAgbGV0IGV4cGVjdGVkVmFsdWVMZW5ndGggPSBleHBlY3RlZFZhbHVlLmxlbmd0aFxuICBpZiAoZXhwZWN0ZWRWYWx1ZUxlbmd0aCAhPT0gMCAmJiBleHBlY3RlZFZhbHVlW2V4cGVjdGVkVmFsdWVMZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgZXhwZWN0ZWRWYWx1ZUxlbmd0aCAtPSAxXG4gIH1cbiAgaWYgKGV4cGVjdGVkVmFsdWVMZW5ndGggIT09IDAgJiYgZXhwZWN0ZWRWYWx1ZVtleHBlY3RlZFZhbHVlTGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgIGV4cGVjdGVkVmFsdWVMZW5ndGggLT0gMVxuICB9XG5cbiAgaWYgKGFjdHVhbFZhbHVlTGVuZ3RoICE9PSBleHBlY3RlZFZhbHVlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdHVhbFZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoXG4gICAgICBhY3R1YWxWYWx1ZVtpXSA9PT0gZXhwZWN0ZWRWYWx1ZVtpXSB8fFxuICAgICAgKGFjdHVhbFZhbHVlW2ldID09PSAnKycgJiYgZXhwZWN0ZWRWYWx1ZVtpXSA9PT0gJy0nKSB8fFxuICAgICAgKGFjdHVhbFZhbHVlW2ldID09PSAnLycgJiYgZXhwZWN0ZWRWYWx1ZVtpXSA9PT0gJ18nKVxuICAgICkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbHlBbGdvcml0aG1Ub0J5dGVzLFxuICBieXRlc01hdGNoLFxuICBjYXNlU2Vuc2l0aXZlTWF0Y2gsXG4gIGlzVmFsaWRTUklIYXNoQWxnb3JpdGhtLFxuICBnZXRTdHJvbmdlc3RNZXRhZGF0YSxcbiAgcGFyc2VNZXRhZGF0YVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/webidl/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/webidl/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\nconst UNDEFINED = 1\nconst BOOLEAN = 2\nconst STRING = 3\nconst SYMBOL = 4\nconst NUMBER = 5\nconst BIGINT = 6\nconst NULL = 7\nconst OBJECT = 8 // function and object\n\nconst FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance])\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {\n  converters: {},\n  util: {},\n  errors: {},\n  is: {}\n}\n\n/**\n * @description Instantiate an error.\n *\n * @param {Object} opts\n * @param {string} opts.header\n * @param {string} opts.message\n * @returns {TypeError}\n */\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\n/**\n * @description Instantiate an error when conversion from one type to another has failed.\n *\n * @param {Object} opts\n * @param {string} opts.prefix\n * @param {string} opts.argument\n * @param {string[]} opts.types\n * @returns {TypeError}\n */\nwebidl.errors.conversionFailed = function (opts) {\n  const plural = opts.types.length === 1 ? '' : ' one of'\n  const message =\n    `${opts.argument} could not be converted to` +\n    `${plural}: ${opts.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: opts.prefix,\n    message\n  })\n}\n\n/**\n * @description Instantiate an error when an invalid argument is provided\n *\n * @param {Object} context\n * @param {string} context.prefix\n * @param {string} context.value\n * @param {string} context.type\n * @returns {TypeError}\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I) {\n  if (!FunctionPrototypeSymbolHasInstance(I, V)) {\n    const err = new TypeError('Illegal invocation')\n    err.code = 'ERR_INVALID_THIS' // node compat.\n    throw err\n  }\n}\n\nwebidl.brandCheckMultiple = function (List) {\n  const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c))\n\n  return (V) => {\n    if (prototypes.every(typeCheck => !typeCheck(V))) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\nwebidl.util.MakeTypeAssertion = function (I) {\n  return (O) => FunctionPrototypeSymbolHasInstance(I, O)\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return UNDEFINED\n    case 'boolean': return BOOLEAN\n    case 'string': return STRING\n    case 'symbol': return SYMBOL\n    case 'number': return NUMBER\n    case 'bigint': return BIGINT\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return NULL\n      }\n\n      return OBJECT\n    }\n  }\n}\n\nwebidl.util.Types = {\n  UNDEFINED,\n  BOOLEAN,\n  STRING,\n  SYMBOL,\n  NUMBER,\n  BIGINT,\n  NULL,\n  OBJECT\n}\n\nwebidl.util.TypeValueToString = function (o) {\n  switch (webidl.util.Type(o)) {\n    case UNDEFINED: return 'Undefined'\n    case BOOLEAN: return 'Boolean'\n    case STRING: return 'String'\n    case SYMBOL: return 'Symbol'\n    case NUMBER: return 'Number'\n    case BIGINT: return 'BigInt'\n    case NULL: return 'Null'\n    case OBJECT: return 'Object'\n  }\n}\n\nwebidl.util.markAsUncloneable = runtimeFeatures.has('markAsUncloneable')\n  ? (__webpack_require__(/*! node:worker_threads */ \"node:worker_threads\").markAsUncloneable)\n  : () => {}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, flags) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53  1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be 2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength  1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength  1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength  1  1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is 0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (webidl.util.HasFlag(flags, webidl.attributes.EnforceRange)) {\n    // 1. If x is NaN, +, or , then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && webidl.util.HasFlag(flags, webidl.attributes.Clamp)) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than 0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +, or , then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x  2^bitLength  1,\n  //    then return x  2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1  r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case SYMBOL:\n      return `Symbol(${V.description})`\n    case OBJECT:\n      return inspect(V)\n    case STRING:\n      return `\"${V}\"`\n    case BIGINT:\n      return `${V}n`\n    default:\n      return `${V}`\n  }\n}\n\nwebidl.util.IsResizableArrayBuffer = function (V) {\n  if (types.isArrayBuffer(V)) {\n    return V.resizable\n  }\n\n  if (types.isSharedArrayBuffer(V)) {\n    return V.growable\n  }\n\n  throw webidl.errors.exception({\n    header: 'IsResizableArrayBuffer',\n    message: `\"${webidl.util.Stringify(V)}\" is not an array buffer.`\n  })\n}\n\nwebidl.util.HasFlag = function (flags, attributes) {\n  return typeof flags === 'number' && (flags & attributes) === attributes\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.TypeValueToString(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        const keyName = webidl.util.Stringify(key)\n\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (TypeCheck, name) {\n  return (V, prefix, argument) => {\n    if (!TypeCheck(V)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const dict = {}\n\n    if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (dictionary == null || !Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary?.[key]\n      const hasDefault = defaultValue !== undefined\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value === undefined) {\n        value = defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nwebidl.is.USVString = function (value) {\n  return (\n    typeof value === 'string' &&\n    value.isWellFormed()\n  )\n}\n\nwebidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream)\nwebidl.is.Blob = webidl.util.MakeTypeAssertion(Blob)\nwebidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams)\nwebidl.is.File = webidl.util.MakeTypeAssertion(File)\nwebidl.is.URL = webidl.util.MakeTypeAssertion(URL)\nwebidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal)\nwebidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort)\n\nwebidl.is.BufferSource = function (V) {\n  return types.isArrayBuffer(V) || (\n    ArrayBuffer.isView(V) &&\n    types.isArrayBuffer(V.buffer)\n  )\n}\n\n// https://webidl.spec.whatwg.org/#dfn-get-buffer-source-copy\nwebidl.util.getCopyOfBytesHeldByBufferSource = function (bufferSource) {\n  // 1. Let jsBufferSource be the result of converting bufferSource to a JavaScript value.\n  const jsBufferSource = bufferSource\n\n  // 2. Let jsArrayBuffer be jsBufferSource.\n  let jsArrayBuffer = jsBufferSource\n\n  // 3. Let offset be 0.\n  let offset = 0\n\n  // 4. Let length be 0.\n  let length = 0\n\n  // 5. If jsBufferSource has a [[ViewedArrayBuffer]] internal slot, then:\n  if (types.isTypedArray(jsBufferSource) || types.isDataView(jsBufferSource)) {\n    // 5.1. Set jsArrayBuffer to jsBufferSource.[[ViewedArrayBuffer]].\n    jsArrayBuffer = jsBufferSource.buffer\n\n    // 5.2. Set offset to jsBufferSource.[[ByteOffset]].\n    offset = jsBufferSource.byteOffset\n\n    // 5.3. Set length to jsBufferSource.[[ByteLength]].\n    length = jsBufferSource.byteLength\n  } else {\n    // 6. Otherwise:\n\n    // 6.1. Assert: jsBufferSource is an ArrayBuffer or SharedArrayBuffer object.\n    assert(types.isAnyArrayBuffer(jsBufferSource))\n\n    // 6.2. Set length to jsBufferSource.[[ArrayBufferByteLength]].\n    length = jsBufferSource.byteLength\n  }\n\n  // 7. If IsDetachedBuffer(jsArrayBuffer) is true, then return the empty byte sequence.\n  if (jsArrayBuffer.detached) {\n    return new Uint8Array(0)\n  }\n\n  // 8. Let bytes be a new byte sequence of length equal to length.\n  const bytes = new Uint8Array(length)\n\n  // 9. For i in the range offset to offset + length  1, inclusive,\n  //    set bytes[i  offset] to GetValueFromBuffer(jsArrayBuffer, i, Uint8, true, Unordered).\n  const view = new Uint8Array(jsArrayBuffer, offset, length)\n  bytes.set(view)\n\n  // 10. Return bytes.\n  return bytes\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, flags) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && webidl.util.HasFlag(flags, webidl.attributes.LegacyNullToEmptyString)) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a ByteString.`\n    })\n  }\n\n  const x = String(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n * @see https://webidl.spec.whatwg.org/#es-USVString\n */\nwebidl.converters.USVString = function (value) {\n  // TODO: rewrite this so we can control the errors thrown\n  if (typeof value === 'string') {\n    return value.toWellFormed()\n  }\n  return `${value}`.toWellFormed()\n}\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  // https://262.ecma-international.org/10.0/index.html#table-10\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', 0, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', 0, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', 0, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, flags) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', flags, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, flags) {\n  // 1. If V is not an Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // 2. If IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a resizable ArrayBuffer.`\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#idl-SharedArrayBuffer\nwebidl.converters.SharedArrayBuffer = function (V, prefix, argument, flags) {\n  // 1. If V is not an Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // 2. If IsSharedArrayBuffer(V) is false, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isSharedArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['SharedArrayBuffer']\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a resizable SharedArrayBuffer.`\n    })\n  }\n\n  // 4. Return the IDL SharedArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#dfn-typed-array-type\nwebidl.converters.TypedArray = function (V, T, prefix, argument, flags) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to Ts name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#idl-DataView\nwebidl.converters.DataView = function (V, prefix, argument, flags) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['DataView']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#ArrayBufferView\nwebidl.converters.ArrayBufferView = function (V, prefix, argument, flags) {\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isArrayBufferView(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBufferView']\n    })\n  }\n\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, argument, flags) {\n  if (types.isArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isArrayBufferView(V)) {\n    flags &= ~webidl.attributes.AllowShared\n\n    return webidl.converters.ArrayBufferView(V, prefix, argument, flags)\n  }\n\n  // Make this explicit for easier debugging\n  if (types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a SharedArrayBuffer.`\n    })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['ArrayBuffer', 'ArrayBufferView']\n  })\n}\n\n// https://webidl.spec.whatwg.org/#AllowSharedBufferSource\nwebidl.converters.AllowSharedBufferSource = function (V, prefix, argument, flags) {\n  if (types.isArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isSharedArrayBuffer(V)) {\n    return webidl.converters.SharedArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isArrayBufferView(V)) {\n    flags |= webidl.attributes.AllowShared\n    return webidl.converters.ArrayBufferView(V, prefix, argument, flags)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['ArrayBuffer', 'SharedArrayBuffer', 'ArrayBufferView']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nwebidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, 'Blob')\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  webidl.is.AbortSignal,\n  'AbortSignal'\n)\n\n/**\n * [LegacyTreatNonObjectAsNull]\n * callback EventHandlerNonNull = any (Event event);\n * typedef EventHandlerNonNull? EventHandler;\n * @param {*} V\n */\nwebidl.converters.EventHandlerNonNull = function (V) {\n  if (webidl.util.Type(V) !== OBJECT) {\n    return null\n  }\n\n  // [I]f the value is not an object, it will be converted to null, and if the value is not callable,\n  // it will be converted to a callback function value that does nothing when called.\n  if (typeof V === 'function') {\n    return V\n  }\n\n  return () => {}\n}\n\nwebidl.attributes = {\n  Clamp: 1 << 0,\n  EnforceRange: 1 << 1,\n  AllowShared: 1 << 2,\n  AllowResizable: 1 << 3,\n  LegacyNullToEmptyString: 1 << 4\n}\n\nmodule.exports = {\n  webidl\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2ViaWRsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDOUMsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDZGQUE2Qjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLHdDQUF3QztBQUNuRDtBQUNBLGdCQUFnQjtBQUNoQixVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxJQUFJLGdCQUFnQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCLE9BQU8sT0FBTyxJQUFJLHNCQUFzQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxrQkFBa0IsYUFBYTtBQUM5RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLElBQUkseUJBQXlCO0FBQzFEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLElBQUkseUJBQXlCO0FBQzFEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVUsSUFBSSx5QkFBeUI7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLElBQUkseUJBQXlCO0FBQzFEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsSUFBSSx5QkFBeUI7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixVQUFVLElBQUkseUJBQXlCO0FBQ3hEO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYmlkbFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgdHlwZXMsIGluc3BlY3QgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IHJ1bnRpbWVGZWF0dXJlcyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ydW50aW1lLWZlYXR1cmVzJylcblxuY29uc3QgVU5ERUZJTkVEID0gMVxuY29uc3QgQk9PTEVBTiA9IDJcbmNvbnN0IFNUUklORyA9IDNcbmNvbnN0IFNZTUJPTCA9IDRcbmNvbnN0IE5VTUJFUiA9IDVcbmNvbnN0IEJJR0lOVCA9IDZcbmNvbnN0IE5VTEwgPSA3XG5jb25zdCBPQkpFQ1QgPSA4IC8vIGZ1bmN0aW9uIGFuZCBvYmplY3RcblxuY29uc3QgRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLmNhbGwuYmluZChGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSlcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uLy4uL3R5cGVzL3dlYmlkbCcpLldlYmlkbH0gKi9cbmNvbnN0IHdlYmlkbCA9IHtcbiAgY29udmVydGVyczoge30sXG4gIHV0aWw6IHt9LFxuICBlcnJvcnM6IHt9LFxuICBpczoge31cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gSW5zdGFudGlhdGUgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmhlYWRlclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubWVzc2FnZVxuICogQHJldHVybnMge1R5cGVFcnJvcn1cbiAqL1xud2ViaWRsLmVycm9ycy5leGNlcHRpb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgJHttZXNzYWdlLmhlYWRlcn06ICR7bWVzc2FnZS5tZXNzYWdlfWApXG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEluc3RhbnRpYXRlIGFuIGVycm9yIHdoZW4gY29udmVyc2lvbiBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5hcmd1bWVudFxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0cy50eXBlc1xuICogQHJldHVybnMge1R5cGVFcnJvcn1cbiAqL1xud2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgY29uc3QgcGx1cmFsID0gb3B0cy50eXBlcy5sZW5ndGggPT09IDEgPyAnJyA6ICcgb25lIG9mJ1xuICBjb25zdCBtZXNzYWdlID1cbiAgICBgJHtvcHRzLmFyZ3VtZW50fSBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvYCArXG4gICAgYCR7cGx1cmFsfTogJHtvcHRzLnR5cGVzLmpvaW4oJywgJyl9LmBcblxuICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogb3B0cy5wcmVmaXgsXG4gICAgbWVzc2FnZVxuICB9KVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBJbnN0YW50aWF0ZSBhbiBlcnJvciB3aGVuIGFuIGludmFsaWQgYXJndW1lbnQgaXMgcHJvdmlkZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQucHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC52YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQudHlwZVxuICogQHJldHVybnMge1R5cGVFcnJvcn1cbiAqL1xud2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogY29udGV4dC5wcmVmaXgsXG4gICAgbWVzc2FnZTogYFwiJHtjb250ZXh0LnZhbHVlfVwiIGlzIGFuIGludmFsaWQgJHtjb250ZXh0LnR5cGV9LmBcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpbXBsZW1lbnRzXG53ZWJpZGwuYnJhbmRDaGVjayA9IGZ1bmN0aW9uIChWLCBJKSB7XG4gIGlmICghRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZShJLCBWKSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfVEhJUycgLy8gbm9kZSBjb21wYXQuXG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxud2ViaWRsLmJyYW5kQ2hlY2tNdWx0aXBsZSA9IGZ1bmN0aW9uIChMaXN0KSB7XG4gIGNvbnN0IHByb3RvdHlwZXMgPSBMaXN0Lm1hcCgoYykgPT4gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oYykpXG5cbiAgcmV0dXJuIChWKSA9PiB7XG4gICAgaWYgKHByb3RvdHlwZXMuZXZlcnkodHlwZUNoZWNrID0+ICF0eXBlQ2hlY2soVikpKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGludm9jYXRpb24nKVxuICAgICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfVEhJUycgLy8gbm9kZSBjb21wYXQuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxud2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2sgPSBmdW5jdGlvbiAoeyBsZW5ndGggfSwgbWluLCBjdHgpIHtcbiAgaWYgKGxlbmd0aCA8IG1pbikge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIG1lc3NhZ2U6IGAke21pbn0gYXJndW1lbnQke21pbiAhPT0gMSA/ICdzJyA6ICcnfSByZXF1aXJlZCwgYCArXG4gICAgICAgICAgICAgICBgYnV0JHtsZW5ndGggPyAnIG9ubHknIDogJyd9ICR7bGVuZ3RofSBmb3VuZC5gLFxuICAgICAgaGVhZGVyOiBjdHhcbiAgICB9KVxuICB9XG59XG5cbndlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6ICdUeXBlRXJyb3InLFxuICAgIG1lc3NhZ2U6ICdJbGxlZ2FsIGNvbnN0cnVjdG9yJ1xuICB9KVxufVxuXG53ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbiA9IGZ1bmN0aW9uIChJKSB7XG4gIHJldHVybiAoTykgPT4gRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZShJLCBPKVxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXG53ZWJpZGwudXRpbC5UeXBlID0gZnVuY3Rpb24gKFYpIHtcbiAgc3dpdGNoICh0eXBlb2YgVikge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiBVTkRFRklORURcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIEJPT0xFQU5cbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gU1RSSU5HXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuIFNZTUJPTFxuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBOVU1CRVJcbiAgICBjYXNlICdiaWdpbnQnOiByZXR1cm4gQklHSU5UXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBOVUxMXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPQkpFQ1RcbiAgICB9XG4gIH1cbn1cblxud2ViaWRsLnV0aWwuVHlwZXMgPSB7XG4gIFVOREVGSU5FRCxcbiAgQk9PTEVBTixcbiAgU1RSSU5HLFxuICBTWU1CT0wsXG4gIE5VTUJFUixcbiAgQklHSU5ULFxuICBOVUxMLFxuICBPQkpFQ1Rcbn1cblxud2ViaWRsLnV0aWwuVHlwZVZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbiAobykge1xuICBzd2l0Y2ggKHdlYmlkbC51dGlsLlR5cGUobykpIHtcbiAgICBjYXNlIFVOREVGSU5FRDogcmV0dXJuICdVbmRlZmluZWQnXG4gICAgY2FzZSBCT09MRUFOOiByZXR1cm4gJ0Jvb2xlYW4nXG4gICAgY2FzZSBTVFJJTkc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgU1lNQk9MOiByZXR1cm4gJ1N5bWJvbCdcbiAgICBjYXNlIE5VTUJFUjogcmV0dXJuICdOdW1iZXInXG4gICAgY2FzZSBCSUdJTlQ6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgTlVMTDogcmV0dXJuICdOdWxsJ1xuICAgIGNhc2UgT0JKRUNUOiByZXR1cm4gJ09iamVjdCdcbiAgfVxufVxuXG53ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSA9IHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ21hcmtBc1VuY2xvbmVhYmxlJylcbiAgPyByZXF1aXJlKCdub2RlOndvcmtlcl90aHJlYWRzJykubWFya0FzVW5jbG9uZWFibGVcbiAgOiAoKSA9PiB7fVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgZmxhZ3MpIHtcbiAgbGV0IHVwcGVyQm91bmRcbiAgbGV0IGxvd2VyQm91bmRcblxuICAvLyAxLiBJZiBiaXRMZW5ndGggaXMgNjQsIHRoZW46XG4gIGlmIChiaXRMZW5ndGggPT09IDY0KSB7XG4gICAgLy8gMS4gTGV0IHVwcGVyQm91bmQgYmUgMl41MyDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG4gICAgLy8gMi4gSWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW4gbGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgbG93ZXJCb3VuZCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlIGxldCBsb3dlckJvdW5kIGJlIOKIkjJeNTMgKyAxLlxuICAgICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCA1MykgKyAxXG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBsb3dlckJvdW5kID0gMFxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgLTJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgYml0TGVuZ3RoKSAtIDFcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKSAtIDFcbiAgfVxuXG4gIC8vIDQuIExldCB4IGJlID8gVG9OdW1iZXIoVikuXG4gIGxldCB4ID0gTnVtYmVyKFYpXG5cbiAgLy8gNS4gSWYgeCBpcyDiiJIwLCB0aGVuIHNldCB4IHRvICswLlxuICBpZiAoeCA9PT0gMCkge1xuICAgIHggPSAwXG4gIH1cblxuICAvLyA2LiBJZiB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtFbmZvcmNlUmFuZ2VdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKHdlYmlkbC51dGlsLkhhc0ZsYWcoZmxhZ3MsIHdlYmlkbC5hdHRyaWJ1dGVzLkVuZm9yY2VSYW5nZSkpIHtcbiAgICAvLyAxLiBJZiB4IGlzIE5hTiwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnSW50ZWdlciBjb252ZXJzaW9uJyxcbiAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBjb252ZXJ0ICR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfSB0byBhbiBpbnRlZ2VyLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHggdG8gSW50ZWdlclBhcnQoeCkuXG4gICAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgICAvLyAzLiBJZiB4IDwgbG93ZXJCb3VuZCBvciB4ID4gdXBwZXJCb3VuZCwgdGhlblxuICAgIC8vICAgIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgVmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7bG93ZXJCb3VuZH0tJHt1cHBlckJvdW5kfSwgZ290ICR7eH0uYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4geC5cbiAgICByZXR1cm4geFxuICB9XG5cbiAgLy8gNy4gSWYgeCBpcyBub3QgTmFOIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJRExcbiAgLy8gICAgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIFtDbGFtcF0gZXh0ZW5kZWRcbiAgLy8gICAgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAoIU51bWJlci5pc05hTih4KSAmJiB3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5DbGFtcCkpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG53ZWJpZGwudXRpbC5TdHJpbmdpZnkgPSBmdW5jdGlvbiAoVikge1xuICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShWKVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU1lNQk9MOlxuICAgICAgcmV0dXJuIGBTeW1ib2woJHtWLmRlc2NyaXB0aW9ufSlgXG4gICAgY2FzZSBPQkpFQ1Q6XG4gICAgICByZXR1cm4gaW5zcGVjdChWKVxuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgcmV0dXJuIGBcIiR7Vn1cImBcbiAgICBjYXNlIEJJR0lOVDpcbiAgICAgIHJldHVybiBgJHtWfW5gXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgJHtWfWBcbiAgfVxufVxuXG53ZWJpZGwudXRpbC5Jc1Jlc2l6YWJsZUFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoVikpIHtcbiAgICByZXR1cm4gVi5yZXNpemFibGVcbiAgfVxuXG4gIGlmICh0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIFYuZ3Jvd2FibGVcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6ICdJc1Jlc2l6YWJsZUFycmF5QnVmZmVyJyxcbiAgICBtZXNzYWdlOiBgXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIiBpcyBub3QgYW4gYXJyYXkgYnVmZmVyLmBcbiAgfSlcbn1cblxud2ViaWRsLnV0aWwuSGFzRmxhZyA9IGZ1bmN0aW9uIChmbGFncywgYXR0cmlidXRlcykge1xuICByZXR1cm4gdHlwZW9mIGZsYWdzID09PSAnbnVtYmVyJyAmJiAoZmxhZ3MgJiBhdHRyaWJ1dGVzKSA9PT0gYXR0cmlidXRlc1xufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXNlcXVlbmNlXG53ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCwgSXRlcmFibGUpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBPQkpFQ1QpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSAoJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9KSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgbWV0aG9kIGJlID8gR2V0TWV0aG9kKFYsIEBAaXRlcmF0b3IpLlxuICAgIC8qKiBAdHlwZSB7R2VuZXJhdG9yfSAqL1xuICAgIGNvbnN0IG1ldGhvZCA9IHR5cGVvZiBJdGVyYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IEl0ZXJhYmxlKCkgOiBWPy5bU3ltYm9sLml0ZXJhdG9yXT8uKClcbiAgICBjb25zdCBzZXEgPSBbXVxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDMuIElmIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIG1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0eXBlb2YgbWV0aG9kLm5leHQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1zZXF1ZW5jZS1mcm9tLWl0ZXJhYmxlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IG1ldGhvZC5uZXh0KClcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgc2VxLnB1c2goY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fVske2luZGV4Kyt9XWApKVxuICAgIH1cblxuICAgIHJldHVybiBzZXFcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXRvLXJlY29yZFxud2ViaWRsLnJlY29yZENvbnZlcnRlciA9IGZ1bmN0aW9uIChrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gIHJldHVybiAoTywgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoTykgIT09IE9CSkVDVCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuVHlwZVZhbHVlVG9TdHJpbmcoTyl9XCIpIGlzIG5vdCBhbiBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIGEgbmV3IGVtcHR5IGluc3RhbmNlIG9mIHJlY29yZDxLLCBWPi5cbiAgICBjb25zdCByZXN1bHQgPSB7fVxuXG4gICAgaWYgKCF0eXBlcy5pc1Byb3h5KE8pKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU5hbWUgPSB3ZWJpZGwudXRpbC5TdHJpbmdpZnkoa2V5KVxuXG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBgS2V5ICR7a2V5TmFtZX0gaW4gJHthcmd1bWVudH1gKVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSwgcHJlZml4LCBgJHthcmd1bWVudH1bJHtrZXlOYW1lfV1gKVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGtleXMgYmUgPyBPLltbT3duUHJvcGVydHlLZXlzXV0oKS5cbiAgICBjb25zdCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKE8pXG5cbiAgICAvLyA0LiBGb3IgZWFjaCBrZXkgb2Yga2V5cy5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5KVxuXG4gICAgICAvLyAyLiBJZiBkZXNjIGlzIG5vdCB1bmRlZmluZWQgYW5kIGRlc2MuW1tFbnVtZXJhYmxlXV0gaXMgdHJ1ZTpcbiAgICAgIGlmIChkZXNjPy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0sIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG53ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyID0gZnVuY3Rpb24gKFR5cGVDaGVjaywgbmFtZSkge1xuICByZXR1cm4gKFYsIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICBpZiAoIVR5cGVDaGVjayhWKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke25hbWV9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFZcbiAgfVxufVxuXG53ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIHJldHVybiAoZGljdGlvbmFyeSwgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKGRpY3Rpb25hcnkgIT0gbnVsbCAmJiB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpICE9PSBPQkpFQ1QpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29udmVydGVycykge1xuICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGRpY3Rpb25hcnkgPT0gbnVsbCB8fCAhT2JqZWN0Lmhhc093bihkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBrZXkgXCIke2tleX1cIi5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSBkaWN0aW9uYXJ5Py5ba2V5XVxuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkXG5cbiAgICAgIC8vIE9ubHkgdXNlIGRlZmF1bHRWYWx1ZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kXG4gICAgICAvLyBhIGRlZmF1bHRWYWx1ZSBvcHRpb25zIHdhcyBwcm92aWRlZC5cbiAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWUoKVxuICAgICAgfVxuXG4gICAgICAvLyBBIGtleSBjYW4gYmUgb3B0aW9uYWwgYW5kIGhhdmUgbm8gZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBkbyBub3QgcGVyZm9ybSBhIGNvbnZlcnNpb24sXG4gICAgICAvLyBhbmQgZG8gbm90IGFzc2lnbiB0aGUga2V5IGEgdmFsdWUuXG4gICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fS4ke2tleX1gKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiZcbiAgICAgICAgICAhb3B0aW9ucy5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGljdFtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdFxuICB9XG59XG5cbndlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50KSA9PiB7XG4gICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlcihWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbndlYmlkbC5pcy5VU1ZTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgdmFsdWUuaXNXZWxsRm9ybWVkKClcbiAgKVxufVxuXG53ZWJpZGwuaXMuUmVhZGFibGVTdHJlYW0gPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihSZWFkYWJsZVN0cmVhbSlcbndlYmlkbC5pcy5CbG9iID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oQmxvYilcbndlYmlkbC5pcy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihVUkxTZWFyY2hQYXJhbXMpXG53ZWJpZGwuaXMuRmlsZSA9IHdlYmlkbC51dGlsLk1ha2VUeXBlQXNzZXJ0aW9uKEZpbGUpXG53ZWJpZGwuaXMuVVJMID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oVVJMKVxud2ViaWRsLmlzLkFib3J0U2lnbmFsID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oQWJvcnRTaWduYWwpXG53ZWJpZGwuaXMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihNZXNzYWdlUG9ydClcblxud2ViaWRsLmlzLkJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHJldHVybiB0eXBlcy5pc0FycmF5QnVmZmVyKFYpIHx8IChcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcoVikgJiZcbiAgICB0eXBlcy5pc0FycmF5QnVmZmVyKFYuYnVmZmVyKVxuICApXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWdldC1idWZmZXItc291cmNlLWNvcHlcbndlYmlkbC51dGlsLmdldENvcHlPZkJ5dGVzSGVsZEJ5QnVmZmVyU291cmNlID0gZnVuY3Rpb24gKGJ1ZmZlclNvdXJjZSkge1xuICAvLyAxLiBMZXQganNCdWZmZXJTb3VyY2UgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGJ1ZmZlclNvdXJjZSB0byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gIGNvbnN0IGpzQnVmZmVyU291cmNlID0gYnVmZmVyU291cmNlXG5cbiAgLy8gMi4gTGV0IGpzQXJyYXlCdWZmZXIgYmUganNCdWZmZXJTb3VyY2UuXG4gIGxldCBqc0FycmF5QnVmZmVyID0ganNCdWZmZXJTb3VyY2VcblxuICAvLyAzLiBMZXQgb2Zmc2V0IGJlIDAuXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgLy8gNC4gTGV0IGxlbmd0aCBiZSAwLlxuICBsZXQgbGVuZ3RoID0gMFxuXG4gIC8vIDUuIElmIGpzQnVmZmVyU291cmNlIGhhcyBhIFtbVmlld2VkQXJyYXlCdWZmZXJdXSBpbnRlcm5hbCBzbG90LCB0aGVuOlxuICBpZiAodHlwZXMuaXNUeXBlZEFycmF5KGpzQnVmZmVyU291cmNlKSB8fCB0eXBlcy5pc0RhdGFWaWV3KGpzQnVmZmVyU291cmNlKSkge1xuICAgIC8vIDUuMS4gU2V0IGpzQXJyYXlCdWZmZXIgdG8ganNCdWZmZXJTb3VyY2UuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dLlxuICAgIGpzQXJyYXlCdWZmZXIgPSBqc0J1ZmZlclNvdXJjZS5idWZmZXJcblxuICAgIC8vIDUuMi4gU2V0IG9mZnNldCB0byBqc0J1ZmZlclNvdXJjZS5bW0J5dGVPZmZzZXRdXS5cbiAgICBvZmZzZXQgPSBqc0J1ZmZlclNvdXJjZS5ieXRlT2Zmc2V0XG5cbiAgICAvLyA1LjMuIFNldCBsZW5ndGggdG8ganNCdWZmZXJTb3VyY2UuW1tCeXRlTGVuZ3RoXV0uXG4gICAgbGVuZ3RoID0ganNCdWZmZXJTb3VyY2UuYnl0ZUxlbmd0aFxuICB9IGVsc2Uge1xuICAgIC8vIDYuIE90aGVyd2lzZTpcblxuICAgIC8vIDYuMS4gQXNzZXJ0OiBqc0J1ZmZlclNvdXJjZSBpcyBhbiBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QuXG4gICAgYXNzZXJ0KHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoanNCdWZmZXJTb3VyY2UpKVxuXG4gICAgLy8gNi4yLiBTZXQgbGVuZ3RoIHRvIGpzQnVmZmVyU291cmNlLltbQXJyYXlCdWZmZXJCeXRlTGVuZ3RoXV0uXG4gICAgbGVuZ3RoID0ganNCdWZmZXJTb3VyY2UuYnl0ZUxlbmd0aFxuICB9XG5cbiAgLy8gNy4gSWYgSXNEZXRhY2hlZEJ1ZmZlcihqc0FycmF5QnVmZmVyKSBpcyB0cnVlLCB0aGVuIHJldHVybiB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgaWYgKGpzQXJyYXlCdWZmZXIuZGV0YWNoZWQpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMClcbiAgfVxuXG4gIC8vIDguIExldCBieXRlcyBiZSBhIG5ldyBieXRlIHNlcXVlbmNlIG9mIGxlbmd0aCBlcXVhbCB0byBsZW5ndGguXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuXG4gIC8vIDkuIEZvciBpIGluIHRoZSByYW5nZSBvZmZzZXQgdG8gb2Zmc2V0ICsgbGVuZ3RoIOKIkiAxLCBpbmNsdXNpdmUsXG4gIC8vICAgIHNldCBieXRlc1tpIOKIkiBvZmZzZXRdIHRvIEdldFZhbHVlRnJvbUJ1ZmZlcihqc0FycmF5QnVmZmVyLCBpLCBVaW50OCwgdHJ1ZSwgVW5vcmRlcmVkKS5cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGpzQXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKVxuICBieXRlcy5zZXQodmlldylcblxuICAvLyAxMC4gUmV0dXJuIGJ5dGVzLlxuICByZXR1cm4gYnl0ZXNcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ET01TdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncykge1xuICAvLyAxLiBJZiBWIGlzIG51bGwgYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlXG4gIC8vICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0xlZ2FjeU51bGxUb0VtcHR5U3RyaW5nXVxuICAvLyAgICBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW4gcmV0dXJuIHRoZSBET01TdHJpbmcgdmFsdWVcbiAgLy8gICAgdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGlmIChWID09PSBudWxsICYmIHdlYmlkbC51dGlsLkhhc0ZsYWcoZmxhZ3MsIHdlYmlkbC5hdHRyaWJ1dGVzLkxlZ2FjeU51bGxUb0VtcHR5U3RyaW5nKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMi4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGlzIGEgc3ltYm9sLCB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgRE9NU3RyaW5nLmBcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSBJREwgRE9NU3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gICAgc2FtZSBzZXF1ZW5jZSBvZiBjb2RlIHVuaXRzIGFzIHRoZSBvbmUgdGhlXG4gIC8vICAgIEVDTUFTY3JpcHQgU3RyaW5nIHZhbHVlIHggcmVwcmVzZW50cy5cbiAgcmV0dXJuIFN0cmluZyhWKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLUJ5dGVTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICBpZiAodHlwZW9mIFYgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gaXMgYSBzeW1ib2wsIHdoaWNoIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBCeXRlU3RyaW5nLmBcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgeCA9IFN0cmluZyhWKVxuXG4gIC8vIDIuIElmIHRoZSB2YWx1ZSBvZiBhbnkgZWxlbWVudCBvZiB4IGlzIGdyZWF0ZXIgdGhhblxuICAvLyAgICAyNTUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmICh4LmNoYXJDb2RlQXQoaW5kZXgpID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgdG8gYSBCeXRlU3RyaW5nIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBhdCAnICtcbiAgICAgICAgYGluZGV4ICR7aW5kZXh9IGhhcyBhIHZhbHVlIG9mICR7eC5jaGFyQ29kZUF0KGluZGV4KX0gd2hpY2ggaXMgZ3JlYXRlciB0aGFuIDI1NS5gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGFuIElETCBCeXRlU3RyaW5nIHZhbHVlIHdob3NlIGxlbmd0aCBpcyB0aGVcbiAgLy8gICAgbGVuZ3RoIG9mIHgsIGFuZCB3aGVyZSB0aGUgdmFsdWUgb2YgZWFjaCBlbGVtZW50IGlzXG4gIC8vICAgIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IG9mIHguXG4gIHJldHVybiB4XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1VU1ZTdHJpbmdcbiAqL1xud2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIFRPRE86IHJld3JpdGUgdGhpcyBzbyB3ZSBjYW4gY29udHJvbCB0aGUgZXJyb3JzIHRocm93blxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZS50b1dlbGxGb3JtZWQoKVxuICB9XG4gIHJldHVybiBgJHt2YWx1ZX1gLnRvV2VsbEZvcm1lZCgpXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYm9vbGVhblxud2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlIHRoZSByZXN1bHQgb2YgY29tcHV0aW5nIFRvQm9vbGVhbihWKS5cbiAgLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy8xMC4wL2luZGV4Lmh0bWwjdGFibGUtMTBcbiAgY29uc3QgeCA9IEJvb2xlYW4oVilcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBib29sZWFuIHZhbHVlIHRoYXQgaXMgdGhlIG9uZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgdHJ1dGggdmFsdWUgYXMgdGhlIEVDTUFTY3JpcHQgQm9vbGVhbiB2YWx1ZSB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWFueVxud2ViaWRsLmNvbnZlcnRlcnMuYW55ID0gZnVuY3Rpb24gKFYpIHtcbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3NpZ25lZCcsIDAsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgbG9uZyBsb25nIHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3Vuc2lnbmVkJywgMCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMzIsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMzIsICd1bnNpZ25lZCcsIDAsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLXNob3J0XG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncykge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAxNiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAxNiwgJ3Vuc2lnbmVkJywgZmxhZ3MsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgc2hvcnQgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpZGwtQXJyYXlCdWZmZXJcbndlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIGZsYWdzKSB7XG4gIC8vIDEuIElmIFYgaXMgbm90IGFuIE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFuXG4gIC8vICAgIFtbQXJyYXlCdWZmZXJEYXRhXV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgLy8gMi4gSWYgSXNTaGFyZWRBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBPQkpFQ1QgfHxcbiAgICAhdHlwZXMuaXNBcnJheUJ1ZmZlcihWKVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4LFxuICAgICAgYXJndW1lbnQ6IGAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFsnQXJyYXlCdWZmZXInXVxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1Jlc2l6YWJsZSkgJiYgd2ViaWRsLnV0aWwuSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGNhbm5vdCBiZSBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIEFycmF5QnVmZmVyIHZhbHVlIHRoYXQgaXMgYVxuICAvLyAgICByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaWRsLVNoYXJlZEFycmF5QnVmZmVyXG53ZWJpZGwuY29udmVydGVycy5TaGFyZWRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncykge1xuICAvLyAxLiBJZiBWIGlzIG5vdCBhbiBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhblxuICAvLyAgICBbW0FycmF5QnVmZmVyRGF0YV1dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIDIuIElmIElzU2hhcmVkQXJyYXlCdWZmZXIoVikgaXMgZmFsc2UsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1zaGFyZWRhcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09IE9CSkVDVCB8fFxuICAgICF0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYpXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXgsXG4gICAgICBhcmd1bWVudDogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgICB0eXBlczogWydTaGFyZWRBcnJheUJ1ZmZlciddXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAoIXdlYmlkbC51dGlsLkhhc0ZsYWcoZmxhZ3MsIHdlYmlkbC5hdHRyaWJ1dGVzLkFsbG93UmVzaXphYmxlKSAmJiB3ZWJpZGwudXRpbC5Jc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gY2Fubm90IGJlIGEgcmVzaXphYmxlIFNoYXJlZEFycmF5QnVmZmVyLmBcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgU2hhcmVkQXJyYXlCdWZmZXIgdmFsdWUgdGhhdCBpcyBhXG4gIC8vICAgIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4tdHlwZWQtYXJyYXktdHlwZVxud2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChWLCBULCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncykge1xuICAvLyAxLiBMZXQgVCBiZSB0aGUgSURMIHR5cGUgViBpcyBiZWluZyBjb252ZXJ0ZWQgdG8uXG5cbiAgLy8gMi4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW1R5cGVkQXJyYXlOYW1lXV0gaW50ZXJuYWwgc2xvdCB3aXRoIGEgdmFsdWVcbiAgLy8gICAgZXF1YWwgdG8gVOKAmXMgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09IE9CSkVDVCB8fFxuICAgICF0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICBWLmNvbnN0cnVjdG9yLm5hbWUgIT09IFQubmFtZVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4LFxuICAgICAgYXJndW1lbnQ6IGAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFtULm5hbWVdXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1NoYXJlZCkgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBjYW5ub3QgYmUgYSB2aWV3IG9uIGEgc2hhcmVkIGFycmF5IGJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1Jlc2l6YWJsZSkgJiYgd2ViaWRsLnV0aWwuSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBjYW5ub3QgYmUgYSB2aWV3IG9uIGEgcmVzaXphYmxlIGFycmF5IGJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDUuIFJldHVybiB0aGUgSURMIHZhbHVlIG9mIHR5cGUgVCB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2lkbC1EYXRhVmlld1xud2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgZmxhZ3MpIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW0RhdGFWaWV3XV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09IE9CSkVDVCB8fCAhdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXgsXG4gICAgICBhcmd1bWVudDogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgICB0eXBlczogWydEYXRhVmlldyddXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1NoYXJlZCkgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBjYW5ub3QgYmUgYSB2aWV3IG9uIGEgc2hhcmVkIGFycmF5IGJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1Jlc2l6YWJsZSkgJiYgd2ViaWRsLnV0aWwuSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBjYW5ub3QgYmUgYSB2aWV3IG9uIGEgcmVzaXphYmxlIGFycmF5IGJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIERhdGFWaWV3IHZhbHVlIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jQXJyYXlCdWZmZXJWaWV3XG53ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgZmxhZ3MpIHtcbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09IE9CSkVDVCB8fFxuICAgICF0eXBlcy5pc0FycmF5QnVmZmVyVmlldyhWKVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4LFxuICAgICAgYXJndW1lbnQ6IGAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFsnQXJyYXlCdWZmZXJWaWV3J11cbiAgICB9KVxuICB9XG5cbiAgaWYgKCF3ZWJpZGwudXRpbC5IYXNGbGFnKGZsYWdzLCB3ZWJpZGwuYXR0cmlidXRlcy5BbGxvd1NoYXJlZCkgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBjYW5ub3QgYmUgYSB2aWV3IG9uIGEgc2hhcmVkIGFycmF5IGJ1ZmZlci5gXG4gICAgfSlcbiAgfVxuXG4gIGlmICghd2ViaWRsLnV0aWwuSGFzRmxhZyhmbGFncywgd2ViaWRsLmF0dHJpYnV0ZXMuQWxsb3dSZXNpemFibGUpICYmIHdlYmlkbC51dGlsLklzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gY2Fubm90IGJlIGEgdmlldyBvbiBhIHJlc2l6YWJsZSBhcnJheSBidWZmZXIuYFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI0J1ZmZlclNvdXJjZVxud2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIGZsYWdzKSB7XG4gIGlmICh0eXBlcy5pc0FycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIHByZWZpeCwgYXJndW1lbnQsIGZsYWdzKVxuICB9XG5cbiAgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXJWaWV3KFYpKSB7XG4gICAgZmxhZ3MgJj0gfndlYmlkbC5hdHRyaWJ1dGVzLkFsbG93U2hhcmVkXG5cbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXJWaWV3KFYsIHByZWZpeCwgYXJndW1lbnQsIGZsYWdzKVxuICB9XG5cbiAgLy8gTWFrZSB0aGlzIGV4cGxpY2l0IGZvciBlYXNpZXIgZGVidWdnaW5nXG4gIGlmICh0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gY2Fubm90IGJlIGEgU2hhcmVkQXJyYXlCdWZmZXIuYFxuICAgIH0pXG4gIH1cblxuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgIHByZWZpeCxcbiAgICBhcmd1bWVudDogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgdHlwZXM6IFsnQXJyYXlCdWZmZXInLCAnQXJyYXlCdWZmZXJWaWV3J11cbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNBbGxvd1NoYXJlZEJ1ZmZlclNvdXJjZVxud2ViaWRsLmNvbnZlcnRlcnMuQWxsb3dTaGFyZWRCdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIoViwgcHJlZml4LCBhcmd1bWVudCwgZmxhZ3MpXG4gIH1cblxuICBpZiAodHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5TaGFyZWRBcnJheUJ1ZmZlcihWLCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncylcbiAgfVxuXG4gIGlmICh0eXBlcy5pc0FycmF5QnVmZmVyVmlldyhWKSkge1xuICAgIGZsYWdzIHw9IHdlYmlkbC5hdHRyaWJ1dGVzLkFsbG93U2hhcmVkXG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyVmlldyhWLCBwcmVmaXgsIGFyZ3VtZW50LCBmbGFncylcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4LFxuICAgIGFyZ3VtZW50OiBgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICB0eXBlczogWydBcnJheUJ1ZmZlcicsICdTaGFyZWRBcnJheUJ1ZmZlcicsICdBcnJheUJ1ZmZlclZpZXcnXVxuICB9KVxufVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnMuQmxvYiA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIod2ViaWRsLmlzLkJsb2IsICdCbG9iJylcblxud2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICB3ZWJpZGwuaXMuQWJvcnRTaWduYWwsXG4gICdBYm9ydFNpZ25hbCdcbilcblxuLyoqXG4gKiBbTGVnYWN5VHJlYXROb25PYmplY3RBc051bGxdXG4gKiBjYWxsYmFjayBFdmVudEhhbmRsZXJOb25OdWxsID0gYW55IChFdmVudCBldmVudCk7XG4gKiB0eXBlZGVmIEV2ZW50SGFuZGxlck5vbk51bGw/IEV2ZW50SGFuZGxlcjtcbiAqIEBwYXJhbSB7Kn0gVlxuICovXG53ZWJpZGwuY29udmVydGVycy5FdmVudEhhbmRsZXJOb25OdWxsID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09IE9CSkVDVCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBbSV1mIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBudWxsLCBhbmQgaWYgdGhlIHZhbHVlIGlzIG5vdCBjYWxsYWJsZSxcbiAgLy8gaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBjYWxsYmFjayBmdW5jdGlvbiB2YWx1ZSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIGNhbGxlZC5cbiAgaWYgKHR5cGVvZiBWID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7fVxufVxuXG53ZWJpZGwuYXR0cmlidXRlcyA9IHtcbiAgQ2xhbXA6IDEgPDwgMCxcbiAgRW5mb3JjZVJhbmdlOiAxIDw8IDEsXG4gIEFsbG93U2hhcmVkOiAxIDw8IDIsXG4gIEFsbG93UmVzaXphYmxlOiAxIDw8IDMsXG4gIExlZ2FjeU51bGxUb0VtcHR5U3RyaW5nOiAxIDw8IDRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdlYmlkbFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/webidl/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { parseExtensions, isClosed, isClosing, isEstablished, isConnecting, validateCloseCodeAndReason } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\n\nconst crypto = runtimeFeatures.has('crypto')\n  ? __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  : null\n\nlet warningEmitted = false\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').Handler} handler\n * @param {Partial<import('../../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, handler, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    redirect mode is \"error\", and use-URL-credentials flag is set.\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error',\n    useURLCredentials: true\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to requests header list.\n  // 4. Append (`Connection`, `Upgrade`) to requests header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue, true)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13', true)\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol, true)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     requests header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate, true)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      // if (response.type === 'error' || ((response.socket?.session != null && response.status !== 200) && response.status !== 101)) {\n      if (response.type === 'error' || response.status !== 101) {\n        // The presence of a session property on the socket indicates HTTP2\n        // HTTP1\n        if (response.socket?.session == null) {\n          failWebsocketConnection(handler, 1002, 'Received network error or non-101 status code.', response.error)\n          return\n        }\n\n        // HTTP2\n        if (response.status !== 200) {\n          failWebsocketConnection(handler, 1002, 'Received network error or non-200 status code.', response.error)\n          return\n        }\n      }\n\n      if (warningEmitted === false && response.socket?.session != null) {\n        process.emitWarning('WebSocket over HTTP2 is experimental, and subject to change.', 'ExperimentalWarning')\n        warningEmitted = true\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and responses\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(handler, 1002, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      //    For H2, no upgrade header is expected.\n      if (response.socket.session == null && response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      //    For H2, no connection header is expected.\n      if (response.socket.session == null && response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.hash('sha1', keyValue + uid, 'base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(handler, 1002, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(handler, 1002, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(handler, 1002, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', handler.onSocketData)\n      response.socket.on('close', handler.onSocketClose)\n      response.socket.on('error', handler.onSocketError)\n\n      handler.wasEverConnected = true\n      handler.onConnectionEstablished(response, extensions)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @see https://whatpr.org/websockets/48.html#close-the-websocket\n * @param {import('./websocket').Handler} object\n * @param {number} [code=null]\n * @param {string} [reason='']\n */\nfunction closeWebSocketConnection (object, code, reason, validate = false) {\n  // 1. If code was not supplied, let code be null.\n  code ??= null\n\n  // 2. If reason was not supplied, let reason be the empty string.\n  reason ??= ''\n\n  // 3. Validate close code and reason with code and reason.\n  if (validate) validateCloseCodeAndReason(code, reason)\n\n  // 4. Run the first matching steps from the following list:\n  //     - If objects ready state is CLOSING (2) or CLOSED (3)\n  //     - If the WebSocket connection is not yet established [WSP]\n  //     - If the WebSocket closing handshake has not yet been started [WSP]\n  //     - Otherwise\n  if (isClosed(object.readyState) || isClosing(object.readyState)) {\n    // Do nothing.\n  } else if (!isEstablished(object.readyState)) {\n    // Fail the WebSocket connection and set objects ready state to CLOSING (2). [WSP]\n    failWebsocketConnection(object)\n    object.readyState = states.CLOSING\n  } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    // If code is null and reason is the empty string, the WebSocket Close frame must not have a body.\n    // If reason is non-empty but code is null, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // If code is set, then the status code to use in the WebSocket Close frame must be the integer given by code.\n    assert(code === null || Number.isInteger(code))\n\n    if (code === null && reason.length === 0) {\n      frame.frameData = emptyBuffer\n    } else if (code !== null && reason === null) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== null && reason !== null) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason))\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    object.socket.write(frame.createFrame(opcodes.CLOSE))\n\n    object.closeState.add(sentCloseFrameState.SENT)\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    object.readyState = states.CLOSING\n  } else {\n    // Set objects ready state to CLOSING (2).\n    object.readyState = states.CLOSING\n  }\n}\n\n/**\n * @param {import('./websocket').Handler} handler\n * @param {number} code\n * @param {string|undefined} reason\n * @param {unknown} cause\n * @returns {void}\n */\nfunction failWebsocketConnection (handler, code, reason, cause) {\n  // If _The WebSocket Connection is Established_ prior to the point where\n  // the endpoint is required to _Fail the WebSocket Connection_, the\n  // endpoint SHOULD send a Close frame with an appropriate status code\n  // (Section 7.4) before proceeding to _Close the WebSocket Connection_.\n  if (isEstablished(handler.readyState)) {\n    closeWebSocketConnection(handler, code, reason, false)\n  }\n\n  handler.controller.abort()\n\n  if (isConnecting(handler.readyState)) {\n    // If the connection was not established, we must still emit an 'error' and 'close' events\n    handler.onSocketClose()\n  } else if (handler.socket?.destroyed === false) {\n    handler.socket.destroy()\n  }\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  failWebsocketConnection,\n  closeWebSocketConnection\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3hGLFFBQVEsZ0dBQWdHLEVBQUUsbUJBQU8sQ0FBQyxxRUFBUTtBQUMxSCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLDhFQUFrQjtBQUNsRCxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDBFQUFnQjtBQUM3QyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQzlELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsRCxRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyw2RkFBNkI7O0FBRWpFO0FBQ0EsSUFBSSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVywyREFBMkQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcY29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB1aWQsIHN0YXRlcywgc2VudENsb3NlRnJhbWVTdGF0ZSwgZW1wdHlCdWZmZXIsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgcGFyc2VFeHRlbnNpb25zLCBpc0Nsb3NlZCwgaXNDbG9zaW5nLCBpc0VzdGFibGlzaGVkLCBpc0Nvbm5lY3RpbmcsIHZhbGlkYXRlQ2xvc2VDb2RlQW5kUmVhc29uIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IEhlYWRlcnMsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcbmNvbnN0IHsgZ2V0RGVjb2RlU3BsaXQgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBydW50aW1lRmVhdHVyZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcnVudGltZS1mZWF0dXJlcycpXG5cbmNvbnN0IGNyeXB0byA9IHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ2NyeXB0bycpXG4gID8gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuICA6IG51bGxcblxubGV0IHdhcm5pbmdFbWl0dGVkID0gZmFsc2VcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtd2Vic29ja2V0LWVzdGFibGlzaFxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3RvY29sc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gaGFuZGxlclxuICogQHBhcmFtIHtQYXJ0aWFsPGltcG9ydCgnLi4vLi4vLi4vdHlwZXMvd2Vic29ja2V0JykuV2ViU29ja2V0SW5pdD59IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiAodXJsLCBwcm90b2NvbHMsIGNsaWVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIHJlZGlyZWN0IG1vZGUgaXMgXCJlcnJvclwiLCBhbmQgdXNlLVVSTC1jcmVkZW50aWFscyBmbGFnIGlzIHNldC5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgY2xpZW50LFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnbm9uZScsXG4gICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcicsXG4gICAgbW9kZTogJ3dlYnNvY2tldCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICByZWRpcmVjdDogJ2Vycm9yJyxcbiAgICB1c2VVUkxDcmVkZW50aWFsczogdHJ1ZVxuICB9KVxuXG4gIC8vIE5vdGU6IHVuZGljaSBleHRlbnNpb24sIGFsbG93IHNldHRpbmcgY3VzdG9tIGhlYWRlcnMuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycykpXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSwgdHJ1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycsIHRydWUpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sLCB0cnVlKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICBjb25zdCBwZXJtZXNzYWdlRGVmbGF0ZSA9ICdwZXJtZXNzYWdlLWRlZmxhdGU7IGNsaWVudF9tYXhfd2luZG93X2JpdHMnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSwgdHJ1ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgKChyZXNwb25zZS5zb2NrZXQ/LnNlc3Npb24gIT0gbnVsbCAmJiByZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpKSB7XG4gICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgIT09IDEwMSkge1xuICAgICAgICAvLyBUaGUgcHJlc2VuY2Ugb2YgYSBzZXNzaW9uIHByb3BlcnR5IG9uIHRoZSBzb2NrZXQgaW5kaWNhdGVzIEhUVFAyXG4gICAgICAgIC8vIEhUVFAxXG4gICAgICAgIGlmIChyZXNwb25zZS5zb2NrZXQ/LnNlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKGhhbmRsZXIsIDEwMDIsICdSZWNlaXZlZCBuZXR3b3JrIGVycm9yIG9yIG5vbi0xMDEgc3RhdHVzIGNvZGUuJywgcmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIVFRQMlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnUmVjZWl2ZWQgbmV0d29yayBlcnJvciBvciBub24tMjAwIHN0YXR1cyBjb2RlLicsIHJlc3BvbnNlLmVycm9yKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXJuaW5nRW1pdHRlZCA9PT0gZmFsc2UgJiYgcmVzcG9uc2Uuc29ja2V0Py5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnV2ViU29ja2V0IG92ZXIgSFRUUDIgaXMgZXhwZXJpbWVudGFsLCBhbmQgc3ViamVjdCB0byBjaGFuZ2UuJywgJ0V4cGVyaW1lbnRhbFdhcm5pbmcnKVxuICAgICAgICB3YXJuaW5nRW1pdHRlZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgcHJvdG9jb2xzIGlzIG5vdCB0aGUgZW1wdHkgbGlzdCBhbmQgZXh0cmFjdGluZyBoZWFkZXJcbiAgICAgIC8vICAgIGxpc3QgdmFsdWVzIGdpdmVuIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBhbmQgcmVzcG9uc2XigJlzXG4gICAgICAvLyAgICBoZWFkZXIgbGlzdCByZXN1bHRzIGluIG51bGwsIGZhaWx1cmUsIG9yIHRoZSBlbXB0eSBieXRlXG4gICAgICAvLyAgICBzZXF1ZW5jZSwgdGhlbiBmYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSAwICYmICFyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIHNlbnQgcHJvdG9jb2xzLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBGb2xsb3cgdGhlIHJlcXVpcmVtZW50cyBzdGF0ZWQgc3RlcCAyIHRvIHN0ZXAgNiwgaW5jbHVzaXZlLFxuICAgICAgLy8gICAgb2YgdGhlIGxhc3Qgc2V0IG9mIHN0ZXBzIGluIHNlY3Rpb24gNC4xIG9mIFRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIFByb3RvY29sIHRvIHZhbGlkYXRlIHJlc3BvbnNlLiBUaGlzIGVpdGhlciByZXN1bHRzIGluIGZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBvciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgICAgIC8vICAgIGVzdGFibGlzaGVkLlxuXG4gICAgICAvLyAyLiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYW4gfFVwZ3JhZGV8IGhlYWRlciBmaWVsZCBvciB0aGUgfFVwZ3JhZGV8XG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBhbiBBU0NJSSBjYXNlLVxuICAgICAgLy8gICAgaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIndlYnNvY2tldFwiLCB0aGUgY2xpZW50IE1VU1RcbiAgICAgIC8vICAgIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICAvLyAgICBGb3IgSDIsIG5vIHVwZ3JhZGUgaGVhZGVyIGlzIGV4cGVjdGVkLlxuICAgICAgaWYgKHJlc3BvbnNlLnNvY2tldC5zZXNzaW9uID09IG51bGwgJiYgcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdVcGdyYWRlJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKGhhbmRsZXIsIDEwMDIsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGVcbiAgICAgIC8vICAgIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgLy8gICAgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICAvLyAgICBGb3IgSDIsIG5vIGNvbm5lY3Rpb24gaGVhZGVyIGlzIGV4cGVjdGVkLlxuICAgICAgaWYgKHJlc3BvbnNlLnNvY2tldC5zZXNzaW9uID09IG51bGwgJiYgcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdDb25uZWN0aW9uJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnU2VydmVyIGRpZCBub3Qgc2V0IENvbm5lY3Rpb24gaGVhZGVyIHRvIFwidXBncmFkZVwiLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA0LiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGhlYWRlciBmaWVsZCBvclxuICAgICAgLy8gICAgdGhlIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgY29udGFpbnMgYSB2YWx1ZSBvdGhlciB0aGFuIHRoZVxuICAgICAgLy8gICAgYmFzZTY0LWVuY29kZWQgU0hBLTEgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHxTZWMtV2ViU29ja2V0LVxuICAgICAgLy8gICAgS2V5fCAoYXMgYSBzdHJpbmcsIG5vdCBiYXNlNjQtZGVjb2RlZCkgd2l0aCB0aGUgc3RyaW5nIFwiMjU4RUFGQTUtXG4gICAgICAvLyAgICBFOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTFcIiBidXQgaWdub3JpbmcgYW55IGxlYWRpbmcgYW5kXG4gICAgICAvLyAgICB0cmFpbGluZyB3aGl0ZXNwYWNlLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNXU0FjY2VwdCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1BY2NlcHQnKVxuICAgICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmhhc2goJ3NoYTEnLCBrZXlWYWx1ZSArIHVpZCwgJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnSW5jb3JyZWN0IGhhc2ggcmVjZWl2ZWQgaW4gU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgYSB8U2VjLVdlYlNvY2tldC1FeHRlbnNpb25zfCBoZWFkZXJcbiAgICAgIC8vICAgIGZpZWxkIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhbiBleHRlbnNpb25cbiAgICAgIC8vICAgIHRoYXQgd2FzIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzXG4gICAgICAvLyAgICBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCksIHRoZSBjbGllbnRcbiAgICAgIC8vICAgIE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy4gIChUaGUgcGFyc2luZyBvZiB0aGlzXG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgYXJlIHJlcXVlc3RlZCBpc1xuICAgICAgLy8gICAgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOS4xLilcbiAgICAgIGNvbnN0IHNlY0V4dGVuc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJylcbiAgICAgIGxldCBleHRlbnNpb25zXG5cbiAgICAgIGlmIChzZWNFeHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhzZWNFeHRlbnNpb24pXG5cbiAgICAgICAgaWYgKCFleHRlbnNpb25zLmhhcygncGVybWVzc2FnZS1kZWZsYXRlJykpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBkb2VzIG5vdCBtYXRjaC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBoZWFkZXIgZmllbGRcbiAgICAgIC8vICAgIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhIHN1YnByb3RvY29sIHRoYXQgd2FzXG4gICAgICAvLyAgICBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhcyBpbmRpY2F0ZWQgYVxuICAgICAgLy8gICAgc3VicHJvdG9jb2wgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjUHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKVxuXG4gICAgICBpZiAoc2VjUHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFByb3RvY29scyA9IGdldERlY29kZVNwbGl0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJywgcmVxdWVzdC5oZWFkZXJzTGlzdClcblxuICAgICAgICAvLyBUaGUgY2xpZW50IGNhbiByZXF1ZXN0IHRoYXQgdGhlIHNlcnZlciB1c2UgYSBzcGVjaWZpYyBzdWJwcm90b2NvbCBieVxuICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBmaWVsZCBpbiBpdHMgaGFuZHNoYWtlLiAgSWYgaXRcbiAgICAgICAgLy8gaXMgc3BlY2lmaWVkLCB0aGUgc2VydmVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHNhbWUgZmllbGQgYW5kIG9uZSBvZlxuICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgc3VicHJvdG9jb2wgdmFsdWVzIGluIGl0cyByZXNwb25zZSBmb3IgdGhlIGNvbm5lY3Rpb24gdG9cbiAgICAgICAgLy8gYmUgZXN0YWJsaXNoZWQuXG4gICAgICAgIGlmICghcmVxdWVzdFByb3RvY29scy5pbmNsdWRlcyhzZWNQcm90b2NvbCkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgaGFuZGxlci5vblNvY2tldERhdGEpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Nsb3NlJywgaGFuZGxlci5vblNvY2tldENsb3NlKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdlcnJvcicsIGhhbmRsZXIub25Tb2NrZXRFcnJvcilcblxuICAgICAgaGFuZGxlci53YXNFdmVyQ29ubmVjdGVkID0gdHJ1ZVxuICAgICAgaGFuZGxlci5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSwgZXh0ZW5zaW9ucylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGNvbnRyb2xsZXJcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2hhdHByLm9yZy93ZWJzb2NrZXRzLzQ4Lmh0bWwjY2xvc2UtdGhlLXdlYnNvY2tldFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2NvZGU9bnVsbF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uPScnXVxuICovXG5mdW5jdGlvbiBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24gKG9iamVjdCwgY29kZSwgcmVhc29uLCB2YWxpZGF0ZSA9IGZhbHNlKSB7XG4gIC8vIDEuIElmIGNvZGUgd2FzIG5vdCBzdXBwbGllZCwgbGV0IGNvZGUgYmUgbnVsbC5cbiAgY29kZSA/Pz0gbnVsbFxuXG4gIC8vIDIuIElmIHJlYXNvbiB3YXMgbm90IHN1cHBsaWVkLCBsZXQgcmVhc29uIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHJlYXNvbiA/Pz0gJydcblxuICAvLyAzLiBWYWxpZGF0ZSBjbG9zZSBjb2RlIGFuZCByZWFzb24gd2l0aCBjb2RlIGFuZCByZWFzb24uXG4gIGlmICh2YWxpZGF0ZSkgdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24oY29kZSwgcmVhc29uKVxuXG4gIC8vIDQuIFJ1biB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gIC8vICAgICAtIElmIG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAvLyAgICAgLSBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCBbV1NQXVxuICAvLyAgICAgLSBJZiB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IGJlZW4gc3RhcnRlZCBbV1NQXVxuICAvLyAgICAgLSBPdGhlcndpc2VcbiAgaWYgKGlzQ2xvc2VkKG9iamVjdC5yZWFkeVN0YXRlKSB8fCBpc0Nsb3Npbmcob2JqZWN0LnJlYWR5U3RhdGUpKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfSBlbHNlIGlmICghaXNFc3RhYmxpc2hlZChvYmplY3QucmVhZHlTdGF0ZSkpIHtcbiAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuIFtXU1BdXG4gICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24ob2JqZWN0KVxuICAgIG9iamVjdC5yZWFkeVN0YXRlID0gc3RhdGVzLkNMT1NJTkdcbiAgfSBlbHNlIGlmICghb2JqZWN0LmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkgJiYgIW9iamVjdC5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKSkge1xuICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG5cbiAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgLy8gSWYgY29kZSBpcyBudWxsIGFuZCByZWFzb24gaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlIFdlYlNvY2tldCBDbG9zZSBmcmFtZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cbiAgICAvLyBJZiByZWFzb24gaXMgbm9uLWVtcHR5IGJ1dCBjb2RlIGlzIG51bGwsIHRoZW4gc2V0IGNvZGUgdG8gMTAwMCAoXCJOb3JtYWwgQ2xvc3VyZVwiKS5cbiAgICBpZiAocmVhc29uLmxlbmd0aCAhPT0gMCAmJiBjb2RlID09PSBudWxsKSB7XG4gICAgICBjb2RlID0gMTAwMFxuICAgIH1cblxuICAgIC8vIElmIGNvZGUgaXMgc2V0LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlIFdlYlNvY2tldCBDbG9zZSBmcmFtZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgYXNzZXJ0KGNvZGUgPT09IG51bGwgfHwgTnVtYmVyLmlzSW50ZWdlcihjb2RlKSlcblxuICAgIGlmIChjb2RlID09PSBudWxsICYmIHJlYXNvbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IGVtcHR5QnVmZmVyXG4gICAgfSBlbHNlIGlmIChjb2RlICE9PSBudWxsICYmIHJlYXNvbiA9PT0gbnVsbCkge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gbnVsbCAmJiByZWFzb24gIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHJlYXNvbiBpcyBhbHNvIHByZXNlbnQsIHRoZW4gcmVhc29uQnl0ZXMgbXVzdCBiZVxuICAgICAgLy8gcHJvdmlkZWQgaW4gdGhlIENsb3NlIG1lc3NhZ2UgYWZ0ZXIgdGhlIHN0YXR1cyBjb2RlLlxuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChyZWFzb24pKVxuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlVUludDE2QkUoY29kZSwgMClcbiAgICAgIC8vIHRoZSBib2R5IE1BWSBjb250YWluIFVURi04LWVuY29kZWQgZGF0YSB3aXRoIHZhbHVlIC9yZWFzb24vXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGUocmVhc29uLCAyLCAndXRmLTgnKVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5mcmFtZURhdGEgPSBlbXB0eUJ1ZmZlclxuICAgIH1cblxuICAgIG9iamVjdC5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSkpXG5cbiAgICBvYmplY3QuY2xvc2VTdGF0ZS5hZGQoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKVxuXG4gICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICBvYmplY3QucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TSU5HXG4gIH0gZWxzZSB7XG4gICAgLy8gU2V0IG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgb2JqZWN0LnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gaGFuZGxlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gKiBAcGFyYW0ge3Vua25vd259IGNhdXNlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKGhhbmRsZXIsIGNvZGUsIHJlYXNvbiwgY2F1c2UpIHtcbiAgLy8gSWYgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBFc3RhYmxpc2hlZF8gcHJpb3IgdG8gdGhlIHBvaW50IHdoZXJlXG4gIC8vIHRoZSBlbmRwb2ludCBpcyByZXF1aXJlZCB0byBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLCB0aGVcbiAgLy8gZW5kcG9pbnQgU0hPVUxEIHNlbmQgYSBDbG9zZSBmcmFtZSB3aXRoIGFuIGFwcHJvcHJpYXRlIHN0YXR1cyBjb2RlXG4gIC8vIChTZWN0aW9uIDcuNCkgYmVmb3JlIHByb2NlZWRpbmcgdG8gX0Nsb3NlIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gIGlmIChpc0VzdGFibGlzaGVkKGhhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24oaGFuZGxlciwgY29kZSwgcmVhc29uLCBmYWxzZSlcbiAgfVxuXG4gIGhhbmRsZXIuY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKGlzQ29ubmVjdGluZyhoYW5kbGVyLnJlYWR5U3RhdGUpKSB7XG4gICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gd2FzIG5vdCBlc3RhYmxpc2hlZCwgd2UgbXVzdCBzdGlsbCBlbWl0IGFuICdlcnJvcicgYW5kICdjbG9zZScgZXZlbnRzXG4gICAgaGFuZGxlci5vblNvY2tldENsb3NlKClcbiAgfSBlbHNlIGlmIChoYW5kbGVyLnNvY2tldD8uZGVzdHJveWVkID09PSBmYWxzZSkge1xuICAgIGhhbmRsZXIuc29ja2V0LmRlc3Ryb3koKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLFxuICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbixcbiAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * This is a Globally Unique Identifier unique used to validate that the\n * endpoint accepts websocket connections.\n * @see https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\n * @type {'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'}\n */\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/**\n * @type {PropertyDescriptor}\n */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * The states of the WebSocket connection.\n *\n * @readonly\n * @enum\n * @property {0} CONNECTING\n * @property {1} OPEN\n * @property {2} CLOSING\n * @property {3} CLOSED\n */\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\n/**\n * @readonly\n * @enum\n * @property {0} NOT_SENT\n * @property {1} PROCESSING\n * @property {2} SENT\n */\nconst sentCloseFrameState = {\n  SENT: 1,\n  RECEIVED: 2\n}\n\n/**\n * The WebSocket opcodes.\n *\n * @readonly\n * @enum\n * @property {0x0} CONTINUATION\n * @property {0x1} TEXT\n * @property {0x2} BINARY\n * @property {0x8} CLOSE\n * @property {0x9} PING\n * @property {0xA} PONG\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n */\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\n/**\n * The maximum value for an unsigned 16-bit integer.\n *\n * @type {65535} 2 ** 16 - 1\n */\nconst maxUnsigned16Bit = 65535\n\n/**\n * The states of the parser.\n *\n * @readonly\n * @enum\n * @property {0} INFO\n * @property {2} PAYLOADLENGTH_16\n * @property {3} PAYLOADLENGTH_64\n * @property {4} READ_DATA\n */\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\n/**\n * An empty buffer.\n *\n * @type {Buffer}\n */\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n/**\n * @readonly\n * @property {1} text\n * @property {2} typedArray\n * @property {3} arrayBuffer\n * @property {4} blob\n */\nconst sendHints = {\n  text: 1,\n  typedArray: 2,\n  arrayBuffer: 3,\n  blob: 4\n}\n\nmodule.exports = {\n  uid,\n  sentCloseFrameState,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer,\n  sendHints\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUaGlzIGlzIGEgR2xvYmFsbHkgVW5pcXVlIElkZW50aWZpZXIgdW5pcXVlIHVzZWQgdG8gdmFsaWRhdGUgdGhhdCB0aGVcbiAqIGVuZHBvaW50IGFjY2VwdHMgd2Vic29ja2V0IGNvbm5lY3Rpb25zLlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tMS4zXG4gKiBAdHlwZSB7JzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSd9XG4gKi9cbmNvbnN0IHVpZCA9ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnXG5cbi8qKlxuICogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn1cbiAqL1xuY29uc3Qgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59XG5cbi8qKlxuICogVGhlIHN0YXRlcyBvZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bVxuICogQHByb3BlcnR5IHswfSBDT05ORUNUSU5HXG4gKiBAcHJvcGVydHkgezF9IE9QRU5cbiAqIEBwcm9wZXJ0eSB7Mn0gQ0xPU0lOR1xuICogQHByb3BlcnR5IHszfSBDTE9TRURcbiAqL1xuY29uc3Qgc3RhdGVzID0ge1xuICBDT05ORUNUSU5HOiAwLFxuICBPUEVOOiAxLFxuICBDTE9TSU5HOiAyLFxuICBDTE9TRUQ6IDNcbn1cblxuLyoqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtXG4gKiBAcHJvcGVydHkgezB9IE5PVF9TRU5UXG4gKiBAcHJvcGVydHkgezF9IFBST0NFU1NJTkdcbiAqIEBwcm9wZXJ0eSB7Mn0gU0VOVFxuICovXG5jb25zdCBzZW50Q2xvc2VGcmFtZVN0YXRlID0ge1xuICBTRU5UOiAxLFxuICBSRUNFSVZFRDogMlxufVxuXG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgb3Bjb2Rlcy5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtXG4gKiBAcHJvcGVydHkgezB4MH0gQ09OVElOVUFUSU9OXG4gKiBAcHJvcGVydHkgezB4MX0gVEVYVFxuICogQHByb3BlcnR5IHsweDJ9IEJJTkFSWVxuICogQHByb3BlcnR5IHsweDh9IENMT1NFXG4gKiBAcHJvcGVydHkgezB4OX0gUElOR1xuICogQHByb3BlcnR5IHsweEF9IFBPTkdcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS4yXG4gKi9cbmNvbnN0IG9wY29kZXMgPSB7XG4gIENPTlRJTlVBVElPTjogMHgwLFxuICBURVhUOiAweDEsXG4gIEJJTkFSWTogMHgyLFxuICBDTE9TRTogMHg4LFxuICBQSU5HOiAweDksXG4gIFBPTkc6IDB4QVxufVxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAdHlwZSB7NjU1MzV9IDIgKiogMTYgLSAxXG4gKi9cbmNvbnN0IG1heFVuc2lnbmVkMTZCaXQgPSA2NTUzNVxuXG4vKipcbiAqIFRoZSBzdGF0ZXMgb2YgdGhlIHBhcnNlci5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtXG4gKiBAcHJvcGVydHkgezB9IElORk9cbiAqIEBwcm9wZXJ0eSB7Mn0gUEFZTE9BRExFTkdUSF8xNlxuICogQHByb3BlcnR5IHszfSBQQVlMT0FETEVOR1RIXzY0XG4gKiBAcHJvcGVydHkgezR9IFJFQURfREFUQVxuICovXG5jb25zdCBwYXJzZXJTdGF0ZXMgPSB7XG4gIElORk86IDAsXG4gIFBBWUxPQURMRU5HVEhfMTY6IDIsXG4gIFBBWUxPQURMRU5HVEhfNjQ6IDMsXG4gIFJFQURfREFUQTogNFxufVxuXG4vKipcbiAqIEFuIGVtcHR5IGJ1ZmZlci5cbiAqXG4gKiBAdHlwZSB7QnVmZmVyfVxuICovXG5jb25zdCBlbXB0eUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuXG4vKipcbiAqIEByZWFkb25seVxuICogQHByb3BlcnR5IHsxfSB0ZXh0XG4gKiBAcHJvcGVydHkgezJ9IHR5cGVkQXJyYXlcbiAqIEBwcm9wZXJ0eSB7M30gYXJyYXlCdWZmZXJcbiAqIEBwcm9wZXJ0eSB7NH0gYmxvYlxuICovXG5jb25zdCBzZW5kSGludHMgPSB7XG4gIHRleHQ6IDEsXG4gIHR5cGVkQXJyYXk6IDIsXG4gIGFycmF5QnVmZmVyOiAzLFxuICBibG9iOiA0XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1aWQsXG4gIHNlbnRDbG9zZUZyYW1lU3RhdGUsXG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHN0YXRlcyxcbiAgb3Bjb2RlcyxcbiAgbWF4VW5zaWduZWQxNkJpdCxcbiAgcGFyc2VyU3RhdGVzLFxuICBlbXB0eUJ1ZmZlcixcbiAgc2VuZEhpbnRzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    if (type === kConstruct) {\n      super(arguments[1], arguments[2])\n      webidl.util.markAsUncloneable(this)\n      return\n    }\n\n    const prefix = 'MessageEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict')\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent')\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n\n  static createFastMessageEvent (type, init) {\n    const messageEvent = new MessageEvent(kConstruct, type, init)\n    messageEvent.#eventInit = init\n    messageEvent.#eventInit.data ??= null\n    messageEvent.#eventInit.origin ??= ''\n    messageEvent.#eventInit.lastEventId ??= ''\n    messageEvent.#eventInit.source ??= null\n    messageEvent.#eventInit.ports ??= []\n    return messageEvent\n  }\n}\n\nconst { createFastMessageEvent } = MessageEvent\ndelete MessageEvent.createFastMessageEvent\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    const prefix = 'CloseEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    const prefix = 'ErrorEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    super(type, eventInitDict)\n    webidl.util.markAsUncloneable(this)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(\n  webidl.is.MessagePort,\n  'MessagePort'\n)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: () => null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: () => null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    defaultValue: () => []\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent,\n  createFastMessageEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDekQsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXGV2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI21lc3NhZ2VldmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgaWYgKHR5cGUgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHN1cGVyKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKVxuICAgICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeCA9ICdNZXNzYWdlRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QsIHByZWZpeCwgJ2V2ZW50SW5pdERpY3QnKVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICB9XG5cbiAgZ2V0IGRhdGEgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZGF0YVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5vcmlnaW5cbiAgfVxuXG4gIGdldCBsYXN0RXZlbnRJZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5sYXN0RXZlbnRJZFxuICB9XG5cbiAgZ2V0IHNvdXJjZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5zb3VyY2VcbiAgfVxuXG4gIGdldCBwb3J0cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odGhpcy4jZXZlbnRJbml0LnBvcnRzKSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLiNldmVudEluaXQucG9ydHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5wb3J0c1xuICB9XG5cbiAgaW5pdE1lc3NhZ2VFdmVudCAoXG4gICAgdHlwZSxcbiAgICBidWJibGVzID0gZmFsc2UsXG4gICAgY2FuY2VsYWJsZSA9IGZhbHNlLFxuICAgIGRhdGEgPSBudWxsLFxuICAgIG9yaWdpbiA9ICcnLFxuICAgIGxhc3RFdmVudElkID0gJycsXG4gICAgc291cmNlID0gbnVsbCxcbiAgICBwb3J0cyA9IFtdXG4gICkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ01lc3NhZ2VFdmVudC5pbml0TWVzc2FnZUV2ZW50JylcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUV2ZW50KHR5cGUsIHtcbiAgICAgIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRhdGEsIG9yaWdpbiwgbGFzdEV2ZW50SWQsIHNvdXJjZSwgcG9ydHNcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgKHR5cGUsIGluaXQpIHtcbiAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KGtDb25zdHJ1Y3QsIHR5cGUsIGluaXQpXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQgPSBpbml0XG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQuZGF0YSA/Pz0gbnVsbFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0Lm9yaWdpbiA/Pz0gJydcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5sYXN0RXZlbnRJZCA/Pz0gJydcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5zb3VyY2UgPz89IG51bGxcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5wb3J0cyA/Pz0gW11cbiAgICByZXR1cm4gbWVzc2FnZUV2ZW50XG4gIH1cbn1cblxuY29uc3QgeyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IH0gPSBNZXNzYWdlRXZlbnRcbmRlbGV0ZSBNZXNzYWdlRXZlbnQuY3JlYXRlRmFzdE1lc3NhZ2VFdmVudFxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jdGhlLWNsb3NlZXZlbnQtaW50ZXJmYWNlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ0Nsb3NlRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdChldmVudEluaXREaWN0KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICB9XG5cbiAgZ2V0IHdhc0NsZWFuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC53YXNDbGVhblxuICB9XG5cbiAgZ2V0IGNvZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvZGVcbiAgfVxuXG4gIGdldCByZWFzb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnJlYXNvblxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCN0aGUtZXJyb3JldmVudC1pbnRlcmZhY2VcbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCkge1xuICAgIGNvbnN0IHByZWZpeCA9ICdFcnJvckV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCBtZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5tZXNzYWdlXG4gIH1cblxuICBnZXQgZmlsZW5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmZpbGVuYW1lXG4gIH1cblxuICBnZXQgbGluZW5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5saW5lbm9cbiAgfVxuXG4gIGdldCBjb2xubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29sbm9cbiAgfVxuXG4gIGdldCBlcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZXJyb3JcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNZXNzYWdlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdNZXNzYWdlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBkYXRhOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcmlnaW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxhc3RFdmVudElkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzb3VyY2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHBvcnRzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbml0TWVzc2FnZUV2ZW50OiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDbG9zZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2xvc2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIHJlYXNvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgd2FzQ2xlYW46IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVycm9yRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdFcnJvckV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZmlsZW5hbWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxpbmVubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29sbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5pcy5NZXNzYWdlUG9ydCxcbiAgJ01lc3NhZ2VQb3J0J1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0XG4pXG5cbmNvbnN0IGV2ZW50SW5pdCA9IFtcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdvcmlnaW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xhc3RFdmVudElkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzb3VyY2UnLFxuICAgIC8vIE5vZGUgZG9lc24ndCBpbXBsZW1lbnQgV2luZG93UHJveHkgb3IgU2VydmljZVdvcmtlciwgc28gdGhlIG9ubHlcbiAgICAvLyB2YWxpZCB2YWx1ZSBmb3Igc291cmNlIGlzIGEgTWVzc2FnZVBvcnQuXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQpLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAncG9ydHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gW11cbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ3dhc0NsZWFuJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlYXNvbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnbWVzc2FnZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZmlsZW5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xpbmVubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMFxuICB9LFxuICB7XG4gICAga2V5OiAnY29sbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2Vycm9yJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZUV2ZW50LFxuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { runtimeFeatures } = __webpack_require__(/*! ../../util/runtime-features */ \"(rsc)/./node_modules/undici/lib/util/runtime-features.js\")\nconst { maxUnsigned16Bit, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\n\nconst BUFFER_SIZE = 8 * 1024\n\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\nconst randomFillSync = runtimeFeatures.has('crypto')\n  ? (__webpack_require__(/*! node:crypto */ \"node:crypto\").randomFillSync)\n  // not full compatibility, but minimum.\n  : function randomFillSync (buffer, _offset, _size) {\n    for (let i = 0; i < buffer.length; ++i) {\n      buffer[i] = Math.random() * 255 | 0\n    }\n    return buffer\n  }\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    randomFillSync((buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n\n  /**\n   * @param {Uint8Array} buffer\n   */\n  static createFastTextFrame (buffer) {\n    const maskKey = generateMask()\n\n    const bodyLength = buffer.length\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[i] ^= maskKey[i & 3]\n    }\n\n    let payloadLength = bodyLength\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n    const head = Buffer.allocUnsafeSlow(offset)\n\n    head[0] = 0x80 /* FIN */ | opcodes.TEXT /* opcode TEXT */\n    head[1] = payloadLength | 0x80 /* MASK */\n    head[offset - 4] = maskKey[0]\n    head[offset - 3] = maskKey[1]\n    head[offset - 2] = maskKey[2]\n    head[offset - 1] = maskKey[3]\n\n    if (payloadLength === 126) {\n      head.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      head[2] = head[3] = 0\n      head.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    return [head, buffer]\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend,\n  generateMask // for benchmark\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyw2RkFBNkI7QUFDakUsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLCtFQUFhOztBQUUzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxzRUFBcUM7QUFDekM7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcZnJhbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcnVudGltZUZlYXR1cmVzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL3J1bnRpbWUtZmVhdHVyZXMnKVxuY29uc3QgeyBtYXhVbnNpZ25lZDE2Qml0LCBvcGNvZGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IEJVRkZFUl9TSVpFID0gOCAqIDEwMjRcblxubGV0IGJ1ZmZlciA9IG51bGxcbmxldCBidWZJZHggPSBCVUZGRVJfU0laRVxuXG5jb25zdCByYW5kb21GaWxsU3luYyA9IHJ1bnRpbWVGZWF0dXJlcy5oYXMoJ2NyeXB0bycpXG4gID8gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKS5yYW5kb21GaWxsU3luY1xuICAvLyBub3QgZnVsbCBjb21wYXRpYmlsaXR5LCBidXQgbWluaW11bS5cbiAgOiBmdW5jdGlvbiByYW5kb21GaWxsU3luYyAoYnVmZmVyLCBfb2Zmc2V0LCBfc2l6ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1IHwgMFxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXNrICgpIHtcbiAgaWYgKGJ1ZklkeCA9PT0gQlVGRkVSX1NJWkUpIHtcbiAgICBidWZJZHggPSAwXG4gICAgcmFuZG9tRmlsbFN5bmMoKGJ1ZmZlciA/Pz0gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhCVUZGRVJfU0laRSkpLCAwLCBCVUZGRVJfU0laRSlcbiAgfVxuICByZXR1cm4gW2J1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK11dXG59XG5cbmNsYXNzIFdlYnNvY2tldEZyYW1lU2VuZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnx1bmRlZmluZWR9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5mcmFtZURhdGEgPSBkYXRhXG4gIH1cblxuICBjcmVhdGVGcmFtZSAob3Bjb2RlKSB7XG4gICAgY29uc3QgZnJhbWVEYXRhID0gdGhpcy5mcmFtZURhdGFcbiAgICBjb25zdCBtYXNrS2V5ID0gZ2VuZXJhdGVNYXNrKClcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gZnJhbWVEYXRhPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gYm9keUxlbmd0aCAvLyAwLTEyNVxuICAgIGxldCBvZmZzZXQgPSA2XG5cbiAgICBpZiAoYm9keUxlbmd0aCA+IG1heFVuc2lnbmVkMTZCaXQpIHtcbiAgICAgIG9mZnNldCArPSA4IC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgOCBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyN1xuICAgIH0gZWxzZSBpZiAoYm9keUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDIgLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCAyIGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJvZHlMZW5ndGggKyBvZmZzZXQpXG5cbiAgICAvLyBDbGVhciBmaXJzdCAyIGJ5dGVzLCBldmVyeXRoaW5nIGVsc2UgaXMgb3ZlcndyaXR0ZW5cbiAgICBidWZmZXJbMF0gPSBidWZmZXJbMV0gPSAwXG4gICAgYnVmZmVyWzBdIHw9IDB4ODAgLy8gRklOXG4gICAgYnVmZmVyWzBdID0gKGJ1ZmZlclswXSAmIDB4RjApICsgb3Bjb2RlIC8vIG9wY29kZVxuXG4gICAgLyohIHdzLiBNSVQgTGljZW5zZS4gRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+ICovXG4gICAgYnVmZmVyW29mZnNldCAtIDRdID0gbWFza0tleVswXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAzXSA9IG1hc2tLZXlbMV1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMl0gPSBtYXNrS2V5WzJdXG4gICAgYnVmZmVyW29mZnNldCAtIDFdID0gbWFza0tleVszXVxuXG4gICAgYnVmZmVyWzFdID0gcGF5bG9hZExlbmd0aFxuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgYnVmZmVyLndyaXRlVUludDE2QkUoYm9keUxlbmd0aCwgMilcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgLy8gQ2xlYXIgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGhcbiAgICAgIGJ1ZmZlclsyXSA9IGJ1ZmZlclszXSA9IDBcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnRCRShib2R5TGVuZ3RoLCA0LCA2KVxuICAgIH1cblxuICAgIGJ1ZmZlclsxXSB8PSAweDgwIC8vIE1BU0tcblxuICAgIC8vIG1hc2sgYm9keVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBmcmFtZURhdGFbaV0gXiBtYXNrS2V5W2kgJiAzXVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUZhc3RUZXh0RnJhbWUgKGJ1ZmZlcikge1xuICAgIGNvbnN0IG1hc2tLZXkgPSBnZW5lcmF0ZU1hc2soKVxuXG4gICAgY29uc3QgYm9keUxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcblxuICAgIC8vIG1hc2sgYm9keVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmZXJbaV0gXj0gbWFza0tleVtpICYgM11cbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGJvZHlMZW5ndGhcbiAgICBsZXQgb2Zmc2V0ID0gNlxuXG4gICAgaWYgKGJvZHlMZW5ndGggPiBtYXhVbnNpZ25lZDE2Qml0KSB7XG4gICAgICBvZmZzZXQgKz0gOCAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDggYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjdcbiAgICB9IGVsc2UgaWYgKGJvZHlMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyIC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgMiBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNlxuICAgIH1cbiAgICBjb25zdCBoZWFkID0gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhvZmZzZXQpXG5cbiAgICBoZWFkWzBdID0gMHg4MCAvKiBGSU4gKi8gfCBvcGNvZGVzLlRFWFQgLyogb3Bjb2RlIFRFWFQgKi9cbiAgICBoZWFkWzFdID0gcGF5bG9hZExlbmd0aCB8IDB4ODAgLyogTUFTSyAqL1xuICAgIGhlYWRbb2Zmc2V0IC0gNF0gPSBtYXNrS2V5WzBdXG4gICAgaGVhZFtvZmZzZXQgLSAzXSA9IG1hc2tLZXlbMV1cbiAgICBoZWFkW29mZnNldCAtIDJdID0gbWFza0tleVsyXVxuICAgIGhlYWRbb2Zmc2V0IC0gMV0gPSBtYXNrS2V5WzNdXG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICBoZWFkLndyaXRlVUludDE2QkUoYm9keUxlbmd0aCwgMilcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgaGVhZFsyXSA9IGhlYWRbM10gPSAwXG4gICAgICBoZWFkLndyaXRlVUludEJFKGJvZHlMZW5ndGgsIDQsIDYpXG4gICAgfVxuXG4gICAgcmV0dXJuIFtoZWFkLCBidWZmZXJdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYnNvY2tldEZyYW1lU2VuZCxcbiAgZ2VuZXJhdGVNYXNrIC8vIGZvciBiZW5jaG1hcmtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\n\nconst tail = Buffer.from([0x00, 0x00, 0xff, 0xff])\nconst kBuffer = Symbol('kBuffer')\nconst kLength = Symbol('kLength')\n\nclass PerMessageDeflate {\n  /** @type {import('node:zlib').InflateRaw} */\n  #inflate\n\n  #options = {}\n\n  constructor (extensions) {\n    this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover')\n    this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits')\n  }\n\n  decompress (chunk, fin, callback) {\n    // An endpoint uses the following algorithm to decompress a message.\n    // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n    //     payload of the message.\n    // 2.  Decompress the resulting data using DEFLATE.\n\n    if (!this.#inflate) {\n      let windowBits = Z_DEFAULT_WINDOWBITS\n\n      if (this.#options.serverMaxWindowBits) { // empty values default to Z_DEFAULT_WINDOWBITS\n        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n          callback(new Error('Invalid server_max_window_bits'))\n          return\n        }\n\n        windowBits = Number.parseInt(this.#options.serverMaxWindowBits)\n      }\n\n      this.#inflate = createInflateRaw({ windowBits })\n      this.#inflate[kBuffer] = []\n      this.#inflate[kLength] = 0\n\n      this.#inflate.on('data', (data) => {\n        this.#inflate[kBuffer].push(data)\n        this.#inflate[kLength] += data.length\n      })\n\n      this.#inflate.on('error', (err) => {\n        this.#inflate = null\n        callback(err)\n      })\n    }\n\n    this.#inflate.write(chunk)\n    if (fin) {\n      this.#inflate.write(tail)\n    }\n\n    this.#inflate.flush(() => {\n      const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength])\n\n      this.#inflate[kBuffer].length = 0\n      this.#inflate[kLength] = 0\n\n      callback(null, full)\n    })\n  }\n}\n\nmodule.exports = { PerMessageDeflate }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDdEUsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFFQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxccGVybWVzc2FnZS1kZWZsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZUluZmxhdGVSYXcsIFpfREVGQVVMVF9XSU5ET1dCSVRTIH0gPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3QgeyBpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgdGFpbCA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSlcbmNvbnN0IGtCdWZmZXIgPSBTeW1ib2woJ2tCdWZmZXInKVxuY29uc3Qga0xlbmd0aCA9IFN5bWJvbCgna0xlbmd0aCcpXG5cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6emxpYicpLkluZmxhdGVSYXd9ICovXG4gICNpbmZsYXRlXG5cbiAgI29wdGlvbnMgPSB7fVxuXG4gIGNvbnN0cnVjdG9yIChleHRlbnNpb25zKSB7XG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9IGV4dGVuc2lvbnMuaGFzKCdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcicpXG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID0gZXh0ZW5zaW9ucy5nZXQoJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKVxuICB9XG5cbiAgZGVjb21wcmVzcyAoY2h1bmssIGZpbiwgY2FsbGJhY2spIHtcbiAgICAvLyBBbiBlbmRwb2ludCB1c2VzIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtIHRvIGRlY29tcHJlc3MgYSBtZXNzYWdlLlxuICAgIC8vIDEuICBBcHBlbmQgNCBvY3RldHMgb2YgMHgwMCAweDAwIDB4ZmYgMHhmZiB0byB0aGUgdGFpbCBlbmQgb2YgdGhlXG4gICAgLy8gICAgIHBheWxvYWQgb2YgdGhlIG1lc3NhZ2UuXG4gICAgLy8gMi4gIERlY29tcHJlc3MgdGhlIHJlc3VsdGluZyBkYXRhIHVzaW5nIERFRkxBVEUuXG5cbiAgICBpZiAoIXRoaXMuI2luZmxhdGUpIHtcbiAgICAgIGxldCB3aW5kb3dCaXRzID0gWl9ERUZBVUxUX1dJTkRPV0JJVFNcblxuICAgICAgaWYgKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykgeyAvLyBlbXB0eSB2YWx1ZXMgZGVmYXVsdCB0byBaX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICBpZiAoIWlzVmFsaWRDbGllbnRXaW5kb3dCaXRzKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykpIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmVyX21heF93aW5kb3dfYml0cycpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Qml0cyA9IE51bWJlci5wYXJzZUludCh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2luZmxhdGUgPSBjcmVhdGVJbmZsYXRlUmF3KHsgd2luZG93Qml0cyB9KVxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSA9IFtdXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICB0aGlzLiNpbmZsYXRlLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5wdXNoKGRhdGEpXG4gICAgICAgIHRoaXMuI2luZmxhdGVba0xlbmd0aF0gKz0gZGF0YS5sZW5ndGhcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuI2luZmxhdGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNpbmZsYXRlID0gbnVsbFxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUud3JpdGUoY2h1bmspXG4gICAgaWYgKGZpbikge1xuICAgICAgdGhpcy4jaW5mbGF0ZS53cml0ZSh0YWlsKVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZnVsbCA9IEJ1ZmZlci5jb25jYXQodGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSwgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSlcblxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5sZW5ndGggPSAwXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICBjYWxsYmFjayhudWxsLCBmdWxsKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFBlck1lc3NhZ2VEZWZsYXRlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { failWebsocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\")\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #fragmentsBytes = 0\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  /** @type {import('./websocket').Handler} */\n  #handler\n\n  constructor (handler, extensions) {\n    super()\n\n    this.#handler = handler\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.#handler, 1002, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.#handler, 1002, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.#handler, 1002, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.#handler, 1002, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.#handler, 1002, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.#handler, 1009, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.writeFragments(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                failWebsocketConnection(this.#handler, 1007, error.message)\n                return\n              }\n\n              this.writeFragments(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    this.#byteOffset -= n\n\n    const first = this.#buffers[0]\n\n    if (first.length > n) {\n      // replace with remaining buffer\n      this.#buffers[0] = first.subarray(n, first.length)\n      return first.subarray(0, n)\n    } else if (first.length === n) {\n      // prefect match\n      return this.#buffers.shift()\n    } else {\n      let offset = 0\n      // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n      const buffer = Buffer.allocUnsafeSlow(n)\n      while (offset !== n) {\n        const next = this.#buffers[0]\n        const length = next.length\n\n        if (length + offset === n) {\n          buffer.set(this.#buffers.shift(), offset)\n          break\n        } else if (length + offset > n) {\n          buffer.set(next.subarray(0, n - offset), offset)\n          this.#buffers[0] = next.subarray(n - offset)\n          break\n        } else {\n          buffer.set(this.#buffers.shift(), offset)\n          offset += length\n        }\n      }\n\n      return buffer\n    }\n  }\n\n  writeFragments (fragment) {\n    this.#fragmentsBytes += fragment.length\n    this.#fragments.push(fragment)\n  }\n\n  consumeFragments () {\n    const fragments = this.#fragments\n\n    if (fragments.length === 1) {\n      // single fragment\n      this.#fragmentsBytes = 0\n      return fragments.shift()\n    }\n\n    let offset = 0\n    // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n    const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes)\n\n    for (let i = 0; i < fragments.length; ++i) {\n      const buffer = fragments[i]\n      output.set(buffer, offset)\n      offset += buffer.length\n    }\n\n    this.#fragments = []\n    this.#fragmentsBytes = 0\n\n    return output\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.#handler, 1002, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        failWebsocketConnection(this.#handler, code, reason)\n        return false\n      }\n\n      // Upon receiving such a frame, the other peer sends a\n      // Close frame in response, if it hasn't already sent one.\n      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE))\n        this.#handler.closeState.add(sentCloseFrameState.SENT)\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.#handler.readyState = states.CLOSING\n      this.#handler.closeState.add(sentCloseFrameState.RECEIVED)\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(frame.createFrame(opcodes.PONG))\n\n        this.#handler.onPing(body)\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n      this.#handler.onPong(body)\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDcEIsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLGlGQUFjO0FBQzFELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUztBQUNoRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsaUdBQXNCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxnQ0FBZ0M7QUFDN0M7O0FBRUEsYUFBYSwrQkFBK0I7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDZDQUE2QyxNQUFNLE1BQU07QUFDckoscUdBQXFHLEtBQUs7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWU7QUFDZjs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHJlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHBhcnNlclN0YXRlcywgb3Bjb2Rlcywgc3RhdGVzLCBlbXB0eUJ1ZmZlciwgc2VudENsb3NlRnJhbWVTdGF0ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZE9wY29kZSxcbiAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkLFxuICB1dGY4RGVjb2RlLFxuICBpc0NvbnRyb2xGcmFtZSxcbiAgaXNUZXh0QmluYXJ5RnJhbWUsXG4gIGlzQ29udGludWF0aW9uRnJhbWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgUGVyTWVzc2FnZURlZmxhdGUgfSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJylcblxuLy8gVGhpcyBjb2RlIHdhcyBpbmZsdWVuY2VkIGJ5IHdzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCAoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBcm5vdXQgS2F6ZW1pZXIgYW5kIGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE2IEx1aWdpIFBpbmNhIGFuZCBjb250cmlidXRvcnNcblxuY2xhc3MgQnl0ZVBhcnNlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgI2J1ZmZlcnMgPSBbXVxuICAjZnJhZ21lbnRzQnl0ZXMgPSAwXG4gICNieXRlT2Zmc2V0ID0gMFxuICAjbG9vcCA9IGZhbHNlXG5cbiAgI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAjaW5mbyA9IHt9XG4gICNmcmFnbWVudHMgPSBbXVxuXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgUGVyTWVzc2FnZURlZmxhdGU+fSAqL1xuICAjZXh0ZW5zaW9uc1xuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLkhhbmRsZXJ9ICovXG4gICNoYW5kbGVyXG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXIsIGV4dGVuc2lvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zID09IG51bGwgPyBuZXcgTWFwKCkgOiBleHRlbnNpb25zXG5cbiAgICBpZiAodGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zLnNldCgncGVybWVzc2FnZS1kZWZsYXRlJywgbmV3IFBlck1lc3NhZ2VEZWZsYXRlKGV4dGVuc2lvbnMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNidWZmZXJzLnB1c2goY2h1bmspXG4gICAgdGhpcy4jYnl0ZU9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLiNsb29wID0gdHJ1ZVxuXG4gICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUnVucyB3aGVuZXZlciBhIG5ldyBjaHVuayBpcyByZWNlaXZlZC5cbiAgICogQ2FsbGJhY2sgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyBidWZmZXJpbmcsXG4gICAqIG9yIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGJ1ZmZlcmVkIHRvIHBhcnNlLlxuICAgKi9cbiAgcnVuIChjYWxsYmFjaykge1xuICAgIHdoaWxlICh0aGlzLiNsb29wKSB7XG4gICAgICBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5JTkZPKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBlbm91Z2ggYnl0ZXMgdG8gcGFyc2UgdGhlIHBheWxvYWQgbGVuZ3RoLCBldGMuXG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcbiAgICAgICAgY29uc3QgZmluID0gKGJ1ZmZlclswXSAmIDB4ODApICE9PSAwXG4gICAgICAgIGNvbnN0IG9wY29kZSA9IGJ1ZmZlclswXSAmIDB4MEZcbiAgICAgICAgY29uc3QgbWFza2VkID0gKGJ1ZmZlclsxXSAmIDB4ODApID09PSAweDgwXG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnRlZCA9ICFmaW4gJiYgb3Bjb2RlICE9PSBvcGNvZGVzLkNPTlRJTlVBVElPTlxuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gYnVmZmVyWzFdICYgMHg3RlxuXG4gICAgICAgIGNvbnN0IHJzdjEgPSBidWZmZXJbMF0gJiAweDQwXG4gICAgICAgIGNvbnN0IHJzdjIgPSBidWZmZXJbMF0gJiAweDIwXG4gICAgICAgIGNvbnN0IHJzdjMgPSBidWZmZXJbMF0gJiAweDEwXG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkT3Bjb2RlKG9wY29kZSkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCAxMDAyLCAnSW52YWxpZCBvcGNvZGUgcmVjZWl2ZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFza2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0ZyYW1lIGNhbm5vdCBiZSBtYXNrZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBNVVNUIGJlIDAgdW5sZXNzIGFuIGV4dGVuc2lvbiBpcyBuZWdvdGlhdGVkIHRoYXQgZGVmaW5lcyBtZWFuaW5nc1xuICAgICAgICAvLyBmb3Igbm9uLXplcm8gdmFsdWVzLiAgSWYgYSBub256ZXJvIHZhbHVlIGlzIHJlY2VpdmVkIGFuZCBub25lIG9mXG4gICAgICAgIC8vIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnMgZGVmaW5lcyB0aGUgbWVhbmluZyBvZiBzdWNoIGEgbm9uemVyb1xuICAgICAgICAvLyB2YWx1ZSwgdGhlIHJlY2VpdmluZyBlbmRwb2ludCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgICAgLy8gQ29ubmVjdGlvbl8uXG4gICAgICAgIC8vIFRoaXMgZG9jdW1lbnQgYWxsb2NhdGVzIHRoZSBSU1YxIGJpdCBvZiB0aGUgV2ViU29ja2V0IGhlYWRlciBmb3JcbiAgICAgICAgLy8gUE1DRXMgYW5kIGNhbGxzIHRoZSBiaXQgdGhlIFwiUGVyLU1lc3NhZ2UgQ29tcHJlc3NlZFwiIGJpdC4gIE9uIGFcbiAgICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gd2hlcmUgYSBQTUNFIGlzIGluIHVzZSwgdGhpcyBiaXQgaW5kaWNhdGVzXG4gICAgICAgIC8vIHdoZXRoZXIgYSBtZXNzYWdlIGlzIGNvbXByZXNzZWQgb3Igbm90LlxuICAgICAgICBpZiAocnN2MSAhPT0gMCAmJiAhdGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0V4cGVjdGVkIFJTVjEgdG8gYmUgY2xlYXIuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyc3YyICE9PSAwIHx8IHJzdjMgIT09IDApIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCAxMDAyLCAnUlNWMSwgUlNWMiwgUlNWMyBtdXN0IGJlIGNsZWFyJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudGVkICYmICFpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgLy8gT25seSB0ZXh0IGFuZCBiaW5hcnkgZnJhbWVzIGNhbiBiZSBmcmFnbWVudGVkXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0ludmFsaWQgZnJhbWUgdHlwZSB3YXMgZnJhZ21lbnRlZC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFyc2luZyBhIHRleHQvYmluYXJ5IGZyYW1lIGFuZCBkbyBub3QgcmVjZWl2ZSBlaXRoZXJcbiAgICAgICAgLy8gYSBjb250aW51YXRpb24gZnJhbWUgb3IgY2xvc2UgZnJhbWUsIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIGlmIChpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpICYmIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0V4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIGZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAvLyBBIGZyYWdtZW50ZWQgZnJhbWUgY2FuJ3QgYmUgZnJhZ21lbnRlZCBpdHNlbGZcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCAxMDAyLCAnRnJhZ21lbnRlZCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFwiQWxsIGNvbnRyb2wgZnJhbWVzIE1VU1QgaGF2ZSBhIHBheWxvYWQgbGVuZ3RoIG9mIDEyNSBieXRlcyBvciBsZXNzXG4gICAgICAgIC8vIGFuZCBNVVNUIE5PVCBiZSBmcmFnbWVudGVkLlwiXG4gICAgICAgIGlmICgocGF5bG9hZExlbmd0aCA+IDEyNSB8fCBmcmFnbWVudGVkKSAmJiBpc0NvbnRyb2xGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0NvbnRyb2wgZnJhbWUgZWl0aGVyIHRvbyBsYXJnZSBvciBmcmFnbWVudGVkJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbnRpbnVhdGlvbkZyYW1lKG9wY29kZSkgJiYgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy4jaW5mby5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ1VuZXhwZWN0ZWQgY29udGludWF0aW9uIGZyYW1lJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoIDw9IDEyNSkge1xuICAgICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IHBheWxvYWRMZW5ndGhcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLmJpbmFyeVR5cGUgPSBvcGNvZGVcbiAgICAgICAgICB0aGlzLiNpbmZvLmNvbXByZXNzZWQgPSByc3YxICE9PSAwXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9IG9wY29kZVxuICAgICAgICB0aGlzLiNpbmZvLm1hc2tlZCA9IG1hc2tlZFxuICAgICAgICB0aGlzLiNpbmZvLmZpbiA9IGZpblxuICAgICAgICB0aGlzLiNpbmZvLmZyYWdtZW50ZWQgPSBmcmFnbWVudGVkXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNikge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKVxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoOClcbiAgICAgICAgY29uc3QgdXBwZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG5cbiAgICAgICAgLy8gMl4zMSBpcyB0aGUgbWF4aW11bSBieXRlcyBhbiBhcnJheWJ1ZmZlciBjYW4gY29udGFpblxuICAgICAgICAvLyBvbiAzMi1iaXQgc3lzdGVtcy4gQWx0aG91Z2gsIG9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzXG4gICAgICAgIC8vIDJeNTMtMSBieXRlcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0ludmFsaWRfYXJyYXlfbGVuZ3RoXG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9jb21tb24vZ2xvYmFscy5oO2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlO2Jwdj0xO2JwdD0xO2w9MTI3NVxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvb2JqZWN0cy9qcy1hcnJheS1idWZmZXIuaDtsPTM0O2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlXG4gICAgICAgIGlmICh1cHBlciA+IDIgKiogMzEgLSAxKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwOSwgJ1JlY2VpdmVkIHBheWxvYWQgbGVuZ3RoID4gMl4zMSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDQpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gKHVwcGVyIDw8IDgpICsgbG93ZXJcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBKSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUodGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgIGlmIChpc0NvbnRyb2xGcmFtZSh0aGlzLiNpbmZvLm9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNsb29wID0gdGhpcy5wYXJzZUNvbnRyb2xGcmFtZShib2R5KVxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUZyYWdtZW50cyhib2R5KVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgbm90IGZyYWdtZW50ZWQsIGEgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmcmFtZSBpcyBmcmFnbWVudGVkLCBpdCB3aWxsIHRlcm1pbmF0ZSB3aXRoIGEgZmluIGJpdCBzZXRcbiAgICAgICAgICAgIC8vIGFuZCBhbiBvcGNvZGUgb2YgMCAoY29udGludWF0aW9uKSwgdGhlcmVmb3JlIHdlIGhhbmRsZSB0aGF0IHdoZW5cbiAgICAgICAgICAgIC8vIHBhcnNpbmcgY29udGludWF0aW9uIGZyYW1lcywgbm90IGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiB0aGlzLiNpbmZvLmZpbikge1xuICAgICAgICAgICAgICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQodGhpcy4jaGFuZGxlciwgdGhpcy4jaW5mby5iaW5hcnlUeXBlLCB0aGlzLmNvbnN1bWVGcmFnbWVudHMoKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNleHRlbnNpb25zLmdldCgncGVybWVzc2FnZS1kZWZsYXRlJykuZGVjb21wcmVzcyhib2R5LCB0aGlzLiNpbmZvLmZpbiwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDcsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLndyaXRlRnJhZ21lbnRzKGRhdGEpXG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICAgICAgICB0aGlzLiNsb29wID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMuI2hhbmRsZXIsIHRoaXMuI2luZm8uYmluYXJ5VHlwZSwgdGhpcy5jb25zdW1lRnJhZ21lbnRzKCkpXG5cbiAgICAgICAgICAgICAgdGhpcy4jbG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICAgICAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuI2xvb3AgPSBmYWxzZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBuIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIEJ1ZmZlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIGNvbnN1bWUgKG4pIHtcbiAgICBpZiAobiA+IHRoaXMuI2J5dGVPZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGNvbnN1bWUoKSBiZWZvcmUgYnVmZmVycyBzYXRpYXRlZC4nKVxuICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5QnVmZmVyXG4gICAgfVxuXG4gICAgdGhpcy4jYnl0ZU9mZnNldCAtPSBuXG5cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2J1ZmZlcnNbMF1cblxuICAgIGlmIChmaXJzdC5sZW5ndGggPiBuKSB7XG4gICAgICAvLyByZXBsYWNlIHdpdGggcmVtYWluaW5nIGJ1ZmZlclxuICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IGZpcnN0LnN1YmFycmF5KG4sIGZpcnN0Lmxlbmd0aClcbiAgICAgIHJldHVybiBmaXJzdC5zdWJhcnJheSgwLCBuKVxuICAgIH0gZWxzZSBpZiAoZmlyc3QubGVuZ3RoID09PSBuKSB7XG4gICAgICAvLyBwcmVmZWN0IG1hdGNoXG4gICAgICByZXR1cm4gdGhpcy4jYnVmZmVycy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvZmZzZXQgPSAwXG4gICAgICAvLyBJZiBCdWZmZXIuYWxsb2NVbnNhZmUgaXMgdXNlZCwgZXh0cmEgY29waWVzIHdpbGwgYmUgbWFkZSBiZWNhdXNlIHRoZSBvZmZzZXQgaXMgbm9uLXplcm8uXG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KG4pXG4gICAgICB3aGlsZSAob2Zmc2V0ICE9PSBuKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLiNidWZmZXJzWzBdXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG5leHQubGVuZ3RoXG5cbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA9PT0gbikge1xuICAgICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggKyBvZmZzZXQgPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNldChuZXh0LnN1YmFycmF5KDAsIG4gLSBvZmZzZXQpLCBvZmZzZXQpXG4gICAgICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IG5leHQuc3ViYXJyYXkobiAtIG9mZnNldClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG4gIH1cblxuICB3cml0ZUZyYWdtZW50cyAoZnJhZ21lbnQpIHtcbiAgICB0aGlzLiNmcmFnbWVudHNCeXRlcyArPSBmcmFnbWVudC5sZW5ndGhcbiAgICB0aGlzLiNmcmFnbWVudHMucHVzaChmcmFnbWVudClcbiAgfVxuXG4gIGNvbnN1bWVGcmFnbWVudHMgKCkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuI2ZyYWdtZW50c1xuXG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHNpbmdsZSBmcmFnbWVudFxuICAgICAgdGhpcy4jZnJhZ21lbnRzQnl0ZXMgPSAwXG4gICAgICByZXR1cm4gZnJhZ21lbnRzLnNoaWZ0KClcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0ID0gMFxuICAgIC8vIElmIEJ1ZmZlci5hbGxvY1Vuc2FmZSBpcyB1c2VkLCBleHRyYSBjb3BpZXMgd2lsbCBiZSBtYWRlIGJlY2F1c2UgdGhlIG9mZnNldCBpcyBub24temVyby5cbiAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHRoaXMuI2ZyYWdtZW50c0J5dGVzKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYWdtZW50c1tpXVxuICAgICAgb3V0cHV0LnNldChidWZmZXIsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoXG4gICAgfVxuXG4gICAgdGhpcy4jZnJhZ21lbnRzID0gW11cbiAgICB0aGlzLiNmcmFnbWVudHNCeXRlcyA9IDBcblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIHBhcnNlQ2xvc2VCb2R5IChkYXRhKSB7XG4gICAgYXNzZXJ0KGRhdGEubGVuZ3RoICE9PSAxKVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjVcbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvZGVcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAyKSB7XG4gICAgICAvLyBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzXG4gICAgICAvLyBkZWZpbmVkIGFzIHRoZSBzdGF0dXMgY29kZSAoU2VjdGlvbiA3LjQpIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3QgQ2xvc2VcbiAgICAgIC8vIGNvbnRyb2wgZnJhbWUgcmVjZWl2ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMClcbiAgICB9XG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIHsgY29kZTogMTAwMiwgcmVhc29uOiAnSW52YWxpZCBzdGF0dXMgY29kZScsIGVycm9yOiB0cnVlIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNlxuICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgIGxldCByZWFzb24gPSBkYXRhLnN1YmFycmF5KDIpXG5cbiAgICAvLyBSZW1vdmUgQk9NXG4gICAgaWYgKHJlYXNvblswXSA9PT0gMHhFRiAmJiByZWFzb25bMV0gPT09IDB4QkIgJiYgcmVhc29uWzJdID09PSAweEJGKSB7XG4gICAgICByZWFzb24gPSByZWFzb24uc3ViYXJyYXkoMylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmVhc29uID0gdXRmOERlY29kZShyZWFzb24pXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4geyBjb2RlOiAxMDA3LCByZWFzb246ICdJbnZhbGlkIFVURi04JywgZXJyb3I6IHRydWUgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIHJlYXNvbiwgZXJyb3I6IGZhbHNlIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgY29udHJvbCBmcmFtZXMuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBib2R5XG4gICAqL1xuICBwYXJzZUNvbnRyb2xGcmFtZSAoYm9keSkge1xuICAgIGNvbnN0IHsgb3Bjb2RlLCBwYXlsb2FkTGVuZ3RoIH0gPSB0aGlzLiNpbmZvXG5cbiAgICBpZiAob3Bjb2RlID09PSBvcGNvZGVzLkNMT1NFKSB7XG4gICAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCAxMDAyLCAnUmVjZWl2ZWQgY2xvc2UgZnJhbWUgd2l0aCBhIDEtYnl0ZSBib2R5LicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNpbmZvLmNsb3NlSW5mbyA9IHRoaXMucGFyc2VDbG9zZUJvZHkoYm9keSlcblxuICAgICAgaWYgKHRoaXMuI2luZm8uY2xvc2VJbmZvLmVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZSwgcmVhc29uIH0gPSB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuXG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIGNvZGUsIHJlYXNvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIFVwb24gcmVjZWl2aW5nIHN1Y2ggYSBmcmFtZSwgdGhlIG90aGVyIHBlZXIgc2VuZHMgYVxuICAgICAgLy8gQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UsIGlmIGl0IGhhc24ndCBhbHJlYWR5IHNlbnQgb25lLlxuICAgICAgaWYgKCF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkgJiYgIXRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5SRUNFSVZFRCkpIHtcbiAgICAgICAgLy8gSWYgYW4gZW5kcG9pbnQgcmVjZWl2ZXMgYSBDbG9zZSBmcmFtZSBhbmQgZGlkIG5vdCBwcmV2aW91c2x5IHNlbmQgYVxuICAgICAgICAvLyBDbG9zZSBmcmFtZSwgdGhlIGVuZHBvaW50IE1VU1Qgc2VuZCBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLiAgKFdoZW5cbiAgICAgICAgLy8gc2VuZGluZyBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLCB0aGUgZW5kcG9pbnQgdHlwaWNhbGx5IGVjaG9zIHRoZVxuICAgICAgICAvLyBzdGF0dXMgY29kZSBpdCByZWNlaXZlZC4pXG4gICAgICAgIGxldCBib2R5ID0gZW1wdHlCdWZmZXJcbiAgICAgICAgaWYgKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUpIHtcbiAgICAgICAgICBib2R5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICAgICAgYm9keS53cml0ZVVJbnQxNkJFKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUsIDApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvc2VGcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYm9keSlcblxuICAgICAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC53cml0ZShjbG9zZUZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpKVxuICAgICAgICB0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuYWRkKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVClcbiAgICAgIH1cblxuICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuICAgICAgdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmFkZChzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HKSB7XG4gICAgICAvLyBVcG9uIHJlY2VpcHQgb2YgYSBQaW5nIGZyYW1lLCBhbiBlbmRwb2ludCBNVVNUIHNlbmQgYSBQb25nIGZyYW1lIGluXG4gICAgICAvLyByZXNwb25zZSwgdW5sZXNzIGl0IGFscmVhZHkgcmVjZWl2ZWQgYSBDbG9zZSBmcmFtZS5cbiAgICAgIC8vIEEgUG9uZyBmcmFtZSBzZW50IGluIHJlc3BvbnNlIHRvIGEgUGluZyBmcmFtZSBtdXN0IGhhdmUgaWRlbnRpY2FsXG4gICAgICAvLyBcIkFwcGxpY2F0aW9uIGRhdGFcIlxuXG4gICAgICBpZiAoIXRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5SRUNFSVZFRCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgdGhpcy4jaGFuZGxlci5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5QT05HKSlcblxuICAgICAgICB0aGlzLiNoYW5kbGVyLm9uUGluZyhib2R5KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3Bjb2RlID09PSBvcGNvZGVzLlBPTkcpIHtcbiAgICAgIC8vIEEgUG9uZyBmcmFtZSBNQVkgYmUgc2VudCB1bnNvbGljaXRlZC4gIFRoaXMgc2VydmVzIGFzIGFcbiAgICAgIC8vIHVuaWRpcmVjdGlvbmFsIGhlYXJ0YmVhdC4gIEEgcmVzcG9uc2UgdG8gYW4gdW5zb2xpY2l0ZWQgUG9uZyBmcmFtZSBpc1xuICAgICAgLy8gbm90IGV4cGVjdGVkLlxuICAgICAgdGhpcy4jaGFuZGxlci5vblBvbmcoYm9keSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZ2V0IGNsb3NpbmdJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5mby5jbG9zZUluZm9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQnl0ZVBhcnNlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      if (!this.#running) {\n        // TODO(@tsctx): support fast-path for string on running\n        if (hint === sendHints.text) {\n          // special fast-path for string\n          const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item)\n          this.#socket.cork()\n          this.#socket.write(head)\n          this.#socket.write(body, cb)\n          this.#socket.uncork()\n        } else {\n          // direct writing\n          this.#socket.write(createFrame(item, hint), cb)\n        }\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame: createFrame(item, hint)\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.text:\n    case sendHints.typedArray:\n      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new Uint8Array(data)\n  }\n}\n\nmodule.exports = { SendQueue }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLCtGQUE4Qjs7QUFFekQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcc2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IG9wY29kZXMsIHNlbmRIaW50cyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4uLy4uL2Rpc3BhdGNoZXIvZml4ZWQtcXVldWUnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRRdWV1ZU5vZGVcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9IHByb21pc2VcbiAqIEBwcm9wZXJ0eSB7KCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KX0gY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7QnVmZmVyIHwgbnVsbH0gZnJhbWVcbiAqL1xuXG5jbGFzcyBTZW5kUXVldWUge1xuICAvKipcbiAgICogQHR5cGUge0ZpeGVkUXVldWV9XG4gICAqL1xuICAjcXVldWUgPSBuZXcgRml4ZWRRdWV1ZSgpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgI3J1bm5pbmcgPSBmYWxzZVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOm5ldCcpLlNvY2tldH0gKi9cbiAgI3NvY2tldFxuXG4gIGNvbnN0cnVjdG9yIChzb2NrZXQpIHtcbiAgICB0aGlzLiNzb2NrZXQgPSBzb2NrZXRcbiAgfVxuXG4gIGFkZCAoaXRlbSwgY2IsIGhpbnQpIHtcbiAgICBpZiAoaGludCAhPT0gc2VuZEhpbnRzLmJsb2IpIHtcbiAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAvLyBUT0RPKEB0c2N0eCk6IHN1cHBvcnQgZmFzdC1wYXRoIGZvciBzdHJpbmcgb24gcnVubmluZ1xuICAgICAgICBpZiAoaGludCA9PT0gc2VuZEhpbnRzLnRleHQpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZhc3QtcGF0aCBmb3Igc3RyaW5nXG4gICAgICAgICAgY29uc3QgeyAwOiBoZWFkLCAxOiBib2R5IH0gPSBXZWJzb2NrZXRGcmFtZVNlbmQuY3JlYXRlRmFzdFRleHRGcmFtZShpdGVtKVxuICAgICAgICAgIHRoaXMuI3NvY2tldC5jb3JrKClcbiAgICAgICAgICB0aGlzLiNzb2NrZXQud3JpdGUoaGVhZClcbiAgICAgICAgICB0aGlzLiNzb2NrZXQud3JpdGUoYm9keSwgY2IpXG4gICAgICAgICAgdGhpcy4jc29ja2V0LnVuY29yaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGlyZWN0IHdyaXRpbmdcbiAgICAgICAgICB0aGlzLiNzb2NrZXQud3JpdGUoY3JlYXRlRnJhbWUoaXRlbSwgaGludCksIGNiKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgICAgZnJhbWU6IGNyZWF0ZUZyYW1lKGl0ZW0sIGhpbnQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcXVldWUucHVzaChub2RlKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtTZW5kUXVldWVOb2RlfSAqL1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBwcm9taXNlOiBpdGVtLmFycmF5QnVmZmVyKCkudGhlbigoYWIpID0+IHtcbiAgICAgICAgbm9kZS5wcm9taXNlID0gbnVsbFxuICAgICAgICBub2RlLmZyYW1lID0gY3JlYXRlRnJhbWUoYWIsIGhpbnQpXG4gICAgICB9KSxcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIGZyYW1lOiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy4jcXVldWUucHVzaChub2RlKVxuXG4gICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICB0aGlzLiNydW4oKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jICNydW4gKCkge1xuICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlXG4gICAgY29uc3QgcXVldWUgPSB0aGlzLiNxdWV1ZVxuICAgIHdoaWxlICghcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCBub2RlID0gcXVldWUuc2hpZnQoKVxuICAgICAgLy8gd2FpdCBwZW5kaW5nIHByb21pc2VcbiAgICAgIGlmIChub2RlLnByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgbm9kZS5wcm9taXNlXG4gICAgICB9XG4gICAgICAvLyB3cml0ZVxuICAgICAgdGhpcy4jc29ja2V0LndyaXRlKG5vZGUuZnJhbWUsIG5vZGUuY2FsbGJhY2spXG4gICAgICAvLyBjbGVhbnVwXG4gICAgICBub2RlLmNhbGxiYWNrID0gbm9kZS5mcmFtZSA9IG51bGxcbiAgICB9XG4gICAgdGhpcy4jcnVubmluZyA9IGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhbWUgKGRhdGEsIGhpbnQpIHtcbiAgcmV0dXJuIG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQodG9CdWZmZXIoZGF0YSwgaGludCkpLmNyZWF0ZUZyYW1lKGhpbnQgPT09IHNlbmRIaW50cy50ZXh0ID8gb3Bjb2Rlcy5URVhUIDogb3Bjb2Rlcy5CSU5BUlkpXG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyIChkYXRhLCBoaW50KSB7XG4gIHN3aXRjaCAoaGludCkge1xuICAgIGNhc2Ugc2VuZEhpbnRzLnRleHQ6XG4gICAgY2FzZSBzZW5kSGludHMudHlwZWRBcnJheTpcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gICAgY2FzZSBzZW5kSGludHMuYXJyYXlCdWZmZXI6XG4gICAgY2FzZSBzZW5kSGludHMuYmxvYjpcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBTZW5kUXVldWUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/stream/websocketerror.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { webidl } = __webpack_require__(/*! ../../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { validateCloseCodeAndReason } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction createInheritableDOMException () {\n  // https://github.com/nodejs/node/issues/59677\n  class Test extends DOMException {\n    get reason () {\n      return ''\n    }\n  }\n\n  if (new Test().reason !== undefined) {\n    return DOMException\n  }\n\n  return new Proxy(DOMException, {\n    construct (target, args, newTarget) {\n      const instance = Reflect.construct(target, args, target)\n      Object.setPrototypeOf(instance, newTarget.prototype)\n      return instance\n    }\n  })\n}\n\nclass WebSocketError extends createInheritableDOMException() {\n  #closeCode\n  #reason\n\n  constructor (message = '', init = undefined) {\n    message = webidl.converters.DOMString(message, 'WebSocketError', 'message')\n\n    // 1. Set this 's name to \" WebSocketError \".\n    // 2. Set this 's message to message .\n    super(message, 'WebSocketError')\n\n    if (init === kConstruct) {\n      return\n    } else if (init !== null) {\n      init = webidl.converters.WebSocketCloseInfo(init)\n    }\n\n    // 3. Let code be init [\" closeCode \"] if it exists , or null otherwise.\n    let code = init.closeCode ?? null\n\n    // 4. Let reason be init [\" reason \"] if it exists , or the empty string otherwise.\n    const reason = init.reason ?? ''\n\n    // 5. Validate close code and reason with code and reason .\n    validateCloseCodeAndReason(code, reason)\n\n    // 6. If reason is non-empty, but code is not set, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // 7. Set this 's closeCode to code .\n    this.#closeCode = code\n\n    // 8. Set this 's reason to reason .\n    this.#reason = reason\n  }\n\n  get closeCode () {\n    return this.#closeCode\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  /**\n   * @param {string} message\n   * @param {number|null} code\n   * @param {string} reason\n   */\n  static createUnvalidatedWebSocketError (message, code, reason) {\n    const error = new WebSocketError(message, kConstruct)\n    error.#closeCode = code\n    error.#reason = reason\n    return error\n  }\n}\n\nconst { createUnvalidatedWebSocketError } = WebSocketError\ndelete WebSocketError.createUnvalidatedWebSocketError\n\nObject.defineProperties(WebSocketError.prototype, {\n  closeCode: kEnumerableProperty,\n  reason: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketError',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError)\n\nmodule.exports = { WebSocketError, createUnvalidatedWebSocketError }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N0cmVhbS93ZWJzb2NrZXRlcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3pDLFFBQVEsNkJBQTZCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBUztBQUN4RCxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDhFQUF1QjtBQUN0RCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsd0VBQW9COztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxrQ0FBa0M7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXERvY3VtZW50c1xcV2Vla2x5XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcc3RyZWFtXFx3ZWJzb2NrZXRlcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYmlkbCcpXG5jb25zdCB7IHZhbGlkYXRlQ2xvc2VDb2RlQW5kUmVhc29uIH0gPSByZXF1aXJlKCcuLi91dGlsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS91dGlsJylcblxuZnVuY3Rpb24gY3JlYXRlSW5oZXJpdGFibGVET01FeGNlcHRpb24gKCkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzU5Njc3XG4gIGNsYXNzIFRlc3QgZXh0ZW5kcyBET01FeGNlcHRpb24ge1xuICAgIGdldCByZWFzb24gKCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ldyBUZXN0KCkucmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gRE9NRXhjZXB0aW9uXG4gIH1cblxuICByZXR1cm4gbmV3IFByb3h5KERPTUV4Y2VwdGlvbiwge1xuICAgIGNvbnN0cnVjdCAodGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmdzLCB0YXJnZXQpXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIG5ld1RhcmdldC5wcm90b3R5cGUpXG4gICAgICByZXR1cm4gaW5zdGFuY2VcbiAgICB9XG4gIH0pXG59XG5cbmNsYXNzIFdlYlNvY2tldEVycm9yIGV4dGVuZHMgY3JlYXRlSW5oZXJpdGFibGVET01FeGNlcHRpb24oKSB7XG4gICNjbG9zZUNvZGVcbiAgI3JlYXNvblxuXG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlID0gJycsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICBtZXNzYWdlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKG1lc3NhZ2UsICdXZWJTb2NrZXRFcnJvcicsICdtZXNzYWdlJylcblxuICAgIC8vIDEuIFNldCB0aGlzICdzIG5hbWUgdG8gXCIgV2ViU29ja2V0RXJyb3IgXCIuXG4gICAgLy8gMi4gU2V0IHRoaXMgJ3MgbWVzc2FnZSB0byBtZXNzYWdlIC5cbiAgICBzdXBlcihtZXNzYWdlLCAnV2ViU29ja2V0RXJyb3InKVxuXG4gICAgaWYgKGluaXQgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldENsb3NlSW5mbyhpbml0KVxuICAgIH1cblxuICAgIC8vIDMuIExldCBjb2RlIGJlIGluaXQgW1wiIGNsb3NlQ29kZSBcIl0gaWYgaXQgZXhpc3RzICwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgbGV0IGNvZGUgPSBpbml0LmNsb3NlQ29kZSA/PyBudWxsXG5cbiAgICAvLyA0LiBMZXQgcmVhc29uIGJlIGluaXQgW1wiIHJlYXNvbiBcIl0gaWYgaXQgZXhpc3RzICwgb3IgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gICAgY29uc3QgcmVhc29uID0gaW5pdC5yZWFzb24gPz8gJydcblxuICAgIC8vIDUuIFZhbGlkYXRlIGNsb3NlIGNvZGUgYW5kIHJlYXNvbiB3aXRoIGNvZGUgYW5kIHJlYXNvbiAuXG4gICAgdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24oY29kZSwgcmVhc29uKVxuXG4gICAgLy8gNi4gSWYgcmVhc29uIGlzIG5vbi1lbXB0eSwgYnV0IGNvZGUgaXMgbm90IHNldCwgdGhlbiBzZXQgY29kZSB0byAxMDAwIChcIk5vcm1hbCBDbG9zdXJlXCIpLlxuICAgIGlmIChyZWFzb24ubGVuZ3RoICE9PSAwICYmIGNvZGUgPT09IG51bGwpIHtcbiAgICAgIGNvZGUgPSAxMDAwXG4gICAgfVxuXG4gICAgLy8gNy4gU2V0IHRoaXMgJ3MgY2xvc2VDb2RlIHRvIGNvZGUgLlxuICAgIHRoaXMuI2Nsb3NlQ29kZSA9IGNvZGVcblxuICAgIC8vIDguIFNldCB0aGlzICdzIHJlYXNvbiB0byByZWFzb24gLlxuICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvblxuICB9XG5cbiAgZ2V0IGNsb3NlQ29kZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nsb3NlQ29kZVxuICB9XG5cbiAgZ2V0IHJlYXNvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYXNvblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3IgKG1lc3NhZ2UsIGNvZGUsIHJlYXNvbikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFdlYlNvY2tldEVycm9yKG1lc3NhZ2UsIGtDb25zdHJ1Y3QpXG4gICAgZXJyb3IuI2Nsb3NlQ29kZSA9IGNvZGVcbiAgICBlcnJvci4jcmVhc29uID0gcmVhc29uXG4gICAgcmV0dXJuIGVycm9yXG4gIH1cbn1cblxuY29uc3QgeyBjcmVhdGVVbnZhbGlkYXRlZFdlYlNvY2tldEVycm9yIH0gPSBXZWJTb2NrZXRFcnJvclxuZGVsZXRlIFdlYlNvY2tldEVycm9yLmNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3JcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0RXJyb3IucHJvdG90eXBlLCB7XG4gIGNsb3NlQ29kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnV2ViU29ja2V0RXJyb3InLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmlzLldlYlNvY2tldEVycm9yID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oV2ViU29ja2V0RXJyb3IpXG5cbm1vZHVsZS5leHBvcnRzID0geyBXZWJTb2NrZXRFcnJvciwgY3JlYXRlVW52YWxpZGF0ZWRXZWJTb2NrZXRFcnJvciB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js":
/*!*************************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/stream/websocketstream.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { createDeferredPromise } = __webpack_require__(/*! ../../../util/promise */ \"(rsc)/./node_modules/undici/lib/util/promise.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { states, opcodes, sentCloseFrameState } = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { webidl } = __webpack_require__(/*! ../../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { channels } = __webpack_require__(/*! ../../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ../frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { ByteParser } = __webpack_require__(/*! ../receiver */ \"(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { WebSocketError, createUnvalidatedWebSocketError } = __webpack_require__(/*! ./websocketerror */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ../../../encoding */ \"(rsc)/./node_modules/undici/lib/encoding/index.js\")\n\nlet emittedExperimentalWarning = false\n\nclass WebSocketStream {\n  // Each WebSocketStream object has an associated url , which is a URL record .\n  /** @type {URL} */\n  #url\n\n  // Each WebSocketStream object has an associated opened promise , which is a promise.\n  /** @type {import('../../../util/promise').DeferredPromise} */\n  #openedPromise\n\n  // Each WebSocketStream object has an associated closed promise , which is a promise.\n  /** @type {import('../../../util/promise').DeferredPromise} */\n  #closedPromise\n\n  // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .\n  /** @type {ReadableStream} */\n  #readableStream\n  /** @type {ReadableStreamDefaultController} */\n  #readableStreamController\n\n  // Each WebSocketStream object has an associated writable stream , which is a WritableStream .\n  /** @type {WritableStream} */\n  #writableStream\n\n  // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.\n  #handshakeAborted = false\n\n  /** @type {import('../websocket').Handler} */\n  #handler = {\n    // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#handler.socket.resume(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n    onPing: () => {},\n    onPong: () => {},\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  /** @type {import('../receiver').ByteParser} */\n  #parser\n\n  constructor (url, options = undefined) {\n    if (!emittedExperimentalWarning) {\n      process.emitWarning('WebSocketStream is experimental! Expect it to change at any time.', {\n        code: 'UNDICI-WSS'\n      })\n      emittedExperimentalWarning = true\n    }\n\n    webidl.argumentLengthCheck(arguments, 1, 'WebSocket')\n\n    url = webidl.converters.USVString(url)\n    if (options !== null) {\n      options = webidl.converters.WebSocketStreamOptions(options)\n    }\n\n    // 1. Let baseURL be this 's relevant settings object 's API base URL .\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL .\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. Let protocols be options [\" protocols \"] if it exists , otherwise an empty sequence.\n    const protocols = options.protocols\n\n    // 4. If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of ` Sec-WebSocket-Protocol ` fields as defined by The WebSocket Protocol , then throw a \" SyntaxError \" DOMException . [WSP]\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this 's url to urlRecord .\n    this.#url = urlRecord.toString()\n\n    // 6. Set this 's opened promise and closed promise to new promises.\n    this.#openedPromise = createDeferredPromise()\n    this.#closedPromise = createDeferredPromise()\n\n    // 7. Apply backpressure to the WebSocket.\n    // TODO\n\n    // 8.  If options [\" signal \"] exists ,\n    if (options.signal != null) {\n      // 8.1. Let signal be options [\" signal \"].\n      const signal = options.signal\n\n      // 8.2. If signal is aborted , then reject this 's opened promise and closed promise with signal s abort reason\n      //      and return.\n      if (signal.aborted) {\n        this.#openedPromise.reject(signal.reason)\n        this.#closedPromise.reject(signal.reason)\n        return\n      }\n\n      // 8.3. Add the following abort steps to signal :\n      signal.addEventListener('abort', () => {\n        // 8.3.1. If the WebSocket connection is not yet established : [WSP]\n        if (!isEstablished(this.#handler.readyState)) {\n          // 8.3.1.1. Fail the WebSocket connection .\n          failWebsocketConnection(this.#handler)\n\n          // Set this 's ready state to CLOSING .\n          this.#handler.readyState = states.CLOSING\n\n          // Reject this 's opened promise and closed promise with signal s abort reason .\n          this.#openedPromise.reject(signal.reason)\n          this.#closedPromise.reject(signal.reason)\n\n          // Set this 's handshake aborted to true.\n          this.#handshakeAborted = true\n        }\n      }, { once: true })\n    }\n\n    // 9.  Let client be this 's relevant settings object .\n    const client = environmentSettingsObject.settingsObject\n\n    // 10. Run this step in parallel :\n    // 10.1. Establish a WebSocket connection given urlRecord , protocols , and client . [FETCH]\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n  }\n\n  // The url getter steps are to return this 's url , serialized .\n  get url () {\n    return this.#url.toString()\n  }\n\n  // The opened getter steps are to return this 's opened promise .\n  get opened () {\n    return this.#openedPromise.promise\n  }\n\n  // The closed getter steps are to return this 's closed promise .\n  get closed () {\n    return this.#closedPromise.promise\n  }\n\n  // The close( closeInfo ) method steps are:\n  close (closeInfo = undefined) {\n    if (closeInfo !== null) {\n      closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo)\n    }\n\n    // 1. Let code be closeInfo [\" closeCode \"] if present, or null otherwise.\n    const code = closeInfo.closeCode ?? null\n\n    // 2. Let reason be closeInfo [\" reason \"].\n    const reason = closeInfo.reason\n\n    // 3. Close the WebSocket with this , code , and reason .\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  #write (chunk) {\n    // See /websockets/stream/tentative/write.any.html\n    chunk = webidl.converters.WebSocketStreamWrite(chunk)\n\n    // 1. Let promise be a new promise created in stream s relevant realm .\n    const promise = createDeferredPromise()\n\n    // 2. Let data be null.\n    let data = null\n\n    // 3. Let opcode be null.\n    let opcode = null\n\n    // 4. If chunk is a BufferSource ,\n    if (webidl.is.BufferSource(chunk)) {\n      // 4.1. Set data to a copy of the bytes given chunk .\n      data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk.slice())\n\n      // 4.2. Set opcode to a binary frame opcode.\n      opcode = opcodes.BINARY\n    } else {\n      // 5. Otherwise,\n\n      // 5.1. Let string be the result of converting chunk to an IDL USVString .\n      //    If this throws an exception, return a promise rejected with the exception.\n      let string\n\n      try {\n        string = webidl.converters.DOMString(chunk)\n      } catch (e) {\n        promise.reject(e)\n        return promise.promise\n      }\n\n      // 5.2. Set data to the result of UTF-8 encoding string .\n      data = new TextEncoder().encode(string)\n\n      // 5.3. Set opcode to a text frame opcode.\n      opcode = opcodes.TEXT\n    }\n\n    // 6. In parallel,\n    // 6.1. Wait until there is sufficient buffer space in stream to send the message.\n\n    // 6.2. If the closing handshake has not yet started , Send a WebSocket Message to stream comprised of data using opcode .\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      const frame = new WebsocketFrameSend(data)\n\n      this.#handler.socket.write(frame.createFrame(opcode), () => {\n        promise.resolve(undefined)\n      })\n    }\n\n    // 6.3. Queue a global task on the WebSocket task source given stream s relevant global object to resolve promise with undefined.\n    return promise.promise\n  }\n\n  /** @type {import('../websocket').Handler['onConnectionEstablished']} */\n  #onConnectionEstablished (response, parsedExtensions) {\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n\n    // 1. Change stream s ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Set stream s was ever connected to true.\n    // This is done in the opening handshake.\n\n    // 3. Let extensions be the extensions in use .\n    const extensions = parsedExtensions ?? ''\n\n    // 4. Let protocol be the subprotocol in use .\n    const protocol = response.headersList.get('sec-websocket-protocol') ?? ''\n\n    // 5. Let pullAlgorithm be an action that pulls bytes from stream .\n    // 6. Let cancelAlgorithm be an action that cancels stream with reason , given reason .\n    // 7. Let readable be a new ReadableStream .\n    // 8. Set up readable with pullAlgorithm and cancelAlgorithm .\n    const readable = new ReadableStream({\n      start: (controller) => {\n        this.#readableStreamController = controller\n      },\n      pull (controller) {\n        let chunk\n        while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {\n          controller.enqueue(chunk)\n        }\n      },\n      cancel: (reason) => this.#cancel(reason)\n    })\n\n    // 9. Let writeAlgorithm be an action that writes chunk to stream , given chunk .\n    // 10. Let closeAlgorithm be an action that closes stream .\n    // 11. Let abortAlgorithm be an action that aborts stream with reason , given reason .\n    // 12. Let writable be a new WritableStream .\n    // 13. Set up writable with writeAlgorithm , closeAlgorithm , and abortAlgorithm .\n    const writable = new WritableStream({\n      write: (chunk) => this.#write(chunk),\n      close: () => closeWebSocketConnection(this.#handler, null, null),\n      abort: (reason) => this.#closeUsingReason(reason)\n    })\n\n    // Set stream s readable stream to readable .\n    this.#readableStream = readable\n\n    // Set stream s writable stream to writable .\n    this.#writableStream = writable\n\n    // Resolve stream s opened promise with WebSocketOpenInfo [ \" extensions \"  extensions , \" protocol \"  protocol , \" readable \"  readable , \" writable \"  writable ].\n    this.#openedPromise.resolve({\n      extensions,\n      protocol,\n      readable,\n      writable\n    })\n  }\n\n  /** @type {import('../websocket').Handler['onMessage']} */\n  #onMessage (type, data) {\n    // 1. If streams ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let chunk be determined by switching on type:\n    //      - type indicates that the data is Text\n    //          a new DOMString containing data\n    //      - type indicates that the data is Binary\n    //          a new Uint8Array object, created in the relevant Realm of the\n    //          WebSocketStream object, whose contents are data\n    let chunk\n\n    if (type === opcodes.TEXT) {\n      try {\n        chunk = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    }\n\n    // 3. Enqueue chunk into streams readable stream.\n    this.#readableStreamController.enqueue(chunk)\n\n    // 4. Apply backpressure to the WebSocket.\n  }\n\n  /** @type {import('../websocket').Handler['onSocketClose']} */\n  #onSocketClose () {\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If stream s handshake aborted is true, then return.\n    if (this.#handshakeAborted) {\n      return\n    }\n\n    // 3. If stream s was ever connected is false, then reject stream s opened promise with a new WebSocketError.\n    if (!this.#handler.wasEverConnected) {\n      this.#openedPromise.reject(new WebSocketError('Socket never opened'))\n    }\n\n    const result = this.#parser?.closingInfo\n\n    // 4. Let code be the WebSocket connection close code .\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    // If this Close control frame contains no status code, _The WebSocket\n    // Connection Close Code_ is considered to be 1005. If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    let code = result?.code ?? 1005\n\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      code = 1006\n    }\n\n    // 5. Let reason be the result of applying UTF-8 decode without BOM to the WebSocket connection close reason .\n    const reason = result?.reason == null ? '' : utf8DecodeBytes(Buffer.from(result.reason))\n\n    // 6. If the connection was closed cleanly ,\n    if (wasClean) {\n      // 6.1. Close stream s readable stream .\n      this.#readableStreamController.close()\n\n      // 6.2. Error stream s writable stream with an \" InvalidStateError \" DOMException indicating that a closed WebSocketStream cannot be written to.\n      if (!this.#writableStream.locked) {\n        this.#writableStream.abort(new DOMException('A closed WebSocketStream cannot be written to', 'InvalidStateError'))\n      }\n\n      // 6.3. Resolve stream s closed promise with WebSocketCloseInfo [ \" closeCode \"  code , \" reason \"  reason ].\n      this.#closedPromise.resolve({\n        closeCode: code,\n        reason\n      })\n    } else {\n      // 7. Otherwise,\n\n      // 7.1. Let error be a new WebSocketError whose closeCode is code and reason is reason .\n      const error = createUnvalidatedWebSocketError('unclean close', code, reason)\n\n      // 7.2. Error stream s readable stream with error .\n      this.#readableStreamController?.error(error)\n\n      // 7.3. Error stream s writable stream with error .\n      this.#writableStream?.abort(error)\n\n      // 7.4. Reject stream s closed promise with error .\n      this.#closedPromise.reject(error)\n    }\n  }\n\n  #closeUsingReason (reason) {\n    // 1. Let code be null.\n    let code = null\n\n    // 2. Let reasonString be the empty string.\n    let reasonString = ''\n\n    // 3. If reason implements WebSocketError ,\n    if (webidl.is.WebSocketError(reason)) {\n      // 3.1. Set code to reason s closeCode .\n      code = reason.closeCode\n\n      // 3.2. Set reasonString to reason s reason .\n      reasonString = reason.reason\n    }\n\n    // 4. Close the WebSocket with stream , code , and reasonString . If this throws an exception,\n    //    discard code and reasonString and close the WebSocket with stream .\n    closeWebSocketConnection(this.#handler, code, reasonString)\n  }\n\n  //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .\n  #cancel (reason) {\n    this.#closeUsingReason(reason)\n  }\n}\n\nObject.defineProperties(WebSocketStream.prototype, {\n  url: kEnumerableProperty,\n  opened: kEnumerableProperty,\n  closed: kEnumerableProperty,\n  close: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketStream',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.sequenceConverter(webidl.converters.USVString),\n    defaultValue: () => []\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(webidl.converters.AbortSignal),\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([\n  {\n    key: 'closeCode',\n    converter: (V) => webidl.converters['unsigned short'](V, webidl.attributes.EnforceRange)\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.WebSocketStreamWrite = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  return webidl.converters.BufferSource(V)\n}\n\nmodule.exports = { WebSocketStream }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N0cmVhbS93ZWJzb2NrZXRzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDhFQUF1QjtBQUNqRSxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsMkVBQWtCO0FBQ2hFLFFBQVEsdUNBQXVDLEVBQUUsbUJBQU8sQ0FBQyxnRkFBYztBQUN2RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3pDLFFBQVEsOERBQThELEVBQUUsbUJBQU8sQ0FBQyxzRUFBUztBQUN6RixRQUFRLGtGQUFrRixFQUFFLG1CQUFPLENBQUMsa0ZBQWU7QUFDbkgsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzRkFBMkI7QUFDeEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsOEVBQWE7QUFDNUMsUUFBUSxrREFBa0QsRUFBRSxtQkFBTyxDQUFDLGdHQUFrQjtBQUN0RixRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsd0VBQW9CO0FBQzVELFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBbUI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLGlEQUFpRDtBQUM5RDs7QUFFQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGlDQUFpQztBQUM5Qzs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQ0FBa0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsMkRBQTJEO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLGlEQUFpRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxEb2N1bWVudHNcXFdlZWtseVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHN0cmVhbVxcd2Vic29ja2V0c3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZURlZmVycmVkUHJvbWlzZSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9wcm9taXNlJylcbmNvbnN0IHsgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCB7IHN0YXRlcywgb3Bjb2Rlcywgc2VudENsb3NlRnJhbWVTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi8uLi93ZWJpZGwnKVxuY29uc3QgeyBnZXRVUkxSZWNvcmQsIGlzVmFsaWRTdWJwcm90b2NvbCwgaXNFc3RhYmxpc2hlZCwgdXRmOERlY29kZSB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5jb25zdCB7IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24sIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4uL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9kaWFnbm9zdGljcycpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi4vZnJhbWUnKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuLi9yZWNlaXZlcicpXG5jb25zdCB7IFdlYlNvY2tldEVycm9yLCBjcmVhdGVVbnZhbGlkYXRlZFdlYlNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuL3dlYnNvY2tldGVycm9yJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgdXRmOERlY29kZUJ5dGVzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9lbmNvZGluZycpXG5cbmxldCBlbWl0dGVkRXhwZXJpbWVudGFsV2FybmluZyA9IGZhbHNlXG5cbmNsYXNzIFdlYlNvY2tldFN0cmVhbSB7XG4gIC8vIEVhY2ggV2ViU29ja2V0U3RyZWFtIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCB1cmwgLCB3aGljaCBpcyBhIFVSTCByZWNvcmQgLlxuICAvKiogQHR5cGUge1VSTH0gKi9cbiAgI3VybFxuXG4gIC8vIEVhY2ggV2ViU29ja2V0U3RyZWFtIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBvcGVuZWQgcHJvbWlzZSAsIHdoaWNoIGlzIGEgcHJvbWlzZS5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uLy4uL3V0aWwvcHJvbWlzZScpLkRlZmVycmVkUHJvbWlzZX0gKi9cbiAgI29wZW5lZFByb21pc2VcblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgY2xvc2VkIHByb21pc2UgLCB3aGljaCBpcyBhIHByb21pc2UuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi8uLi91dGlsL3Byb21pc2UnKS5EZWZlcnJlZFByb21pc2V9ICovXG4gICNjbG9zZWRQcm9taXNlXG5cbiAgLy8gRWFjaCBXZWJTb2NrZXRTdHJlYW0gb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIHJlYWRhYmxlIHN0cmVhbSAsIHdoaWNoIGlzIGEgUmVhZGFibGVTdHJlYW0gLlxuICAvKiogQHR5cGUge1JlYWRhYmxlU3RyZWFtfSAqL1xuICAjcmVhZGFibGVTdHJlYW1cbiAgLyoqIEB0eXBlIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSAqL1xuICAjcmVhZGFibGVTdHJlYW1Db250cm9sbGVyXG5cbiAgLy8gRWFjaCBXZWJTb2NrZXRTdHJlYW0gb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIHdyaXRhYmxlIHN0cmVhbSAsIHdoaWNoIGlzIGEgV3JpdGFibGVTdHJlYW0gLlxuICAvKiogQHR5cGUge1dyaXRhYmxlU3RyZWFtfSAqL1xuICAjd3JpdGFibGVTdHJlYW1cblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgYm9vbGVhbiBoYW5kc2hha2UgYWJvcnRlZCAsIHdoaWNoIGlzIGluaXRpYWxseSBmYWxzZS5cbiAgI2hhbmRzaGFrZUFib3J0ZWQgPSBmYWxzZVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi93ZWJzb2NrZXQnKS5IYW5kbGVyfSAqL1xuICAjaGFuZGxlciA9IHtcbiAgICAvLyBodHRwczovL3doYXRwci5vcmcvd2Vic29ja2V0cy80OC83Yjc0OGQzLi4uZDU1NzBmMy5odG1sI2ZlZWRiYWNrLXRvLXdlYnNvY2tldC1zdHJlYW0tZnJvbS10aGUtcHJvdG9jb2xcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZDogKHJlc3BvbnNlLCBleHRlbnNpb25zKSA9PiB0aGlzLiNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSwgZXh0ZW5zaW9ucyksXG4gICAgb25NZXNzYWdlOiAob3Bjb2RlLCBkYXRhKSA9PiB0aGlzLiNvbk1lc3NhZ2Uob3Bjb2RlLCBkYXRhKSxcbiAgICBvblBhcnNlckVycm9yOiAoZXJyKSA9PiBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCBudWxsLCBlcnIubWVzc2FnZSksXG4gICAgb25QYXJzZXJEcmFpbjogKCkgPT4gdGhpcy4jaGFuZGxlci5zb2NrZXQucmVzdW1lKCksXG4gICAgb25Tb2NrZXREYXRhOiAoY2h1bmspID0+IHtcbiAgICAgIGlmICghdGhpcy4jcGFyc2VyLndyaXRlKGNodW5rKSkge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC5wYXVzZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBvblNvY2tldEVycm9yOiAoZXJyKSA9PiB7XG4gICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gICAgICBpZiAoY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LmRlc3Ryb3koKVxuICAgIH0sXG4gICAgb25Tb2NrZXRDbG9zZTogKCkgPT4gdGhpcy4jb25Tb2NrZXRDbG9zZSgpLFxuICAgIG9uUGluZzogKCkgPT4ge30sXG4gICAgb25Qb25nOiAoKSA9PiB7fSxcblxuICAgIHJlYWR5U3RhdGU6IHN0YXRlcy5DT05ORUNUSU5HLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBjbG9zZVN0YXRlOiBuZXcgU2V0KCksXG4gICAgY29udHJvbGxlcjogbnVsbCxcbiAgICB3YXNFdmVyQ29ubmVjdGVkOiBmYWxzZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3JlY2VpdmVyJykuQnl0ZVBhcnNlcn0gKi9cbiAgI3BhcnNlclxuXG4gIGNvbnN0cnVjdG9yICh1cmwsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIWVtaXR0ZWRFeHBlcmltZW50YWxXYXJuaW5nKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdXZWJTb2NrZXRTdHJlYW0gaXMgZXhwZXJpbWVudGFsISBFeHBlY3QgaXQgdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgY29kZTogJ1VORElDSS1XU1MnXG4gICAgICB9KVxuICAgICAgZW1pdHRlZEV4cGVyaW1lbnRhbFdhcm5pbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnV2ViU29ja2V0JylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTdHJlYW1PcHRpb25zKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IGJhc2VVUkwgYmUgdGhpcyAncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QgJ3MgQVBJIGJhc2UgVVJMIC5cbiAgICBjb25zdCBiYXNlVVJMID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsXG5cbiAgICAvLyAyLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIFVSTCByZWNvcmQgZ2l2ZW4gdXJsIGFuZCBiYXNlVVJMIC5cbiAgICBjb25zdCB1cmxSZWNvcmQgPSBnZXRVUkxSZWNvcmQodXJsLCBiYXNlVVJMKVxuXG4gICAgLy8gMy4gTGV0IHByb3RvY29scyBiZSBvcHRpb25zIFtcIiBwcm90b2NvbHMgXCJdIGlmIGl0IGV4aXN0cyAsIG90aGVyd2lzZSBhbiBlbXB0eSBzZXF1ZW5jZS5cbiAgICBjb25zdCBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sc1xuXG4gICAgLy8gNC4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gcHJvdG9jb2xzIG9jY3VyIG1vcmUgdGhhbiBvbmNlIG9yIG90aGVyd2lzZSBmYWlsIHRvIG1hdGNoIHRoZSByZXF1aXJlbWVudHMgZm9yIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhlIHZhbHVlIG9mIGAgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBgIGZpZWxkcyBhcyBkZWZpbmVkIGJ5IFRoZSBXZWJTb2NrZXQgUHJvdG9jb2wgLCB0aGVuIHRocm93IGEgXCIgU3ludGF4RXJyb3IgXCIgRE9NRXhjZXB0aW9uIC4gW1dTUF1cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gbmV3IFNldChwcm90b2NvbHMubWFwKHAgPT4gcC50b0xvd2VyQ2FzZSgpKSkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDAgJiYgIXByb3RvY29scy5ldmVyeShwID0+IGlzVmFsaWRTdWJwcm90b2NvbChwKSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IHRoaXMgJ3MgdXJsIHRvIHVybFJlY29yZCAuXG4gICAgdGhpcy4jdXJsID0gdXJsUmVjb3JkLnRvU3RyaW5nKClcblxuICAgIC8vIDYuIFNldCB0aGlzICdzIG9wZW5lZCBwcm9taXNlIGFuZCBjbG9zZWQgcHJvbWlzZSB0byBuZXcgcHJvbWlzZXMuXG4gICAgdGhpcy4jb3BlbmVkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy4jY2xvc2VkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LiBBcHBseSBiYWNrcHJlc3N1cmUgdG8gdGhlIFdlYlNvY2tldC5cbiAgICAvLyBUT0RPXG5cbiAgICAvLyA4LiAgSWYgb3B0aW9ucyBbXCIgc2lnbmFsIFwiXSBleGlzdHMgLFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCAhPSBudWxsKSB7XG4gICAgICAvLyA4LjEuIExldCBzaWduYWwgYmUgb3B0aW9ucyBbXCIgc2lnbmFsIFwiXS5cbiAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsXG5cbiAgICAgIC8vIDguMi4gSWYgc2lnbmFsIGlzIGFib3J0ZWQgLCB0aGVuIHJlamVjdCB0aGlzICdzIG9wZW5lZCBwcm9taXNlIGFuZCBjbG9zZWQgcHJvbWlzZSB3aXRoIHNpZ25hbCDigJlzIGFib3J0IHJlYXNvblxuICAgICAgLy8gICAgICBhbmQgcmV0dXJuLlxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMuI29wZW5lZFByb21pc2UucmVqZWN0KHNpZ25hbC5yZWFzb24pXG4gICAgICAgIHRoaXMuI2Nsb3NlZFByb21pc2UucmVqZWN0KHNpZ25hbC5yZWFzb24pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA4LjMuIEFkZCB0aGUgZm9sbG93aW5nIGFib3J0IHN0ZXBzIHRvIHNpZ25hbCA6XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgIC8vIDguMy4xLiBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCA6IFtXU1BdXG4gICAgICAgIGlmICghaXNFc3RhYmxpc2hlZCh0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgLy8gOC4zLjEuMS4gRmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gLlxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIpXG5cbiAgICAgICAgICAvLyBTZXQgdGhpcyAncyByZWFkeSBzdGF0ZSB0byBDTE9TSU5HIC5cbiAgICAgICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gICAgICAgICAgLy8gUmVqZWN0IHRoaXMgJ3Mgb3BlbmVkIHByb21pc2UgYW5kIGNsb3NlZCBwcm9taXNlIHdpdGggc2lnbmFsIOKAmXMgYWJvcnQgcmVhc29uIC5cbiAgICAgICAgICB0aGlzLiNvcGVuZWRQcm9taXNlLnJlamVjdChzaWduYWwucmVhc29uKVxuICAgICAgICAgIHRoaXMuI2Nsb3NlZFByb21pc2UucmVqZWN0KHNpZ25hbC5yZWFzb24pXG5cbiAgICAgICAgICAvLyBTZXQgdGhpcyAncyBoYW5kc2hha2UgYWJvcnRlZCB0byB0cnVlLlxuICAgICAgICAgIHRoaXMuI2hhbmRzaGFrZUFib3J0ZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KVxuICAgIH1cblxuICAgIC8vIDkuICBMZXQgY2xpZW50IGJlIHRoaXMgJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0IC5cbiAgICBjb25zdCBjbGllbnQgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0XG5cbiAgICAvLyAxMC4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbCA6XG4gICAgLy8gMTAuMS4gRXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ2l2ZW4gdXJsUmVjb3JkICwgcHJvdG9jb2xzICwgYW5kIGNsaWVudCAuIFtGRVRDSF1cbiAgICB0aGlzLiNoYW5kbGVyLmNvbnRyb2xsZXIgPSBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uKFxuICAgICAgdXJsUmVjb3JkLFxuICAgICAgcHJvdG9jb2xzLFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy4jaGFuZGxlcixcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gIH1cblxuICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMgJ3MgdXJsICwgc2VyaWFsaXplZCAuXG4gIGdldCB1cmwgKCkge1xuICAgIHJldHVybiB0aGlzLiN1cmwudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gVGhlIG9wZW5lZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzICdzIG9wZW5lZCBwcm9taXNlIC5cbiAgZ2V0IG9wZW5lZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29wZW5lZFByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLy8gVGhlIGNsb3NlZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzICdzIGNsb3NlZCBwcm9taXNlIC5cbiAgZ2V0IGNsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nsb3NlZFByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLy8gVGhlIGNsb3NlKCBjbG9zZUluZm8gKSBtZXRob2Qgc3RlcHMgYXJlOlxuICBjbG9zZSAoY2xvc2VJbmZvID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGNsb3NlSW5mbyAhPT0gbnVsbCkge1xuICAgICAgY2xvc2VJbmZvID0gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0Q2xvc2VJbmZvKGNsb3NlSW5mbylcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgY29kZSBiZSBjbG9zZUluZm8gW1wiIGNsb3NlQ29kZSBcIl0gaWYgcHJlc2VudCwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgY29uc3QgY29kZSA9IGNsb3NlSW5mby5jbG9zZUNvZGUgPz8gbnVsbFxuXG4gICAgLy8gMi4gTGV0IHJlYXNvbiBiZSBjbG9zZUluZm8gW1wiIHJlYXNvbiBcIl0uXG4gICAgY29uc3QgcmVhc29uID0gY2xvc2VJbmZvLnJlYXNvblxuXG4gICAgLy8gMy4gQ2xvc2UgdGhlIFdlYlNvY2tldCB3aXRoIHRoaXMgLCBjb2RlICwgYW5kIHJlYXNvbiAuXG4gICAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIGNvZGUsIHJlYXNvbiwgdHJ1ZSlcbiAgfVxuXG4gICN3cml0ZSAoY2h1bmspIHtcbiAgICAvLyBTZWUgL3dlYnNvY2tldHMvc3RyZWFtL3RlbnRhdGl2ZS93cml0ZS5hbnkuaHRtbFxuICAgIGNodW5rID0gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U3RyZWFtV3JpdGUoY2h1bmspXG5cbiAgICAvLyAxLiBMZXQgcHJvbWlzZSBiZSBhIG5ldyBwcm9taXNlIGNyZWF0ZWQgaW4gc3RyZWFtIOKAmXMgcmVsZXZhbnQgcmVhbG0gLlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMi4gTGV0IGRhdGEgYmUgbnVsbC5cbiAgICBsZXQgZGF0YSA9IG51bGxcblxuICAgIC8vIDMuIExldCBvcGNvZGUgYmUgbnVsbC5cbiAgICBsZXQgb3Bjb2RlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgY2h1bmsgaXMgYSBCdWZmZXJTb3VyY2UgLFxuICAgIGlmICh3ZWJpZGwuaXMuQnVmZmVyU291cmNlKGNodW5rKSkge1xuICAgICAgLy8gNC4xLiBTZXQgZGF0YSB0byBhIGNvcHkgb2YgdGhlIGJ5dGVzIGdpdmVuIGNodW5rIC5cbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSA6IGNodW5rLnNsaWNlKCkpXG5cbiAgICAgIC8vIDQuMi4gU2V0IG9wY29kZSB0byBhIGJpbmFyeSBmcmFtZSBvcGNvZGUuXG4gICAgICBvcGNvZGUgPSBvcGNvZGVzLkJJTkFSWVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA1LiBPdGhlcndpc2UsXG5cbiAgICAgIC8vIDUuMS4gTGV0IHN0cmluZyBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgY2h1bmsgdG8gYW4gSURMIFVTVlN0cmluZyAuXG4gICAgICAvLyAgICBJZiB0aGlzIHRocm93cyBhbiBleGNlcHRpb24sIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZXhjZXB0aW9uLlxuICAgICAgbGV0IHN0cmluZ1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdHJpbmcgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2h1bmspXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpXG4gICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgICAgIH1cblxuICAgICAgLy8gNS4yLiBTZXQgZGF0YSB0byB0aGUgcmVzdWx0IG9mIFVURi04IGVuY29kaW5nIHN0cmluZyAuXG4gICAgICBkYXRhID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cmluZylcblxuICAgICAgLy8gNS4zLiBTZXQgb3Bjb2RlIHRvIGEgdGV4dCBmcmFtZSBvcGNvZGUuXG4gICAgICBvcGNvZGUgPSBvcGNvZGVzLlRFWFRcbiAgICB9XG5cbiAgICAvLyA2LiBJbiBwYXJhbGxlbCxcbiAgICAvLyA2LjEuIFdhaXQgdW50aWwgdGhlcmUgaXMgc3VmZmljaWVudCBidWZmZXIgc3BhY2UgaW4gc3RyZWFtIHRvIHNlbmQgdGhlIG1lc3NhZ2UuXG5cbiAgICAvLyA2LjIuIElmIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkICwgU2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIHRvIHN0cmVhbSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBvcGNvZGUgLlxuICAgIGlmICghdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQpICYmICF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuUkVDRUlWRUQpKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoZGF0YSlcblxuICAgICAgdGhpcy4jaGFuZGxlci5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2RlKSwgKCkgPT4ge1xuICAgICAgICBwcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA2LjMuIFF1ZXVlIGEgZ2xvYmFsIHRhc2sgb24gdGhlIFdlYlNvY2tldCB0YXNrIHNvdXJjZSBnaXZlbiBzdHJlYW0g4oCZcyByZWxldmFudCBnbG9iYWwgb2JqZWN0IHRvIHJlc29sdmUgcHJvbWlzZSB3aXRoIHVuZGVmaW5lZC5cbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnLi4vd2Vic29ja2V0JykuSGFuZGxlclsnb25Db25uZWN0aW9uRXN0YWJsaXNoZWQnXX0gKi9cbiAgI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIChyZXNwb25zZSwgcGFyc2VkRXh0ZW5zaW9ucykge1xuICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0ID0gcmVzcG9uc2Uuc29ja2V0XG5cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgQnl0ZVBhcnNlcih0aGlzLiNoYW5kbGVyLCBwYXJzZWRFeHRlbnNpb25zKVxuICAgIHBhcnNlci5vbignZHJhaW4nLCAoKSA9PiB0aGlzLiNoYW5kbGVyLm9uUGFyc2VyRHJhaW4oKSlcbiAgICBwYXJzZXIub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy4jaGFuZGxlci5vblBhcnNlckVycm9yKGVycikpXG5cbiAgICB0aGlzLiNwYXJzZXIgPSBwYXJzZXJcblxuICAgIC8vIDEuIENoYW5nZSBzdHJlYW0g4oCZcyByZWFkeSBzdGF0ZSB0byBPUEVOICgxKS5cbiAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuT1BFTlxuXG4gICAgLy8gMi4gU2V0IHN0cmVhbSDigJlzIHdhcyBldmVyIGNvbm5lY3RlZCB0byB0cnVlLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBpbiB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG5cbiAgICAvLyAzLiBMZXQgZXh0ZW5zaW9ucyBiZSB0aGUgZXh0ZW5zaW9ucyBpbiB1c2UgLlxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBwYXJzZWRFeHRlbnNpb25zID8/ICcnXG5cbiAgICAvLyA0LiBMZXQgcHJvdG9jb2wgYmUgdGhlIHN1YnByb3RvY29sIGluIHVzZSAuXG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnKSA/PyAnJ1xuXG4gICAgLy8gNS4gTGV0IHB1bGxBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgcHVsbHMgYnl0ZXMgZnJvbSBzdHJlYW0gLlxuICAgIC8vIDYuIExldCBjYW5jZWxBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgY2FuY2VscyBzdHJlYW0gd2l0aCByZWFzb24gLCBnaXZlbiByZWFzb24gLlxuICAgIC8vIDcuIExldCByZWFkYWJsZSBiZSBhIG5ldyBSZWFkYWJsZVN0cmVhbSAuXG4gICAgLy8gOC4gU2V0IHVwIHJlYWRhYmxlIHdpdGggcHVsbEFsZ29yaXRobSBhbmQgY2FuY2VsQWxnb3JpdGhtIC5cbiAgICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdGhpcy4jcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlclxuICAgICAgfSxcbiAgICAgIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IGNodW5rXG4gICAgICAgIHdoaWxlIChjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMCAmJiAoY2h1bmsgPSByZXNwb25zZS5zb2NrZXQucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4gdGhpcy4jY2FuY2VsKHJlYXNvbilcbiAgICB9KVxuXG4gICAgLy8gOS4gTGV0IHdyaXRlQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHdyaXRlcyBjaHVuayB0byBzdHJlYW0gLCBnaXZlbiBjaHVuayAuXG4gICAgLy8gMTAuIExldCBjbG9zZUFsZ29yaXRobSBiZSBhbiBhY3Rpb24gdGhhdCBjbG9zZXMgc3RyZWFtIC5cbiAgICAvLyAxMS4gTGV0IGFib3J0QWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IGFib3J0cyBzdHJlYW0gd2l0aCByZWFzb24gLCBnaXZlbiByZWFzb24gLlxuICAgIC8vIDEyLiBMZXQgd3JpdGFibGUgYmUgYSBuZXcgV3JpdGFibGVTdHJlYW0gLlxuICAgIC8vIDEzLiBTZXQgdXAgd3JpdGFibGUgd2l0aCB3cml0ZUFsZ29yaXRobSAsIGNsb3NlQWxnb3JpdGhtICwgYW5kIGFib3J0QWxnb3JpdGhtIC5cbiAgICBjb25zdCB3cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICB3cml0ZTogKGNodW5rKSA9PiB0aGlzLiN3cml0ZShjaHVuayksXG4gICAgICBjbG9zZTogKCkgPT4gY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIG51bGwsIG51bGwpLFxuICAgICAgYWJvcnQ6IChyZWFzb24pID0+IHRoaXMuI2Nsb3NlVXNpbmdSZWFzb24ocmVhc29uKVxuICAgIH0pXG5cbiAgICAvLyBTZXQgc3RyZWFtIOKAmXMgcmVhZGFibGUgc3RyZWFtIHRvIHJlYWRhYmxlIC5cbiAgICB0aGlzLiNyZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlXG5cbiAgICAvLyBTZXQgc3RyZWFtIOKAmXMgd3JpdGFibGUgc3RyZWFtIHRvIHdyaXRhYmxlIC5cbiAgICB0aGlzLiN3cml0YWJsZVN0cmVhbSA9IHdyaXRhYmxlXG5cbiAgICAvLyBSZXNvbHZlIHN0cmVhbSDigJlzIG9wZW5lZCBwcm9taXNlIHdpdGggV2ViU29ja2V0T3BlbkluZm8gwqtbIFwiIGV4dGVuc2lvbnMgXCIg4oaSIGV4dGVuc2lvbnMgLCBcIiBwcm90b2NvbCBcIiDihpIgcHJvdG9jb2wgLCBcIiByZWFkYWJsZSBcIiDihpIgcmVhZGFibGUgLCBcIiB3cml0YWJsZSBcIiDihpIgd3JpdGFibGUgXcK7LlxuICAgIHRoaXMuI29wZW5lZFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBleHRlbnNpb25zLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICByZWFkYWJsZSxcbiAgICAgIHdyaXRhYmxlXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi93ZWJzb2NrZXQnKS5IYW5kbGVyWydvbk1lc3NhZ2UnXX0gKi9cbiAgI29uTWVzc2FnZSAodHlwZSwgZGF0YSkge1xuICAgIC8vIDEuIElmIHN0cmVhbeKAmXMgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlICE9PSBzdGF0ZXMuT1BFTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNodW5rIGJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIG9uIHR5cGU6XG4gICAgLy8gICAgICAtIHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgVGV4dFxuICAgIC8vICAgICAgICAgIGEgbmV3IERPTVN0cmluZyBjb250YWluaW5nIGRhdGFcbiAgICAvLyAgICAgIC0gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBCaW5hcnlcbiAgICAvLyAgICAgICAgICBhIG5ldyBVaW50OEFycmF5IG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlXG4gICAgLy8gICAgICAgICAgV2ViU29ja2V0U3RyZWFtIG9iamVjdCwgd2hvc2UgY29udGVudHMgYXJlIGRhdGFcbiAgICBsZXQgY2h1bmtcblxuICAgIGlmICh0eXBlID09PSBvcGNvZGVzLlRFWFQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNodW5rID0gdXRmOERlY29kZShkYXRhKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsICdSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBvcGNvZGVzLkJJTkFSWSkge1xuICAgICAgY2h1bmsgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMy4gRW5xdWV1ZSBjaHVuayBpbnRvIHN0cmVhbeKAmXMgcmVhZGFibGUgc3RyZWFtLlxuICAgIHRoaXMuI3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuXG4gICAgLy8gNC4gQXBwbHkgYmFja3ByZXNzdXJlIHRvIHRoZSBXZWJTb2NrZXQuXG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnLi4vd2Vic29ja2V0JykuSGFuZGxlclsnb25Tb2NrZXRDbG9zZSddfSAqL1xuICAjb25Tb2NrZXRDbG9zZSAoKSB7XG4gICAgY29uc3Qgd2FzQ2xlYW4gPVxuICAgICAgdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQpICYmXG4gICAgICB0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuUkVDRUlWRUQpXG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gICAgdGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlID0gc3RhdGVzLkNMT1NFRFxuXG4gICAgLy8gMi4gSWYgc3RyZWFtIOKAmXMgaGFuZHNoYWtlIGFib3J0ZWQgaXMgdHJ1ZSwgdGhlbiByZXR1cm4uXG4gICAgaWYgKHRoaXMuI2hhbmRzaGFrZUFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDMuIElmIHN0cmVhbSDigJlzIHdhcyBldmVyIGNvbm5lY3RlZCBpcyBmYWxzZSwgdGhlbiByZWplY3Qgc3RyZWFtIOKAmXMgb3BlbmVkIHByb21pc2Ugd2l0aCBhIG5ldyBXZWJTb2NrZXRFcnJvci5cbiAgICBpZiAoIXRoaXMuI2hhbmRsZXIud2FzRXZlckNvbm5lY3RlZCkge1xuICAgICAgdGhpcy4jb3BlbmVkUHJvbWlzZS5yZWplY3QobmV3IFdlYlNvY2tldEVycm9yKCdTb2NrZXQgbmV2ZXIgb3BlbmVkJykpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jcGFyc2VyPy5jbG9zaW5nSW5mb1xuXG4gICAgLy8gNC4gTGV0IGNvZGUgYmUgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUgLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS41XG4gICAgLy8gSWYgdGhpcyBDbG9zZSBjb250cm9sIGZyYW1lIGNvbnRhaW5zIG5vIHN0YXR1cyBjb2RlLCBfVGhlIFdlYlNvY2tldFxuICAgIC8vIENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXMgY29uc2lkZXJlZCB0byBiZSAxMDA1LiBJZiBfVGhlIFdlYlNvY2tldFxuICAgIC8vIENvbm5lY3Rpb24gaXMgQ2xvc2VkXyBhbmQgbm8gQ2xvc2UgY29udHJvbCBmcmFtZSB3YXMgcmVjZWl2ZWQgYnkgdGhlXG4gICAgLy8gZW5kcG9pbnQgKHN1Y2ggYXMgY291bGQgb2NjdXIgaWYgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb25cbiAgICAvLyBpcyBsb3N0KSwgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpcyBjb25zaWRlcmVkIHRvIGJlXG4gICAgLy8gMTAwNi5cbiAgICBsZXQgY29kZSA9IHJlc3VsdD8uY29kZSA/PyAxMDA1XG5cbiAgICBpZiAoIXRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKSAmJiAhdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKSkge1xuICAgICAgY29kZSA9IDEwMDZcbiAgICB9XG5cbiAgICAvLyA1LiBMZXQgcmVhc29uIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLTggZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZSByZWFzb24gLlxuICAgIGNvbnN0IHJlYXNvbiA9IHJlc3VsdD8ucmVhc29uID09IG51bGwgPyAnJyA6IHV0ZjhEZWNvZGVCeXRlcyhCdWZmZXIuZnJvbShyZXN1bHQucmVhc29uKSlcblxuICAgIC8vIDYuIElmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgY2xlYW5seSAsXG4gICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICAvLyA2LjEuIENsb3NlIHN0cmVhbSDigJlzIHJlYWRhYmxlIHN0cmVhbSAuXG4gICAgICB0aGlzLiNyZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKVxuXG4gICAgICAvLyA2LjIuIEVycm9yIHN0cmVhbSDigJlzIHdyaXRhYmxlIHN0cmVhbSB3aXRoIGFuIFwiIEludmFsaWRTdGF0ZUVycm9yIFwiIERPTUV4Y2VwdGlvbiBpbmRpY2F0aW5nIHRoYXQgYSBjbG9zZWQgV2ViU29ja2V0U3RyZWFtIGNhbm5vdCBiZSB3cml0dGVuIHRvLlxuICAgICAgaWYgKCF0aGlzLiN3cml0YWJsZVN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhpcy4jd3JpdGFibGVTdHJlYW0uYWJvcnQobmV3IERPTUV4Y2VwdGlvbignQSBjbG9zZWQgV2ViU29ja2V0U3RyZWFtIGNhbm5vdCBiZSB3cml0dGVuIHRvJywgJ0ludmFsaWRTdGF0ZUVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDYuMy4gUmVzb2x2ZSBzdHJlYW0g4oCZcyBjbG9zZWQgcHJvbWlzZSB3aXRoIFdlYlNvY2tldENsb3NlSW5mbyDCq1sgXCIgY2xvc2VDb2RlIFwiIOKGkiBjb2RlICwgXCIgcmVhc29uIFwiIOKGkiByZWFzb24gXcK7LlxuICAgICAgdGhpcy4jY2xvc2VkUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgY2xvc2VDb2RlOiBjb2RlLFxuICAgICAgICByZWFzb25cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDcuIE90aGVyd2lzZSxcblxuICAgICAgLy8gNy4xLiBMZXQgZXJyb3IgYmUgYSBuZXcgV2ViU29ja2V0RXJyb3Igd2hvc2UgY2xvc2VDb2RlIGlzIGNvZGUgYW5kIHJlYXNvbiBpcyByZWFzb24gLlxuICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVVbnZhbGlkYXRlZFdlYlNvY2tldEVycm9yKCd1bmNsZWFuIGNsb3NlJywgY29kZSwgcmVhc29uKVxuXG4gICAgICAvLyA3LjIuIEVycm9yIHN0cmVhbSDigJlzIHJlYWRhYmxlIHN0cmVhbSB3aXRoIGVycm9yIC5cbiAgICAgIHRoaXMuI3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcj8uZXJyb3IoZXJyb3IpXG5cbiAgICAgIC8vIDcuMy4gRXJyb3Igc3RyZWFtIOKAmXMgd3JpdGFibGUgc3RyZWFtIHdpdGggZXJyb3IgLlxuICAgICAgdGhpcy4jd3JpdGFibGVTdHJlYW0/LmFib3J0KGVycm9yKVxuXG4gICAgICAvLyA3LjQuIFJlamVjdCBzdHJlYW0g4oCZcyBjbG9zZWQgcHJvbWlzZSB3aXRoIGVycm9yIC5cbiAgICAgIHRoaXMuI2Nsb3NlZFByb21pc2UucmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gICNjbG9zZVVzaW5nUmVhc29uIChyZWFzb24pIHtcbiAgICAvLyAxLiBMZXQgY29kZSBiZSBudWxsLlxuICAgIGxldCBjb2RlID0gbnVsbFxuXG4gICAgLy8gMi4gTGV0IHJlYXNvblN0cmluZyBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGxldCByZWFzb25TdHJpbmcgPSAnJ1xuXG4gICAgLy8gMy4gSWYgcmVhc29uIGltcGxlbWVudHMgV2ViU29ja2V0RXJyb3IgLFxuICAgIGlmICh3ZWJpZGwuaXMuV2ViU29ja2V0RXJyb3IocmVhc29uKSkge1xuICAgICAgLy8gMy4xLiBTZXQgY29kZSB0byByZWFzb24g4oCZcyBjbG9zZUNvZGUgLlxuICAgICAgY29kZSA9IHJlYXNvbi5jbG9zZUNvZGVcblxuICAgICAgLy8gMy4yLiBTZXQgcmVhc29uU3RyaW5nIHRvIHJlYXNvbiDigJlzIHJlYXNvbiAuXG4gICAgICByZWFzb25TdHJpbmcgPSByZWFzb24ucmVhc29uXG4gICAgfVxuXG4gICAgLy8gNC4gQ2xvc2UgdGhlIFdlYlNvY2tldCB3aXRoIHN0cmVhbSAsIGNvZGUgLCBhbmQgcmVhc29uU3RyaW5nIC4gSWYgdGhpcyB0aHJvd3MgYW4gZXhjZXB0aW9uLFxuICAgIC8vICAgIGRpc2NhcmQgY29kZSBhbmQgcmVhc29uU3RyaW5nIGFuZCBjbG9zZSB0aGUgV2ViU29ja2V0IHdpdGggc3RyZWFtIC5cbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgY29kZSwgcmVhc29uU3RyaW5nKVxuICB9XG5cbiAgLy8gIFRvIGNhbmNlbCBhIFdlYlNvY2tldFN0cmVhbSBzdHJlYW0gZ2l2ZW4gcmVhc29uICwgY2xvc2UgdXNpbmcgcmVhc29uIGdpdmluZyBzdHJlYW0gYW5kIHJlYXNvbiAuXG4gICNjYW5jZWwgKHJlYXNvbikge1xuICAgIHRoaXMuI2Nsb3NlVXNpbmdSZWFzb24ocmVhc29uKVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcGVuZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb3NlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdXZWJTb2NrZXRTdHJlYW0nLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U3RyZWFtT3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3Byb3RvY29scycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IFtdXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsKSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0Q2xvc2VJbmZvID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnY2xvc2VDb2RlJyxcbiAgICBjb252ZXJ0ZXI6IChWKSA9PiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShWLCB3ZWJpZGwuYXR0cmlidXRlcy5FbmZvcmNlUmFuZ2UpXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWFzb24nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U3RyZWFtV3JpdGUgPSBmdW5jdGlvbiAoVikge1xuICBpZiAodHlwZW9mIFYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgV2ViU29ja2V0U3RyZWFtIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../infra */ \"(rsc)/./node_modules/undici/lib/web/infra/index.js\")\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isConnecting (readyState) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return readyState === states.CONNECTING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isEstablished (readyState) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return readyState === states.OPEN\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosing (readyState) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return readyState === states.CLOSING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosed (readyState) {\n  return readyState === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n * @returns {void}\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize events type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').Handler} handler\n * @param {number} type Opcode\n * @param {Buffer} data application data\n * @returns {void}\n */\nfunction websocketMessageReceived (handler, type, data) {\n  handler.onMessage(type, data)\n}\n\n/**\n * @param {Buffer} buffer\n * @returns {ArrayBuffer}\n */\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return new Uint8Array(buffer).buffer\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n * @returns {boolean}\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n * @returns {boolean}\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\n/**\n *\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=', 2)\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://whatpr.org/websockets/48/7b748d3...d5570f3.html#get-a-url-record\n * @param {string} url\n * @param {string} [baseURL]\n */\nfunction getURLRecord (url, baseURL) {\n  // 1. Let urlRecord be the result of applying the URL parser to url with baseURL .\n  // 2. If urlRecord is failure, then throw a \" SyntaxError \" DOMException .\n  let urlRecord\n\n  try {\n    urlRecord = new URL(url, baseURL)\n  } catch (e) {\n    throw new DOMException(e, 'SyntaxError')\n  }\n\n  // 3. If urlRecord s scheme is \" http \", then set urlRecord s scheme to \" ws \".\n  // 4. Otherwise, if urlRecord s scheme is \" https \", set urlRecord s scheme to \" wss \".\n  if (urlRecord.protocol === 'http:') {\n    urlRecord.protocol = 'ws:'\n  } else if (urlRecord.protocol === 'https:') {\n    urlRecord.protocol = 'wss:'\n  }\n\n  // 5. If urlRecord s scheme is not \" ws \" or \" wss \", then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n    throw new DOMException('expected a ws: or wss: url', 'SyntaxError')\n  }\n\n  // If urlRecord s fragment is non-null, then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.hash.length || urlRecord.href.endsWith('#')) {\n    throw new DOMException('hash', 'SyntaxError')\n  }\n\n  // Return urlRecord .\n  return urlRecord\n}\n\n// https://whatpr.org/websockets/48.html#validate-close-code-and-reason\nfunction validateCloseCodeAndReason (code, reason) {\n  // 1. If code is not null, but is neither an integer equal to\n  //    1000 nor an integer in the range 3000 to 4999, inclusive,\n  //    throw an \"InvalidAccessError\" DOMException.\n  if (code !== null) {\n    if (code !== 1000 && (code < 3000 || code > 4999)) {\n      throw new DOMException('invalid code', 'InvalidAccessError')\n    }\n  }\n\n  // 2. If reason is not null, then:\n  if (reason !== null) {\n    // 2.1. Let reasonBytes be the result of UTF-8 encoding reason.\n    // 2.2. If reasonBytes is longer than 123 bytes, then throw a\n    //      \"SyntaxError\" DOMException.\n    const reasonBytesLength = Buffer.byteLength(reason)\n\n    if (reasonBytesLength > 123) {\n      throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, 'SyntaxError')\n    }\n  }\n}\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @type {(buffer: Buffer) => string}\n */\nconst utf8Decode = (() => {\n  if (typeof process.versions.icu === 'string') {\n    const fatalDecoder = new TextDecoder('utf-8', { fatal: true })\n    return fatalDecoder.decode.bind(fatalDecoder)\n  }\n  return function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n})()\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits,\n  toArrayBuffer,\n  getURLRecord,\n  validateCloseCodeAndReason\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2pELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEMsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUM1RCxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsb0VBQVU7O0FBRS9EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyx5REFBeUQ7QUFDcEUsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiO0FBQ0EsdUdBQXVHO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsV0FBVyxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0YXRlcywgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IHsgcmVtb3ZlSFRUUFdoaXRlc3BhY2UgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgfSA9IHJlcXVpcmUoJy4uL2luZnJhJylcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVhZHlTdGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ29ubmVjdGluZyAocmVhZHlTdGF0ZSkge1xuICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCwgYW5kIHRoZSBjb25uZWN0aW9uXG4gIC8vIGlzIG5vdCB5ZXQgY2xvc2VkLCB0aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ09OTkVDVElORyBzdGF0ZS5cbiAgcmV0dXJuIHJlYWR5U3RhdGUgPT09IHN0YXRlcy5DT05ORUNUSU5HXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlYWR5U3RhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VzdGFibGlzaGVkIChyZWFkeVN0YXRlKSB7XG4gIC8vIElmIHRoZSBzZXJ2ZXIncyByZXNwb25zZSBpcyB2YWxpZGF0ZWQgYXMgcHJvdmlkZWQgZm9yIGFib3ZlLCBpdCBpc1xuICAvLyBzYWlkIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBFc3RhYmxpc2hlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIGluIHRoZSBPUEVOIHN0YXRlLlxuICByZXR1cm4gcmVhZHlTdGF0ZSA9PT0gc3RhdGVzLk9QRU5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVhZHlTdGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2luZyAocmVhZHlTdGF0ZSkge1xuICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gIHJldHVybiByZWFkeVN0YXRlID09PSBzdGF0ZXMuQ0xPU0lOR1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWFkeVN0YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbG9zZWQgKHJlYWR5U3RhdGUpIHtcbiAgcmV0dXJuIHJlYWR5U3RhdGUgPT09IHN0YXRlcy5DTE9TRURcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0geyguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEV2ZW50PikgPT4gRXZlbnR9IGV2ZW50RmFjdG9yeVxuICogQHBhcmFtIHtFdmVudEluaXQgfCB1bmRlZmluZWR9IGV2ZW50SW5pdERpY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmaXJlRXZlbnQgKGUsIHRhcmdldCwgZXZlbnRGYWN0b3J5ID0gKHR5cGUsIGluaXQpID0+IG5ldyBFdmVudCh0eXBlLCBpbml0KSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gIC8vIDEuIElmIGV2ZW50Q29uc3RydWN0b3IgaXMgbm90IGdpdmVuLCB0aGVuIGxldCBldmVudENvbnN0cnVjdG9yIGJlIEV2ZW50LlxuXG4gIC8vIDIuIExldCBldmVudCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGV2ZW50IGdpdmVuIGV2ZW50Q29uc3RydWN0b3IsXG4gIC8vICAgIGluIHRoZSByZWxldmFudCByZWFsbSBvZiB0YXJnZXQuXG4gIC8vIDMuIEluaXRpYWxpemUgZXZlbnTigJlzIHR5cGUgYXR0cmlidXRlIHRvIGUuXG4gIGNvbnN0IGV2ZW50ID0gZXZlbnRGYWN0b3J5KGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgLy8gNC4gSW5pdGlhbGl6ZSBhbnkgb3RoZXIgSURMIGF0dHJpYnV0ZXMgb2YgZXZlbnQgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyAgICBpbnZvY2F0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXG4gIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGRpc3BhdGNoaW5nIGV2ZW50IGF0IHRhcmdldCwgd2l0aCBsZWdhY3kgdGFyZ2V0XG4gIC8vICAgIG92ZXJyaWRlIGZsYWcgc2V0IGlmIHNldC5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gaGFuZGxlclxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgT3Bjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBhcHBsaWNhdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIChoYW5kbGVyLCB0eXBlLCBkYXRhKSB7XG4gIGhhbmRsZXIub25NZXNzYWdlKHR5cGUsIGRhdGEpXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyIChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSBidWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlclxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpLmJ1ZmZlclxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1XG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjYxNlxuICogQHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zOTg0MDdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdWJwcm90b2NvbCAocHJvdG9jb2wpIHtcbiAgLy8gSWYgcHJlc2VudCwgdGhpcyB2YWx1ZSBpbmRpY2F0ZXMgb25lXG4gIC8vIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHN1YnByb3RvY29sIHRoZSBjbGllbnQgd2lzaGVzIHRvIHNwZWFrLFxuICAvLyBvcmRlcmVkIGJ5IHByZWZlcmVuY2UuICBUaGUgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGlzIHZhbHVlXG4gIC8vIE1VU1QgYmUgbm9uLWVtcHR5IHN0cmluZ3Mgd2l0aCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSBVKzAwMjEgdG9cbiAgLy8gVSswMDdFIG5vdCBpbmNsdWRpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBpblxuICAvLyBbUkZDMjYxNl0gYW5kIE1VU1QgYWxsIGJlIHVuaXF1ZSBzdHJpbmdzLlxuICBpZiAocHJvdG9jb2wubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3RvY29sLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHByb3RvY29sLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIENUTCwgY29udGFpbnMgU1AgKDB4MjApIGFuZCBIVCAoMHgwOSlcbiAgICAgIGNvZGUgPiAweDdFIHx8XG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDJGIHx8IC8vIC9cbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDNDIHx8IC8vIDxcbiAgICAgIGNvZGUgPT09IDB4M0QgfHwgLy8gPVxuICAgICAgY29kZSA9PT0gMHgzRSB8fCAvLyA+XG4gICAgICBjb2RlID09PSAweDNGIHx8IC8vID9cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHg1QiB8fCAvLyBbXG4gICAgICBjb2RlID09PSAweDVDIHx8IC8vIFxcXG4gICAgICBjb2RlID09PSAweDVEIHx8IC8vIF1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy00XG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlIChjb2RlKSB7XG4gIGlmIChjb2RlID49IDEwMDAgJiYgY29kZSA8IDEwMTUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY29kZSAhPT0gMTAwNCAmJiAvLyByZXNlcnZlZFxuICAgICAgY29kZSAhPT0gMTAwNSAmJiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICAgIGNvZGUgIT09IDEwMDYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuNVxuICogQHBhcmFtIHtudW1iZXJ9IG9wY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ29udHJvbEZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBvcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UgfHxcbiAgICBvcGNvZGUgPT09IG9wY29kZXMuUElORyB8fFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb250aW51YXRpb25GcmFtZSAob3Bjb2RlKSB7XG4gIHJldHVybiBvcGNvZGUgPT09IG9wY29kZXMuQ09OVElOVUFUSU9OXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9wY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dEJpbmFyeUZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIG9wY29kZSA9PT0gb3Bjb2Rlcy5URVhUIHx8IG9wY29kZSA9PT0gb3Bjb2Rlcy5CSU5BUllcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9wY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRPcGNvZGUgKG9wY29kZSkge1xuICByZXR1cm4gaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSB8fCBpc0NvbnRpbnVhdGlvbkZyYW1lKG9wY29kZSkgfHwgaXNDb250cm9sRnJhbWUob3Bjb2RlKVxufVxuXG4vKipcbiAqIFBhcnNlcyBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uc1xuICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbi8vIFRPRE8oQFV6bG9wYWssIEBLaGFmcmFEZXYpOiBtYWtlIGNvbXBsaWFudCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbmZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9ucyAoZXh0ZW5zaW9ucykge1xuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICBjb25zdCBleHRlbnNpb25MaXN0ID0gbmV3IE1hcCgpXG5cbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYWlyID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoJzsnLCBleHRlbnNpb25zLCBwb3NpdGlvbilcbiAgICBjb25zdCBbbmFtZSwgdmFsdWUgPSAnJ10gPSBwYWlyLnNwbGl0KCc9JywgMilcblxuICAgIGV4dGVuc2lvbkxpc3Quc2V0KFxuICAgICAgcmVtb3ZlSFRUUFdoaXRlc3BhY2UobmFtZSwgdHJ1ZSwgZmFsc2UpLFxuICAgICAgcmVtb3ZlSFRUUFdoaXRlc3BhY2UodmFsdWUsIGZhbHNlLCB0cnVlKVxuICAgIClcblxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgfVxuXG4gIHJldHVybiBleHRlbnNpb25MaXN0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzY5MiNzZWN0aW9uLTcuMS4yLjJcbiAqIEBkZXNjcmlwdGlvbiBcImNsaWVudC1tYXgtd2luZG93LWJpdHMgPSAxKkRJR0lUXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzICh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChieXRlIDwgMHgzMCB8fCBieXRlID4gMHgzOSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2hhdHByLm9yZy93ZWJzb2NrZXRzLzQ4LzdiNzQ4ZDMuLi5kNTU3MGYzLmh0bWwjZ2V0LWEtdXJsLXJlY29yZFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlVVJMXVxuICovXG5mdW5jdGlvbiBnZXRVUkxSZWNvcmQgKHVybCwgYmFzZVVSTCkge1xuICAvLyAxLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFVSTCBwYXJzZXIgdG8gdXJsIHdpdGggYmFzZVVSTCAuXG4gIC8vIDIuIElmIHVybFJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgXCIgU3ludGF4RXJyb3IgXCIgRE9NRXhjZXB0aW9uIC5cbiAgbGV0IHVybFJlY29yZFxuXG4gIHRyeSB7XG4gICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIGJhc2VVUkwpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gIH1cblxuICAvLyAzLiBJZiB1cmxSZWNvcmQg4oCZcyBzY2hlbWUgaXMgXCIgaHR0cCBcIiwgdGhlbiBzZXQgdXJsUmVjb3JkIOKAmXMgc2NoZW1lIHRvIFwiIHdzIFwiLlxuICAvLyA0LiBPdGhlcndpc2UsIGlmIHVybFJlY29yZCDigJlzIHNjaGVtZSBpcyBcIiBodHRwcyBcIiwgc2V0IHVybFJlY29yZCDigJlzIHNjaGVtZSB0byBcIiB3c3MgXCIuXG4gIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3M6J1xuICB9IGVsc2UgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3NzOidcbiAgfVxuXG4gIC8vIDUuIElmIHVybFJlY29yZCDigJlzIHNjaGVtZSBpcyBub3QgXCIgd3MgXCIgb3IgXCIgd3NzIFwiLCB0aGVuIHRocm93IGEgXCIgU3ludGF4RXJyb3IgXCIgRE9NRXhjZXB0aW9uIC5cbiAgaWYgKHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgdXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3NzOicpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdleHBlY3RlZCBhIHdzOiBvciB3c3M6IHVybCcsICdTeW50YXhFcnJvcicpXG4gIH1cblxuICAvLyBJZiB1cmxSZWNvcmQg4oCZcyBmcmFnbWVudCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFwiIFN5bnRheEVycm9yIFwiIERPTUV4Y2VwdGlvbiAuXG4gIGlmICh1cmxSZWNvcmQuaGFzaC5sZW5ndGggfHwgdXJsUmVjb3JkLmhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ2hhc2gnLCAnU3ludGF4RXJyb3InKVxuICB9XG5cbiAgLy8gUmV0dXJuIHVybFJlY29yZCAuXG4gIHJldHVybiB1cmxSZWNvcmRcbn1cblxuLy8gaHR0cHM6Ly93aGF0cHIub3JnL3dlYnNvY2tldHMvNDguaHRtbCN2YWxpZGF0ZS1jbG9zZS1jb2RlLWFuZC1yZWFzb25cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xvc2VDb2RlQW5kUmVhc29uIChjb2RlLCByZWFzb24pIHtcbiAgLy8gMS4gSWYgY29kZSBpcyBub3QgbnVsbCwgYnV0IGlzIG5laXRoZXIgYW4gaW50ZWdlciBlcXVhbCB0b1xuICAvLyAgICAxMDAwIG5vciBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSAzMDAwIHRvIDQ5OTksIGluY2x1c2l2ZSxcbiAgLy8gICAgdGhyb3cgYW4gXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBET01FeGNlcHRpb24uXG4gIGlmIChjb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignaW52YWxpZCBjb2RlJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpXG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgcmVhc29uIGlzIG5vdCBudWxsLCB0aGVuOlxuICBpZiAocmVhc29uICE9PSBudWxsKSB7XG4gICAgLy8gMi4xLiBMZXQgcmVhc29uQnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBVVEYtOCBlbmNvZGluZyByZWFzb24uXG4gICAgLy8gMi4yLiBJZiByZWFzb25CeXRlcyBpcyBsb25nZXIgdGhhbiAxMjMgYnl0ZXMsIHRoZW4gdGhyb3cgYVxuICAgIC8vICAgICAgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBjb25zdCByZWFzb25CeXRlc0xlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHJlYXNvbilcblxuICAgIGlmIChyZWFzb25CeXRlc0xlbmd0aCA+IDEyMykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihgUmVhc29uIG11c3QgYmUgbGVzcyB0aGFuIDEyMyBieXRlczsgcmVjZWl2ZWQgJHtyZWFzb25CeXRlc0xlbmd0aH1gLCAnU3ludGF4RXJyb3InKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgQnVmZmVyIHRvIHV0Zi04LCBldmVuIG9uIHBsYXRmb3JtcyB3aXRob3V0IGljdS5cbiAqIEB0eXBlIHsoYnVmZmVyOiBCdWZmZXIpID0+IHN0cmluZ31cbiAqL1xuY29uc3QgdXRmOERlY29kZSA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5pY3UgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZmF0YWxEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSlcbiAgICByZXR1cm4gZmF0YWxEZWNvZGVyLmRlY29kZS5iaW5kKGZhdGFsRGVjb2RlcilcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIGlmIChpc1V0ZjgoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHV0Zi04IHJlY2VpdmVkLicpXG4gIH1cbn0pKClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQ29ubmVjdGluZyxcbiAgaXNFc3RhYmxpc2hlZCxcbiAgaXNDbG9zaW5nLFxuICBpc0Nsb3NlZCxcbiAgZmlyZUV2ZW50LFxuICBpc1ZhbGlkU3VicHJvdG9jb2wsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQsXG4gIHV0ZjhEZWNvZGUsXG4gIGlzQ29udHJvbEZyYW1lLFxuICBpc0NvbnRpbnVhdGlvbkZyYW1lLFxuICBpc1RleHRCaW5hcnlGcmFtZSxcbiAgaXNWYWxpZE9wY29kZSxcbiAgcGFyc2VFeHRlbnNpb25zLFxuICBpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgZ2V0VVJMUmVjb3JkLFxuICB2YWxpZGF0ZUNsb3NlQ29kZUFuZFJlYXNvblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  isValidSubprotocol,\n  fireEvent,\n  utf8Decode,\n  toArrayBuffer,\n  getURLRecord\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { ErrorEvent, CloseEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/undici/lib/web/websocket/sender.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\n\n/**\n * @typedef {object} Handler\n * @property {(response: any, extensions?: string[]) => void} onConnectionEstablished\n * @property {(opcode: number, data: Buffer) => void} onMessage\n * @property {(error: Error) => void} onParserError\n * @property {() => void} onParserDrain\n * @property {(chunk: Buffer) => void} onSocketData\n * @property {(err: Error) => void} onSocketError\n * @property {() => void} onSocketClose\n * @property {(body: Buffer) => void} onPing\n * @property {(body: Buffer) => void} onPong\n *\n * @property {number} readyState\n * @property {import('stream').Duplex} socket\n * @property {Set<number>} closeState\n * @property {import('../fetch/index').Fetch} controller\n * @property {boolean} [wasEverConnected=false]\n */\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /** @type {Handler} */\n  #handler = {\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#onParserDrain(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n    onPing: (body) => {\n      if (channels.ping.hasSubscribers) {\n        channels.ping.publish({\n          payload: body,\n          websocket: this\n        })\n      }\n    },\n    onPong: (body) => {\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body,\n          websocket: this\n        })\n      }\n    },\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  #url\n  #binaryType\n  /** @type {import('./receiver').ByteParser} */\n  #parser\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL.\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 4. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this's url to urlRecord.\n    this.#url = new URL(urlRecord.href)\n\n    // 6. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 7. Run this step in parallel:\n    // 7.1. Establish a WebSocket connection given urlRecord, protocols,\n    //      and client.\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this.#handler.readyState = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this.#binaryType = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', webidl.attributes.Clamp)\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is the special value \"missing\", then set code to null.\n    code ??= null\n\n    // 2. If reason is the special value \"missing\", then set reason to the empty string.\n    reason ??= ''\n\n    // 3. Close the WebSocket with this, code, and reason.\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this.#handler.readyState)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const buffer = Buffer.from(data)\n\n      this.#bufferedAmount += buffer.byteLength\n      this.#sendQueue.add(buffer, () => {\n        this.#bufferedAmount -= buffer.byteLength\n      }, sendHints.text)\n    } else if (isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of datas buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (webidl.is.Blob(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob objects raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this.#handler.readyState\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this.#url)\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n      this.#events.open = fn\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n      this.#events.error = fn\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('close', listener)\n      this.#events.close = fn\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n      this.#events.message = fn\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#binaryType\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this.#binaryType = 'blob'\n    } else {\n      this.#binaryType = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"responses header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Change the extensions attributes value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attributes value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n\n    if (channels.open.hasSubscribers) {\n      // Convert headers to a plain object for the event\n      const headers = response.headersList.entries\n      channels.open.publish({\n        address: response.socket.address(),\n        protocol: this.#protocol,\n        extensions: this.#extensions,\n        websocket: this,\n        handshakeResponse: {\n          status: response.status,\n          statusText: response.statusText,\n          headers\n        }\n      })\n    }\n  }\n\n  #onMessage (type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent\n\n    if (type === opcodes.TEXT) {\n      // -> type indicates that the data is Text\n      //      a new DOMString containing data\n      try {\n        dataForEvent = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 1007, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      if (this.#binaryType === 'blob') {\n        // -> type indicates that the data is Binary and binary type is \"blob\"\n        //      a new Blob object, created in the relevant Realm of the WebSocket\n        //      object, that represents data as its raw data\n        dataForEvent = new Blob([data])\n      } else {\n        // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n        //      a new ArrayBuffer object, created in the relevant Realm of the\n        //      WebSocket object, whose contents are data\n        dataForEvent = toArrayBuffer(data)\n      }\n    }\n\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    objects url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent('message', this, createFastMessageEvent, {\n      origin: this.#url.origin,\n      data: dataForEvent\n    })\n  }\n\n  #onParserDrain () {\n    this.#handler.socket.resume()\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n   */\n  #onSocketClose () {\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    let code = 1005\n    let reason = ''\n\n    const result = this.#parser?.closingInfo\n\n    if (result && !result.error) {\n      code = result.code ?? 1005\n      reason = result.reason\n    }\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      // If _The WebSocket\n      // Connection is Closed_ and no Close control frame was received by the\n      // endpoint (such as could occur if the underlying transport connection\n      // is lost), _The WebSocket Connection Close Code_ is considered to be\n      // 1006.\n      code = 1006\n\n      fireEvent('error', this, (type, init) => new ErrorEvent(type, init), {\n        error: new TypeError(reason)\n      })\n    }\n\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    // TODO: process.nextTick\n    fireEvent('close', this, (type, init) => new CloseEvent(type, init), {\n      wasClean, code, reason\n    })\n\n    if (channels.close.hasSubscribers) {\n      channels.close.publish({\n        websocket: this,\n        code,\n        reason\n      })\n    }\n  }\n\n  /**\n   * @param {WebSocket} ws\n   * @param {Buffer|undefined} buffer\n   */\n  static ping (ws, buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      if (buffer.length > 125) {\n        throw new TypeError('A PING frame cannot have a body larger than 125 bytes.')\n      }\n    } else if (buffer !== undefined) {\n      throw new TypeError('Expected buffer payload')\n    }\n\n    // An endpoint MAY send a Ping frame any time after the connection is\n    // established and before the connection is closed.\n    const readyState = ws.#handler.readyState\n\n    if (isEstablished(readyState) && !isClosing(readyState) && !isClosed(readyState)) {\n      const frame = new WebsocketFrameSend(buffer)\n      ws.#handler.socket.write(frame.createFrame(opcodes.PING))\n    }\n  }\n}\n\nconst { ping } = WebSocket\nReflect.deleteProperty(WebSocket, 'ping')\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => []\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    if (webidl.is.Blob(V)) {\n      return V\n    }\n\n    if (webidl.is.BufferSource(V)) {\n      return V\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket,\n  ping\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsd0NBQWlCO0FBQ25ELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsd0VBQWU7QUFDN0QsUUFBUSw2RUFBNkUsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDcEIsUUFBUSxrRkFBa0YsRUFBRSxtQkFBTyxDQUFDLGlGQUFjO0FBQ2xILFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsNkVBQVk7QUFDM0MsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN6RCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDdEQsUUFBUSxpREFBaUQsRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQzdFLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVU7QUFDeEMsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHVFQUFTO0FBQ2hELFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCOztBQUVyRDtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdEQUFnRDtBQUM5RCxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLFlBQVk7QUFDMUIsY0FBYyx5QkFBeUI7QUFDdkMsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxZQUFZO0FBQzFCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsYUFBYTtBQUMzQixjQUFjLGdDQUFnQztBQUM5QyxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBRE1JTlxcRG9jdW1lbnRzXFxXZWVrbHlcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx3ZWJzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLCBzdGF0ZXMsIHNlbnRDbG9zZUZyYW1lU3RhdGUsIHNlbmRIaW50cywgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBpc0Nvbm5lY3RpbmcsXG4gIGlzRXN0YWJsaXNoZWQsXG4gIGlzQ2xvc2luZyxcbiAgaXNDbG9zZWQsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgZmlyZUV2ZW50LFxuICB1dGY4RGVjb2RlLFxuICB0b0FycmF5QnVmZmVyLFxuICBnZXRVUkxSZWNvcmRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLCBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24sIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJylcbmNvbnN0IHsgRXJyb3JFdmVudCwgQ2xvc2VFdmVudCwgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBTZW5kUXVldWUgfSA9IHJlcXVpcmUoJy4vc2VuZGVyJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGlhZ25vc3RpY3MnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEhhbmRsZXJcbiAqIEBwcm9wZXJ0eSB7KHJlc3BvbnNlOiBhbnksIGV4dGVuc2lvbnM/OiBzdHJpbmdbXSkgPT4gdm9pZH0gb25Db25uZWN0aW9uRXN0YWJsaXNoZWRcbiAqIEBwcm9wZXJ0eSB7KG9wY29kZTogbnVtYmVyLCBkYXRhOiBCdWZmZXIpID0+IHZvaWR9IG9uTWVzc2FnZVxuICogQHByb3BlcnR5IHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSBvblBhcnNlckVycm9yXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IG9uUGFyc2VyRHJhaW5cbiAqIEBwcm9wZXJ0eSB7KGNodW5rOiBCdWZmZXIpID0+IHZvaWR9IG9uU29ja2V0RGF0YVxuICogQHByb3BlcnR5IHsoZXJyOiBFcnJvcikgPT4gdm9pZH0gb25Tb2NrZXRFcnJvclxuICogQHByb3BlcnR5IHsoKSA9PiB2b2lkfSBvblNvY2tldENsb3NlXG4gKiBAcHJvcGVydHkgeyhib2R5OiBCdWZmZXIpID0+IHZvaWR9IG9uUGluZ1xuICogQHByb3BlcnR5IHsoYm9keTogQnVmZmVyKSA9PiB2b2lkfSBvblBvbmdcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVhZHlTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gc29ja2V0XG4gKiBAcHJvcGVydHkge1NldDxudW1iZXI+fSBjbG9zZVN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZmV0Y2gvaW5kZXgnKS5GZXRjaH0gY29udHJvbGxlclxuICogQHByb3BlcnR5IHtib29sZWFufSBbd2FzRXZlckNvbm5lY3RlZD1mYWxzZV1cbiAqL1xuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZGVmaW5pdGlvblxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgY2xvc2U6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI2J1ZmZlcmVkQW1vdW50ID0gMFxuICAjcHJvdG9jb2wgPSAnJ1xuICAjZXh0ZW5zaW9ucyA9ICcnXG5cbiAgLyoqIEB0eXBlIHtTZW5kUXVldWV9ICovXG4gICNzZW5kUXVldWVcblxuICAvKiogQHR5cGUge0hhbmRsZXJ9ICovXG4gICNoYW5kbGVyID0ge1xuICAgIG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkOiAocmVzcG9uc2UsIGV4dGVuc2lvbnMpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlLCBleHRlbnNpb25zKSxcbiAgICBvbk1lc3NhZ2U6IChvcGNvZGUsIGRhdGEpID0+IHRoaXMuI29uTWVzc2FnZShvcGNvZGUsIGRhdGEpLFxuICAgIG9uUGFyc2VyRXJyb3I6IChlcnIpID0+IGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIG51bGwsIGVyci5tZXNzYWdlKSxcbiAgICBvblBhcnNlckRyYWluOiAoKSA9PiB0aGlzLiNvblBhcnNlckRyYWluKCksXG4gICAgb25Tb2NrZXREYXRhOiAoY2h1bmspID0+IHtcbiAgICAgIGlmICghdGhpcy4jcGFyc2VyLndyaXRlKGNodW5rKSkge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC5wYXVzZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBvblNvY2tldEVycm9yOiAoZXJyKSA9PiB7XG4gICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gICAgICBpZiAoY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LmRlc3Ryb3koKVxuICAgIH0sXG4gICAgb25Tb2NrZXRDbG9zZTogKCkgPT4gdGhpcy4jb25Tb2NrZXRDbG9zZSgpLFxuICAgIG9uUGluZzogKGJvZHkpID0+IHtcbiAgICAgIGlmIChjaGFubmVscy5waW5nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLnBpbmcucHVibGlzaCh7XG4gICAgICAgICAgcGF5bG9hZDogYm9keSxcbiAgICAgICAgICB3ZWJzb2NrZXQ6IHRoaXNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uUG9uZzogKGJvZHkpID0+IHtcbiAgICAgIGlmIChjaGFubmVscy5wb25nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLnBvbmcucHVibGlzaCh7XG4gICAgICAgICAgcGF5bG9hZDogYm9keSxcbiAgICAgICAgICB3ZWJzb2NrZXQ6IHRoaXNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVhZHlTdGF0ZTogc3RhdGVzLkNPTk5FQ1RJTkcsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGNsb3NlU3RhdGU6IG5ldyBTZXQoKSxcbiAgICBjb250cm9sbGVyOiBudWxsLFxuICAgIHdhc0V2ZXJDb25uZWN0ZWQ6IGZhbHNlXG4gIH1cblxuICAjdXJsXG4gICNiaW5hcnlUeXBlXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlY2VpdmVyJykuQnl0ZVBhcnNlcn0gKi9cbiAgI3BhcnNlclxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHByb3RvY29scyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjb25zdCBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXShwcm90b2NvbHMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybClcbiAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sc1xuXG4gICAgLy8gMS4gTGV0IGJhc2VVUkwgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdCdzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVVJMID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsXG5cbiAgICAvLyAyLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIFVSTCByZWNvcmQgZ2l2ZW4gdXJsIGFuZCBiYXNlVVJMLlxuICAgIGNvbnN0IHVybFJlY29yZCA9IGdldFVSTFJlY29yZCh1cmwsIGJhc2VVUkwpXG5cbiAgICAvLyAzLiBJZiBwcm90b2NvbHMgaXMgYSBzdHJpbmcsIHNldCBwcm90b2NvbHMgdG8gYSBzZXF1ZW5jZSBjb25zaXN0aW5nXG4gICAgLy8gICAgb2YganVzdCB0aGF0IHN0cmluZy5cbiAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gcHJvdG9jb2xzIG9jY3VyIG1vcmUgdGhhbiBvbmNlIG9yIG90aGVyd2lzZVxuICAgIC8vICAgIGZhaWwgdG8gbWF0Y2ggdGhlIHJlcXVpcmVtZW50cyBmb3IgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGUgdmFsdWVcbiAgICAvLyAgICBvZiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgZmllbGRzIGFzIGRlZmluZWQgYnkgVGhlIFdlYlNvY2tldFxuICAgIC8vICAgIHByb3RvY29sLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gbmV3IFNldChwcm90b2NvbHMubWFwKHAgPT4gcC50b0xvd2VyQ2FzZSgpKSkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDAgJiYgIXByb3RvY29scy5ldmVyeShwID0+IGlzVmFsaWRTdWJwcm90b2NvbChwKSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IHRoaXMncyB1cmwgdG8gdXJsUmVjb3JkLlxuICAgIHRoaXMuI3VybCA9IG5ldyBVUkwodXJsUmVjb3JkLmhyZWYpXG5cbiAgICAvLyA2LiBMZXQgY2xpZW50IGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgY29uc3QgY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gNy4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbDpcbiAgICAvLyA3LjEuIEVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uIGdpdmVuIHVybFJlY29yZCwgcHJvdG9jb2xzLFxuICAgIC8vICAgICAgYW5kIGNsaWVudC5cbiAgICB0aGlzLiNoYW5kbGVyLmNvbnRyb2xsZXIgPSBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uKFxuICAgICAgdXJsUmVjb3JkLFxuICAgICAgcHJvdG9jb2xzLFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy4jaGFuZGxlcixcbiAgICAgIG9wdGlvbnNcbiAgICApXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZHkgc3RhdGUsIHdoaWNoIGlzIGFcbiAgICAvLyBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi4gSW5pdGlhbGx5IGl0IG11c3RcbiAgICAvLyBiZSBDT05ORUNUSU5HICgwKS5cbiAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElOR1xuXG4gICAgLy8gVGhlIGV4dGVuc2lvbnMgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gVGhlIHByb3RvY29sIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBiaW5hcnkgdHlwZSwgd2hpY2ggaXMgYVxuICAgIC8vIEJpbmFyeVR5cGUuIEluaXRpYWxseSBpdCBtdXN0IGJlIFwiYmxvYlwiLlxuICAgIHRoaXMuI2JpbmFyeVR5cGUgPSAnYmxvYidcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gICAqL1xuICBjbG9zZSAoY29kZSA9IHVuZGVmaW5lZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldC5jbG9zZSdcblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvZGUgPSB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShjb2RlLCBwcmVmaXgsICdjb2RlJywgd2ViaWRsLmF0dHJpYnV0ZXMuQ2xhbXApXG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWFzb24gPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcocmVhc29uKVxuICAgIH1cblxuICAgIC8vIDEuIElmIGNvZGUgaXMgdGhlIHNwZWNpYWwgdmFsdWUgXCJtaXNzaW5nXCIsIHRoZW4gc2V0IGNvZGUgdG8gbnVsbC5cbiAgICBjb2RlID8/PSBudWxsXG5cbiAgICAvLyAyLiBJZiByZWFzb24gaXMgdGhlIHNwZWNpYWwgdmFsdWUgXCJtaXNzaW5nXCIsIHRoZW4gc2V0IHJlYXNvbiB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIHJlYXNvbiA/Pz0gJydcblxuICAgIC8vIDMuIENsb3NlIHRoZSBXZWJTb2NrZXQgd2l0aCB0aGlzLCBjb2RlLCBhbmQgcmVhc29uLlxuICAgIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCBjb2RlLCByZWFzb24sIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LXNlbmRcbiAgICogQHBhcmFtIHtOb2RlSlMuVHlwZWRBcnJheXxBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ30gZGF0YVxuICAgKi9cbiAgc2VuZCAoZGF0YSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQuc2VuZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGRhdGEgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YShkYXRhLCBwcmVmaXgsICdkYXRhJylcblxuICAgIC8vIDEuIElmIHRoaXMncyByZWFkeSBzdGF0ZSBpcyBDT05ORUNUSU5HLCB0aGVuIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAoaXNDb25uZWN0aW5nKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbnQgYmVmb3JlIGNvbm5lY3RlZC4nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgIH1cblxuICAgIC8vIDIuIFJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTYuMVxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMlxuXG4gICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkgfHwgaXNDbG9zaW5nKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGRhdGEgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnRcbiAgICAgIC8vIG11c3Qgc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiB0aGUgZGF0YSBhcmd1bWVudFxuICAgICAgLy8gdXNpbmcgYSB0ZXh0IGZyYW1lIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy5cbiAgICAgIC8vIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLFxuICAgICAgLy8gdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZVxuICAgICAgLy8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFcbiAgICAgIC8vIHN0cmluZyBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlXG4gICAgICAvLyB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvXG4gICAgICAvLyBleHByZXNzIHRoZSBhcmd1bWVudCBhcyBVVEYtOC5cblxuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSlcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICB9LCBzZW5kSGludHMudGV4dClcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZFxuICAgICAgLy8gdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gVGhlIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciBkZXNjcmliZWRcbiAgICAgIC8vIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QuIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYW5cbiAgICAgIC8vIEFycmF5QnVmZmVyIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3RcbiAgICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy5hcnJheUJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZVxuICAgICAgLy8gZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgc2VjdGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICAvLyBkZXNjcmliZWQgYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IGRhdGEgcmVmZXJlbmNlcy4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggdGhpcyBraW5kIG9mIGFyZ3VtZW50IHRoYXQgZG9lc1xuICAgICAgLy8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGVcbiAgICAgIC8vIGJ5IHRoZSBsZW5ndGggb2YgZGF0YeKAmXMgYnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy50eXBlZEFycmF5KVxuICAgIH0gZWxzZSBpZiAod2ViaWRsLmlzLkJsb2IoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGUgZGF0YVxuICAgICAgLy8gdG8gYmUgc2VudCBpcyB0aGUgcmF3IGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIEJsb2Igb2JqZWN0LiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhIEJsb2IgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvd1xuICAgICAgLy8gYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgc2l6ZVxuICAgICAgLy8gb2YgdGhlIEJsb2Igb2JqZWN04oCZcyByYXcgZGF0YSwgaW4gYnl0ZXMuXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGRhdGEuc2l6ZVxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGRhdGEuc2l6ZVxuICAgICAgfSwgc2VuZEhpbnRzLmJsb2IpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSByZWFkeVN0YXRlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyByZWFkeSBzdGF0ZS5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlXG4gIH1cblxuICBnZXQgYnVmZmVyZWRBbW91bnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNidWZmZXJlZEFtb3VudFxuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgdXJsLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXMuI3VybClcbiAgfVxuXG4gIGdldCBleHRlbnNpb25zICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXh0ZW5zaW9uc1xuICB9XG5cbiAgZ2V0IHByb3RvY29sICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jcHJvdG9jb2xcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgbGlzdGVuZXIpXG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKVxuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmNsb3NlXG4gIH1cblxuICBzZXQgb25jbG9zZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmNsb3NlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy4jZXZlbnRzLmNsb3NlKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKVxuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gZm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRIYW5kbGVyTm9uTnVsbChmbilcblxuICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpXG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBiaW5hcnlUeXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jYmluYXJ5VHlwZVxuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUgKHR5cGUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodHlwZSAhPT0gJ2Jsb2InICYmIHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgIHRoaXMuI2JpbmFyeVR5cGUgPSAnYmxvYidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYmluYXJ5VHlwZSA9IHR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICAgKi9cbiAgI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIChyZXNwb25zZSwgcGFyc2VkRXh0ZW5zaW9ucykge1xuICAgIC8vIHByb2Nlc3NSZXNwb25zZSBpcyBjYWxsZWQgd2hlbiB0aGUgXCJyZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIGluaXRpYWxpemVkLlwiXG4gICAgLy8gb25jZSB0aGlzIGhhcHBlbnMsIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICB0aGlzLiNoYW5kbGVyLnNvY2tldCA9IHJlc3BvbnNlLnNvY2tldFxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEJ5dGVQYXJzZXIodGhpcy4jaGFuZGxlciwgcGFyc2VkRXh0ZW5zaW9ucylcbiAgICBwYXJzZXIub24oJ2RyYWluJywgKCkgPT4gdGhpcy4jaGFuZGxlci5vblBhcnNlckRyYWluKCkpXG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIChlcnIpID0+IHRoaXMuI2hhbmRsZXIub25QYXJzZXJFcnJvcihlcnIpKVxuXG4gICAgdGhpcy4jcGFyc2VyID0gcGFyc2VyXG4gICAgdGhpcy4jc2VuZFF1ZXVlID0gbmV3IFNlbmRRdWV1ZShyZXNwb25zZS5zb2NrZXQpXG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIE9QRU4gKDEpLlxuICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5PUEVOXG5cbiAgICAvLyAyLiBDaGFuZ2UgdGhlIGV4dGVuc2lvbnMgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgZXh0ZW5zaW9ucyBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucycpXG5cbiAgICBpZiAoZXh0ZW5zaW9ucyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNcbiAgICB9XG5cbiAgICAvLyAzLiBDaGFuZ2UgdGhlIHByb3RvY29sIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIHN1YnByb3RvY29sIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tMS45XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnKVxuXG4gICAgaWYgKHByb3RvY29sICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNwcm90b2NvbCA9IHByb3RvY29sXG4gICAgfVxuXG4gICAgLy8gNC4gRmlyZSBhbiBldmVudCBuYW1lZCBvcGVuIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgIGZpcmVFdmVudCgnb3BlbicsIHRoaXMpXG5cbiAgICBpZiAoY2hhbm5lbHMub3Blbi5oYXNTdWJzY3JpYmVycykge1xuICAgICAgLy8gQ29udmVydCBoZWFkZXJzIHRvIGEgcGxhaW4gb2JqZWN0IGZvciB0aGUgZXZlbnRcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5lbnRyaWVzXG4gICAgICBjaGFubmVscy5vcGVuLnB1Ymxpc2goe1xuICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICBwcm90b2NvbDogdGhpcy4jcHJvdG9jb2wsXG4gICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuI2V4dGVuc2lvbnMsXG4gICAgICAgIHdlYnNvY2tldDogdGhpcyxcbiAgICAgICAgaGFuZHNoYWtlUmVzcG9uc2U6IHtcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAjb25NZXNzYWdlICh0eXBlLCBkYXRhKSB7XG4gICAgLy8gMS4gSWYgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlICE9PSBzdGF0ZXMuT1BFTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGRhdGFGb3JFdmVudCBiZSBkZXRlcm1pbmVkIGJ5IHN3aXRjaGluZyBvbiB0eXBlIGFuZCBiaW5hcnkgdHlwZTpcbiAgICBsZXQgZGF0YUZvckV2ZW50XG5cbiAgICBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIFRleHRcbiAgICAgIC8vICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YUZvckV2ZW50ID0gdXRmOERlY29kZShkYXRhKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDcsICdSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBvcGNvZGVzLkJJTkFSWSkge1xuICAgICAgaWYgKHRoaXMuI2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJibG9iXCJcbiAgICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgICAvLyAgICAgIG9iamVjdCwgdGhhdCByZXByZXNlbnRzIGRhdGEgYXMgaXRzIHJhdyBkYXRhXG4gICAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBCbG9iKFtkYXRhXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImFycmF5YnVmZmVyXCJcbiAgICAgICAgLy8gICAgICBhIG5ldyBBcnJheUJ1ZmZlciBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZVxuICAgICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICAgIGRhdGFGb3JFdmVudCA9IHRvQXJyYXlCdWZmZXIoZGF0YSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIG1lc3NhZ2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsIHVzaW5nIE1lc3NhZ2VFdmVudCxcbiAgICAvLyAgICB3aXRoIHRoZSBvcmlnaW4gYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBvYmplY3TigJlzIHVybCdzIG9yaWdpbiwgYW5kIHRoZSBkYXRhIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byBkYXRhRm9yRXZlbnQuXG4gICAgZmlyZUV2ZW50KCdtZXNzYWdlJywgdGhpcywgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCwge1xuICAgICAgb3JpZ2luOiB0aGlzLiN1cmwub3JpZ2luLFxuICAgICAgZGF0YTogZGF0YUZvckV2ZW50XG4gICAgfSlcbiAgfVxuXG4gICNvblBhcnNlckRyYWluICgpIHtcbiAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC5yZXN1bWUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAgICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNFxuICAgKi9cbiAgI29uU29ja2V0Q2xvc2UgKCkge1xuICAgIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAgIC8vIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSB3YXMgY29tcGxldGVkLCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAvLyBpcyBzYWlkIHRvIGhhdmUgYmVlbiBjbG9zZWQgX2NsZWFubHlfLlxuICAgIGNvbnN0IHdhc0NsZWFuID1cbiAgICAgIHRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKSAmJlxuICAgICAgdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKVxuXG4gICAgbGV0IGNvZGUgPSAxMDA1XG4gICAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNwYXJzZXI/LmNsb3NpbmdJbmZvXG5cbiAgICBpZiAocmVzdWx0ICYmICFyZXN1bHQuZXJyb3IpIHtcbiAgICAgIGNvZGUgPSByZXN1bHQuY29kZSA/PyAxMDA1XG4gICAgICByZWFzb24gPSByZXN1bHQucmVhc29uXG4gICAgfVxuXG4gICAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBDTE9TRUQgKDMpLlxuICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TRURcblxuICAgIC8vIDIuIElmIHRoZSB1c2VyIGFnZW50IHdhcyByZXF1aXJlZCB0byBmYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBjb25uZWN0aW9uLCBvciBpZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAgIC8vICAgIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgIGlmICghdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKSkge1xuICAgICAgLy8gSWYgX1RoZSBXZWJTb2NrZXRcbiAgICAgIC8vIENvbm5lY3Rpb24gaXMgQ2xvc2VkXyBhbmQgbm8gQ2xvc2UgY29udHJvbCBmcmFtZSB3YXMgcmVjZWl2ZWQgYnkgdGhlXG4gICAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgICAgLy8gaXMgbG9zdCksIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXMgY29uc2lkZXJlZCB0byBiZVxuICAgICAgLy8gMTAwNi5cbiAgICAgIGNvZGUgPSAxMDA2XG5cbiAgICAgIGZpcmVFdmVudCgnZXJyb3InLCB0aGlzLCAodHlwZSwgaW5pdCkgPT4gbmV3IEVycm9yRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICAgICAgZXJyb3I6IG5ldyBUeXBlRXJyb3IocmVhc29uKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIGNsb3NlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LFxuICAgIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAgIC8vICAgIGluaXRpYWxpemVkIHRvIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gY2xvc2VkIGNsZWFubHlcbiAgICAvLyAgICBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB0aGUgY29kZSBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG9cbiAgICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgICAvLyAgICBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyBVVEYtOFxuICAgIC8vICAgIGRlY29kZSB3aXRob3V0IEJPTSB0byB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VcbiAgICAvLyAgICByZWFzb24uXG4gICAgLy8gVE9ETzogcHJvY2Vzcy5uZXh0VGlja1xuICAgIGZpcmVFdmVudCgnY2xvc2UnLCB0aGlzLCAodHlwZSwgaW5pdCkgPT4gbmV3IENsb3NlRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICAgIHdhc0NsZWFuLCBjb2RlLCByZWFzb25cbiAgICB9KVxuXG4gICAgaWYgKGNoYW5uZWxzLmNsb3NlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jbG9zZS5wdWJsaXNoKHtcbiAgICAgICAgd2Vic29ja2V0OiB0aGlzLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZWFzb25cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB3c1xuICAgKiBAcGFyYW0ge0J1ZmZlcnx1bmRlZmluZWR9IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHBpbmcgKHdzLCBidWZmZXIpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMTI1KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgUElORyBmcmFtZSBjYW5ub3QgaGF2ZSBhIGJvZHkgbGFyZ2VyIHRoYW4gMTI1IGJ5dGVzLicpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChidWZmZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYnVmZmVyIHBheWxvYWQnKVxuICAgIH1cblxuICAgIC8vIEFuIGVuZHBvaW50IE1BWSBzZW5kIGEgUGluZyBmcmFtZSBhbnkgdGltZSBhZnRlciB0aGUgY29ubmVjdGlvbiBpc1xuICAgIC8vIGVzdGFibGlzaGVkIGFuZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB3cy4jaGFuZGxlci5yZWFkeVN0YXRlXG5cbiAgICBpZiAoaXNFc3RhYmxpc2hlZChyZWFkeVN0YXRlKSAmJiAhaXNDbG9zaW5nKHJlYWR5U3RhdGUpICYmICFpc0Nsb3NlZChyZWFkeVN0YXRlKSkge1xuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJ1ZmZlcilcbiAgICAgIHdzLiNoYW5kbGVyLnNvY2tldC53cml0ZShmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLlBJTkcpKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCB7IHBpbmcgfSA9IFdlYlNvY2tldFxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShXZWJTb2NrZXQsICdwaW5nJylcblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jb25uZWN0aW5nXG5XZWJTb2NrZXQuQ09OTkVDVElORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ09OTkVDVElORyA9IHN0YXRlcy5DT05ORUNUSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LW9wZW5cbldlYlNvY2tldC5PUEVOID0gV2ViU29ja2V0LnByb3RvdHlwZS5PUEVOID0gc3RhdGVzLk9QRU5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2luZ1xuV2ViU29ja2V0LkNMT1NJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NJTkcgPSBzdGF0ZXMuQ0xPU0lOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZWRcbldlYlNvY2tldC5DTE9TRUQgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NFRCA9IHN0YXRlcy5DTE9TRURcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYnVmZmVyZWRBbW91bnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ub3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25jbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYmluYXJ5VHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2VuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXh0ZW5zaW9uczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHJvdG9jb2w6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdXZWJTb2NrZXQnLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yc1xufSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IHdlYmlkbC51dGlsLlR5cGVzLk9CSkVDVCAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gVikge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbi8vIFRoaXMgaW1wbGVtZW50cyB0aGUgcHJvcG9zYWwgbWFkZSBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3dlYnNvY2tldHMvaXNzdWVzLzQyXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAncHJvdG9jb2xzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gW11cbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55LFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSB3ZWJpZGwudXRpbC5UeXBlcy5PQkpFQ1QgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdChWKVxuICB9XG5cbiAgcmV0dXJuIHsgcHJvdG9jb2xzOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXShWKSB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IHdlYmlkbC51dGlsLlR5cGVzLk9CSkVDVCkge1xuICAgIGlmICh3ZWJpZGwuaXMuQmxvYihWKSkge1xuICAgICAgcmV0dXJuIFZcbiAgICB9XG5cbiAgICBpZiAod2ViaWRsLmlzLkJ1ZmZlclNvdXJjZShWKSkge1xuICAgICAgcmV0dXJuIFZcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXQsXG4gIHBpbmdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;